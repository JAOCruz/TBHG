(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Webamp = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var jszip_min = {exports: {}};

	/*!

	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
	<http://stuartk.com/jszip>

	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

	JSZip uses the library pako released under the MIT license :
	https://github.com/nodeca/pako/blob/main/LICENSE
	*/

	(function (module, exports) {
		!function(e){module.exports=e();}(function(){return function s(a,o,h){function u(r,e){if(!o[r]){if(!a[r]){var t="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&t)return t(r,!0);if(l)return l(r,!0);var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return u(t||e)},i,i.exports,s,a,o,h);}return o[r].exports}for(var l="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<h.length;e++)u(h[e]);return u}({1:[function(e,t,r){var d=e("./utils"),c=e("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(e){for(var t,r,n,i,s,a,o,h=[],u=0,l=e.length,f=l,c="string"!==d.getTypeOf(e);u<e.length;)f=l-u,n=c?(t=e[u++],r=u<l?e[u++]:0,u<l?e[u++]:0):(t=e.charCodeAt(u++),r=u<l?e.charCodeAt(u++):0,u<l?e.charCodeAt(u++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<f?(15&r)<<2|n>>6:64,o=2<f?63&n:64,h.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(e){var t,r,n,i,s,a,o=0,h=0,u="data:";if(e.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(e=e.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=c.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),l[h++]=t,64!==s&&(l[h++]=r),64!==a&&(l[h++]=n);return l};},{"./support":30,"./utils":32}],2:[function(e,t,r){var n=e("./external"),i=e("./stream/DataWorker"),s=e("./stream/Crc32Probe"),a=e("./stream/DataLengthProbe");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i;}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),t=this;return e.on("end",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",t)},t.exports=o;},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(e,t,r){var n=e("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(){return new n("STORE compression")},uncompressWorker:function(){return new n("STORE decompression")}},r.DEFLATE=e("./flate");},{"./flate":7,"./stream/GenericWorker":28}],4:[function(e,t,r){var n=e("./utils");var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t){return void 0!==e&&e.length?"string"!==n.getTypeOf(e)?function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e}(0|t,e,e.length,0):function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t.charCodeAt(a))];return -1^e}(0|t,e,e.length,0):0};},{"./utils":32}],5:[function(e,t,r){r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null;},{}],6:[function(e,t,r){var n=null;n="undefined"!=typeof Promise?Promise:e("lie"),t.exports={Promise:n};},{lie:37}],7:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,i=e("pako"),s=e("./utils"),a=e("./stream/GenericWorker"),o=n?"uint8array":"array";function h(e,t){a.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={};}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1);},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0);},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null;},h.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta});};},r.compressWorker=function(e){return new h("Deflate",e)},r.uncompressWorker=function(){return new h("Inflate",{})};},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(e,t,r){function A(e,t){var r,n="";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function n(e,t,r,n,i,s){var a,o,h=e.file,u=e.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),c=I.transformTo("string",O.utf8encode(h.name)),d=h.comment,p=I.transformTo("string",s(d)),m=I.transformTo("string",O.utf8encode(d)),_=c.length!==h.name.length,g=m.length!==d.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===i?(C=798,z|=function(e,t){var r=e;return e||(r=t?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(e){return 63&(e||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+c,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(n,4)+f+b+p}}var I=e("../utils"),i=e("../stream/GenericWorker"),O=e("../utf8"),B=e("../crc32"),R=e("../signature");function s(e,t,r,n){i.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[];}I.inherits(s,i),s.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))/r:100}}));},s.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=n(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}});}else this.accumulate=!0;},s.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,r=n(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),t)this.push({data:function(e){return R.DATA_DESCRIPTOR+A(e.crc32,4)+A(e.compressedSize,4)+A(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null;},s.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r=this.bytesWritten-e,n=function(e,t,r,n,i){var s=I.transformTo("string",i(n));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(e,2)+A(e,2)+A(t,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,e,this.zipComment,this.encodeFileName);this.push({data:n,meta:{percent:100}});},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume();},s.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end();}),e.on("error",function(e){t.error(e);}),this},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return !1;for(var r=0;r<t.length;r++)try{t[r].error(e);}catch(e){}return !0},s.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock();},t.exports=s;},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(e,t,r){var u=e("../compressions"),n=e("./ZipFileWorker");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),h=0;try{e.forEach(function(e,t){h++;var r=function(e,t){var r=e||t,n=u[r];if(!n)throw new Error(r+" is not a valid compression method !");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo("file",{name:e,dir:i,date:s,comment:t.comment||"",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o);}),o.entriesCount=h;}catch(e){o.error(e);}return o};},{"../compressions":3,"./ZipFileWorker":8}],10:[function(e,t,r){function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var e=new n;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e};}(n.prototype=e("./object")).loadAsync=e("./load"),n.support=e("./support"),n.defaults=e("./defaults"),n.version="3.10.1",n.loadAsync=function(e,t){return (new n).loadAsync(e,t)},n.external=e("./external"),t.exports=n;},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(e,t,r){var u=e("./utils"),i=e("./external"),n=e("./utf8"),s=e("./zipEntries"),a=e("./stream/Crc32Probe"),l=e("./nodejsUtils");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new a);r.on("error",function(e){t(e);}).on("end",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error("Corrupted zip : CRC32 mismatch")):e();}).resume();})}t.exports=function(e,o){var h=this;return o=u.extend(o||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:n.utf8decode}),l.isNode&&l.isStream(e)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):u.prepareContent("the loaded zip file",e,!0,o.optimizedBinaryString,o.base64).then(function(e){var t=new s(o);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(o.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n],s=i.fileNameStr,a=u.resolve(i.fileNameStr);h.file(a,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:o.createFolders}),i.dir||(h.file(a).unsafeOriginalName=s);}return t.zipComment.length&&(h.comment=t.zipComment),h})};},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(e,t,r){var n=e("../utils"),i=e("../stream/GenericWorker");function s(e,t){i.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t);}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on("data",function(e){t.push({data:e,meta:{percent:0}});}).on("error",function(e){t.isPaused?this.generatedError=e:t.error(e);}).on("end",function(){t.isPaused?t._upstreamEnded=!0:t.end();});},s.prototype.pause=function(){return !!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s;},{"../stream/GenericWorker":28,"../utils":32}],13:[function(e,t,r){var i=e("readable-stream").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on("data",function(e,t){n.push(e)||n._helper.pause(),r&&r(t);}).on("error",function(e){n.emit("error",e);}).on("end",function(){n.push(null);});}e("../utils").inherits(n,i),n.prototype._read=function(){this._helper.resume();},t.exports=n;},{"../utils":32,"readable-stream":16}],14:[function(e,t,r){t.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if("number"==typeof e)throw new Error('The "data" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}};},{}],15:[function(e,t,r){function s(e,t,r){var n,i=u.getTypeOf(t),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=g(e)),s.createFolders&&(n=_(e))&&b.call(this,n,!0);var a="string"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t="",s.compression="STORE",i="string");var o=null;o=t instanceof c||t instanceof l?t:p.isNode&&p.isStream(t)?new m(e,t):u.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var h=new d(e,o,s);this.files[e]=h;}var i=e("./utf8"),u=e("./utils"),l=e("./stream/GenericWorker"),a=e("./stream/StreamHelper"),f=e("./defaults"),c=e("./compressedObject"),d=e("./zipObject"),o=e("./generate"),p=e("./nodejsUtils"),m=e("./nodejs/NodejsStreamInputAdapter"),_=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return 0<t?e.substring(0,t):""},g=function(e){return "/"!==e.slice(-1)&&(e+="/"),e},b=function(e,t){return t=void 0!==t?t:f.createFolders,e=g(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function h(e){return "[object RegExp]"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,r,n;for(t in this.files)n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n);},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t);}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(h(e)){var n=e;return this.filter(function(e,t){return !t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=b.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||("/"!==r.slice(-1)&&(r+="/"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,r={};try{if((r=u.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var n=r.comment||this.comment||"";t=o.generateWorker(this,r,n);}catch(e){(t=new l("error")).error(e);}return new a(t,r.type||"string",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return (e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n;},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(e,t,r){t.exports=e("stream");},{stream:void 0}],17:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t];}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return -1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return [];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],18:[function(e,t,r){var n=e("../utils");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0;}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e);},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e;},skip:function(e){this.setIndex(this.index+e);},byteAt:function(){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo("string",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i;},{"../utils":32}],19:[function(e,t,r){var n=e("./Uint8ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],21:[function(e,t,r){var n=e("./ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./ArrayReader":17}],22:[function(e,t,r){var n=e("../utils"),i=e("../support"),s=e("./ArrayReader"),a=e("./StringReader"),o=e("./NodeBufferReader"),h=e("./Uint8ArrayReader");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),"string"!==t||i.uint8array?"nodebuffer"===t?new o(e):i.uint8array?new h(n.transformTo("uint8array",e)):new s(n.transformTo("array",e)):new a(e)};},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(e,t,r){r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b";},{}],24:[function(e,t,r){var n=e("./GenericWorker"),i=e("../utils");function s(e){n.call(this,"ConvertWorker to "+e),this.destType=e;}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta});},t.exports=s;},{"../utils":32,"./GenericWorker":28}],25:[function(e,t,r){var n=e("./GenericWorker"),i=e("../crc32");function s(){n.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0);}e("../utils").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e);},t.exports=s;},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0);}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length;}i.prototype.processChunk.call(this,e);},t.exports=s;},{"../utils":32,"./GenericWorker":28}],27:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat();},function(e){t.error(e);});}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null;},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0));},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return !1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t);}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s;},{"../utils":32,"./GenericWorker":28}],28:[function(e,t,r){function n(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null;}n.prototype={push:function(e){this.emit("data",e);},end:function(){if(this.isFinished)return !1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0;}catch(e){this.emit("error",e);}return !0},error:function(e){return !this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[];},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t);},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.end();}),e.on("error",function(e){t.error(e);}),this},pause:function(){return !this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return !1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e);},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,e)&&(this.streamInfo[e]=this.extraStreamInfo[e]);},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock();},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},t.exports=n;},{}],29:[function(e,t,r){var h=e("../utils"),i=e("./ConvertWorker"),s=e("./GenericWorker"),u=e("../base64"),n=e("../support"),a=e("../external"),o=null;if(n.nodestream)try{o=e("../nodejs/NodejsStreamOutputAdapter");}catch(e){}function l(e,o){return new a.Promise(function(t,r){var n=[],i=e._internalType,s=e._outputType,a=e._mimeType;e.on("data",function(e,t){n.push(e),o&&o(t);}).on("error",function(e){n=[],r(e);}).on("end",function(){try{var e=function(e,t,r){switch(e){case"blob":return h.newBlob(h.transformTo("arraybuffer",t),r);case"base64":return u.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case"string":return t.join("");case"array":return Array.prototype.concat.apply([],t);case"uint8array":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case"nodebuffer":return Buffer.concat(t);default:throw new Error("concat : unsupported type '"+e+"'")}}(i,n),a);t(e);}catch(e){r(e);}n=[];}).resume();})}function f(e,t,r){var n=t;switch(t){case"blob":case"arraybuffer":n="uint8array";break;case"base64":n="string";}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock();}catch(e){this._worker=new s("error"),this._worker.error(e);}}f.prototype={accumulate:function(e){return l(this,e)},on:function(e,t){var r=this;return "data"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta);}):this._worker.on(e,function(){h.delay(t,arguments,r);}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},e)}},t.exports=f;},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(e,t,r){if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else {var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:"application/zip"}).size;}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob("application/zip").size;}catch(e){r.blob=!1;}}}try{r.nodestream=!!e("readable-stream").Readable;}catch(e){r.nodestream=!1;}},{"readable-stream":16}],31:[function(e,t,s){for(var o=e("./utils"),h=e("./support"),r=e("./nodejsUtils"),n=e("./stream/GenericWorker"),u=new Array(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;u[254]=u[254]=1;function a(){n.call(this,"utf-8 decode"),this.leftOver=null;}function l(){n.call(this,"utf-8 encode");}s.utf8encode=function(e){return h.nodebuffer?r.newBufferFrom(e,"utf-8"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=h.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return h.nodebuffer?o.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=u[n]))a[r++]=65533,t+=i-1;else {for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n);}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(h.uint8array?"uint8array":"array",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(h.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length);}else t=this.leftOver.concat(t);this.leftOver=null;}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}(t),i=t;n!==t.length&&(h.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta});},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null);},s.Utf8DecodeWorker=a,o.inherits(l,n),l.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta});},s.Utf8EncodeWorker=l;},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(e,t,a){var o=e("./support"),h=e("./base64"),r=e("./nodejsUtils"),u=e("./external");function n(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}e("setimmediate"),a.newBlob=function(t,r){a.checkSupport("blob");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var i={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)"array"===t||"nodebuffer"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join("")},stringifyByChar:function(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return !1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return !1}}()}};function s(e){var t=65536,r=a.getTypeOf(e),n=!0;if("uint8array"===r?n=i.applyCanBeUsed.uint8array:"nodebuffer"===r&&(n=i.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return i.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t/2);}return i.stringifyByChar(e)}function f(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}a.applyFromCharCode=s;var c={};c.string={string:n,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:s,array:n,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return s(new Uint8Array(e))},array:function(e){return f(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:n,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:n,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:n},a.transformTo=function(e,t){if(t=t||"",!e)return t;a.checkSupport(e);var r=a.getTypeOf(t);return c[r][e](t)},a.resolve=function(e){for(var t=e.split("/"),r=[],n=0;n<t.length;n++){var i=t[n];"."===i||""===i&&0!==n&&n!==t.length-1||(".."===i?r.pop():r.push(i));}return r.join("/")},a.getTypeOf=function(e){return "string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":o.nodebuffer&&r.isBuffer(e)?"nodebuffer":o.uint8array&&e instanceof Uint8Array?"uint8array":o.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(e){if(!o[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(e){var t,r,n="";for(r=0;r<(e||"").length;r++)n+="\\x"+((t=e.charCodeAt(r))<16?"0":"")+t.toString(16).toUpperCase();return n},a.delay=function(e,t,r){setImmediate(function(){e.apply(r||null,t||[]);});},a.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r;},a.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e],t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},a.prepareContent=function(r,e,n,i,s){return u.Promise.resolve(e).then(function(n){return o.blob&&(n instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(n)))&&"undefined"!=typeof FileReader?new u.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result);},e.onerror=function(e){r(e.target.error);},e.readAsArrayBuffer(n);}):n}).then(function(e){var t=a.getTypeOf(e);return t?("arraybuffer"===t?e=a.transformTo("uint8array",e):"string"===t&&(s?e=h.decode(e):n&&!0!==i&&(e=function(e){return l(e,o.uint8array?new Uint8Array(e.length):new Array(e.length))}(e))),e):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})};},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(e,t,r){var n=e("./reader/readerFor"),i=e("./utils"),s=e("./signature"),a=e("./zipEntry"),o=e("./support");function h(e){this.files=[],this.loadOptions=e;}h.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?"uint8array":"array",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r);},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r};},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes();},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw !this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral();}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error("Corrupted zip: missing "+Math.abs(n)+" bytes.")},prepareReader:function(e){this.reader=n(e);},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles();}},t.exports=h;},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(e,t,r){var n=e("./reader/readerFor"),s=e("./utils"),i=e("./compressedObject"),a=e("./crc32"),o=e("./utf8"),h=e("./compressions"),u=e("./support");function l(e,t){this.options=e,this.loadOptions=t;}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in h)if(Object.prototype.hasOwnProperty.call(h,t)&&h[t].magic===e)return h[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize));},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength);},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0);},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4));}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i);},handleUTF8:function(){var e=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else {var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else {var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r);}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else {var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i);}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=l;},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(e,t,r){function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions};}var s=e("./stream/StreamHelper"),i=e("./stream/DataWorker"),a=e("./utf8"),o=e("./compressedObject"),h=e("./stream/GenericWorker");n.prototype={internalStream:function(e){var t=null,r="string";try{if(!e)throw new Error("No output type specified.");var n="string"===(r=e.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker));}catch(e){(t=new h("error")).error(e);}return new s(t,r,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new i(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)n.prototype[u[f]]=l;t.exports=n;},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(e,l,t){(function(t){var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(u),a=t.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2;};}else if(t.setImmediate||void 0===t.MessageChannel)r="document"in t&&"onreadystatechange"in t.document.createElement("script")?function(){var e=t.document.createElement("script");e.onreadystatechange=function(){u(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null;},t.document.documentElement.appendChild(e);}:function(){setTimeout(u,0);};else {var o=new t.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0);};}var h=[];function u(){var e,t;n=!0;for(var r=h.length;r;){for(t=h,h=[],e=-1;++e<r;)t[e]();r=h.length;}n=!1;}l.exports=function(e){1!==h.push(e)||n||r();};}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}],37:[function(e,t,r){var i=e("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],n=["PENDING"];function o(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=n,this.queue=[],this.outcome=void 0,e!==u&&d(this,e);}function h(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected);}function f(t,r,n){i(function(){var e;try{e=r(n);}catch(e){return l.reject(t,e)}e===t?l.reject(t,new TypeError("Cannot resolve promise with itself")):l.resolve(t,e);});}function c(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments);}}function d(t,e){var r=!1;function n(e){r||(r=!0,l.reject(t,e));}function i(e){r||(r=!0,l.resolve(t,e));}var s=p(function(){e(i,n);});"error"===s.status&&n(s.value);}function p(e,t){var r={};try{r.value=e(t),r.status="success";}catch(e){r.status="error",r.value=e;}return r}(t.exports=o).prototype.finally=function(t){if("function"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if("function"!=typeof e&&this.state===a||"function"!=typeof t&&this.state===s)return this;var r=new this.constructor(u);this.state!==n?f(r,this.state===a?e:t,this.outcome):this.queue.push(new h(r,e,t));return r},h.prototype.callFulfilled=function(e){l.resolve(this.promise,e);},h.prototype.otherCallFulfilled=function(e){f(this.promise,this.onFulfilled,e);},h.prototype.callRejected=function(e){l.reject(this.promise,e);},h.prototype.otherCallRejected=function(e){f(this.promise,this.onRejected,e);},l.resolve=function(e,t){var r=p(c,t);if("error"===r.status)return l.reject(e,r.value);var n=r.value;if(n)d(e,n);else {e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t);}return e},l.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){if(e instanceof this)return e;return l.resolve(new this(u),e)},o.reject=function(e){var t=new this(u);return l.reject(t,e)},o.all=function(e){var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,i=!1;if(!n)return this.resolve([]);var s=new Array(n),a=0,t=-1,o=new this(u);for(;++t<n;)h(e[t],t);return o;function h(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,l.resolve(o,s));},function(e){i||(i=!0,l.reject(o,e));});}},o.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,n=!1;if(!r)return this.resolve([]);var i=-1,s=new this(u);for(;++i<r;)a=e[i],t.resolve(a).then(function(e){n||(n=!0,l.resolve(s,e));},function(e){n||(n=!0,l.reject(s,e));});var a;return s};},{immediate:36}],38:[function(e,t,r){var n={};(0, e("./lib/utils/common").assign)(n,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=n;},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(e,t,r){var a=e("./zlib/deflate"),o=e("./utils/common"),h=e("./utils/strings"),i=e("./zlib/messages"),s=e("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,c=0,d=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:f,method:d,chunkSize:16384,windowBits:15,memLevel:8,strategy:c,to:""},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==l)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n="string"==typeof t.dictionary?h.string2buf(t.dictionary):"[object ArrayBuffer]"===u.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==l)throw new Error(i[r]);this._dict_set=!0;}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return !1;n=t===~~t?t:!0===t?4:0,"string"==typeof e?i.input=h.string2buf(e):"[object ArrayBuffer]"===u.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)));}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==n||(this.onEnd(l),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e);},p.prototype.onEnd=function(e){e===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return (t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return (t=t||{}).gzip=!0,n(e,t)};},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(e,t,r){var c=e("./zlib/inflate"),d=e("./utils/common"),p=e("./utils/strings"),m=e("./zlib/constants"),n=e("./zlib/messages"),i=e("./zlib/zstream"),s=e("./zlib/gzheader"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=d.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=c.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,c.inflateGetHeader(this.strm,this.header);}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return !1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof e?h.input=p.binstring2buf(e):"[object ArrayBuffer]"===_.call(e)?h.input=new Uint8Array(e):h.input=e,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new d.Buf8(u),h.next_out=0,h.avail_out=u),(r=c.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=c.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(i=p.utf8border(h.output,h.next_out),s=h.next_out-i,a=p.buf2string(h.output,i),h.next_out=s,h.avail_out=u-s,s&&d.arraySet(h.output,h.output,i,s,0),this.onData(a)):this.onData(d.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0);}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=c.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e);},a.prototype.onEnd=function(e){e===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return (t=t||{}).raw=!0,o(e,t)},r.ungzip=o;},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){return [].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s));},r.setTyped(n);},{}],42:[function(e,t,r){var h=e("./common"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0]);}catch(e){i=!1;}try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(e){s=!1;}for(var u=new h.Buf8(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function l(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,h.shrinkBuf(e,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}u[254]=u[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new h.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return l(e,e.length)},r.binstring2buf=function(e){for(var t=new h.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=u[i]))o[n++]=65533,r+=s-1;else {for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i);}return l(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t};},{"./common":41}],43:[function(e,t,r){t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521;}return i|s<<16|0};},{}],44:[function(e,t,r){t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};},{}],45:[function(e,t,r){var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e};},{}],46:[function(e,t,r){var h,c=e("../utils/common"),u=e("./trees"),d=e("./adler32"),p=e("./crc32"),n=e("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,i=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(e,t){return e.msg=n[t],t}function T(e){return (e<<1)-(4<e?9:0)}function D(e){for(var t=e.length;0<=--t;)e[t]=0;}function F(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(c.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0));}function N(e,t){u._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,F(e.strm);}function U(e,t){e.pending_buf[e.pending++]=t;}function P(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t;}function L(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,h=e.strstart>e.w_size-z?e.strstart-(e.w_size-z):0,u=e.window,l=e.w_mask,f=e.prev,c=e.strstart+S,d=u[s+a-1],p=u[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(u[(r=t)+a]===p&&u[r+a-1]===d&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<c);if(n=S-(c-s),s=c-S,a<n){if(e.match_start=t,o<=(a=n))break;d=u[s+a-1],p=u[s+a];}}}while((t=f[t&l])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function j(e){var t,r,n,i,s,a,o,h,u,l,f=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=f+(f-z)){for(c.arraySet(e.window,e.window,f,f,0),e.match_start-=f,e.strstart-=f,e.block_start-=f,t=r=e.hash_size;n=e.head[--t],e.head[t]=f<=n?n-f:0,--r;);for(t=r=f;n=e.prev[--t],e.prev[t]=f<=n?n-f:0,--r;);i+=f;}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,h=e.strstart+e.lookahead,u=i,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,c.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=d(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),e.lookahead+=r,e.lookahead+e.insert>=x)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+x-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<x)););}while(e.lookahead<z&&0!==e.strm.avail_in)}function Z(e,t){for(var r,n;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r)),e.match_length>=x)if(n=u._tr_tally(e,e.strstart-e.match_start,e.match_length-x),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=x){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++;}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function W(e,t){for(var r,n,i;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=x-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===x&&4096<e.strstart-e.match_start)&&(e.match_length=x-1)),e.prev_length>=x&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-x,n=u._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-x),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=x-1,e.strstart++,n&&(N(e,!1),0===e.strm.avail_out))return A}else if(e.match_available){if((n=u._tr_tally(e,0,e.window[e.strstart-1]))&&N(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return A}else e.match_available=1,e.strstart++,e.lookahead--;}return e.match_available&&(n=u._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function M(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i;}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new c.Buf16(2*w),this.dyn_dtree=new c.Buf16(2*(2*a+1)),this.bl_tree=new c.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new c.Buf16(k+1),this.heap=new c.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new c.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}function G(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?C:E,e.adler=2===t.wrap?0:1,t.last_flush=l,u._tr_init(t),m):R(e,_)}function K(e){var t=G(e);return t===m&&function(e){e.window_size=2*e.w_size,D(e.head),e.max_lazy_match=h[e.level].max_lazy,e.good_match=h[e.level].good_length,e.nice_match=h[e.level].nice_length,e.max_chain_length=h[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=x-1,e.match_available=0,e.ins_h=0;}(e.state),t}function Y(e,t,r,n,i,s){if(!e)return _;var a=1;if(t===g&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||y<i||r!==v||n<8||15<n||t<0||9<t||s<0||b<s)return R(e,_);8===n&&(n=9);var o=new H;return (e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new c.Buf8(2*o.w_size),o.head=new c.Buf16(o.hash_size),o.prev=new c.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new c.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,K(e)}h=[new M(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(j(e),0===e.lookahead&&t===l)return A;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,N(e,!1),0===e.strm.avail_out))return A;if(e.strstart-e.block_start>=e.w_size-z&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):(e.strstart>e.block_start&&(N(e,!1),e.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(e,t){return Y(e,t,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?_:(e.state.gzhead=t,m):_},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?R(e,_):_;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&t!==f)return R(e,0===e.avail_out?-5:_);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===C)if(2===n.wrap)e.adler=0,U(n,31),U(n,139),U(n,8),n.gzhead?(U(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),U(n,255&n.gzhead.time),U(n,n.gzhead.time>>8&255),U(n,n.gzhead.time>>16&255),U(n,n.gzhead.time>>24&255),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(U(n,255&n.gzhead.extra.length),U(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(U(n,0),U(n,0),U(n,0),U(n,0),U(n,0),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,3),n.status=E);else {var a=v+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=E,P(n,a),0!==n.strstart&&(P(n,e.adler>>>16),P(n,65535&e.adler)),e.adler=1;}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending!==n.pending_buf_size));)U(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73);}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,U(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91);}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,U(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103);}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&F(e),n.pending+2<=n.pending_buf_size&&(U(n,255&e.adler),U(n,e.adler>>8&255),e.adler=0,n.status=E)):n.status=E),0!==n.pending){if(F(e),0===e.avail_out)return n.last_flush=-1,m}else if(0===e.avail_in&&T(t)<=T(r)&&t!==f)return R(e,-5);if(666===n.status&&0!==e.avail_in)return R(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==l&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(j(e),0===e.lookahead)){if(t===l)return A;break}if(e.match_length=0,r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=S){if(j(e),e.lookahead<=S&&t===l)return A;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=x&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+S;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=S-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead);}if(e.match_length>=x?(r=u._tr_tally(e,1,e.match_length-x),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):h[n.level].func(n,t);if(o!==O&&o!==B||(n.status=666),o===A||o===O)return 0===e.avail_out&&(n.last_flush=-1),m;if(o===I&&(1===t?u._tr_align(n):5!==t&&(u._tr_stored_block(n,0,0,!1),3===t&&(D(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),F(e),0===e.avail_out))return n.last_flush=-1,m}return t!==f?m:n.wrap<=0?1:(2===n.wrap?(U(n,255&e.adler),U(n,e.adler>>8&255),U(n,e.adler>>16&255),U(n,e.adler>>24&255),U(n,255&e.total_in),U(n,e.total_in>>8&255),U(n,e.total_in>>16&255),U(n,e.total_in>>24&255)):(P(n,e.adler>>>16),P(n,65535&e.adler)),F(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?m:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==C&&69!==t&&73!==t&&91!==t&&103!==t&&t!==E&&666!==t?R(e,_):(e.state=null,t===E?R(e,-3):m):_},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,h,u,l=t.length;if(!e||!e.state)return _;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(e.adler=d(e.adler,t,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new c.Buf8(r.w_size),c.arraySet(u,t,l-r.w_size,r.w_size,0),t=u,l=r.w_size),a=e.avail_in,o=e.next_in,h=e.input,e.avail_in=l,e.next_in=0,e.input=t,j(r);r.lookahead>=x;){for(n=r.strstart,i=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+x-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=x-1,j(r);}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,e.next_in=o,e.input=h,e.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(e,t,r){t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;};},{}],48:[function(e,t,r){t.exports=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,C=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;e:do{p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=m[d&g];t:for(;;){if(d>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else {if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}w=65535&v,(y&=15)&&(p<y&&(d+=z[n++]<<p,p+=8),w+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=_[d&b];r:for(;;){if(d>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(d&(1<<y)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(k=65535&v,p<(y&=15)&&(d+=z[n++]<<p,(p+=8)<y&&(d+=z[n++]<<p,p+=8)),h<(k+=d&(1<<y)-1)){e.msg="invalid distance too far back",r.mode=30;break e}if(d>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(S=c,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C;}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=c[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=c[x++],--y;);x=s-k,S=C;}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C;}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]));}else {for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]));}break}}break}}while(n<i&&s<o);n-=w=p>>3,d&=(1<<(p-=w<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=d,r.bits=p;};},{}],49:[function(e,t,r){var I=e("../utils/common"),O=e("./adler32"),B=e("./crc32"),R=e("./inffast"),T=e("./inftrees"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return (e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function h(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function u(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=h(e,t))!==N&&(e.state=null),r):U}var l,f,c=!0;function j(e){if(c){var t;for(l=new I.Buf32(512),f=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(T(D,e.lens,0,288,l,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;T(F,e.lens,0,32,f,0,e.work,{bits:5}),c=!1;}e.lencode=l,e.lenbits=9,e.distcode=f,e.distbits=5;}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(e){return u(e,15)},r.inflateInit2=u,r.inflate=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,f=o,c=h,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){e.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){e.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(r.flags=u,8!=(255&r.flags)){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0;}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(d=r.length)&&(d=o),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,d,k)),512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=u=0;}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}e.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;u>>>=2,l-=2;break e;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30;}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if((65535&u)!=(u>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(d=r.length){if(o<d&&(d=o),h<d&&(d=h),0===d)break e;I.arraySet(i,n,s,d,a),o-=d,s+=d,h-=d,a+=d,r.length-=d;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3;}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else {if(16===b){for(z=_+2;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u>>>=_,l-=_,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],d=3+(3&u),u>>>=2,l-=2;}else if(17===b){for(z=_+3;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}l-=_,k=0,d=3+(7&(u>>>=_)),u>>>=3,l-=3;}else {for(z=_+7;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}l-=_,k=0,d=11+(127&(u>>>=_)),u>>>=7,l-=7;}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=k;}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=h){e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,R(e,c),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}u>>>=v,l-=v,r.back+=v;}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra;}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}u>>>=v,l-=v,r.back+=v;}if(u>>>=_,l-=_,r.back+=_,64&g){e.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra;}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break e;if(d=c-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}p=d>r.wnext?(d-=r.wnext,r.wsize-d):r.wnext-d,d>r.length&&(d=r.length),m=r.window;}else m=i,p=a-r.offset,d=r.length;for(h<d&&(d=h),h-=d,r.length-=d;i[a++]=m[p++],--d;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break e;i[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break e;o--,u|=n[s++]<<l,l+=8;}if(c-=h,e.total_out+=c,r.total+=c,c&&(e.adler=r.check=r.flags?B(r.check,i,c,a-c):O(r.check,i,c,a-c)),c=h,(r.flags?u:L(u))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=u=0;}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=u=0;}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return -4;case 32:default:return U}return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,(r.wsize||c!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,c-e.avail_out)?(r.mode=31,-4):(f-=e.avail_in,c-=e.avail_out,e.total_in+=f,e.total_out+=c,r.total+=c,r.wrap&&c&&(e.adler=r.check=r.flags?B(r.check,i,c,e.next_out-c):O(r.check,i,c,e.next_out-c)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===c||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(e,t,r){var D=e("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var h,u,l,f,c,d,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<n;v++)O[t[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return -1;if(0<z&&(0===e||1!==w))return -1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<n;v++)0!==t[r+v]&&(a[B[t[r+v]]++]=v);if(d=0===e?(A=R=a,19):1===e?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,c=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===e&&852<C||2===e&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<d?(m=0,a[v]):a[v]>d?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;i[c+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=t[r+a[v]];}if(k<b&&(E&f)!==l){for(0===S&&(S=k),c+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===e&&852<C||2===e&&592<C)return 1;i[l=E&f]=k<<24|x<<16|c-s|0;}}return 0!==E&&(i[c+E]=b-S<<24|64<<16|0),o.bits=k,0};},{"../utils/common":41}],51:[function(e,t,r){t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};},{}],52:[function(e,t,r){var i=e("../utils/common"),o=0,h=1;function n(e){for(var t=e.length;0<=--t;)e[t]=0;}var s=0,a=29,u=256,l=u+1+a,f=30,c=19,_=2*l+1,g=15,d=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));n(z);var C=new Array(2*f);n(C);var E=new Array(512);n(E);var A=new Array(256);n(A);var I=new Array(a);n(I);var O,B,R,T=new Array(f);function D(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length;}function F(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t;}function N(e){return e<256?E[e]:E[256+(e>>>7)]}function U(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255;}function P(e,t,r){e.bi_valid>d-r?(e.bi_buf|=t<<e.bi_valid&65535,U(e,e.bi_buf),e.bi_buf=t>>d-e.bi_valid,e.bi_valid+=r-d):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r);}function L(e,t,r){P(e,r[2*t],r[2*t+1]);}function j(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function Z(e,t,r){var n,i,s=new Array(g+1),a=0;for(n=1;n<=g;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=j(s[o]++,o));}}function W(e){var t;for(t=0;t<l;t++)e.dyn_ltree[2*t]=0;for(t=0;t<f;t++)e.dyn_dtree[2*t]=0;for(t=0;t<c;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*m]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0;}function M(e){8<e.bi_valid?U(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0;}function H(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function G(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&H(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!H(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n;}function K(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?L(e,i,t):(L(e,(s=A[i])+u+1,t),0!==(a=w[s])&&P(e,i-=I[s],a),L(e,s=N(--n),r),0!==(a=k[s])&&P(e,n-=T[s],a)),o<e.last_lit;);L(e,m,t);}function Y(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,h=t.stat_desc.elems,u=-1;for(e.heap_len=0,e.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(e.heap[++e.heap_len]=u=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=u<2?++u:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=u,r=e.heap_len>>1;1<=r;r--)G(e,s,r);for(i=h;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],G(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,G(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,h=t.dyn_tree,u=t.max_code,l=t.stat_desc.static_tree,f=t.stat_desc.has_stree,c=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=g;s++)e.bl_count[s]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<_;r++)p<(s=h[2*h[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),h[2*n+1]=s,u<n||(e.bl_count[s]++,a=0,d<=n&&(a=c[n-d]),o=h[2*n],e.opt_len+=o*(s+a),f&&(e.static_len+=o*(l[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2;}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)u<(i=e.heap[--r])||(h[2*i+1]!==s&&(e.opt_len+=(s-h[2*i+1])*h[2*i],h[2*i+1]=s),n--);}}(e,t),Z(s,u,e.bl_count);}function X(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<h&&i===a||(o<u?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[2*b]++):o<=10?e.bl_tree[2*v]++:e.bl_tree[2*y]++,s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4));}function V(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<h&&i===a)){if(o<u)for(;L(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(L(e,i,e.bl_tree),o--),L(e,b,e.bl_tree),P(e,o-3,2)):o<=10?(L(e,v,e.bl_tree),P(e,o-3,3)):(L(e,y,e.bl_tree),P(e,o-11,7));s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4);}}n(T);var q=!1;function J(e,t,r,n){P(e,(s<<1)+(n?1:0),3),function(e,t,r,n){M(e),(U(e,r),U(e,~r)),i.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r;}(e,t,r);}r._tr_init=function(e){q||(function(){var e,t,r,n,i,s=new Array(g+1);for(n=r=0;n<a-1;n++)for(I[n]=r,e=0;e<1<<w[n];e++)A[r++]=n;for(A[r-1]=n,n=i=0;n<16;n++)for(T[n]=i,e=0;e<1<<k[n];e++)E[i++]=n;for(i>>=7;n<f;n++)for(T[n]=i<<7,e=0;e<1<<k[n]-7;e++)E[256+i++]=n;for(t=0;t<=g;t++)s[t]=0;for(e=0;e<=143;)z[2*e+1]=8,e++,s[8]++;for(;e<=255;)z[2*e+1]=9,e++,s[9]++;for(;e<=279;)z[2*e+1]=7,e++,s[7]++;for(;e<=287;)z[2*e+1]=8,e++,s[8]++;for(Z(z,l+1,s),e=0;e<f;e++)C[2*e+1]=5,C[2*e]=j(e,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,c,p);}(),q=!0),e.l_desc=new F(e.dyn_ltree,O),e.d_desc=new F(e.dyn_dtree,B),e.bl_desc=new F(e.bl_tree,R),e.bi_buf=0,e.bi_valid=0,W(e);},r._tr_stored_block=J,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return o;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return h;for(t=32;t<u;t++)if(0!==e.dyn_ltree[2*t])return h;return o}(e)),Y(e,e.l_desc),Y(e,e.d_desc),a=function(e){var t;for(X(e,e.dyn_ltree,e.l_desc.max_code),X(e,e.dyn_dtree,e.d_desc.max_code),Y(e,e.bl_desc),t=c-1;3<=t&&0===e.bl_tree[2*S[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?J(e,t,r,n):4===e.strategy||s===i?(P(e,2+(n?1:0),3),K(e,z,C)):(P(e,4+(n?1:0),3),function(e,t,r,n){var i;for(P(e,t-257,5),P(e,r-1,5),P(e,n-4,4),i=0;i<n;i++)P(e,e.bl_tree[2*S[i]+1],3);V(e,e.dyn_ltree,t-1),V(e,e.dyn_dtree,r-1);}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),K(e,e.dyn_ltree,e.dyn_dtree)),W(e),n&&M(e);},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(A[r]+u+1)]++,e.dyn_dtree[2*N(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){P(e,2,3),L(e,m,z),function(e){16===e.bi_valid?(U(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):8<=e.bi_valid&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8);}(e);};},{"../utils/common":41}],53:[function(e,t,r){t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;};},{}],54:[function(e,t,r){(function(e){!function(r,n){if(!r.setImmediate){var i,s,t,a,o=1,h={},u=!1,l=r.document,e=Object.getPrototypeOf&&Object.getPrototypeOf(r);e=e&&e.setTimeout?e:r,i="[object process]"==={}.toString.call(r.process)?function(e){process.nextTick(function(){c(e);});}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1;},r.postMessage("","*"),r.onmessage=t,e}}()?(a="setImmediate$"+Math.random()+"$",r.addEventListener?r.addEventListener("message",d,!1):r.attachEvent("onmessage",d),function(e){r.postMessage(a+e,"*");}):r.MessageChannel?((t=new MessageChannel).port1.onmessage=function(e){c(e.data);},function(e){t.port2.postMessage(e);}):l&&"onreadystatechange"in l.createElement("script")?(s=l.documentElement,function(e){var t=l.createElement("script");t.onreadystatechange=function(){c(e),t.onreadystatechange=null,s.removeChild(t),t=null;},s.appendChild(t);}):function(e){setTimeout(c,0,e);},e.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var n={callback:e,args:t};return h[o]=n,i(o),o++},e.clearImmediate=f;}function f(e){delete h[e];}function c(e){if(u)setTimeout(c,0,e);else {var t=h[e];if(t){u=!0;try{!function(e){var t=e.callback,r=e.args;switch(r.length){case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break;case 3:t(r[0],r[1],r[2]);break;default:t.apply(n,r);}}(t);}finally{f(e),u=!1;}}}}function d(e){e.source===r&&"string"==typeof e.data&&0===e.data.indexOf(a)&&c(+e.data.slice(a.length));}}("undefined"==typeof self?void 0===e?this:e:self);}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[10])(10)}); 
	} (jszip_min));

	var jszip_minExports = jszip_min.exports;
	var JSZip = /*@__PURE__*/getDefaultExportFromCjs(jszip_minExports);

	const defaultMessages = 'End-Of-Stream';
	/**
	 * Thrown on read operation of the end of file or stream has been reached
	 */
	class EndOfStreamError extends Error {
	    constructor() {
	        super(defaultMessages);
	        this.name = "EndOfStreamError";
	    }
	}
	class AbortError extends Error {
	    constructor(message = "The operation was aborted") {
	        super(message);
	        this.name = "AbortError";
	    }
	}

	class AbstractStreamReader {
	    constructor() {
	        this.endOfStream = false;
	        this.interrupted = false;
	        /**
	         * Store peeked data
	         * @type {Array}
	         */
	        this.peekQueue = [];
	    }
	    async peek(uint8Array, mayBeLess = false) {
	        const bytesRead = await this.read(uint8Array, mayBeLess);
	        this.peekQueue.push(uint8Array.subarray(0, bytesRead)); // Put read data back to peek buffer
	        return bytesRead;
	    }
	    async read(buffer, mayBeLess = false) {
	        if (buffer.length === 0) {
	            return 0;
	        }
	        let bytesRead = this.readFromPeekBuffer(buffer);
	        if (!this.endOfStream) {
	            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
	        }
	        if (bytesRead === 0 && !mayBeLess) {
	            throw new EndOfStreamError();
	        }
	        return bytesRead;
	    }
	    /**
	     * Read chunk from stream
	     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
	     * @returns Number of bytes read
	     */
	    readFromPeekBuffer(buffer) {
	        let remaining = buffer.length;
	        let bytesRead = 0;
	        // consume peeked data first
	        while (this.peekQueue.length > 0 && remaining > 0) {
	            const peekData = this.peekQueue.pop(); // Front of queue
	            if (!peekData)
	                throw new Error('peekData should be defined');
	            const lenCopy = Math.min(peekData.length, remaining);
	            buffer.set(peekData.subarray(0, lenCopy), bytesRead);
	            bytesRead += lenCopy;
	            remaining -= lenCopy;
	            if (lenCopy < peekData.length) {
	                // remainder back to queue
	                this.peekQueue.push(peekData.subarray(lenCopy));
	            }
	        }
	        return bytesRead;
	    }
	    async readRemainderFromStream(buffer, mayBeLess) {
	        let bytesRead = 0;
	        // Continue reading from stream if required
	        while (bytesRead < buffer.length && !this.endOfStream) {
	            if (this.interrupted) {
	                throw new AbortError();
	            }
	            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
	            if (chunkLen === 0)
	                break;
	            bytesRead += chunkLen;
	        }
	        if (!mayBeLess && bytesRead < buffer.length) {
	            throw new EndOfStreamError();
	        }
	        return bytesRead;
	    }
	}

	class WebStreamReader extends AbstractStreamReader {
	    constructor(reader) {
	        super();
	        this.reader = reader;
	    }
	    async abort() {
	        return this.close();
	    }
	    async close() {
	        this.reader.releaseLock();
	    }
	}

	/**
	 * Read from a WebStream using a BYOB reader
	 * Reference: https://nodejs.org/api/webstreams.html#class-readablestreambyobreader
	 */
	class WebStreamByobReader extends WebStreamReader {
	    /**
	     * Read from stream
	     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
	     * @param mayBeLess - If true, may fill the buffer partially
	     * @protected Bytes read
	     */
	    async readFromStream(buffer, mayBeLess) {
	        if (buffer.length === 0)
	            return 0;
	        // @ts-ignore
	        const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
	        if (result.done) {
	            this.endOfStream = result.done;
	        }
	        if (result.value) {
	            buffer.set(result.value);
	            return result.value.length;
	        }
	        return 0;
	    }
	}

	class WebStreamDefaultReader extends AbstractStreamReader {
	    constructor(reader) {
	        super();
	        this.reader = reader;
	        this.buffer = null; // Internal buffer to store excess data
	    }
	    /**
	     * Copy chunk to target, and store the remainder in this.buffer
	     */
	    writeChunk(target, chunk) {
	        const written = Math.min(chunk.length, target.length);
	        target.set(chunk.subarray(0, written));
	        // Adjust the remainder of the buffer
	        if (written < chunk.length) {
	            this.buffer = chunk.subarray(written);
	        }
	        else {
	            this.buffer = null;
	        }
	        return written;
	    }
	    /**
	     * Read from stream
	     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
	     * @param mayBeLess - If true, may fill the buffer partially
	     * @protected Bytes read
	     */
	    async readFromStream(buffer, mayBeLess) {
	        if (buffer.length === 0)
	            return 0;
	        let totalBytesRead = 0;
	        // Serve from the internal buffer first
	        if (this.buffer) {
	            totalBytesRead += this.writeChunk(buffer, this.buffer);
	        }
	        // Continue reading from the stream if more data is needed
	        while (totalBytesRead < buffer.length && !this.endOfStream) {
	            const result = await this.reader.read();
	            if (result.done) {
	                this.endOfStream = true;
	                break;
	            }
	            if (result.value) {
	                totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
	            }
	        }
	        if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
	            throw new EndOfStreamError();
	        }
	        return totalBytesRead;
	    }
	    abort() {
	        this.interrupted = true;
	        return this.reader.cancel();
	    }
	    async close() {
	        await this.abort();
	        this.reader.releaseLock();
	    }
	}

	function makeWebStreamReader(stream) {
	    try {
	        const reader = stream.getReader({ mode: "byob" });
	        if (reader instanceof ReadableStreamDefaultReader) {
	            // Fallback to default reader in case `mode: byob` is ignored
	            return new WebStreamDefaultReader(reader);
	        }
	        return new WebStreamByobReader(reader);
	    }
	    catch (error) {
	        if (error instanceof TypeError) {
	            // Fallback to default reader in case `mode: byob` rejected by a `TypeError`
	            return new WebStreamDefaultReader(stream.getReader());
	        }
	        throw error;
	    }
	}

	/**
	 * Core tokenizer
	 */
	class AbstractTokenizer {
	    /**
	     * Constructor
	     * @param options Tokenizer options
	     * @protected
	     */
	    constructor(options) {
	        this.numBuffer = new Uint8Array(8);
	        /**
	         * Tokenizer-stream position
	         */
	        this.position = 0;
	        this.onClose = options?.onClose;
	        if (options?.abortSignal) {
	            options.abortSignal.addEventListener('abort', () => {
	                this.abort();
	            });
	        }
	    }
	    /**
	     * Read a token from the tokenizer-stream
	     * @param token - The token to read
	     * @param position - If provided, the desired position in the tokenizer-stream
	     * @returns Promise with token data
	     */
	    async readToken(token, position = this.position) {
	        const uint8Array = new Uint8Array(token.len);
	        const len = await this.readBuffer(uint8Array, { position });
	        if (len < token.len)
	            throw new EndOfStreamError();
	        return token.get(uint8Array, 0);
	    }
	    /**
	     * Peek a token from the tokenizer-stream.
	     * @param token - Token to peek from the tokenizer-stream.
	     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
	     * @returns Promise with token data
	     */
	    async peekToken(token, position = this.position) {
	        const uint8Array = new Uint8Array(token.len);
	        const len = await this.peekBuffer(uint8Array, { position });
	        if (len < token.len)
	            throw new EndOfStreamError();
	        return token.get(uint8Array, 0);
	    }
	    /**
	     * Read a numeric token from the stream
	     * @param token - Numeric token
	     * @returns Promise with number
	     */
	    async readNumber(token) {
	        const len = await this.readBuffer(this.numBuffer, { length: token.len });
	        if (len < token.len)
	            throw new EndOfStreamError();
	        return token.get(this.numBuffer, 0);
	    }
	    /**
	     * Read a numeric token from the stream
	     * @param token - Numeric token
	     * @returns Promise with number
	     */
	    async peekNumber(token) {
	        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
	        if (len < token.len)
	            throw new EndOfStreamError();
	        return token.get(this.numBuffer, 0);
	    }
	    /**
	     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
	     * @param length - Number of bytes to ignore
	     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
	     */
	    async ignore(length) {
	        if (this.fileInfo.size !== undefined) {
	            const bytesLeft = this.fileInfo.size - this.position;
	            if (length > bytesLeft) {
	                this.position += bytesLeft;
	                return bytesLeft;
	            }
	        }
	        this.position += length;
	        return length;
	    }
	    async close() {
	        await this.abort();
	        await this.onClose?.();
	    }
	    normalizeOptions(uint8Array, options) {
	        if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
	            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	        }
	        return {
	            ...{
	                mayBeLess: false,
	                offset: 0,
	                length: uint8Array.length,
	                position: this.position
	            }, ...options
	        };
	    }
	    abort() {
	        return Promise.resolve(); // Ignore abort signal
	    }
	}

	const maxBufferSize = 256000;
	class ReadStreamTokenizer extends AbstractTokenizer {
	    /**
	     * Constructor
	     * @param streamReader stream-reader to read from
	     * @param options Tokenizer options
	     */
	    constructor(streamReader, options) {
	        super(options);
	        this.streamReader = streamReader;
	        this.fileInfo = options?.fileInfo ?? {};
	    }
	    /**
	     * Read buffer from tokenizer
	     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
	     * @param options - Read behaviour options
	     * @returns Promise with number of bytes read
	     */
	    async readBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        const skipBytes = normOptions.position - this.position;
	        if (skipBytes > 0) {
	            await this.ignore(skipBytes);
	            return this.readBuffer(uint8Array, options);
	        }
	        if (skipBytes < 0) {
	            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	        }
	        if (normOptions.length === 0) {
	            return 0;
	        }
	        const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
	        this.position += bytesRead;
	        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
	            throw new EndOfStreamError();
	        }
	        return bytesRead;
	    }
	    /**
	     * Peek (read ahead) buffer from tokenizer
	     * @param uint8Array - Uint8Array (or Buffer) to write data to
	     * @param options - Read behaviour options
	     * @returns Promise with number of bytes peeked
	     */
	    async peekBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        let bytesRead = 0;
	        if (normOptions.position) {
	            const skipBytes = normOptions.position - this.position;
	            if (skipBytes > 0) {
	                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
	                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
	                uint8Array.set(skipBuffer.subarray(skipBytes));
	                return bytesRead - skipBytes;
	            }
	            if (skipBytes < 0) {
	                throw new Error('Cannot peek from a negative offset in a stream');
	            }
	        }
	        if (normOptions.length > 0) {
	            try {
	                bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
	            }
	            catch (err) {
	                if (options?.mayBeLess && err instanceof EndOfStreamError) {
	                    return 0;
	                }
	                throw err;
	            }
	            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {
	                throw new EndOfStreamError();
	            }
	        }
	        return bytesRead;
	    }
	    async ignore(length) {
	        // debug(`ignore ${this.position}...${this.position + length - 1}`);
	        const bufSize = Math.min(maxBufferSize, length);
	        const buf = new Uint8Array(bufSize);
	        let totBytesRead = 0;
	        while (totBytesRead < length) {
	            const remaining = length - totBytesRead;
	            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
	            if (bytesRead < 0) {
	                return bytesRead;
	            }
	            totBytesRead += bytesRead;
	        }
	        return totBytesRead;
	    }
	    abort() {
	        return this.streamReader.abort();
	    }
	    async close() {
	        return this.streamReader.close();
	    }
	    supportsRandomAccess() {
	        return false;
	    }
	}

	class BufferTokenizer extends AbstractTokenizer {
	    /**
	     * Construct BufferTokenizer
	     * @param uint8Array - Uint8Array to tokenize
	     * @param options Tokenizer options
	     */
	    constructor(uint8Array, options) {
	        super(options);
	        this.uint8Array = uint8Array;
	        this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
	    }
	    /**
	     * Read buffer from tokenizer
	     * @param uint8Array - Uint8Array to tokenize
	     * @param options - Read behaviour options
	     * @returns {Promise<number>}
	     */
	    async readBuffer(uint8Array, options) {
	        if (options?.position) {
	            this.position = options.position;
	        }
	        const bytesRead = await this.peekBuffer(uint8Array, options);
	        this.position += bytesRead;
	        return bytesRead;
	    }
	    /**
	     * Peek (read ahead) buffer from tokenizer
	     * @param uint8Array
	     * @param options - Read behaviour options
	     * @returns {Promise<number>}
	     */
	    async peekBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
	        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {
	            throw new EndOfStreamError();
	        }
	        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
	        return bytes2read;
	    }
	    close() {
	        return super.close();
	    }
	    supportsRandomAccess() {
	        return true;
	    }
	    setPosition(position) {
	        this.position = position;
	    }
	}

	/**
	 * Construct ReadStreamTokenizer from given ReadableStream (WebStream API).
	 * Will set fileSize, if provided given Stream has set the .path property/
	 * @param webStream - Read from Node.js Stream.Readable (must be a byte stream)
	 * @param options - Tokenizer options
	 * @returns ReadStreamTokenizer
	 */
	function fromWebStream(webStream, options) {
	    const webStreamReader = makeWebStreamReader(webStream);
	    const _options = options ?? {};
	    const chainedClose = _options.onClose;
	    _options.onClose = async () => {
	        await webStreamReader.close();
	        if (chainedClose) {
	            return chainedClose();
	        }
	    };
	    return new ReadStreamTokenizer(webStreamReader, _options);
	}
	/**
	 * Construct ReadStreamTokenizer from given Buffer.
	 * @param uint8Array - Uint8Array to tokenize
	 * @param options - Tokenizer options
	 * @returns BufferTokenizer
	 */
	function fromBuffer(uint8Array, options) {
	    return new BufferTokenizer(uint8Array, options);
	}

	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

	var read$1 = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	var write$1 = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};

	// Primitive types
	function dv(array) {
	    return new DataView(array.buffer, array.byteOffset);
	}
	/**
	 * 8-bit unsigned integer
	 */
	const UINT8 = {
	    len: 1,
	    get(array, offset) {
	        return dv(array).getUint8(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setUint8(offset, value);
	        return offset + 1;
	    }
	};
	/**
	 * 16-bit unsigned integer, Little Endian byte order
	 */
	const UINT16_LE = {
	    len: 2,
	    get(array, offset) {
	        return dv(array).getUint16(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setUint16(offset, value, true);
	        return offset + 2;
	    }
	};
	/**
	 * 16-bit unsigned integer, Big Endian byte order
	 */
	const UINT16_BE = {
	    len: 2,
	    get(array, offset) {
	        return dv(array).getUint16(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setUint16(offset, value);
	        return offset + 2;
	    }
	};
	/**
	 * 24-bit unsigned integer, Little Endian byte order
	 */
	const UINT24_LE = {
	    len: 3,
	    get(array, offset) {
	        const dataView = dv(array);
	        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
	    },
	    put(array, offset, value) {
	        const dataView = dv(array);
	        dataView.setUint8(offset, value & 0xff);
	        dataView.setUint16(offset + 1, value >> 8, true);
	        return offset + 3;
	    }
	};
	/**
	 * 24-bit unsigned integer, Big Endian byte order
	 */
	const UINT24_BE = {
	    len: 3,
	    get(array, offset) {
	        const dataView = dv(array);
	        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
	    },
	    put(array, offset, value) {
	        const dataView = dv(array);
	        dataView.setUint16(offset, value >> 8);
	        dataView.setUint8(offset + 2, value & 0xff);
	        return offset + 3;
	    }
	};
	/**
	 * 32-bit unsigned integer, Little Endian byte order
	 */
	const UINT32_LE = {
	    len: 4,
	    get(array, offset) {
	        return dv(array).getUint32(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setUint32(offset, value, true);
	        return offset + 4;
	    }
	};
	/**
	 * 32-bit unsigned integer, Big Endian byte order
	 */
	const UINT32_BE = {
	    len: 4,
	    get(array, offset) {
	        return dv(array).getUint32(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setUint32(offset, value);
	        return offset + 4;
	    }
	};
	/**
	 * 8-bit signed integer
	 */
	const INT8 = {
	    len: 1,
	    get(array, offset) {
	        return dv(array).getInt8(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setInt8(offset, value);
	        return offset + 1;
	    }
	};
	/**
	 * 16-bit signed integer, Big Endian byte order
	 */
	const INT16_BE = {
	    len: 2,
	    get(array, offset) {
	        return dv(array).getInt16(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setInt16(offset, value);
	        return offset + 2;
	    }
	};
	/**
	 * 16-bit signed integer, Little Endian byte order
	 */
	const INT16_LE = {
	    len: 2,
	    get(array, offset) {
	        return dv(array).getInt16(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setInt16(offset, value, true);
	        return offset + 2;
	    }
	};
	/**
	 * 24-bit signed integer, Little Endian byte order
	 */
	const INT24_LE = {
	    len: 3,
	    get(array, offset) {
	        const unsigned = UINT24_LE.get(array, offset);
	        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
	    },
	    put(array, offset, value) {
	        const dataView = dv(array);
	        dataView.setUint8(offset, value & 0xff);
	        dataView.setUint16(offset + 1, value >> 8, true);
	        return offset + 3;
	    }
	};
	/**
	 * 24-bit signed integer, Big Endian byte order
	 */
	const INT24_BE = {
	    len: 3,
	    get(array, offset) {
	        const unsigned = UINT24_BE.get(array, offset);
	        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
	    },
	    put(array, offset, value) {
	        const dataView = dv(array);
	        dataView.setUint16(offset, value >> 8);
	        dataView.setUint8(offset + 2, value & 0xff);
	        return offset + 3;
	    }
	};
	/**
	 * 32-bit signed integer, Big Endian byte order
	 */
	const INT32_BE = {
	    len: 4,
	    get(array, offset) {
	        return dv(array).getInt32(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setInt32(offset, value);
	        return offset + 4;
	    }
	};
	/**
	 * 32-bit signed integer, Big Endian byte order
	 */
	const INT32_LE = {
	    len: 4,
	    get(array, offset) {
	        return dv(array).getInt32(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setInt32(offset, value, true);
	        return offset + 4;
	    }
	};
	/**
	 * 64-bit unsigned integer, Little Endian byte order
	 */
	const UINT64_LE = {
	    len: 8,
	    get(array, offset) {
	        return dv(array).getBigUint64(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setBigUint64(offset, value, true);
	        return offset + 8;
	    }
	};
	/**
	 * 64-bit signed integer, Little Endian byte order
	 */
	const INT64_LE = {
	    len: 8,
	    get(array, offset) {
	        return dv(array).getBigInt64(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setBigInt64(offset, value, true);
	        return offset + 8;
	    }
	};
	/**
	 * 64-bit unsigned integer, Big Endian byte order
	 */
	const UINT64_BE = {
	    len: 8,
	    get(array, offset) {
	        return dv(array).getBigUint64(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setBigUint64(offset, value);
	        return offset + 8;
	    }
	};
	/**
	 * 64-bit signed integer, Big Endian byte order
	 */
	const INT64_BE = {
	    len: 8,
	    get(array, offset) {
	        return dv(array).getBigInt64(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setBigInt64(offset, value);
	        return offset + 8;
	    }
	};
	/**
	 * IEEE 754 16-bit (half precision) float, big endian
	 */
	const Float16_BE = {
	    len: 2,
	    get(dataView, offset) {
	        return read$1(dataView, offset, false, 10, this.len);
	    },
	    put(dataView, offset, value) {
	        write$1(dataView, value, offset, false, 10, this.len);
	        return offset + this.len;
	    }
	};
	/**
	 * IEEE 754 16-bit (half precision) float, little endian
	 */
	const Float16_LE = {
	    len: 2,
	    get(array, offset) {
	        return read$1(array, offset, true, 10, this.len);
	    },
	    put(array, offset, value) {
	        write$1(array, value, offset, true, 10, this.len);
	        return offset + this.len;
	    }
	};
	/**
	 * IEEE 754 32-bit (single precision) float, big endian
	 */
	const Float32_BE = {
	    len: 4,
	    get(array, offset) {
	        return dv(array).getFloat32(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setFloat32(offset, value);
	        return offset + 4;
	    }
	};
	/**
	 * IEEE 754 32-bit (single precision) float, little endian
	 */
	const Float32_LE = {
	    len: 4,
	    get(array, offset) {
	        return dv(array).getFloat32(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setFloat32(offset, value, true);
	        return offset + 4;
	    }
	};
	/**
	 * IEEE 754 64-bit (double precision) float, big endian
	 */
	const Float64_BE = {
	    len: 8,
	    get(array, offset) {
	        return dv(array).getFloat64(offset);
	    },
	    put(array, offset, value) {
	        dv(array).setFloat64(offset, value);
	        return offset + 8;
	    }
	};
	/**
	 * IEEE 754 64-bit (double precision) float, little endian
	 */
	const Float64_LE = {
	    len: 8,
	    get(array, offset) {
	        return dv(array).getFloat64(offset, true);
	    },
	    put(array, offset, value) {
	        dv(array).setFloat64(offset, value, true);
	        return offset + 8;
	    }
	};
	/**
	 * IEEE 754 80-bit (extended precision) float, big endian
	 */
	const Float80_BE = {
	    len: 10,
	    get(array, offset) {
	        return read$1(array, offset, false, 63, this.len);
	    },
	    put(array, offset, value) {
	        write$1(array, value, offset, false, 63, this.len);
	        return offset + this.len;
	    }
	};
	/**
	 * IEEE 754 80-bit (extended precision) float, little endian
	 */
	const Float80_LE = {
	    len: 10,
	    get(array, offset) {
	        return read$1(array, offset, true, 63, this.len);
	    },
	    put(array, offset, value) {
	        write$1(array, value, offset, true, 63, this.len);
	        return offset + this.len;
	    }
	};
	/**
	 * Ignore a given number of bytes
	 */
	class IgnoreType {
	    /**
	     * @param len number of bytes to ignore
	     */
	    constructor(len) {
	        this.len = len;
	    }
	    // ToDo: don't read, but skip data
	    get(_array, _off) {
	    }
	}
	class Uint8ArrayType {
	    constructor(len) {
	        this.len = len;
	    }
	    get(array, offset) {
	        return array.subarray(offset, offset + this.len);
	    }
	}
	/**
	 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
	 * Supports all encodings supported by TextDecoder, plus 'windows-1252'.
	 */
	class StringType {
	    constructor(len, encoding) {
	        this.len = len;
	        if (encoding && encoding.toLowerCase() === 'windows-1252') {
	            this.decoder = StringType.decodeWindows1252;
	        }
	        else {
	            const textDecoder = new TextDecoder(encoding);
	            this.decoder = (bytes) => textDecoder.decode(bytes);
	        }
	    }
	    get(data, offset = 0) {
	        const bytes = data.subarray(offset, offset + this.len);
	        return this.decoder(bytes);
	    }
	    static decodeWindows1252(bytes) {
	        let result = '';
	        for (let i = 0; i < bytes.length; i++) {
	            const byte = bytes[i];
	            result += byte < 0x80 || byte >= 0xA0
	                ? String.fromCharCode(byte)
	                : StringType.win1252Map[byte - 0x80];
	        }
	        return result;
	    }
	}
	StringType.win1252Map = '\u20AC\u0081\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\u008D\u017D\u008F\u0090\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\u009D\u017E\u0178';
	/**
	 * ANSI Latin 1 String using Windows-1252 (Code Page 1252)
	 * Windows-1252 is a superset of ISO 8859-1 / Latin-1.
	 */
	class AnsiStringType extends StringType {
	    constructor(len) {
	        super(len, 'windows-1252');
	    }
	}

	var Token = /*#__PURE__*/Object.freeze({
		__proto__: null,
		AnsiStringType: AnsiStringType,
		Float16_BE: Float16_BE,
		Float16_LE: Float16_LE,
		Float32_BE: Float32_BE,
		Float32_LE: Float32_LE,
		Float64_BE: Float64_BE,
		Float64_LE: Float64_LE,
		Float80_BE: Float80_BE,
		Float80_LE: Float80_LE,
		INT16_BE: INT16_BE,
		INT16_LE: INT16_LE,
		INT24_BE: INT24_BE,
		INT24_LE: INT24_LE,
		INT32_BE: INT32_BE,
		INT32_LE: INT32_LE,
		INT64_BE: INT64_BE,
		INT64_LE: INT64_LE,
		INT8: INT8,
		IgnoreType: IgnoreType,
		StringType: StringType,
		UINT16_BE: UINT16_BE,
		UINT16_LE: UINT16_LE,
		UINT24_BE: UINT24_BE,
		UINT24_LE: UINT24_LE,
		UINT32_BE: UINT32_BE,
		UINT32_LE: UINT32_LE,
		UINT64_BE: UINT64_BE,
		UINT64_LE: UINT64_LE,
		UINT8: UINT8,
		Uint8ArrayType: Uint8ArrayType
	});

	// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
	// https://tools.ietf.org/html/rfc1951
	// You may also wish to take a look at the guide I made about this program:
	// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
	// Some of the following code is similar to that of UZIP.js:
	// https://github.com/photopea/UZIP.js
	// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
	// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
	// is better for memory in most engines (I *think*).

	// aliases for shorter compressed code (most minifers don't do this)
	var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
	// fixed length extra bits
	var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
	// fixed distance extra bits
	var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
	// code length index map
	var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
	// get base, reverse index map from extra bits
	var freb = function (eb, start) {
	    var b = new u16(31);
	    for (var i = 0; i < 31; ++i) {
	        b[i] = start += 1 << eb[i - 1];
	    }
	    // numbers here are at max 18 bits
	    var r = new i32(b[30]);
	    for (var i = 1; i < 30; ++i) {
	        for (var j = b[i]; j < b[i + 1]; ++j) {
	            r[j] = ((j - b[i]) << 5) | i;
	        }
	    }
	    return { b: b, r: r };
	};
	var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
	// we can ignore the fact that the other numbers are wrong; they never happen anyway
	fl[28] = 258, revfl[258] = 28;
	var _b = freb(fdeb, 0), fd = _b.b;
	// map of value to reverse (assuming 16 bits)
	var rev = new u16(32768);
	for (var i$1 = 0; i$1 < 32768; ++i$1) {
	    // reverse table algorithm from SO
	    var x$1 = ((i$1 & 0xAAAA) >> 1) | ((i$1 & 0x5555) << 1);
	    x$1 = ((x$1 & 0xCCCC) >> 2) | ((x$1 & 0x3333) << 2);
	    x$1 = ((x$1 & 0xF0F0) >> 4) | ((x$1 & 0x0F0F) << 4);
	    rev[i$1] = (((x$1 & 0xFF00) >> 8) | ((x$1 & 0x00FF) << 8)) >> 1;
	}
	// create huffman tree from u8 "map": index -> code length for code index
	// mb (max bits) must be at most 15
	// TODO: optimize/split up?
	var hMap = (function (cd, mb, r) {
	    var s = cd.length;
	    // index
	    var i = 0;
	    // u16 "map": index -> # of codes with bit length = index
	    var l = new u16(mb);
	    // length of cd must be 288 (total # of codes)
	    for (; i < s; ++i) {
	        if (cd[i])
	            ++l[cd[i] - 1];
	    }
	    // u16 "map": index -> minimum code for bit length = index
	    var le = new u16(mb);
	    for (i = 1; i < mb; ++i) {
	        le[i] = (le[i - 1] + l[i - 1]) << 1;
	    }
	    var co;
	    if (r) {
	        // u16 "map": index -> number of actual bits, symbol for code
	        co = new u16(1 << mb);
	        // bits to remove for reverser
	        var rvb = 15 - mb;
	        for (i = 0; i < s; ++i) {
	            // ignore 0 lengths
	            if (cd[i]) {
	                // num encoding both symbol and bits read
	                var sv = (i << 4) | cd[i];
	                // free bits
	                var r_1 = mb - cd[i];
	                // start value
	                var v = le[cd[i] - 1]++ << r_1;
	                // m is end value
	                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
	                    // every 16 bit value starting with the code yields the same result
	                    co[rev[v] >> rvb] = sv;
	                }
	            }
	        }
	    }
	    else {
	        co = new u16(s);
	        for (i = 0; i < s; ++i) {
	            if (cd[i]) {
	                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);
	            }
	        }
	    }
	    return co;
	});
	// fixed length tree
	var flt = new u8(288);
	for (var i$1 = 0; i$1 < 144; ++i$1)
	    flt[i$1] = 8;
	for (var i$1 = 144; i$1 < 256; ++i$1)
	    flt[i$1] = 9;
	for (var i$1 = 256; i$1 < 280; ++i$1)
	    flt[i$1] = 7;
	for (var i$1 = 280; i$1 < 288; ++i$1)
	    flt[i$1] = 8;
	// fixed distance tree
	var fdt = new u8(32);
	for (var i$1 = 0; i$1 < 32; ++i$1)
	    fdt[i$1] = 5;
	// fixed length map
	var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
	// fixed distance map
	var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
	// find max of array
	var max = function (a) {
	    var m = a[0];
	    for (var i = 1; i < a.length; ++i) {
	        if (a[i] > m)
	            m = a[i];
	    }
	    return m;
	};
	// read d, starting at bit p and mask with m
	var bits = function (d, p, m) {
	    var o = (p / 8) | 0;
	    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
	};
	// read d, starting at bit p continuing for at least 16 bits
	var bits16 = function (d, p) {
	    var o = (p / 8) | 0;
	    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
	};
	// get end of byte
	var shft = function (p) { return ((p + 7) / 8) | 0; };
	// typed array slice - allows garbage collector to free original reference,
	// while being more compatible than .slice
	var slc = function (v, s, e) {
	    if (e == null || e > v.length)
	        e = v.length;
	    // can't use .constructor in case user-supplied
	    return new u8(v.subarray(s, e));
	};
	// error codes
	var ec = [
	    'unexpected EOF',
	    'invalid block type',
	    'invalid length/literal',
	    'invalid distance',
	    'stream finished',
	    'no stream handler',
	    ,
	    'no callback',
	    'invalid UTF-8 data',
	    'extra field too long',
	    'date not in range 1980-2099',
	    'filename too long',
	    'stream finishing',
	    'invalid zip data'
	    // determined by unknown compression method
	];
	var err = function (ind, msg, nt) {
	    var e = new Error(msg || ec[ind]);
	    e.code = ind;
	    if (Error.captureStackTrace)
	        Error.captureStackTrace(e, err);
	    if (!nt)
	        throw e;
	    return e;
	};
	// expands raw DEFLATE data
	var inflt = function (dat, st, buf, dict) {
	    // source length       dict length
	    var sl = dat.length, dl = 0;
	    if (!sl || st.f && !st.l)
	        return buf || new u8(0);
	    var noBuf = !buf;
	    // have to estimate size
	    var resize = noBuf || st.i != 2;
	    // no state
	    var noSt = st.i;
	    // Assumes roughly 33% compression ratio average
	    if (noBuf)
	        buf = new u8(sl * 3);
	    // ensure buffer can fit at least l elements
	    var cbuf = function (l) {
	        var bl = buf.length;
	        // need to increase size to fit
	        if (l > bl) {
	            // Double or set to necessary, whichever is greater
	            var nbuf = new u8(Math.max(bl * 2, l));
	            nbuf.set(buf);
	            buf = nbuf;
	        }
	    };
	    //  last chunk         bitpos           bytes
	    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
	    // total bits
	    var tbts = sl * 8;
	    do {
	        if (!lm) {
	            // BFINAL - this is only 1 when last chunk is next
	            final = bits(dat, pos, 1);
	            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
	            var type = bits(dat, pos + 1, 3);
	            pos += 3;
	            if (!type) {
	                // go to end of byte boundary
	                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
	                if (t > sl) {
	                    if (noSt)
	                        err(0);
	                    break;
	                }
	                // ensure size
	                if (resize)
	                    cbuf(bt + l);
	                // Copy over uncompressed data
	                buf.set(dat.subarray(s, t), bt);
	                // Get new bitpos, update byte count
	                st.b = bt += l, st.p = pos = t * 8, st.f = final;
	                continue;
	            }
	            else if (type == 1)
	                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
	            else if (type == 2) {
	                //  literal                            lengths
	                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
	                var tl = hLit + bits(dat, pos + 5, 31) + 1;
	                pos += 14;
	                // length+distance tree
	                var ldt = new u8(tl);
	                // code length tree
	                var clt = new u8(19);
	                for (var i = 0; i < hcLen; ++i) {
	                    // use index map to get real code
	                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
	                }
	                pos += hcLen * 3;
	                // code lengths bits
	                var clb = max(clt), clbmsk = (1 << clb) - 1;
	                // code lengths map
	                var clm = hMap(clt, clb, 1);
	                for (var i = 0; i < tl;) {
	                    var r = clm[bits(dat, pos, clbmsk)];
	                    // bits read
	                    pos += r & 15;
	                    // symbol
	                    var s = r >> 4;
	                    // code length to copy
	                    if (s < 16) {
	                        ldt[i++] = s;
	                    }
	                    else {
	                        //  copy   count
	                        var c = 0, n = 0;
	                        if (s == 16)
	                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
	                        else if (s == 17)
	                            n = 3 + bits(dat, pos, 7), pos += 3;
	                        else if (s == 18)
	                            n = 11 + bits(dat, pos, 127), pos += 7;
	                        while (n--)
	                            ldt[i++] = c;
	                    }
	                }
	                //    length tree                 distance tree
	                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
	                // max length bits
	                lbt = max(lt);
	                // max dist bits
	                dbt = max(dt);
	                lm = hMap(lt, lbt, 1);
	                dm = hMap(dt, dbt, 1);
	            }
	            else
	                err(1);
	            if (pos > tbts) {
	                if (noSt)
	                    err(0);
	                break;
	            }
	        }
	        // Make sure the buffer can hold this + the largest possible addition
	        // Maximum chunk size (practically, theoretically infinite) is 2^17
	        if (resize)
	            cbuf(bt + 131072);
	        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
	        var lpos = pos;
	        for (;; lpos = pos) {
	            // bits read, code
	            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
	            pos += c & 15;
	            if (pos > tbts) {
	                if (noSt)
	                    err(0);
	                break;
	            }
	            if (!c)
	                err(2);
	            if (sym < 256)
	                buf[bt++] = sym;
	            else if (sym == 256) {
	                lpos = pos, lm = null;
	                break;
	            }
	            else {
	                var add = sym - 254;
	                // no extra bits needed if less
	                if (sym > 264) {
	                    // index
	                    var i = sym - 257, b = fleb[i];
	                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
	                    pos += b;
	                }
	                // dist
	                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
	                if (!d)
	                    err(3);
	                pos += d & 15;
	                var dt = fd[dsym];
	                if (dsym > 3) {
	                    var b = fdeb[dsym];
	                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
	                }
	                if (pos > tbts) {
	                    if (noSt)
	                        err(0);
	                    break;
	                }
	                if (resize)
	                    cbuf(bt + 131072);
	                var end = bt + add;
	                if (bt < dt) {
	                    var shift = dl - dt, dend = Math.min(dt, end);
	                    if (shift + bt < 0)
	                        err(3);
	                    for (; bt < dend; ++bt)
	                        buf[bt] = dict[shift + bt];
	                }
	                for (; bt < end; ++bt)
	                    buf[bt] = buf[bt - dt];
	            }
	        }
	        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
	        if (lm)
	            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
	    } while (!final);
	    // don't reallocate for streams or user buffers
	    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
	};
	// empty
	var et = /*#__PURE__*/ new u8(0);
	// gzip footer: -8 to -4 = CRC, -4 to -0 is length
	// gzip start
	var gzs = function (d) {
	    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
	        err(6, 'invalid gzip data');
	    var flg = d[3];
	    var st = 10;
	    if (flg & 4)
	        st += (d[10] | d[11] << 8) + 2;
	    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
	        ;
	    return st + (flg & 2);
	};
	// gzip length
	var gzl = function (d) {
	    var l = d.length;
	    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
	};
	// zlib start
	var zls = function (d, dict) {
	    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
	        err(6, 'invalid zlib data');
	    if ((d[1] >> 5 & 1) == +!dict)
	        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');
	    return (d[1] >> 3 & 4) + 2;
	};
	/**
	 * Expands DEFLATE data with no wrapper
	 * @param data The data to decompress
	 * @param opts The decompression options
	 * @returns The decompressed version of the data
	 */
	function inflateSync(data, opts) {
	    return inflt(data, { i: 2 }, opts , opts );
	}
	/**
	 * Expands GZIP data
	 * @param data The data to decompress
	 * @param opts The decompression options
	 * @returns The decompressed version of the data
	 */
	function gunzipSync(data, opts) {
	    var st = gzs(data);
	    if (st + 8 > data.length)
	        err(6, 'invalid gzip data');
	    return inflt(data.subarray(st, -8), { i: 2 }, new u8(gzl(data)), opts );
	}
	/**
	 * Expands Zlib data
	 * @param data The data to decompress
	 * @param opts The decompression options
	 * @returns The decompressed version of the data
	 */
	function unzlibSync(data, opts) {
	    return inflt(data.subarray(zls(data, opts ), -4), { i: 2 }, opts , opts );
	}
	/**
	 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
	 * @param data The data to decompress
	 * @param opts The decompression options
	 * @returns The decompressed version of the data
	 */
	function decompressSync(data, opts) {
	    return (data[0] == 31 && data[1] == 139 && data[2] == 8)
	        ? gunzipSync(data, opts)
	        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
	            ? inflateSync(data, opts)
	            : unzlibSync(data, opts);
	}
	// text decoder
	var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
	try {
	    td.decode(et, { stream: true });
	}
	catch (e) { }

	var browser$4 = {exports: {}};

	/**
	 * Helpers.
	 */

	var ms$1;
	var hasRequiredMs;

	function requireMs () {
		if (hasRequiredMs) return ms$1;
		hasRequiredMs = 1;
		var s = 1000;
		var m = s * 60;
		var h = m * 60;
		var d = h * 24;
		var w = d * 7;
		var y = d * 365.25;

		/**
		 * Parse or format the given `val`.
		 *
		 * Options:
		 *
		 *  - `long` verbose formatting [false]
		 *
		 * @param {String|Number} val
		 * @param {Object} [options]
		 * @throws {Error} throw an error if val is not a non-empty string or a number
		 * @return {String|Number}
		 * @api public
		 */

		ms$1 = function (val, options) {
		  options = options || {};
		  var type = typeof val;
		  if (type === 'string' && val.length > 0) {
		    return parse(val);
		  } else if (type === 'number' && isFinite(val)) {
		    return options.long ? fmtLong(val) : fmtShort(val);
		  }
		  throw new Error(
		    'val is not a non-empty string or a valid number. val=' +
		      JSON.stringify(val)
		  );
		};

		/**
		 * Parse the given `str` and return milliseconds.
		 *
		 * @param {String} str
		 * @return {Number}
		 * @api private
		 */

		function parse(str) {
		  str = String(str);
		  if (str.length > 100) {
		    return;
		  }
		  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
		    str
		  );
		  if (!match) {
		    return;
		  }
		  var n = parseFloat(match[1]);
		  var type = (match[2] || 'ms').toLowerCase();
		  switch (type) {
		    case 'years':
		    case 'year':
		    case 'yrs':
		    case 'yr':
		    case 'y':
		      return n * y;
		    case 'weeks':
		    case 'week':
		    case 'w':
		      return n * w;
		    case 'days':
		    case 'day':
		    case 'd':
		      return n * d;
		    case 'hours':
		    case 'hour':
		    case 'hrs':
		    case 'hr':
		    case 'h':
		      return n * h;
		    case 'minutes':
		    case 'minute':
		    case 'mins':
		    case 'min':
		    case 'm':
		      return n * m;
		    case 'seconds':
		    case 'second':
		    case 'secs':
		    case 'sec':
		    case 's':
		      return n * s;
		    case 'milliseconds':
		    case 'millisecond':
		    case 'msecs':
		    case 'msec':
		    case 'ms':
		      return n;
		    default:
		      return undefined;
		  }
		}

		/**
		 * Short format for `ms`.
		 *
		 * @param {Number} ms
		 * @return {String}
		 * @api private
		 */

		function fmtShort(ms) {
		  var msAbs = Math.abs(ms);
		  if (msAbs >= d) {
		    return Math.round(ms / d) + 'd';
		  }
		  if (msAbs >= h) {
		    return Math.round(ms / h) + 'h';
		  }
		  if (msAbs >= m) {
		    return Math.round(ms / m) + 'm';
		  }
		  if (msAbs >= s) {
		    return Math.round(ms / s) + 's';
		  }
		  return ms + 'ms';
		}

		/**
		 * Long format for `ms`.
		 *
		 * @param {Number} ms
		 * @return {String}
		 * @api private
		 */

		function fmtLong(ms) {
		  var msAbs = Math.abs(ms);
		  if (msAbs >= d) {
		    return plural(ms, msAbs, d, 'day');
		  }
		  if (msAbs >= h) {
		    return plural(ms, msAbs, h, 'hour');
		  }
		  if (msAbs >= m) {
		    return plural(ms, msAbs, m, 'minute');
		  }
		  if (msAbs >= s) {
		    return plural(ms, msAbs, s, 'second');
		  }
		  return ms + ' ms';
		}

		/**
		 * Pluralization helper.
		 */

		function plural(ms, msAbs, n, name) {
		  var isPlural = msAbs >= n * 1.5;
		  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
		}
		return ms$1;
	}

	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(/\s+/g, ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	var common = setup;

	/* eslint-env browser */

	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			let m;

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			// eslint-disable-next-line no-return-assign
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = common(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser$4, browser$4.exports));

	var browserExports = browser$4.exports;
	var initDebug = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

	/**
	 * Ref https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
	 */
	const Signature = {
	    LocalFileHeader: 0x04034b50,
	    DataDescriptor: 0x08074b50,
	    CentralFileHeader: 0x02014b50,
	    EndOfCentralDirectory: 0x06054b50
	};
	const DataDescriptor = {
	    get(array) {
	        UINT16_LE.get(array, 6);
	        return {
	            signature: UINT32_LE.get(array, 0),
	            compressedSize: UINT32_LE.get(array, 8),
	            uncompressedSize: UINT32_LE.get(array, 12),
	        };
	    }, len: 16
	};
	/**
	 * First part of the ZIP Local File Header
	 * Offset | Bytes| Description
	 * -------|------+-------------------------------------------------------------------
	 *      0 |    4 | Signature (0x04034b50)
	 *      4 |    2 | Minimum version needed to extract
	 *      6 |    2 | Bit flag
	 *      8 |    2 | Compression method
	 *     10 |    2 | File last modification time (MS-DOS format)
	 *     12 |    2 | File last modification date (MS-DOS format)
	 *     14 |    4 | CRC-32 of uncompressed data
	 *     18 |    4 | Compressed size
	 *     22 |    4 | Uncompressed size
	 *     26 |    2 | File name length (n)
	 *     28 |    2 | Extra field length (m)
	 *     30 |    n | File name
	 * 30 + n |    m | Extra field
	 */
	const LocalFileHeaderToken = {
	    get(array) {
	        const flags = UINT16_LE.get(array, 6);
	        return {
	            signature: UINT32_LE.get(array, 0),
	            minVersion: UINT16_LE.get(array, 4),
	            dataDescriptor: !!(flags & 0x0008),
	            compressedMethod: UINT16_LE.get(array, 8),
	            compressedSize: UINT32_LE.get(array, 18),
	            uncompressedSize: UINT32_LE.get(array, 22),
	            filenameLength: UINT16_LE.get(array, 26),
	            extraFieldLength: UINT16_LE.get(array, 28),
	            filename: null
	        };
	    }, len: 30
	};
	/**
	 * 4.3.16  End of central directory record:
	 *  end of central dir signature (0x06064b50)                                      4 bytes
	 *  number of this disk                                                            2 bytes
	 *  number of the disk with the start of the central directory                     2 bytes
	 *  total number of entries in the central directory on this disk                  2 bytes
	 *  total number of entries in the size of the central directory                   2 bytes
	 *  sizeOfTheCentralDirectory                                                      4 bytes
	 *  offset of start of central directory with respect to the starting disk number  4 bytes
	 *  .ZIP file comment length                                                       2 bytes
	 *  .ZIP file comment       (variable size)
	 */
	const EndOfCentralDirectoryRecordToken = {
	    get(array) {
	        return {
	            signature: UINT32_LE.get(array, 0),
	            nrOfThisDisk: UINT16_LE.get(array, 4),
	            nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
	            nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
	            nrOfEntriesOfSize: UINT16_LE.get(array, 10),
	            sizeOfCd: UINT32_LE.get(array, 12),
	            offsetOfStartOfCd: UINT32_LE.get(array, 16),
	            zipFileCommentLength: UINT16_LE.get(array, 20),
	        };
	    }, len: 22
	};
	/**
	 * File header:
	 *    central file header signature   4 bytes   0 (0x02014b50)
	 *    version made by                 2 bytes   4
	 *    version needed to extract       2 bytes   6
	 *    general purpose bit flag        2 bytes   8
	 *    compression method              2 bytes  10
	 *    last mod file time              2 bytes  12
	 *    last mod file date              2 bytes  14
	 *    crc-32                          4 bytes  16
	 *    compressed size                 4 bytes  20
	 *    uncompressed size               4 bytes  24
	 *    file name length                2 bytes  28
	 *    extra field length              2 bytes  30
	 *    file comment length             2 bytes  32
	 *    disk number start               2 bytes  34
	 *    internal file attributes        2 bytes  36
	 *    external file attributes        4 bytes  38
	 *    relative offset of local header 4 bytes  42
	 */
	const FileHeader = {
	    get(array) {
	        const flags = UINT16_LE.get(array, 8);
	        return {
	            signature: UINT32_LE.get(array, 0),
	            minVersion: UINT16_LE.get(array, 6),
	            dataDescriptor: !!(flags & 0x0008),
	            compressedMethod: UINT16_LE.get(array, 10),
	            compressedSize: UINT32_LE.get(array, 20),
	            uncompressedSize: UINT32_LE.get(array, 24),
	            filenameLength: UINT16_LE.get(array, 28),
	            extraFieldLength: UINT16_LE.get(array, 30),
	            fileCommentLength: UINT16_LE.get(array, 32),
	            relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
	            filename: null
	        };
	    }, len: 46
	};

	function signatureToArray(signature) {
	    const signatureBytes = new Uint8Array(UINT32_LE.len);
	    UINT32_LE.put(signatureBytes, 0, signature);
	    return signatureBytes;
	}
	const debug$s = initDebug('tokenizer:inflate');
	const syncBufferSize = 256 * 1024;
	const ddSignatureArray = signatureToArray(Signature.DataDescriptor);
	const eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
	class ZipHandler {
	    constructor(tokenizer) {
	        this.tokenizer = tokenizer;
	        this.syncBuffer = new Uint8Array(syncBufferSize);
	    }
	    async isZip() {
	        return await this.peekSignature() === Signature.LocalFileHeader;
	    }
	    peekSignature() {
	        return this.tokenizer.peekToken(UINT32_LE);
	    }
	    async findEndOfCentralDirectoryLocator() {
	        const randomReadTokenizer = this.tokenizer;
	        const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
	        const buffer = this.syncBuffer.subarray(0, chunkLength);
	        await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
	        // Search the buffer from end to beginning for EOCD signature
	        // const signature = 0x06054b50;
	        for (let i = buffer.length - 4; i >= 0; i--) {
	            // Compare 4 bytes directly without calling readUInt32LE
	            if (buffer[i] === eocdSignatureBytes[0] &&
	                buffer[i + 1] === eocdSignatureBytes[1] &&
	                buffer[i + 2] === eocdSignatureBytes[2] &&
	                buffer[i + 3] === eocdSignatureBytes[3]) {
	                return randomReadTokenizer.fileInfo.size - chunkLength + i;
	            }
	        }
	        return -1;
	    }
	    async readCentralDirectory() {
	        if (!this.tokenizer.supportsRandomAccess()) {
	            debug$s('Cannot reading central-directory without random-read support');
	            return;
	        }
	        debug$s('Reading central-directory...');
	        const pos = this.tokenizer.position;
	        const offset = await this.findEndOfCentralDirectoryLocator();
	        if (offset > 0) {
	            debug$s('Central-directory 32-bit signature found');
	            const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
	            const files = [];
	            this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
	            for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
	                const entry = await this.tokenizer.readToken(FileHeader);
	                if (entry.signature !== Signature.CentralFileHeader) {
	                    throw new Error('Expected Central-File-Header signature');
	                }
	                entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, 'utf-8'));
	                await this.tokenizer.ignore(entry.extraFieldLength);
	                await this.tokenizer.ignore(entry.fileCommentLength);
	                files.push(entry);
	                debug$s(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
	            }
	            this.tokenizer.setPosition(pos);
	            return files;
	        }
	        this.tokenizer.setPosition(pos);
	    }
	    async unzip(fileCb) {
	        const entries = await this.readCentralDirectory();
	        if (entries) {
	            // Use Central Directory to iterate over files
	            return this.iterateOverCentralDirectory(entries, fileCb);
	        }
	        // Scan Zip files for local-file-header
	        let stop = false;
	        do {
	            const zipHeader = await this.readLocalFileHeader();
	            if (!zipHeader)
	                break;
	            const next = fileCb(zipHeader);
	            stop = !!next.stop;
	            let fileData = undefined;
	            await this.tokenizer.ignore(zipHeader.extraFieldLength);
	            if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
	                const chunks = [];
	                let len = syncBufferSize;
	                debug$s('Compressed-file-size unknown, scanning for next data-descriptor-signature....');
	                let nextHeaderIndex = -1;
	                while (nextHeaderIndex < 0 && len === syncBufferSize) {
	                    len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
	                    nextHeaderIndex = indexOf$1(this.syncBuffer.subarray(0, len), ddSignatureArray);
	                    const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
	                    if (next.handler) {
	                        const data = new Uint8Array(size);
	                        await this.tokenizer.readBuffer(data);
	                        chunks.push(data);
	                    }
	                    else {
	                        // Move position to the next header if found, skip the whole buffer otherwise
	                        await this.tokenizer.ignore(size);
	                    }
	                }
	                debug$s(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
	                if (next.handler) {
	                    await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
	                }
	            }
	            else {
	                if (next.handler) {
	                    debug$s(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
	                    fileData = new Uint8Array(zipHeader.compressedSize);
	                    await this.tokenizer.readBuffer(fileData);
	                    await this.inflate(zipHeader, fileData, next.handler);
	                }
	                else {
	                    debug$s(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
	                    await this.tokenizer.ignore(zipHeader.compressedSize);
	                }
	            }
	            debug$s(`Reading data-descriptor at pos=${this.tokenizer.position}`);
	            if (zipHeader.dataDescriptor) {
	                // await this.tokenizer.ignore(DataDescriptor.len);
	                const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
	                if (dataDescriptor.signature !== 0x08074b50) {
	                    throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
	                }
	            }
	        } while (!stop);
	    }
	    async iterateOverCentralDirectory(entries, fileCb) {
	        for (const fileHeader of entries) {
	            const next = fileCb(fileHeader);
	            if (next.handler) {
	                this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
	                const zipHeader = await this.readLocalFileHeader();
	                if (zipHeader) {
	                    await this.tokenizer.ignore(zipHeader.extraFieldLength);
	                    const fileData = new Uint8Array(fileHeader.compressedSize);
	                    await this.tokenizer.readBuffer(fileData);
	                    await this.inflate(zipHeader, fileData, next.handler);
	                }
	            }
	            if (next.stop)
	                break;
	        }
	    }
	    inflate(zipHeader, fileData, cb) {
	        if (zipHeader.compressedMethod === 0) {
	            return cb(fileData);
	        }
	        debug$s(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
	        const uncompressedData = decompressSync(fileData);
	        return cb(uncompressedData);
	    }
	    async readLocalFileHeader() {
	        const signature = await this.tokenizer.peekToken(UINT32_LE);
	        if (signature === Signature.LocalFileHeader) {
	            const header = await this.tokenizer.readToken(LocalFileHeaderToken);
	            header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, 'utf-8'));
	            return header;
	        }
	        if (signature === Signature.CentralFileHeader) {
	            return false;
	        }
	        if (signature === 0xE011CFD0) {
	            throw new Error('Encrypted ZIP');
	        }
	        throw new Error('Unexpected signature');
	    }
	}
	function indexOf$1(buffer, portion) {
	    const bufferLength = buffer.length;
	    const portionLength = portion.length;
	    // Return -1 if the portion is longer than the buffer
	    if (portionLength > bufferLength)
	        return -1;
	    // Search for the portion in the buffer
	    for (let i = 0; i <= bufferLength - portionLength; i++) {
	        let found = true;
	        for (let j = 0; j < portionLength; j++) {
	            if (buffer[i + j] !== portion[j]) {
	                found = false;
	                break;
	            }
	        }
	        if (found) {
	            return i; // Return the starting offset
	        }
	    }
	    return -1; // Not found
	}
	function mergeArrays(chunks) {
	    // Concatenate chunks into a single Uint8Array
	    const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
	    const mergedArray = new Uint8Array(totalLength);
	    let offset = 0;
	    for (const chunk of chunks) {
	        mergedArray.set(chunk, offset);
	        offset += chunk.length;
	    }
	    return mergedArray;
	}

	const objectToString$3 = Object.prototype.toString;
	const uint8ArrayStringified = '[object Uint8Array]';
	const arrayBufferStringified = '[object ArrayBuffer]';

	function isType(value, typeConstructor, typeStringified) {
		if (!value) {
			return false;
		}

		if (value.constructor === typeConstructor) {
			return true;
		}

		return objectToString$3.call(value) === typeStringified;
	}

	function isUint8Array(value) {
		return isType(value, Uint8Array, uint8ArrayStringified);
	}

	function isArrayBuffer(value) {
		return isType(value, ArrayBuffer, arrayBufferStringified);
	}

	function isUint8ArrayOrArrayBuffer(value) {
		return isUint8Array(value) || isArrayBuffer(value);
	}

	function assertUint8Array(value) {
		if (!isUint8Array(value)) {
			throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
		}
	}

	function assertUint8ArrayOrArrayBuffer(value) {
		if (!isUint8ArrayOrArrayBuffer(value)) {
			throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value}\``);
		}
	}

	const cachedDecoders = {
		utf8: new globalThis.TextDecoder('utf8'),
	};

	function uint8ArrayToString(array, encoding = 'utf8') {
		assertUint8ArrayOrArrayBuffer(array);
		cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
		return cachedDecoders[encoding].decode(array);
	}

	function assertString(value) {
		if (typeof value !== 'string') {
			throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
		}
	}

	const cachedEncoder = new globalThis.TextEncoder();

	function stringToUint8Array(string) {
		assertString(string);
		return cachedEncoder.encode(string);
	}

	const byteToHexLookupTable = Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));

	function uint8ArrayToHex(array) {
		assertUint8Array(array);

		// Concatenating a string is faster than using an array.
		let hexString = '';

		// eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.
		for (let index = 0; index < array.length; index++) {
			hexString += byteToHexLookupTable[array[index]];
		}

		return hexString;
	}

	const hexToDecimalLookupTable = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
	};

	function hexToUint8Array(hexString) {
		assertString(hexString);

		if (hexString.length % 2 !== 0) {
			throw new Error('Invalid Hex string length.');
		}

		const resultLength = hexString.length / 2;
		const bytes = new Uint8Array(resultLength);

		for (let index = 0; index < resultLength; index++) {
			const highNibble = hexToDecimalLookupTable[hexString[index * 2]];
			const lowNibble = hexToDecimalLookupTable[hexString[(index * 2) + 1]];

			if (highNibble === undefined || lowNibble === undefined) {
				throw new Error(`Invalid Hex character encountered at position ${index * 2}`);
			}

			bytes[index] = (highNibble << 4) | lowNibble; // eslint-disable-line no-bitwise
		}

		return bytes;
	}

	/**
	@param {DataView} view
	@returns {number}
	*/
	function getUintBE(view) {
		const {byteLength} = view;

		if (byteLength === 6) {
			return (view.getUint16(0) * (2 ** 32)) + view.getUint32(2);
		}

		if (byteLength === 5) {
			return (view.getUint8(0) * (2 ** 32)) + view.getUint32(1);
		}

		if (byteLength === 4) {
			return view.getUint32(0);
		}

		if (byteLength === 3) {
			return (view.getUint8(0) * (2 ** 16)) + view.getUint16(1);
		}

		if (byteLength === 2) {
			return view.getUint16(0);
		}

		if (byteLength === 1) {
			return view.getUint8(0);
		}
	}

	function stringToBytes(string) {
		return [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point
	}

	/**
	Checks whether the TAR checksum is valid.

	@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.
	@param {number} offset - TAR header offset.
	@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
	*/
	function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
		const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, '').trim(), 8); // Read sum in header
		if (Number.isNaN(readSum)) {
			return false;
		}

		let sum = 8 * 0x20; // Initialize signed bit sum

		for (let index = offset; index < offset + 148; index++) {
			sum += arrayBuffer[index];
		}

		for (let index = offset + 156; index < offset + 512; index++) {
			sum += arrayBuffer[index];
		}

		return readSum === sum;
	}

	/**
	ID3 UINT32 sync-safe tokenizer token.
	28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
	*/
	const uint32SyncSafeToken = {
		get: (buffer, offset) => (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21),
		len: 4,
	};

	const extensions = [
		'jpg',
		'png',
		'apng',
		'gif',
		'webp',
		'flif',
		'xcf',
		'cr2',
		'cr3',
		'orf',
		'arw',
		'dng',
		'nef',
		'rw2',
		'raf',
		'tif',
		'bmp',
		'icns',
		'jxr',
		'psd',
		'indd',
		'zip',
		'tar',
		'rar',
		'gz',
		'bz2',
		'7z',
		'dmg',
		'mp4',
		'mid',
		'mkv',
		'webm',
		'mov',
		'avi',
		'mpg',
		'mp2',
		'mp3',
		'm4a',
		'oga',
		'ogg',
		'ogv',
		'opus',
		'flac',
		'wav',
		'spx',
		'amr',
		'pdf',
		'epub',
		'elf',
		'macho',
		'exe',
		'swf',
		'rtf',
		'wasm',
		'woff',
		'woff2',
		'eot',
		'ttf',
		'otf',
		'ttc',
		'ico',
		'flv',
		'ps',
		'xz',
		'sqlite',
		'nes',
		'crx',
		'xpi',
		'cab',
		'deb',
		'ar',
		'rpm',
		'Z',
		'lz',
		'cfb',
		'mxf',
		'mts',
		'blend',
		'bpg',
		'docx',
		'pptx',
		'xlsx',
		'3gp',
		'3g2',
		'j2c',
		'jp2',
		'jpm',
		'jpx',
		'mj2',
		'aif',
		'qcp',
		'odt',
		'ods',
		'odp',
		'xml',
		'mobi',
		'heic',
		'cur',
		'ktx',
		'ape',
		'wv',
		'dcm',
		'ics',
		'glb',
		'pcap',
		'dsf',
		'lnk',
		'alias',
		'voc',
		'ac3',
		'm4v',
		'm4p',
		'm4b',
		'f4v',
		'f4p',
		'f4b',
		'f4a',
		'mie',
		'asf',
		'ogm',
		'ogx',
		'mpc',
		'arrow',
		'shp',
		'aac',
		'mp1',
		'it',
		's3m',
		'xm',
		'skp',
		'avif',
		'eps',
		'lzh',
		'pgp',
		'asar',
		'stl',
		'chm',
		'3mf',
		'zst',
		'jxl',
		'vcf',
		'jls',
		'pst',
		'dwg',
		'parquet',
		'class',
		'arj',
		'cpio',
		'ace',
		'avro',
		'icc',
		'fbx',
		'vsdx',
		'vtt',
		'apk',
		'drc',
		'lz4',
		'potx',
		'xltx',
		'dotx',
		'xltm',
		'ott',
		'ots',
		'otp',
		'odg',
		'otg',
		'xlsm',
		'docm',
		'dotm',
		'potm',
		'pptm',
		'jar',
		'rm',
		'ppsm',
		'ppsx',
	];

	const mimeTypes = [
		'image/jpeg',
		'image/png',
		'image/gif',
		'image/webp',
		'image/flif',
		'image/x-xcf',
		'image/x-canon-cr2',
		'image/x-canon-cr3',
		'image/tiff',
		'image/bmp',
		'image/vnd.ms-photo',
		'image/vnd.adobe.photoshop',
		'application/x-indesign',
		'application/epub+zip',
		'application/x-xpinstall',
		'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
		'application/vnd.oasis.opendocument.text',
		'application/vnd.oasis.opendocument.spreadsheet',
		'application/vnd.oasis.opendocument.presentation',
		'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
		'application/vnd.openxmlformats-officedocument.presentationml.presentation',
		'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
		'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
		'application/zip',
		'application/x-tar',
		'application/x-rar-compressed',
		'application/gzip',
		'application/x-bzip2',
		'application/x-7z-compressed',
		'application/x-apple-diskimage',
		'application/vnd.apache.arrow.file',
		'video/mp4',
		'audio/midi',
		'video/matroska',
		'video/webm',
		'video/quicktime',
		'video/vnd.avi',
		'audio/wav',
		'audio/qcelp',
		'audio/x-ms-asf',
		'video/x-ms-asf',
		'application/vnd.ms-asf',
		'video/mpeg',
		'video/3gpp',
		'audio/mpeg',
		'audio/mp4', // RFC 4337
		'video/ogg',
		'audio/ogg',
		'audio/ogg; codecs=opus',
		'application/ogg',
		'audio/flac',
		'audio/ape',
		'audio/wavpack',
		'audio/amr',
		'application/pdf',
		'application/x-elf',
		'application/x-mach-binary',
		'application/x-msdownload',
		'application/x-shockwave-flash',
		'application/rtf',
		'application/wasm',
		'font/woff',
		'font/woff2',
		'application/vnd.ms-fontobject',
		'font/ttf',
		'font/otf',
		'font/collection',
		'image/x-icon',
		'video/x-flv',
		'application/postscript',
		'application/eps',
		'application/x-xz',
		'application/x-sqlite3',
		'application/x-nintendo-nes-rom',
		'application/x-google-chrome-extension',
		'application/vnd.ms-cab-compressed',
		'application/x-deb',
		'application/x-unix-archive',
		'application/x-rpm',
		'application/x-compress',
		'application/x-lzip',
		'application/x-cfb',
		'application/x-mie',
		'application/mxf',
		'video/mp2t',
		'application/x-blender',
		'image/bpg',
		'image/j2c',
		'image/jp2',
		'image/jpx',
		'image/jpm',
		'image/mj2',
		'audio/aiff',
		'application/xml',
		'application/x-mobipocket-ebook',
		'image/heif',
		'image/heif-sequence',
		'image/heic',
		'image/heic-sequence',
		'image/icns',
		'image/ktx',
		'application/dicom',
		'audio/x-musepack',
		'text/calendar',
		'text/vcard',
		'text/vtt',
		'model/gltf-binary',
		'application/vnd.tcpdump.pcap',
		'audio/x-dsf', // Non-standard
		'application/x.ms.shortcut', // Invented by us
		'application/x.apple.alias', // Invented by us
		'audio/x-voc',
		'audio/vnd.dolby.dd-raw',
		'audio/x-m4a',
		'image/apng',
		'image/x-olympus-orf',
		'image/x-sony-arw',
		'image/x-adobe-dng',
		'image/x-nikon-nef',
		'image/x-panasonic-rw2',
		'image/x-fujifilm-raf',
		'video/x-m4v',
		'video/3gpp2',
		'application/x-esri-shape',
		'audio/aac',
		'audio/x-it',
		'audio/x-s3m',
		'audio/x-xm',
		'video/MP1S',
		'video/MP2P',
		'application/vnd.sketchup.skp',
		'image/avif',
		'application/x-lzh-compressed',
		'application/pgp-encrypted',
		'application/x-asar',
		'model/stl',
		'application/vnd.ms-htmlhelp',
		'model/3mf',
		'image/jxl',
		'application/zstd',
		'image/jls',
		'application/vnd.ms-outlook',
		'image/vnd.dwg',
		'application/vnd.apache.parquet',
		'application/java-vm',
		'application/x-arj',
		'application/x-cpio',
		'application/x-ace-compressed',
		'application/avro',
		'application/vnd.iccprofile',
		'application/x.autodesk.fbx', // Invented by us
		'application/vnd.visio',
		'application/vnd.android.package-archive',
		'application/vnd.google.draco', // Invented by us
		'application/x-lz4', // Invented by us
		'application/vnd.openxmlformats-officedocument.presentationml.template',
		'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
		'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
		'application/vnd.ms-excel.template.macroenabled.12',
		'application/vnd.oasis.opendocument.text-template',
		'application/vnd.oasis.opendocument.spreadsheet-template',
		'application/vnd.oasis.opendocument.presentation-template',
		'application/vnd.oasis.opendocument.graphics',
		'application/vnd.oasis.opendocument.graphics-template',
		'application/vnd.ms-excel.sheet.macroenabled.12',
		'application/vnd.ms-word.document.macroenabled.12',
		'application/vnd.ms-word.template.macroenabled.12',
		'application/vnd.ms-powerpoint.template.macroenabled.12',
		'application/vnd.ms-powerpoint.presentation.macroenabled.12',
		'application/java-archive',
		'application/vnd.rn-realmedia',
	];

	/**
	Primary entry point, Node.js specific entry point is index.js
	*/


	const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.

	async function fileTypeFromBuffer(input, options) {
		return new FileTypeParser(options).fromBuffer(input);
	}

	function getFileTypeFromMimeType(mimeType) {
		mimeType = mimeType.toLowerCase();
		switch (mimeType) {
			case 'application/epub+zip':
				return {
					ext: 'epub',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.text':
				return {
					ext: 'odt',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.text-template':
				return {
					ext: 'ott',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.spreadsheet':
				return {
					ext: 'ods',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.spreadsheet-template':
				return {
					ext: 'ots',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.presentation':
				return {
					ext: 'odp',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.presentation-template':
				return {
					ext: 'otp',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.graphics':
				return {
					ext: 'odg',
					mime: mimeType,
				};
			case 'application/vnd.oasis.opendocument.graphics-template':
				return {
					ext: 'otg',
					mime: mimeType,
				};
			case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
				return {
					ext: 'ppsx',
					mime: mimeType,
				};
			case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
				return {
					ext: 'xlsx',
					mime: mimeType,
				};
			case 'application/vnd.ms-excel.sheet.macroenabled':
				return {
					ext: 'xlsm',
					mime: 'application/vnd.ms-excel.sheet.macroenabled.12',
				};
			case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
				return {
					ext: 'xltx',
					mime: mimeType,
				};
			case 'application/vnd.ms-excel.template.macroenabled':
				return {
					ext: 'xltm',
					mime: 'application/vnd.ms-excel.template.macroenabled.12',
				};
			case 'application/vnd.ms-powerpoint.slideshow.macroenabled':
				return {
					ext: 'ppsm',
					mime: 'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
				};
			case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
				return {
					ext: 'docx',
					mime: mimeType,
				};
			case 'application/vnd.ms-word.document.macroenabled':
				return {
					ext: 'docm',
					mime: 'application/vnd.ms-word.document.macroenabled.12',
				};
			case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
				return {
					ext: 'dotx',
					mime: mimeType,
				};
			case 'application/vnd.ms-word.template.macroenabledtemplate':
				return {
					ext: 'dotm',
					mime: 'application/vnd.ms-word.template.macroenabled.12',
				};
			case 'application/vnd.openxmlformats-officedocument.presentationml.template':
				return {
					ext: 'potx',
					mime: mimeType,
				};
			case 'application/vnd.ms-powerpoint.template.macroenabled':
				return {
					ext: 'potm',
					mime: 'application/vnd.ms-powerpoint.template.macroenabled.12',
				};
			case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
				return {
					ext: 'pptx',
					mime: mimeType,
				};
			case 'application/vnd.ms-powerpoint.presentation.macroenabled':
				return {
					ext: 'pptm',
					mime: 'application/vnd.ms-powerpoint.presentation.macroenabled.12',
				};
			case 'application/vnd.ms-visio.drawing':
				return {
					ext: 'vsdx',
					mime: 'application/vnd.visio',
				};
			case 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml':
				return {
					ext: '3mf',
					mime: 'model/3mf',
				};
		}
	}

	function _check(buffer, headers, options) {
		options = {
			offset: 0,
			...options,
		};

		for (const [index, header] of headers.entries()) {
			// If a bitmask is set
			if (options.mask) {
				// If header doesn't equal `buf` with bits masked off
				if (header !== (options.mask[index] & buffer[index + options.offset])) {
					return false;
				}
			} else if (header !== buffer[index + options.offset]) {
				return false;
			}
		}

		return true;
	}

	class FileTypeParser {
		constructor(options) {
			this.options = {
				mpegOffsetTolerance: 0,
				...options,
			};

			this.detectors = [...(options?.customDetectors ?? []),
				{id: 'core', detect: this.detectConfident},
				{id: 'core.imprecise', detect: this.detectImprecise}];
			this.tokenizerOptions = {
				abortSignal: options?.signal,
			};
		}

		async fromTokenizer(tokenizer) {
			const initialPosition = tokenizer.position;

			// Iterate through all file-type detectors
			for (const detector of this.detectors) {
				const fileType = await detector.detect(tokenizer);
				if (fileType) {
					return fileType;
				}

				if (initialPosition !== tokenizer.position) {
					return undefined; // Cannot proceed scanning of the tokenizer is at an arbitrary position
				}
			}
		}

		async fromBuffer(input) {
			if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
				throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
			}

			const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);

			if (!(buffer?.length > 1)) {
				return;
			}

			return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
		}

		async fromBlob(blob) {
			return this.fromStream(blob.stream());
		}

		async fromStream(stream) {
			const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
			try {
				return await this.fromTokenizer(tokenizer);
			} finally {
				await tokenizer.close();
			}
		}

		async toDetectionStream(stream, options) {
			const {sampleSize = reasonableDetectionSizeInBytes} = options;
			let detectedFileType;
			let firstChunk;

			const reader = stream.getReader({mode: 'byob'});
			try {
				// Read the first chunk from the stream
				const {value: chunk, done} = await reader.read(new Uint8Array(sampleSize));
				firstChunk = chunk;
				if (!done && chunk) {
					try {
						// Attempt to detect the file type from the chunk
						detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
					} catch (error) {
						if (!(error instanceof EndOfStreamError)) {
							throw error; // Re-throw non-EndOfStreamError
						}

						detectedFileType = undefined;
					}
				}

				firstChunk = chunk;
			} finally {
				reader.releaseLock(); // Ensure the reader is released
			}

			// Create a new ReadableStream to manage locking issues
			const transformStream = new TransformStream({
				async start(controller) {
					controller.enqueue(firstChunk); // Enqueue the initial chunk
				},
				transform(chunk, controller) {
					// Pass through the chunks without modification
					controller.enqueue(chunk);
				},
			});

			const newStream = stream.pipeThrough(transformStream);
			newStream.fileType = detectedFileType;

			return newStream;
		}

		check(header, options) {
			return _check(this.buffer, header, options);
		}

		checkString(header, options) {
			return this.check(stringToBytes(header), options);
		}

		// Detections with a high degree of certainty in identifying the correct file type
		detectConfident = async tokenizer => {
			this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);

			// Keep reading until EOF if the file size is unknown.
			if (tokenizer.fileInfo.size === undefined) {
				tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
			}

			this.tokenizer = tokenizer;

			await tokenizer.peekBuffer(this.buffer, {length: 12, mayBeLess: true});

			// -- 2-byte signatures --

			if (this.check([0x42, 0x4D])) {
				return {
					ext: 'bmp',
					mime: 'image/bmp',
				};
			}

			if (this.check([0x0B, 0x77])) {
				return {
					ext: 'ac3',
					mime: 'audio/vnd.dolby.dd-raw',
				};
			}

			if (this.check([0x78, 0x01])) {
				return {
					ext: 'dmg',
					mime: 'application/x-apple-diskimage',
				};
			}

			if (this.check([0x4D, 0x5A])) {
				return {
					ext: 'exe',
					mime: 'application/x-msdownload',
				};
			}

			if (this.check([0x25, 0x21])) {
				await tokenizer.peekBuffer(this.buffer, {length: 24, mayBeLess: true});

				if (
					this.checkString('PS-Adobe-', {offset: 2})
					&& this.checkString(' EPSF-', {offset: 14})
				) {
					return {
						ext: 'eps',
						mime: 'application/eps',
					};
				}

				return {
					ext: 'ps',
					mime: 'application/postscript',
				};
			}

			if (
				this.check([0x1F, 0xA0])
				|| this.check([0x1F, 0x9D])
			) {
				return {
					ext: 'Z',
					mime: 'application/x-compress',
				};
			}

			if (this.check([0xC7, 0x71])) {
				return {
					ext: 'cpio',
					mime: 'application/x-cpio',
				};
			}

			if (this.check([0x60, 0xEA])) {
				return {
					ext: 'arj',
					mime: 'application/x-arj',
				};
			}

			// -- 3-byte signatures --

			if (this.check([0xEF, 0xBB, 0xBF])) { // UTF-8-BOM
				// Strip off UTF-8-BOM
				this.tokenizer.ignore(3);
				return this.detectConfident(tokenizer);
			}

			if (this.check([0x47, 0x49, 0x46])) {
				return {
					ext: 'gif',
					mime: 'image/gif',
				};
			}

			if (this.check([0x49, 0x49, 0xBC])) {
				return {
					ext: 'jxr',
					mime: 'image/vnd.ms-photo',
				};
			}

			if (this.check([0x1F, 0x8B, 0x8])) {
				return {
					ext: 'gz',
					mime: 'application/gzip',
				};
			}

			if (this.check([0x42, 0x5A, 0x68])) {
				return {
					ext: 'bz2',
					mime: 'application/x-bzip2',
				};
			}

			if (this.checkString('ID3')) {
				await tokenizer.ignore(6); // Skip ID3 header until the header size
				const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
				if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
					// Guess file type based on ID3 header for backward compatibility
					return {
						ext: 'mp3',
						mime: 'audio/mpeg',
					};
				}

				await tokenizer.ignore(id3HeaderLength);
				return this.fromTokenizer(tokenizer); // Skip ID3 header, recursion
			}

			// Musepack, SV7
			if (this.checkString('MP+')) {
				return {
					ext: 'mpc',
					mime: 'audio/x-musepack',
				};
			}

			if (
				(this.buffer[0] === 0x43 || this.buffer[0] === 0x46)
				&& this.check([0x57, 0x53], {offset: 1})
			) {
				return {
					ext: 'swf',
					mime: 'application/x-shockwave-flash',
				};
			}

			// -- 4-byte signatures --

			// Requires a sample size of 4 bytes
			if (this.check([0xFF, 0xD8, 0xFF])) {
				if (this.check([0xF7], {offset: 3})) { // JPG7/SOF55, indicating a ISO/IEC 14495 / JPEG-LS file
					return {
						ext: 'jls',
						mime: 'image/jls',
					};
				}

				return {
					ext: 'jpg',
					mime: 'image/jpeg',
				};
			}

			if (this.check([0x4F, 0x62, 0x6A, 0x01])) {
				return {
					ext: 'avro',
					mime: 'application/avro',
				};
			}

			if (this.checkString('FLIF')) {
				return {
					ext: 'flif',
					mime: 'image/flif',
				};
			}

			if (this.checkString('8BPS')) {
				return {
					ext: 'psd',
					mime: 'image/vnd.adobe.photoshop',
				};
			}

			// Musepack, SV8
			if (this.checkString('MPCK')) {
				return {
					ext: 'mpc',
					mime: 'audio/x-musepack',
				};
			}

			if (this.checkString('FORM')) {
				return {
					ext: 'aif',
					mime: 'audio/aiff',
				};
			}

			if (this.checkString('icns', {offset: 0})) {
				return {
					ext: 'icns',
					mime: 'image/icns',
				};
			}

			// Zip-based file formats
			// Need to be before the `zip` check
			if (this.check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature
				let fileType;
				await new ZipHandler(tokenizer).unzip(zipHeader => {
					switch (zipHeader.filename) {
						case 'META-INF/mozilla.rsa':
							fileType = {
								ext: 'xpi',
								mime: 'application/x-xpinstall',
							};
							return {
								stop: true,
							};
						case 'META-INF/MANIFEST.MF':
							fileType = {
								ext: 'jar',
								mime: 'application/java-archive',
							};
							return {
								stop: true,
							};
						case 'mimetype':
							return {
								async handler(fileData) {
									// Use TextDecoder to decode the UTF-8 encoded data
									const mimeType = new TextDecoder('utf-8').decode(fileData).trim();
									fileType = getFileTypeFromMimeType(mimeType);
								},
								stop: true,
							};

						case '[Content_Types].xml':
							return {
								async handler(fileData) {
									// Use TextDecoder to decode the UTF-8 encoded data
									let xmlContent = new TextDecoder('utf-8').decode(fileData);
									const endPos = xmlContent.indexOf('.main+xml"');
									if (endPos === -1) {
										const mimeType = 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml';
										if (xmlContent.includes(`ContentType="${mimeType}"`)) {
											fileType = getFileTypeFromMimeType(mimeType);
										}
									} else {
										xmlContent = xmlContent.slice(0, Math.max(0, endPos));
										const firstPos = xmlContent.lastIndexOf('"');
										const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
										fileType = getFileTypeFromMimeType(mimeType);
									}
								},
								stop: true,
							};
						default:
							if (/classes\d*\.dex/.test(zipHeader.filename)) {
								fileType = {
									ext: 'apk',
									mime: 'application/vnd.android.package-archive',
								};
								return {stop: true};
							}

							return {};
					}
				});

				return fileType ?? {
					ext: 'zip',
					mime: 'application/zip',
				};
			}

			if (this.checkString('OggS')) {
				// This is an OGG container
				await tokenizer.ignore(28);
				const type = new Uint8Array(8);
				await tokenizer.readBuffer(type);

				// Needs to be before `ogg` check
				if (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
					return {
						ext: 'opus',
						mime: 'audio/ogg; codecs=opus',
					};
				}

				// If ' theora' in header.
				if (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
					return {
						ext: 'ogv',
						mime: 'video/ogg',
					};
				}

				// If '\x01video' in header.
				if (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
					return {
						ext: 'ogm',
						mime: 'video/ogg',
					};
				}

				// If ' FLAC' in header  https://xiph.org/flac/faq.html
				if (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
					return {
						ext: 'oga',
						mime: 'audio/ogg',
					};
				}

				// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
				if (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
					return {
						ext: 'spx',
						mime: 'audio/ogg',
					};
				}

				// If '\x01vorbis' in header
				if (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
					return {
						ext: 'ogg',
						mime: 'audio/ogg',
					};
				}

				// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
				return {
					ext: 'ogx',
					mime: 'application/ogg',
				};
			}

			if (
				this.check([0x50, 0x4B])
				&& (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7)
				&& (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)
			) {
				return {
					ext: 'zip',
					mime: 'application/zip',
				};
			}

			if (this.checkString('MThd')) {
				return {
					ext: 'mid',
					mime: 'audio/midi',
				};
			}

			if (
				this.checkString('wOFF')
				&& (
					this.check([0x00, 0x01, 0x00, 0x00], {offset: 4})
					|| this.checkString('OTTO', {offset: 4})
				)
			) {
				return {
					ext: 'woff',
					mime: 'font/woff',
				};
			}

			if (
				this.checkString('wOF2')
				&& (
					this.check([0x00, 0x01, 0x00, 0x00], {offset: 4})
					|| this.checkString('OTTO', {offset: 4})
				)
			) {
				return {
					ext: 'woff2',
					mime: 'font/woff2',
				};
			}

			if (this.check([0xD4, 0xC3, 0xB2, 0xA1]) || this.check([0xA1, 0xB2, 0xC3, 0xD4])) {
				return {
					ext: 'pcap',
					mime: 'application/vnd.tcpdump.pcap',
				};
			}

			// Sony DSD Stream File (DSF)
			if (this.checkString('DSD ')) {
				return {
					ext: 'dsf',
					mime: 'audio/x-dsf', // Non-standard
				};
			}

			if (this.checkString('LZIP')) {
				return {
					ext: 'lz',
					mime: 'application/x-lzip',
				};
			}

			if (this.checkString('fLaC')) {
				return {
					ext: 'flac',
					mime: 'audio/flac',
				};
			}

			if (this.check([0x42, 0x50, 0x47, 0xFB])) {
				return {
					ext: 'bpg',
					mime: 'image/bpg',
				};
			}

			if (this.checkString('wvpk')) {
				return {
					ext: 'wv',
					mime: 'audio/wavpack',
				};
			}

			if (this.checkString('%PDF')) {
				// Assume this is just a normal PDF
				return {
					ext: 'pdf',
					mime: 'application/pdf',
				};
			}

			if (this.check([0x00, 0x61, 0x73, 0x6D])) {
				return {
					ext: 'wasm',
					mime: 'application/wasm',
				};
			}

			// TIFF, little-endian type
			if (this.check([0x49, 0x49])) {
				const fileType = await this.readTiffHeader(false);
				if (fileType) {
					return fileType;
				}
			}

			// TIFF, big-endian type
			if (this.check([0x4D, 0x4D])) {
				const fileType = await this.readTiffHeader(true);
				if (fileType) {
					return fileType;
				}
			}

			if (this.checkString('MAC ')) {
				return {
					ext: 'ape',
					mime: 'audio/ape',
				};
			}

			// https://github.com/file/file/blob/master/magic/Magdir/matroska
			if (this.check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML
				async function readField() {
					const msb = await tokenizer.peekNumber(UINT8);
					let mask = 0x80;
					let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

					while ((msb & mask) === 0 && mask !== 0) {
						++ic;
						mask >>= 1;
					}

					const id = new Uint8Array(ic + 1);
					await tokenizer.readBuffer(id);
					return id;
				}

				async function readElement() {
					const idField = await readField();
					const lengthField = await readField();

					lengthField[0] ^= 0x80 >> (lengthField.length - 1);
					const nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer

					const idView = new DataView(idField.buffer);
					const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);

					return {
						id: getUintBE(idView),
						len: getUintBE(lengthView),
					};
				}

				async function readChildren(children) {
					while (children > 0) {
						const element = await readElement();
						if (element.id === 0x42_82) {
							const rawValue = await tokenizer.readToken(new StringType(element.len));
							return rawValue.replaceAll(/\00.*$/g, ''); // Return DocType
						}

						await tokenizer.ignore(element.len); // ignore payload
						--children;
					}
				}

				const re = await readElement();
				const documentType = await readChildren(re.len);

				switch (documentType) {
					case 'webm':
						return {
							ext: 'webm',
							mime: 'video/webm',
						};

					case 'matroska':
						return {
							ext: 'mkv',
							mime: 'video/matroska',
						};

					default:
						return;
				}
			}

			if (this.checkString('SQLi')) {
				return {
					ext: 'sqlite',
					mime: 'application/x-sqlite3',
				};
			}

			if (this.check([0x4E, 0x45, 0x53, 0x1A])) {
				return {
					ext: 'nes',
					mime: 'application/x-nintendo-nes-rom',
				};
			}

			if (this.checkString('Cr24')) {
				return {
					ext: 'crx',
					mime: 'application/x-google-chrome-extension',
				};
			}

			if (
				this.checkString('MSCF')
				|| this.checkString('ISc(')
			) {
				return {
					ext: 'cab',
					mime: 'application/vnd.ms-cab-compressed',
				};
			}

			if (this.check([0xED, 0xAB, 0xEE, 0xDB])) {
				return {
					ext: 'rpm',
					mime: 'application/x-rpm',
				};
			}

			if (this.check([0xC5, 0xD0, 0xD3, 0xC6])) {
				return {
					ext: 'eps',
					mime: 'application/eps',
				};
			}

			if (this.check([0x28, 0xB5, 0x2F, 0xFD])) {
				return {
					ext: 'zst',
					mime: 'application/zstd',
				};
			}

			if (this.check([0x7F, 0x45, 0x4C, 0x46])) {
				return {
					ext: 'elf',
					mime: 'application/x-elf',
				};
			}

			if (this.check([0x21, 0x42, 0x44, 0x4E])) {
				return {
					ext: 'pst',
					mime: 'application/vnd.ms-outlook',
				};
			}

			if (this.checkString('PAR1') || this.checkString('PARE')) {
				return {
					ext: 'parquet',
					mime: 'application/vnd.apache.parquet',
				};
			}

			if (this.checkString('ttcf')) {
				return {
					ext: 'ttc',
					mime: 'font/collection',
				};
			}

			if (this.check([0xCF, 0xFA, 0xED, 0xFE])) {
				return {
					ext: 'macho',
					mime: 'application/x-mach-binary',
				};
			}

			if (this.check([0x04, 0x22, 0x4D, 0x18])) {
				return {
					ext: 'lz4',
					mime: 'application/x-lz4', // Invented by us
				};
			}

			// -- 5-byte signatures --

			if (this.check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
				return {
					ext: 'otf',
					mime: 'font/otf',
				};
			}

			if (this.checkString('#!AMR')) {
				return {
					ext: 'amr',
					mime: 'audio/amr',
				};
			}

			if (this.checkString('{\\rtf')) {
				return {
					ext: 'rtf',
					mime: 'application/rtf',
				};
			}

			if (this.check([0x46, 0x4C, 0x56, 0x01])) {
				return {
					ext: 'flv',
					mime: 'video/x-flv',
				};
			}

			if (this.checkString('IMPM')) {
				return {
					ext: 'it',
					mime: 'audio/x-it',
				};
			}

			if (
				this.checkString('-lh0-', {offset: 2})
				|| this.checkString('-lh1-', {offset: 2})
				|| this.checkString('-lh2-', {offset: 2})
				|| this.checkString('-lh3-', {offset: 2})
				|| this.checkString('-lh4-', {offset: 2})
				|| this.checkString('-lh5-', {offset: 2})
				|| this.checkString('-lh6-', {offset: 2})
				|| this.checkString('-lh7-', {offset: 2})
				|| this.checkString('-lzs-', {offset: 2})
				|| this.checkString('-lz4-', {offset: 2})
				|| this.checkString('-lz5-', {offset: 2})
				|| this.checkString('-lhd-', {offset: 2})
			) {
				return {
					ext: 'lzh',
					mime: 'application/x-lzh-compressed',
				};
			}

			// MPEG program stream (PS or MPEG-PS)
			if (this.check([0x00, 0x00, 0x01, 0xBA])) {
				//  MPEG-PS, MPEG-1 Part 1
				if (this.check([0x21], {offset: 4, mask: [0xF1]})) {
					return {
						ext: 'mpg', // May also be .ps, .mpeg
						mime: 'video/MP1S',
					};
				}

				// MPEG-PS, MPEG-2 Part 1
				if (this.check([0x44], {offset: 4, mask: [0xC4]})) {
					return {
						ext: 'mpg', // May also be .mpg, .m2p, .vob or .sub
						mime: 'video/MP2P',
					};
				}
			}

			if (this.checkString('ITSF')) {
				return {
					ext: 'chm',
					mime: 'application/vnd.ms-htmlhelp',
				};
			}

			if (this.check([0xCA, 0xFE, 0xBA, 0xBE])) {
				return {
					ext: 'class',
					mime: 'application/java-vm',
				};
			}

			if (this.checkString('.RMF')) {
				return {
					ext: 'rm',
					mime: 'application/vnd.rn-realmedia',
				};
			}

			// -- 5-byte signatures --

			if (this.checkString('DRACO')) {
				return {
					ext: 'drc',
					mime: 'application/vnd.google.draco', // Invented by us
				};
			}

			// -- 6-byte signatures --

			if (this.check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
				return {
					ext: 'xz',
					mime: 'application/x-xz',
				};
			}

			if (this.checkString('<?xml ')) {
				return {
					ext: 'xml',
					mime: 'application/xml',
				};
			}

			if (this.check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
				return {
					ext: '7z',
					mime: 'application/x-7z-compressed',
				};
			}

			if (
				this.check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7])
				&& (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)
			) {
				return {
					ext: 'rar',
					mime: 'application/x-rar-compressed',
				};
			}

			if (this.checkString('solid ')) {
				return {
					ext: 'stl',
					mime: 'model/stl',
				};
			}

			if (this.checkString('AC')) {
				const version = new StringType(4, 'latin1').get(this.buffer, 2);
				if (version.match('^d*') && version >= 1000 && version <= 1050) {
					return {
						ext: 'dwg',
						mime: 'image/vnd.dwg',
					};
				}
			}

			if (this.checkString('070707')) {
				return {
					ext: 'cpio',
					mime: 'application/x-cpio',
				};
			}

			// -- 7-byte signatures --

			if (this.checkString('BLENDER')) {
				return {
					ext: 'blend',
					mime: 'application/x-blender',
				};
			}

			if (this.checkString('!<arch>')) {
				await tokenizer.ignore(8);
				const string = await tokenizer.readToken(new StringType(13, 'ascii'));
				if (string === 'debian-binary') {
					return {
						ext: 'deb',
						mime: 'application/x-deb',
					};
				}

				return {
					ext: 'ar',
					mime: 'application/x-unix-archive',
				};
			}

			if (
				this.checkString('WEBVTT')
				&&	(
					// One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
					(['\n', '\r', '\t', ' ', '\0'].some(char7 => this.checkString(char7, {offset: 6}))))
			) {
				return {
					ext: 'vtt',
					mime: 'text/vtt',
				};
			}

			// -- 8-byte signatures --

			if (this.check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
				// APNG format (https://wiki.mozilla.org/APNG_Specification)
				// 1. Find the first IDAT (image data) chunk (49 44 41 54)
				// 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)

				// Offset calculated as follows:
				// - 8 bytes: PNG signature
				// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk

				await tokenizer.ignore(8); // ignore PNG signature

				async function readChunkHeader() {
					return {
						length: await tokenizer.readToken(INT32_BE),
						type: await tokenizer.readToken(new StringType(4, 'latin1')),
					};
				}

				do {
					const chunk = await readChunkHeader();
					if (chunk.length < 0) {
						return; // Invalid chunk length
					}

					switch (chunk.type) {
						case 'IDAT':
							return {
								ext: 'png',
								mime: 'image/png',
							};
						case 'acTL':
							return {
								ext: 'apng',
								mime: 'image/apng',
							};
						default:
							await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
					}
				} while (tokenizer.position + 8 < tokenizer.fileInfo.size);

				return {
					ext: 'png',
					mime: 'image/png',
				};
			}

			if (this.check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
				return {
					ext: 'arrow',
					mime: 'application/vnd.apache.arrow.file',
				};
			}

			if (this.check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
				return {
					ext: 'glb',
					mime: 'model/gltf-binary',
				};
			}

			// `mov` format variants
			if (
				this.check([0x66, 0x72, 0x65, 0x65], {offset: 4}) // `free`
				|| this.check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) // `mdat` MJPEG
				|| this.check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) // `moov`
				|| this.check([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`
			) {
				return {
					ext: 'mov',
					mime: 'video/quicktime',
				};
			}

			// -- 9-byte signatures --

			if (this.check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
				return {
					ext: 'orf',
					mime: 'image/x-olympus-orf',
				};
			}

			if (this.checkString('gimp xcf ')) {
				return {
					ext: 'xcf',
					mime: 'image/x-xcf',
				};
			}

			// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
			// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
			// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
			// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
			if (
				this.checkString('ftyp', {offset: 4})
				&& (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
			) {
				// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
				// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
				const brandMajor = new StringType(4, 'latin1').get(this.buffer, 8).replace('\0', ' ').trim();
				switch (brandMajor) {
					case 'avif':
					case 'avis':
						return {ext: 'avif', mime: 'image/avif'};
					case 'mif1':
						return {ext: 'heic', mime: 'image/heif'};
					case 'msf1':
						return {ext: 'heic', mime: 'image/heif-sequence'};
					case 'heic':
					case 'heix':
						return {ext: 'heic', mime: 'image/heic'};
					case 'hevc':
					case 'hevx':
						return {ext: 'heic', mime: 'image/heic-sequence'};
					case 'qt':
						return {ext: 'mov', mime: 'video/quicktime'};
					case 'M4V':
					case 'M4VH':
					case 'M4VP':
						return {ext: 'm4v', mime: 'video/x-m4v'};
					case 'M4P':
						return {ext: 'm4p', mime: 'video/mp4'};
					case 'M4B':
						return {ext: 'm4b', mime: 'audio/mp4'};
					case 'M4A':
						return {ext: 'm4a', mime: 'audio/x-m4a'};
					case 'F4V':
						return {ext: 'f4v', mime: 'video/mp4'};
					case 'F4P':
						return {ext: 'f4p', mime: 'video/mp4'};
					case 'F4A':
						return {ext: 'f4a', mime: 'audio/mp4'};
					case 'F4B':
						return {ext: 'f4b', mime: 'audio/mp4'};
					case 'crx':
						return {ext: 'cr3', mime: 'image/x-canon-cr3'};
					default:
						if (brandMajor.startsWith('3g')) {
							if (brandMajor.startsWith('3g2')) {
								return {ext: '3g2', mime: 'video/3gpp2'};
							}

							return {ext: '3gp', mime: 'video/3gpp'};
						}

						return {ext: 'mp4', mime: 'video/mp4'};
				}
			}

			// -- 12-byte signatures --

			// RIFF file format which might be AVI, WAV, QCP, etc
			if (this.check([0x52, 0x49, 0x46, 0x46])) {
				if (this.checkString('WEBP', {offset: 8})) {
					return {
						ext: 'webp',
						mime: 'image/webp',
					};
				}

				if (this.check([0x41, 0x56, 0x49], {offset: 8})) {
					return {
						ext: 'avi',
						mime: 'video/vnd.avi',
					};
				}

				if (this.check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
					return {
						ext: 'wav',
						mime: 'audio/wav',
					};
				}

				// QLCM, QCP file
				if (this.check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
					return {
						ext: 'qcp',
						mime: 'audio/qcelp',
					};
				}
			}

			if (this.check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
				return {
					ext: 'rw2',
					mime: 'image/x-panasonic-rw2',
				};
			}

			// ASF_Header_Object first 80 bytes
			if (this.check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
				async function readHeader() {
					const guid = new Uint8Array(16);
					await tokenizer.readBuffer(guid);
					return {
						id: guid,
						size: Number(await tokenizer.readToken(UINT64_LE)),
					};
				}

				await tokenizer.ignore(30);
				// Search for header should be in first 1KB of file.
				while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
					const header = await readHeader();
					let payload = header.size - 24;
					if (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
						// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
						const typeId = new Uint8Array(16);
						payload -= await tokenizer.readBuffer(typeId);

						if (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
							// Found audio:
							return {
								ext: 'asf',
								mime: 'audio/x-ms-asf',
							};
						}

						if (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
							// Found video:
							return {
								ext: 'asf',
								mime: 'video/x-ms-asf',
							};
						}

						break;
					}

					await tokenizer.ignore(payload);
				}

				// Default to ASF generic extension
				return {
					ext: 'asf',
					mime: 'application/vnd.ms-asf',
				};
			}

			if (this.check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
				return {
					ext: 'ktx',
					mime: 'image/ktx',
				};
			}

			if ((this.check([0x7E, 0x10, 0x04]) || this.check([0x7E, 0x18, 0x04])) && this.check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {
				return {
					ext: 'mie',
					mime: 'application/x-mie',
				};
			}

			if (this.check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {
				return {
					ext: 'shp',
					mime: 'application/x-esri-shape',
				};
			}

			if (this.check([0xFF, 0x4F, 0xFF, 0x51])) {
				return {
					ext: 'j2c',
					mime: 'image/j2c',
				};
			}

			if (this.check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
				// JPEG-2000 family

				await tokenizer.ignore(20);
				const type = await tokenizer.readToken(new StringType(4, 'ascii'));
				switch (type) {
					case 'jp2 ':
						return {
							ext: 'jp2',
							mime: 'image/jp2',
						};
					case 'jpx ':
						return {
							ext: 'jpx',
							mime: 'image/jpx',
						};
					case 'jpm ':
						return {
							ext: 'jpm',
							mime: 'image/jpm',
						};
					case 'mjp2':
						return {
							ext: 'mj2',
							mime: 'image/mj2',
						};
					default:
						return;
				}
			}

			if (
				this.check([0xFF, 0x0A])
				|| this.check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])
			) {
				return {
					ext: 'jxl',
					mime: 'image/jxl',
				};
			}

			if (this.check([0xFE, 0xFF])) { // UTF-16-BOM-LE
				if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], {offset: 2})) {
					return {
						ext: 'xml',
						mime: 'application/xml',
					};
				}

				return undefined; // Some unknown text based format
			}

			if (this.check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
				// Detected Microsoft Compound File Binary File (MS-CFB) Format.
				return {
					ext: 'cfb',
					mime: 'application/x-cfb',
				};
			}

			// Increase sample size from 12 to 256.
			await tokenizer.peekBuffer(this.buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});

			if (this.check([0x61, 0x63, 0x73, 0x70], {offset: 36})) {
				return {
					ext: 'icc',
					mime: 'application/vnd.iccprofile',
				};
			}

			// ACE: requires 14 bytes in the buffer
			if (this.checkString('**ACE', {offset: 7}) && this.checkString('**', {offset: 12})) {
				return {
					ext: 'ace',
					mime: 'application/x-ace-compressed',
				};
			}

			// -- 15-byte signatures --

			if (this.checkString('BEGIN:')) {
				if (this.checkString('VCARD', {offset: 6})) {
					return {
						ext: 'vcf',
						mime: 'text/vcard',
					};
				}

				if (this.checkString('VCALENDAR', {offset: 6})) {
					return {
						ext: 'ics',
						mime: 'text/calendar',
					};
				}
			}

			// `raf` is here just to keep all the raw image detectors together.
			if (this.checkString('FUJIFILMCCD-RAW')) {
				return {
					ext: 'raf',
					mime: 'image/x-fujifilm-raf',
				};
			}

			if (this.checkString('Extended Module:')) {
				return {
					ext: 'xm',
					mime: 'audio/x-xm',
				};
			}

			if (this.checkString('Creative Voice File')) {
				return {
					ext: 'voc',
					mime: 'audio/x-voc',
				};
			}

			if (this.check([0x04, 0x00, 0x00, 0x00]) && this.buffer.length >= 16) { // Rough & quick check Pickle/ASAR
				const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);

				if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
					try {
						const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
						const json = JSON.parse(header);
						// Check if Pickle is ASAR
						if (json.files) { // Final check, assuring Pickle/ASAR format
							return {
								ext: 'asar',
								mime: 'application/x-asar',
							};
						}
					} catch {}
				}
			}

			if (this.check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
				return {
					ext: 'mxf',
					mime: 'application/mxf',
				};
			}

			if (this.checkString('SCRM', {offset: 44})) {
				return {
					ext: 's3m',
					mime: 'audio/x-s3m',
				};
			}

			// Raw MPEG-2 transport stream (188-byte packets)
			if (this.check([0x47]) && this.check([0x47], {offset: 188})) {
				return {
					ext: 'mts',
					mime: 'video/mp2t',
				};
			}

			// Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet
			if (this.check([0x47], {offset: 4}) && this.check([0x47], {offset: 196})) {
				return {
					ext: 'mts',
					mime: 'video/mp2t',
				};
			}

			if (this.check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
				return {
					ext: 'mobi',
					mime: 'application/x-mobipocket-ebook',
				};
			}

			if (this.check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {
				return {
					ext: 'dcm',
					mime: 'application/dicom',
				};
			}

			if (this.check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
				return {
					ext: 'lnk',
					mime: 'application/x.ms.shortcut', // Invented by us
				};
			}

			if (this.check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
				return {
					ext: 'alias',
					mime: 'application/x.apple.alias', // Invented by us
				};
			}

			if (this.checkString('Kaydara FBX Binary  \u0000')) {
				return {
					ext: 'fbx',
					mime: 'application/x.autodesk.fbx', // Invented by us
				};
			}

			if (
				this.check([0x4C, 0x50], {offset: 34})
				&& (
					this.check([0x00, 0x00, 0x01], {offset: 8})
					|| this.check([0x01, 0x00, 0x02], {offset: 8})
					|| this.check([0x02, 0x00, 0x02], {offset: 8})
				)
			) {
				return {
					ext: 'eot',
					mime: 'application/vnd.ms-fontobject',
				};
			}

			if (this.check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
				return {
					ext: 'indd',
					mime: 'application/x-indesign',
				};
			}

			// Increase sample size from 256 to 512
			await tokenizer.peekBuffer(this.buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});

			// Requires a buffer size of 512 bytes
			if ((this.checkString('ustar', {offset: 257}) && (this.checkString('\0', {offset: 262}) || this.checkString(' ', {offset: 262})))
				|| (this.check([0, 0, 0, 0, 0, 0], {offset: 257}) && tarHeaderChecksumMatches(this.buffer))) {
				return {
					ext: 'tar',
					mime: 'application/x-tar',
				};
			}

			if (this.check([0xFF, 0xFE])) { // UTF-16-BOM-BE
				if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], {offset: 2})) {
					return {
						ext: 'xml',
						mime: 'application/xml',
					};
				}

				if (this.check([0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00], {offset: 2})) {
					return {
						ext: 'skp',
						mime: 'application/vnd.sketchup.skp',
					};
				}

				return undefined; // Some text based format
			}

			if (this.checkString('-----BEGIN PGP MESSAGE-----')) {
				return {
					ext: 'pgp',
					mime: 'application/pgp-encrypted',
				};
			}
		};
		// Detections with limited supporting data, resulting in a higher likelihood of false positives
		detectImprecise = async tokenizer => {
			this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);

			// Read initial sample size of 8 bytes
			await tokenizer.peekBuffer(this.buffer, {length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true});

			if (
				this.check([0x0, 0x0, 0x1, 0xBA])
				|| this.check([0x0, 0x0, 0x1, 0xB3])
			) {
				return {
					ext: 'mpg',
					mime: 'video/mpeg',
				};
			}

			if (this.check([0x00, 0x01, 0x00, 0x00, 0x00])) {
				return {
					ext: 'ttf',
					mime: 'font/ttf',
				};
			}

			if (this.check([0x00, 0x00, 0x01, 0x00])) {
				return {
					ext: 'ico',
					mime: 'image/x-icon',
				};
			}

			if (this.check([0x00, 0x00, 0x02, 0x00])) {
				return {
					ext: 'cur',
					mime: 'image/x-icon',
				};
			}

			// Adjust buffer to `mpegOffsetTolerance`
			await tokenizer.peekBuffer(this.buffer, {length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true});

			// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
			if (this.buffer.length >= (2 + this.options.mpegOffsetTolerance)) {
				for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
					const type = this.scanMpeg(depth);
					if (type) {
						return type;
					}
				}
			}
		};

		async readTiffTag(bigEndian) {
			const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
			this.tokenizer.ignore(10);
			switch (tagId) {
				case 50_341:
					return {
						ext: 'arw',
						mime: 'image/x-sony-arw',
					};
				case 50_706:
					return {
						ext: 'dng',
						mime: 'image/x-adobe-dng',
					};
			}
		}

		async readTiffIFD(bigEndian) {
			const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
			for (let n = 0; n < numberOfTags; ++n) {
				const fileType = await this.readTiffTag(bigEndian);
				if (fileType) {
					return fileType;
				}
			}
		}

		async readTiffHeader(bigEndian) {
			const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
			const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);

			if (version === 42) {
				// TIFF file header
				if (ifdOffset >= 6) {
					if (this.checkString('CR', {offset: 8})) {
						return {
							ext: 'cr2',
							mime: 'image/x-canon-cr2',
						};
					}

					if (ifdOffset >= 8) {
						const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
						const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);

						if (
							(someId1 === 0x1C && someId2 === 0xFE)
							|| (someId1 === 0x1F && someId2 === 0x0B)) {
							return {
								ext: 'nef',
								mime: 'image/x-nikon-nef',
							};
						}
					}
				}

				await this.tokenizer.ignore(ifdOffset);
				const fileType = await this.readTiffIFD(bigEndian);
				return fileType ?? {
					ext: 'tif',
					mime: 'image/tiff',
				};
			}

			if (version === 43) {	// Big TIFF file header
				return {
					ext: 'tif',
					mime: 'image/tiff',
				};
			}
		}

		/**
		Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).

		@param offset - Offset to scan for sync-preamble.
		@returns {{ext: string, mime: string}}
		*/
		scanMpeg(offset) {
			if (this.check([0xFF, 0xE0], {offset, mask: [0xFF, 0xE0]})) {
				if (this.check([0x10], {offset: offset + 1, mask: [0x16]})) {
					// Check for (ADTS) MPEG-2
					if (this.check([0x08], {offset: offset + 1, mask: [0x08]})) {
						return {
							ext: 'aac',
							mime: 'audio/aac',
						};
					}

					// Must be (ADTS) MPEG-4
					return {
						ext: 'aac',
						mime: 'audio/aac',
					};
				}

				// MPEG 1 or 2 Layer 3 header
				// Check for MPEG layer 3
				if (this.check([0x02], {offset: offset + 1, mask: [0x06]})) {
					return {
						ext: 'mp3',
						mime: 'audio/mpeg',
					};
				}

				// Check for MPEG layer 2
				if (this.check([0x04], {offset: offset + 1, mask: [0x06]})) {
					return {
						ext: 'mp2',
						mime: 'audio/mpeg',
					};
				}

				// Check for MPEG layer 1
				if (this.check([0x06], {offset: offset + 1, mask: [0x06]})) {
					return {
						ext: 'mp1',
						mime: 'audio/mpeg',
					};
				}
			}
		}
	}

	new Set(extensions);
	new Set(mimeTypes);

	var contentType = {};

	/*!
	 * content-type
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	 *
	 * parameter     = token "=" ( token / quoted-string )
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	 * obs-text      = %x80-FF
	 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	 */
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g; // eslint-disable-line no-control-regex
	var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/; // eslint-disable-line no-control-regex
	var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

	/**
	 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	 *
	 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	 * obs-text    = %x80-FF
	 */
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	 */
	var QUOTE_REGEXP = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 7231 sec 3.1.1.1
	 *
	 * media-type = type "/" subtype
	 * type       = token
	 * subtype    = token
	 */
	var TYPE_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

	/**
	 * Module exports.
	 * @public
	 */

	contentType.format = format$1;
	contentType.parse = parse$1;

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @public
	 */

	function format$1 (obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || !TYPE_REGEXP$1.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  var string = type;

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      if (!TOKEN_REGEXP.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param]);
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @public
	 */

	function parse$1 (string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  var header = typeof string === 'object'
	    ? getcontenttype(string)
	    : string;

	  if (typeof header !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = header.indexOf(';');
	  var type = index !== -1
	    ? header.slice(0, index).trim()
	    : header.trim();

	  if (!TYPE_REGEXP$1.test(type)) {
	    throw new TypeError('invalid media type')
	  }

	  var obj = new ContentType(type.toLowerCase());

	  // parse parameters
	  if (index !== -1) {
	    var key;
	    var match;
	    var value;

	    PARAM_REGEXP.lastIndex = index;

	    while ((match = PARAM_REGEXP.exec(header))) {
	      if (match.index !== index) {
	        throw new TypeError('invalid parameter format')
	      }

	      index += match[0].length;
	      key = match[1].toLowerCase();
	      value = match[2];

	      if (value.charCodeAt(0) === 0x22 /* " */) {
	        // remove quotes
	        value = value.slice(1, -1);

	        // remove escapes
	        if (value.indexOf('\\') !== -1) {
	          value = value.replace(QESC_REGEXP, '$1');
	        }
	      }

	      obj.parameters[key] = value;
	    }

	    if (index !== header.length) {
	      throw new TypeError('invalid parameter format')
	    }
	  }

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @private
	 */

	function getcontenttype (obj) {
	  var header;

	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    header = obj.getHeader('content-type');
	  } else if (typeof obj.headers === 'object') {
	    // req-like
	    header = obj.headers && obj.headers['content-type'];
	  }

	  if (typeof header !== 'string') {
	    throw new TypeError('content-type header is missing from object')
	  }

	  return header
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring (val) {
	  var str = String(val);

	  // no need to quote tokens
	  if (TOKEN_REGEXP.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
	}

	/**
	 * Class to represent a content type.
	 * @private
	 */
	function ContentType (type) {
	  this.parameters = Object.create(null);
	  this.type = type;
	}

	/*!
	 * media-typer
	 * Copyright(c) 2014-2017 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
	var parse_1 = parse;

	/**
	 * Parse media type to object.
	 *
	 * @param {string} string
	 * @return {object}
	 * @public
	 */

	function parse (string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var match = TYPE_REGEXP.exec(string.toLowerCase());

	  if (!match) {
	    throw new TypeError('invalid media type')
	  }

	  var type = match[1];
	  var subtype = match[2];
	  var suffix;

	  // suffix after last +
	  var index = subtype.lastIndexOf('+');
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1);
	    subtype = subtype.substr(0, index);
	  }

	  return new MediaType(type, subtype, suffix)
	}

	/**
	 * Class for MediaType object.
	 * @public
	 */

	function MediaType (type, subtype, suffix) {
	  this.type = type;
	  this.subtype = subtype;
	  this.suffix = suffix;
	}

	const TargetType = {
	    10: 'shot',
	    20: 'scene',
	    30: 'track',
	    40: 'part',
	    50: 'album',
	    60: 'edition',
	    70: 'collection'
	};
	const TrackType = {
	    video: 0x01,
	    audio: 0x02,
	    complex: 0x03,
	    logo: 0x04,
	    subtitle: 0x11,
	    button: 0x12,
	    control: 0x20
	};
	const TrackTypeValueToKeyMap = {
	    [TrackType.video]: 'video',
	    [TrackType.audio]: 'audio',
	    [TrackType.complex]: 'complex',
	    [TrackType.logo]: 'logo',
	    [TrackType.subtitle]: 'subtitle',
	    [TrackType.button]: 'button',
	    [TrackType.control]: 'control'
	};

	const makeParseError = (name) => {
	    return class ParseError extends Error {
	        constructor(message) {
	            super(message);
	            this.name = name;
	        }
	    };
	};
	// Concrete error class representing a file type determination failure.
	class CouldNotDetermineFileTypeError extends makeParseError('CouldNotDetermineFileTypeError') {
	}
	// Concrete error class representing an unsupported file type.
	class UnsupportedFileTypeError extends makeParseError('UnsupportedFileTypeError') {
	}
	// Concrete error class representing unexpected file content.
	class UnexpectedFileContentError extends makeParseError('UnexpectedFileContentError') {
	    constructor(fileType, message) {
	        super(message);
	        this.fileType = fileType;
	    }
	    // Override toString to include file type information.
	    toString() {
	        return `${this.name} (FileType: ${this.fileType}): ${this.message}`;
	    }
	}
	// Concrete error class representing a field decoding error.
	class FieldDecodingError extends makeParseError('FieldDecodingError') {
	}
	class InternalParserError extends makeParseError('InternalParserError') {
	}
	// Factory function to create a specific type of UnexpectedFileContentError.
	const makeUnexpectedFileContentError = (fileType) => {
	    return class extends UnexpectedFileContentError {
	        constructor(message) {
	            super(fileType, message);
	        }
	    };
	};

	function getBit(buf, off, bit) {
	    return (buf[off] & (1 << bit)) !== 0;
	}
	/**
	 * Found delimiting zero in uint8Array
	 * @param uint8Array Uint8Array to find the zero delimiter in
	 * @param start Offset in uint8Array
	 * @param end Last position to parse in uint8Array
	 * @param encoding The string encoding used
	 * @return Absolute position on uint8Array where zero found
	 */
	function findZero(uint8Array, start, end, encoding) {
	    let i = start;
	    if (encoding === 'utf-16le') {
	        while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {
	            if (i >= end)
	                return end;
	            i += 2;
	        }
	        return i;
	    }
	    while (uint8Array[i] !== 0) {
	        if (i >= end)
	            return end;
	        i++;
	    }
	    return i;
	}
	function trimRightNull(x) {
	    const pos0 = x.indexOf('\0');
	    return pos0 === -1 ? x : x.substr(0, pos0);
	}
	function swapBytes(uint8Array) {
	    const l = uint8Array.length;
	    if ((l & 1) !== 0)
	        throw new FieldDecodingError('Buffer length must be even');
	    for (let i = 0; i < l; i += 2) {
	        const a = uint8Array[i];
	        uint8Array[i] = uint8Array[i + 1];
	        uint8Array[i + 1] = a;
	    }
	    return uint8Array;
	}
	/**
	 * Decode string
	 */
	function decodeString(uint8Array, encoding) {
	    // annoying workaround for a double BOM issue
	    // https://github.com/leetreveil/musicmetadata/issues/84
	    if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) { // little endian
	        return decodeString(uint8Array.subarray(2), encoding);
	    }
	    if (encoding === 'utf-16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {
	        // BOM, indicating big endian decoding
	        if ((uint8Array.length & 1) !== 0)
	            throw new FieldDecodingError('Expected even number of octets for 16-bit unicode string');
	        return decodeString(swapBytes(uint8Array), encoding);
	    }
	    return new StringType(uint8Array.length, encoding).get(uint8Array, 0);
	}
	function stripNulls(str) {
	    str = str.replace(/^\x00+/g, '');
	    str = str.replace(/\x00+$/g, '');
	    return str;
	}
	/**
	 * Read bit-aligned number start from buffer
	 * Total offset in bits = byteOffset * 8 + bitOffset
	 * @param source Byte buffer
	 * @param byteOffset Starting offset in bytes
	 * @param bitOffset Starting offset in bits: 0 = lsb
	 * @param len Length of number in bits
	 * @return Decoded bit aligned number
	 */
	function getBitAllignedNumber$1(source, byteOffset, bitOffset, len) {
	    const byteOff = byteOffset + ~~(bitOffset / 8);
	    const bitOff = bitOffset % 8;
	    let value = source[byteOff];
	    value &= 0xff >> bitOff;
	    const bitsRead = 8 - bitOff;
	    const bitsLeft = len - bitsRead;
	    if (bitsLeft < 0) {
	        value >>= (8 - bitOff - len);
	    }
	    else if (bitsLeft > 0) {
	        value <<= bitsLeft;
	        value |= getBitAllignedNumber$1(source, byteOffset, bitOffset + bitsRead, bitsLeft);
	    }
	    return value;
	}
	/**
	 * Read bit-aligned number start from buffer
	 * Total offset in bits = byteOffset * 8 + bitOffset
	 * @param source Byte Uint8Array
	 * @param byteOffset Starting offset in bytes
	 * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit
	 * @return True if bit is set
	 */
	function isBitSet$2(source, byteOffset, bitOffset) {
	    return getBitAllignedNumber$1(source, byteOffset, bitOffset, 1) === 1;
	}
	function a2hex(str) {
	    const arr = [];
	    for (let i = 0, l = str.length; i < l; i++) {
	        const hex = Number(str.charCodeAt(i)).toString(16);
	        arr.push(hex.length === 1 ? `0${hex}` : hex);
	    }
	    return arr.join(' ');
	}
	/**
	 * Convert power ratio to DB
	 * ratio: [0..1]
	 */
	function ratioToDb(ratio) {
	    return 10 * Math.log10(ratio);
	}
	/**
	 * Convert dB to ratio
	 * db Decibels
	 */
	function dbToRatio(dB) {
	    return 10 ** (dB / 10);
	}
	/**
	 * Convert replay gain to ratio and Decibel
	 * @param value string holding a ratio like '0.034' or '-7.54 dB'
	 */
	function toRatio(value) {
	    const ps = value.split(' ').map(p => p.trim().toLowerCase());
	    // @ts-ignore
	    if (ps.length >= 1) {
	        const v = Number.parseFloat(ps[0]);
	        return ps.length === 2 && ps[1] === 'db' ? {
	            dB: v,
	            ratio: dbToRatio(v)
	        } : {
	            dB: ratioToDb(v),
	            ratio: v
	        };
	    }
	}

	/**
	 * The picture type according to the ID3v2 APIC frame
	 * Ref: http://id3.org/id3v2.3.0#Attached_picture
	 */
	const AttachedPictureType = {
	    0: 'Other',
	    1: "32x32 pixels 'file icon' (PNG only)",
	    2: 'Other file icon',
	    3: 'Cover (front)',
	    4: 'Cover (back)',
	    5: 'Leaflet page',
	    6: 'Media (e.g. label side of CD)',
	    7: 'Lead artist/lead performer/soloist',
	    8: 'Artist/performer',
	    9: 'Conductor',
	    10: 'Band/Orchestra',
	    11: 'Composer',
	    12: 'Lyricist/text writer',
	    13: 'Recording Location',
	    14: 'During recording',
	    15: 'During performance',
	    16: 'Movie/video screen capture',
	    17: 'A bright coloured fish',
	    18: 'Illustration',
	    19: 'Band/artist logotype',
	    20: 'Publisher/Studio logotype'
	};
	/**
	 * https://id3.org/id3v2.3.0#Synchronised_lyrics.2Ftext
	 */
	const LyricsContentType = {
	    other: 0,
	    lyrics: 1,
	    text: 2,
	    movement_part: 3,
	    events: 4,
	    chord: 5,
	    trivia_pop: 6,
	};
	const TimestampFormat = {
	    notSynchronized0: 0,
	    mpegFrameNumber: 1,
	    milliseconds: 2
	};
	/**
	 * 28 bits (representing up to 256MB) integer, the msb is 0 to avoid 'false syncsignals'.
	 * 4 * %0xxxxxxx
	 */
	const UINT32SYNCSAFE = {
	    get: (buf, off) => {
	        return buf[off + 3] & 0x7f | ((buf[off + 2]) << 7) |
	            ((buf[off + 1]) << 14) | ((buf[off]) << 21);
	    },
	    len: 4
	};
	/**
	 * ID3v2 header
	 * Ref: http://id3.org/id3v2.3.0#ID3v2_header
	 * ToDo
	 */
	const ID3v2Header = {
	    len: 10,
	    get: (buf, off) => {
	        return {
	            // ID3v2/file identifier   "ID3"
	            fileIdentifier: new StringType(3, 'ascii').get(buf, off),
	            // ID3v2 versionIndex
	            version: {
	                major: INT8.get(buf, off + 3),
	                revision: INT8.get(buf, off + 4)
	            },
	            // ID3v2 flags
	            flags: {
	                // Unsynchronisation
	                unsynchronisation: getBit(buf, off + 5, 7),
	                // Extended header
	                isExtendedHeader: getBit(buf, off + 5, 6),
	                // Experimental indicator
	                expIndicator: getBit(buf, off + 5, 5),
	                footer: getBit(buf, off + 5, 4)
	            },
	            size: UINT32SYNCSAFE.get(buf, off + 6)
	        };
	    }
	};
	const ExtendedHeader = {
	    len: 10,
	    get: (buf, off) => {
	        return {
	            // Extended header size
	            size: UINT32_BE.get(buf, off),
	            // Extended Flags
	            extendedFlags: UINT16_BE.get(buf, off + 4),
	            // Size of padding
	            sizeOfPadding: UINT32_BE.get(buf, off + 6),
	            // CRC data present
	            crcDataPresent: getBit(buf, off + 4, 31)
	        };
	    }
	};
	const TextEncodingToken = {
	    len: 1,
	    get: (uint8Array, off) => {
	        switch (uint8Array[off]) {
	            case 0x00:
	                return { encoding: 'latin1' }; // binary
	            case 0x01:
	                return { encoding: 'utf-16le', bom: true };
	            case 0x02:
	                return { encoding: 'utf-16le', bom: false };
	            case 0x03:
	                return { encoding: 'utf8', bom: false };
	            default:
	                return { encoding: 'utf8', bom: false };
	        }
	    }
	};
	/**
	 * Used to read first portion of `SYLT` frame
	 */
	const TextHeader = {
	    len: 4,
	    get: (uint8Array, off) => {
	        return {
	            encoding: TextEncodingToken.get(uint8Array, off),
	            language: new StringType(3, 'latin1').get(uint8Array, off + 1)
	        };
	    }
	};
	/**
	 * Used to read first portion of `SYLT` frame
	 */
	const SyncTextHeader = {
	    len: 6,
	    get: (uint8Array, off) => {
	        const text = TextHeader.get(uint8Array, off);
	        return {
	            encoding: text.encoding,
	            language: text.language,
	            timeStampFormat: UINT8.get(uint8Array, off + 4),
	            contentType: UINT8.get(uint8Array, off + 5)
	        };
	    }
	};

	const defaultTagInfo = {
	    multiple: false,
	};
	const commonTags = {
	    year: defaultTagInfo,
	    track: defaultTagInfo,
	    disk: defaultTagInfo,
	    title: defaultTagInfo,
	    artist: defaultTagInfo,
	    artists: { multiple: true, unique: true },
	    albumartist: defaultTagInfo,
	    album: defaultTagInfo,
	    date: defaultTagInfo,
	    originaldate: defaultTagInfo,
	    originalyear: defaultTagInfo,
	    releasedate: defaultTagInfo,
	    comment: { multiple: true, unique: false },
	    genre: { multiple: true, unique: true },
	    picture: { multiple: true, unique: true },
	    composer: { multiple: true, unique: true },
	    lyrics: { multiple: true, unique: false },
	    albumsort: { multiple: false, unique: true },
	    titlesort: { multiple: false, unique: true },
	    work: { multiple: false, unique: true },
	    artistsort: { multiple: false, unique: true },
	    albumartistsort: { multiple: false, unique: true },
	    composersort: { multiple: false, unique: true },
	    lyricist: { multiple: true, unique: true },
	    writer: { multiple: true, unique: true },
	    conductor: { multiple: true, unique: true },
	    remixer: { multiple: true, unique: true },
	    arranger: { multiple: true, unique: true },
	    engineer: { multiple: true, unique: true },
	    producer: { multiple: true, unique: true },
	    technician: { multiple: true, unique: true },
	    djmixer: { multiple: true, unique: true },
	    mixer: { multiple: true, unique: true },
	    label: { multiple: true, unique: true },
	    grouping: defaultTagInfo,
	    subtitle: { multiple: true },
	    discsubtitle: defaultTagInfo,
	    totaltracks: defaultTagInfo,
	    totaldiscs: defaultTagInfo,
	    compilation: defaultTagInfo,
	    rating: { multiple: true },
	    bpm: defaultTagInfo,
	    mood: defaultTagInfo,
	    media: defaultTagInfo,
	    catalognumber: { multiple: true, unique: true },
	    tvShow: defaultTagInfo,
	    tvShowSort: defaultTagInfo,
	    tvSeason: defaultTagInfo,
	    tvEpisode: defaultTagInfo,
	    tvEpisodeId: defaultTagInfo,
	    tvNetwork: defaultTagInfo,
	    podcast: defaultTagInfo,
	    podcasturl: defaultTagInfo,
	    releasestatus: defaultTagInfo,
	    releasetype: { multiple: true },
	    releasecountry: defaultTagInfo,
	    script: defaultTagInfo,
	    language: defaultTagInfo,
	    copyright: defaultTagInfo,
	    license: defaultTagInfo,
	    encodedby: defaultTagInfo,
	    encodersettings: defaultTagInfo,
	    gapless: defaultTagInfo,
	    barcode: defaultTagInfo,
	    isrc: { multiple: true },
	    asin: defaultTagInfo,
	    musicbrainz_recordingid: defaultTagInfo,
	    musicbrainz_trackid: defaultTagInfo,
	    musicbrainz_albumid: defaultTagInfo,
	    musicbrainz_artistid: { multiple: true },
	    musicbrainz_albumartistid: { multiple: true },
	    musicbrainz_releasegroupid: defaultTagInfo,
	    musicbrainz_workid: defaultTagInfo,
	    musicbrainz_trmid: defaultTagInfo,
	    musicbrainz_discid: defaultTagInfo,
	    acoustid_id: defaultTagInfo,
	    acoustid_fingerprint: defaultTagInfo,
	    musicip_puid: defaultTagInfo,
	    musicip_fingerprint: defaultTagInfo,
	    website: defaultTagInfo,
	    'performer:instrument': { multiple: true, unique: true },
	    averageLevel: defaultTagInfo,
	    peakLevel: defaultTagInfo,
	    notes: { multiple: true, unique: false },
	    key: defaultTagInfo,
	    originalalbum: defaultTagInfo,
	    originalartist: defaultTagInfo,
	    discogs_artist_id: { multiple: true, unique: true },
	    discogs_release_id: defaultTagInfo,
	    discogs_label_id: defaultTagInfo,
	    discogs_master_release_id: defaultTagInfo,
	    discogs_votes: defaultTagInfo,
	    discogs_rating: defaultTagInfo,
	    replaygain_track_peak: defaultTagInfo,
	    replaygain_track_gain: defaultTagInfo,
	    replaygain_album_peak: defaultTagInfo,
	    replaygain_album_gain: defaultTagInfo,
	    replaygain_track_minmax: defaultTagInfo,
	    replaygain_album_minmax: defaultTagInfo,
	    replaygain_undo: defaultTagInfo,
	    description: { multiple: true },
	    longDescription: defaultTagInfo,
	    category: { multiple: true },
	    hdVideo: defaultTagInfo,
	    keywords: { multiple: true },
	    movement: defaultTagInfo,
	    movementIndex: defaultTagInfo,
	    movementTotal: defaultTagInfo,
	    podcastId: defaultTagInfo,
	    showMovement: defaultTagInfo,
	    stik: defaultTagInfo
	};
	/**
	 * @param alias Name of common tag
	 * @returns {boolean|*} true if given alias is mapped as a singleton', otherwise false
	 */
	function isSingleton(alias) {
	    return commonTags[alias] && !commonTags[alias].multiple;
	}
	/**
	 * @param alias Common (generic) tag
	 * @returns {boolean|*} true if given alias is a singleton or explicitly marked as unique
	 */
	function isUnique(alias) {
	    return !commonTags[alias].multiple || commonTags[alias].unique || false;
	}

	class CommonTagMapper {
	    static toIntOrNull(str) {
	        const cleaned = Number.parseInt(str, 10);
	        return Number.isNaN(cleaned) ? null : cleaned;
	    }
	    // TODO: a string of 1of1 would fail to be converted
	    // converts 1/10 to no : 1, of : 10
	    // or 1 to no : 1, of : 0
	    static normalizeTrack(origVal) {
	        const split = origVal.toString().split('/');
	        return {
	            no: Number.parseInt(split[0], 10) || null,
	            of: Number.parseInt(split[1], 10) || null
	        };
	    }
	    constructor(tagTypes, tagMap) {
	        this.tagTypes = tagTypes;
	        this.tagMap = tagMap;
	    }
	    /**
	     * Process and set common tags
	     * write common tags to
	     * @param tag Native tag
	     * @param warnings Register warnings
	     * @return common name
	     */
	    mapGenericTag(tag, warnings) {
	        tag = { id: tag.id, value: tag.value }; // clone object
	        this.postMap(tag, warnings);
	        // Convert native tag event to generic 'alias' tag
	        const id = this.getCommonName(tag.id);
	        return id ? { id, value: tag.value } : null;
	    }
	    /**
	     * Convert native tag key to common tag key
	     * @param tag Native header tag
	     * @return common tag name (alias)
	     */
	    getCommonName(tag) {
	        return this.tagMap[tag];
	    }
	    /**
	     * Handle post mapping exceptions / correction
	     * @param tag Tag e.g. {"©alb", "Buena Vista Social Club")
	     * @param warnings Used to register warnings
	     */
	    postMap(_tag, _warnings) {
	        return;
	    }
	}
	CommonTagMapper.maxRatingScore = 1;

	/**
	 * ID3v1 tag mappings
	 */
	const id3v1TagMap = {
	    title: 'title',
	    artist: 'artist',
	    album: 'album',
	    year: 'year',
	    comment: 'comment',
	    track: 'track',
	    genre: 'genre'
	};
	class ID3v1TagMapper extends CommonTagMapper {
	    constructor() {
	        super(['ID3v1'], id3v1TagMap);
	    }
	}

	class CaseInsensitiveTagMap extends CommonTagMapper {
	    constructor(tagTypes, tagMap) {
	        const upperCaseMap = {};
	        for (const tag of Object.keys(tagMap)) {
	            upperCaseMap[tag.toUpperCase()] = tagMap[tag];
	        }
	        super(tagTypes, upperCaseMap);
	    }
	    /**
	     * @tag  Native header tag
	     * @return common tag name (alias)
	     */
	    getCommonName(tag) {
	        return this.tagMap[tag.toUpperCase()];
	    }
	}

	/**
	 * ID3v2.3/ID3v2.4 tag mappings
	 */
	const id3v24TagMap = {
	    // id3v2.3
	    TIT2: 'title',
	    TPE1: 'artist',
	    'TXXX:Artists': 'artists',
	    TPE2: 'albumartist',
	    TALB: 'album',
	    TDRV: 'date', // [ 'date', 'year' ] ToDo: improve 'year' mapping
	    /**
	     * Original release year
	     */
	    TORY: 'originalyear',
	    TPOS: 'disk',
	    TCON: 'genre',
	    APIC: 'picture',
	    TCOM: 'composer',
	    USLT: 'lyrics',
	    TSOA: 'albumsort',
	    TSOT: 'titlesort',
	    TOAL: 'originalalbum',
	    TSOP: 'artistsort',
	    TSO2: 'albumartistsort',
	    TSOC: 'composersort',
	    TEXT: 'lyricist',
	    'TXXX:Writer': 'writer',
	    TPE3: 'conductor',
	    // 'IPLS:instrument': 'performer:instrument', // ToDo
	    TPE4: 'remixer',
	    'IPLS:arranger': 'arranger',
	    'IPLS:engineer': 'engineer',
	    'IPLS:producer': 'producer',
	    'IPLS:DJ-mix': 'djmixer',
	    'IPLS:mix': 'mixer',
	    TPUB: 'label',
	    TIT1: 'grouping',
	    TIT3: 'subtitle',
	    TRCK: 'track',
	    TCMP: 'compilation',
	    POPM: 'rating',
	    TBPM: 'bpm',
	    TMED: 'media',
	    'TXXX:CATALOGNUMBER': 'catalognumber',
	    'TXXX:MusicBrainz Album Status': 'releasestatus',
	    'TXXX:MusicBrainz Album Type': 'releasetype',
	    /**
	     * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
	     */
	    'TXXX:MusicBrainz Album Release Country': 'releasecountry',
	    /**
	     * Release country as implemented // ToDo: report
	     */
	    'TXXX:RELEASECOUNTRY': 'releasecountry',
	    'TXXX:SCRIPT': 'script',
	    TLAN: 'language',
	    TCOP: 'copyright',
	    WCOP: 'license',
	    TENC: 'encodedby',
	    TSSE: 'encodersettings',
	    'TXXX:BARCODE': 'barcode',
	    'TXXX:ISRC': 'isrc',
	    TSRC: 'isrc',
	    'TXXX:ASIN': 'asin',
	    'TXXX:originalyear': 'originalyear',
	    'UFID:http://musicbrainz.org': 'musicbrainz_recordingid',
	    'TXXX:MusicBrainz Release Track Id': 'musicbrainz_trackid',
	    'TXXX:MusicBrainz Album Id': 'musicbrainz_albumid',
	    'TXXX:MusicBrainz Artist Id': 'musicbrainz_artistid',
	    'TXXX:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',
	    'TXXX:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',
	    'TXXX:MusicBrainz Work Id': 'musicbrainz_workid',
	    'TXXX:MusicBrainz TRM Id': 'musicbrainz_trmid',
	    'TXXX:MusicBrainz Disc Id': 'musicbrainz_discid',
	    'TXXX:ACOUSTID_ID': 'acoustid_id',
	    'TXXX:Acoustid Id': 'acoustid_id',
	    'TXXX:Acoustid Fingerprint': 'acoustid_fingerprint',
	    'TXXX:MusicIP PUID': 'musicip_puid',
	    'TXXX:MusicMagic Fingerprint': 'musicip_fingerprint',
	    WOAR: 'website',
	    // id3v2.4
	    // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
	    TDRC: 'date', // date YYYY-MM-DD
	    TYER: 'year',
	    TDOR: 'originaldate',
	    // 'TMCL:instrument': 'performer:instrument',
	    'TIPL:arranger': 'arranger',
	    'TIPL:engineer': 'engineer',
	    'TIPL:producer': 'producer',
	    'TIPL:DJ-mix': 'djmixer',
	    'TIPL:mix': 'mixer',
	    TMOO: 'mood',
	    // additional mappings:
	    SYLT: 'lyrics',
	    TSST: 'discsubtitle',
	    TKEY: 'key',
	    COMM: 'comment',
	    TOPE: 'originalartist',
	    // Windows Media Player
	    'PRIV:AverageLevel': 'averageLevel',
	    'PRIV:PeakLevel': 'peakLevel',
	    // Discogs
	    'TXXX:DISCOGS_ARTIST_ID': 'discogs_artist_id',
	    'TXXX:DISCOGS_ARTISTS': 'artists',
	    'TXXX:DISCOGS_ARTIST_NAME': 'artists',
	    'TXXX:DISCOGS_ALBUM_ARTISTS': 'albumartist',
	    'TXXX:DISCOGS_CATALOG': 'catalognumber',
	    'TXXX:DISCOGS_COUNTRY': 'releasecountry',
	    'TXXX:DISCOGS_DATE': 'originaldate',
	    'TXXX:DISCOGS_LABEL': 'label',
	    'TXXX:DISCOGS_LABEL_ID': 'discogs_label_id',
	    'TXXX:DISCOGS_MASTER_RELEASE_ID': 'discogs_master_release_id',
	    'TXXX:DISCOGS_RATING': 'discogs_rating',
	    'TXXX:DISCOGS_RELEASED': 'date',
	    'TXXX:DISCOGS_RELEASE_ID': 'discogs_release_id',
	    'TXXX:DISCOGS_VOTES': 'discogs_votes',
	    'TXXX:CATALOGID': 'catalognumber',
	    'TXXX:STYLE': 'genre',
	    'TXXX:REPLAYGAIN_TRACK_PEAK': 'replaygain_track_peak',
	    'TXXX:REPLAYGAIN_TRACK_GAIN': 'replaygain_track_gain',
	    'TXXX:REPLAYGAIN_ALBUM_PEAK': 'replaygain_album_peak',
	    'TXXX:REPLAYGAIN_ALBUM_GAIN': 'replaygain_album_gain',
	    'TXXX:MP3GAIN_MINMAX': 'replaygain_track_minmax',
	    'TXXX:MP3GAIN_ALBUM_MINMAX': 'replaygain_album_minmax',
	    'TXXX:MP3GAIN_UNDO': 'replaygain_undo',
	    MVNM: 'movement',
	    MVIN: 'movementIndex',
	    PCST: 'podcast',
	    TCAT: 'category',
	    TDES: 'description',
	    TDRL: 'releasedate',
	    TGID: 'podcastId',
	    TKWD: 'keywords',
	    WFED: 'podcasturl',
	    GRP1: 'grouping'
	};
	class ID3v24TagMapper extends CaseInsensitiveTagMap {
	    static toRating(popm) {
	        return {
	            source: popm.email,
	            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * CommonTagMapper.maxRatingScore : undefined
	        };
	    }
	    constructor() {
	        super(['ID3v2.3', 'ID3v2.4'], id3v24TagMap);
	    }
	    /**
	     * Handle post mapping exceptions / correction
	     * @param tag to post map
	     * @param warnings Wil be used to register (collect) warnings
	     */
	    postMap(tag, warnings) {
	        switch (tag.id) {
	            case 'UFID':
	                {
	                    // decode MusicBrainz Recording Id
	                    const idTag = tag.value;
	                    if (idTag.owner_identifier === 'http://musicbrainz.org') {
	                        tag.id += `:${idTag.owner_identifier}`;
	                        tag.value = decodeString(idTag.identifier, 'latin1'); // latin1 == iso-8859-1
	                    }
	                }
	                break;
	            case 'PRIV':
	                {
	                    const customTag = tag.value;
	                    switch (customTag.owner_identifier) {
	                        // decode Windows Media Player
	                        case 'AverageLevel':
	                        case 'PeakValue':
	                            tag.id += `:${customTag.owner_identifier}`;
	                            tag.value = customTag.data.length === 4 ? UINT32_LE.get(customTag.data, 0) : null;
	                            if (tag.value === null) {
	                                warnings.addWarning('Failed to parse PRIV:PeakValue');
	                            }
	                            break;
	                        default:
	                            warnings.addWarning(`Unknown PRIV owner-identifier: ${customTag.data}`);
	                    }
	                }
	                break;
	            case 'POPM':
	                tag.value = ID3v24TagMapper.toRating(tag.value);
	                break;
	        }
	    }
	}

	/**
	 * ASF Metadata tag mappings.
	 * See http://msdn.microsoft.com/en-us/library/ms867702.aspx
	 */
	const asfTagMap = {
	    Title: 'title',
	    Author: 'artist',
	    'WM/AlbumArtist': 'albumartist',
	    'WM/AlbumTitle': 'album',
	    'WM/Year': 'date', // changed to 'year' to 'date' based on Picard mappings; ToDo: check me
	    'WM/OriginalReleaseTime': 'originaldate',
	    'WM/OriginalReleaseYear': 'originalyear',
	    Description: 'comment',
	    'WM/TrackNumber': 'track',
	    'WM/PartOfSet': 'disk',
	    'WM/Genre': 'genre',
	    'WM/Composer': 'composer',
	    'WM/Lyrics': 'lyrics',
	    'WM/AlbumSortOrder': 'albumsort',
	    'WM/TitleSortOrder': 'titlesort',
	    'WM/ArtistSortOrder': 'artistsort',
	    'WM/AlbumArtistSortOrder': 'albumartistsort',
	    'WM/ComposerSortOrder': 'composersort',
	    'WM/Writer': 'lyricist',
	    'WM/Conductor': 'conductor',
	    'WM/ModifiedBy': 'remixer',
	    'WM/Engineer': 'engineer',
	    'WM/Producer': 'producer',
	    'WM/DJMixer': 'djmixer',
	    'WM/Mixer': 'mixer',
	    'WM/Publisher': 'label',
	    'WM/ContentGroupDescription': 'grouping',
	    'WM/SubTitle': 'subtitle',
	    'WM/SetSubTitle': 'discsubtitle',
	    // 'WM/PartOfSet': 'totaldiscs',
	    'WM/IsCompilation': 'compilation',
	    'WM/SharedUserRating': 'rating',
	    'WM/BeatsPerMinute': 'bpm',
	    'WM/Mood': 'mood',
	    'WM/Media': 'media',
	    'WM/CatalogNo': 'catalognumber',
	    'MusicBrainz/Album Status': 'releasestatus',
	    'MusicBrainz/Album Type': 'releasetype',
	    'MusicBrainz/Album Release Country': 'releasecountry',
	    'WM/Script': 'script',
	    'WM/Language': 'language',
	    Copyright: 'copyright',
	    LICENSE: 'license',
	    'WM/EncodedBy': 'encodedby',
	    'WM/EncodingSettings': 'encodersettings',
	    'WM/Barcode': 'barcode',
	    'WM/ISRC': 'isrc',
	    'MusicBrainz/Track Id': 'musicbrainz_recordingid',
	    'MusicBrainz/Release Track Id': 'musicbrainz_trackid',
	    'MusicBrainz/Album Id': 'musicbrainz_albumid',
	    'MusicBrainz/Artist Id': 'musicbrainz_artistid',
	    'MusicBrainz/Album Artist Id': 'musicbrainz_albumartistid',
	    'MusicBrainz/Release Group Id': 'musicbrainz_releasegroupid',
	    'MusicBrainz/Work Id': 'musicbrainz_workid',
	    'MusicBrainz/TRM Id': 'musicbrainz_trmid',
	    'MusicBrainz/Disc Id': 'musicbrainz_discid',
	    'Acoustid/Id': 'acoustid_id',
	    'Acoustid/Fingerprint': 'acoustid_fingerprint',
	    'MusicIP/PUID': 'musicip_puid',
	    'WM/ARTISTS': 'artists',
	    'WM/InitialKey': 'key',
	    ASIN: 'asin',
	    'WM/Work': 'work',
	    'WM/AuthorURL': 'website',
	    'WM/Picture': 'picture'
	};
	class AsfTagMapper extends CommonTagMapper {
	    static toRating(rating) {
	        return {
	            rating: Number.parseFloat(rating + 1) / 5
	        };
	    }
	    constructor() {
	        super(['asf'], asfTagMap);
	    }
	    postMap(tag) {
	        switch (tag.id) {
	            case 'WM/SharedUserRating': {
	                const keys = tag.id.split(':');
	                tag.value = AsfTagMapper.toRating(tag.value);
	                tag.id = keys[0];
	                break;
	            }
	        }
	    }
	}

	/**
	 * ID3v2.2 tag mappings
	 */
	const id3v22TagMap = {
	    TT2: 'title',
	    TP1: 'artist',
	    TP2: 'albumartist',
	    TAL: 'album',
	    TYE: 'year',
	    COM: 'comment',
	    TRK: 'track',
	    TPA: 'disk',
	    TCO: 'genre',
	    PIC: 'picture',
	    TCM: 'composer',
	    TOR: 'originaldate',
	    TOT: 'originalalbum',
	    TXT: 'lyricist',
	    TP3: 'conductor',
	    TPB: 'label',
	    TT1: 'grouping',
	    TT3: 'subtitle',
	    TLA: 'language',
	    TCR: 'copyright',
	    WCP: 'license',
	    TEN: 'encodedby',
	    TSS: 'encodersettings',
	    WAR: 'website',
	    PCS: 'podcast',
	    TCP: "compilation",
	    TDR: 'date',
	    TS2: 'albumartistsort',
	    TSA: 'albumsort',
	    TSC: 'composersort',
	    TSP: 'artistsort',
	    TST: 'titlesort',
	    WFD: 'podcasturl',
	    TBP: 'bpm'
	};
	class ID3v22TagMapper extends CaseInsensitiveTagMap {
	    constructor() {
	        super(['ID3v2.2'], id3v22TagMap);
	    }
	}

	/**
	 * ID3v2.2 tag mappings
	 */
	const apev2TagMap = {
	    Title: 'title',
	    Artist: 'artist',
	    Artists: 'artists',
	    'Album Artist': 'albumartist',
	    Album: 'album',
	    Year: 'date',
	    Originalyear: 'originalyear',
	    Originaldate: 'originaldate',
	    Releasedate: 'releasedate',
	    Comment: 'comment',
	    Track: 'track',
	    Disc: 'disk',
	    DISCNUMBER: 'disk', // ToDo: backwards compatibility', valid tag?
	    Genre: 'genre',
	    'Cover Art (Front)': 'picture',
	    'Cover Art (Back)': 'picture',
	    Composer: 'composer',
	    Lyrics: 'lyrics',
	    ALBUMSORT: 'albumsort',
	    TITLESORT: 'titlesort',
	    WORK: 'work',
	    ARTISTSORT: 'artistsort',
	    ALBUMARTISTSORT: 'albumartistsort',
	    COMPOSERSORT: 'composersort',
	    Lyricist: 'lyricist',
	    Writer: 'writer',
	    Conductor: 'conductor',
	    // 'Performer=artist (instrument)': 'performer:instrument',
	    MixArtist: 'remixer',
	    Arranger: 'arranger',
	    Engineer: 'engineer',
	    Producer: 'producer',
	    DJMixer: 'djmixer',
	    Mixer: 'mixer',
	    Label: 'label',
	    Grouping: 'grouping',
	    Subtitle: 'subtitle',
	    DiscSubtitle: 'discsubtitle',
	    Compilation: 'compilation',
	    BPM: 'bpm',
	    Mood: 'mood',
	    Media: 'media',
	    CatalogNumber: 'catalognumber',
	    MUSICBRAINZ_ALBUMSTATUS: 'releasestatus',
	    MUSICBRAINZ_ALBUMTYPE: 'releasetype',
	    RELEASECOUNTRY: 'releasecountry',
	    Script: 'script',
	    Language: 'language',
	    Copyright: 'copyright',
	    LICENSE: 'license',
	    EncodedBy: 'encodedby',
	    EncoderSettings: 'encodersettings',
	    Barcode: 'barcode',
	    ISRC: 'isrc',
	    ASIN: 'asin',
	    musicbrainz_trackid: 'musicbrainz_recordingid',
	    musicbrainz_releasetrackid: 'musicbrainz_trackid',
	    MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',
	    MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',
	    MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',
	    MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',
	    MUSICBRAINZ_WORKID: 'musicbrainz_workid',
	    MUSICBRAINZ_TRMID: 'musicbrainz_trmid',
	    MUSICBRAINZ_DISCID: 'musicbrainz_discid',
	    Acoustid_Id: 'acoustid_id',
	    ACOUSTID_FINGERPRINT: 'acoustid_fingerprint',
	    MUSICIP_PUID: 'musicip_puid',
	    Weblink: 'website',
	    REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',
	    REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',
	    MP3GAIN_MINMAX: 'replaygain_track_minmax',
	    MP3GAIN_UNDO: 'replaygain_undo'
	};
	class APEv2TagMapper extends CaseInsensitiveTagMap {
	    constructor() {
	        super(['APEv2'], apev2TagMap);
	    }
	}

	/**
	 * Ref: https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata
	 */
	const mp4TagMap = {
	    '©nam': 'title',
	    '©ART': 'artist',
	    aART: 'albumartist',
	    /**
	     * ToDo: Album artist seems to be stored here while Picard documentation says: aART
	     */
	    '----:com.apple.iTunes:Band': 'albumartist',
	    '©alb': 'album',
	    '©day': 'date',
	    '©cmt': 'comment',
	    '©com': 'comment',
	    trkn: 'track',
	    disk: 'disk',
	    '©gen': 'genre',
	    covr: 'picture',
	    '©wrt': 'composer',
	    '©lyr': 'lyrics',
	    soal: 'albumsort',
	    sonm: 'titlesort',
	    soar: 'artistsort',
	    soaa: 'albumartistsort',
	    soco: 'composersort',
	    '----:com.apple.iTunes:LYRICIST': 'lyricist',
	    '----:com.apple.iTunes:CONDUCTOR': 'conductor',
	    '----:com.apple.iTunes:REMIXER': 'remixer',
	    '----:com.apple.iTunes:ENGINEER': 'engineer',
	    '----:com.apple.iTunes:PRODUCER': 'producer',
	    '----:com.apple.iTunes:DJMIXER': 'djmixer',
	    '----:com.apple.iTunes:MIXER': 'mixer',
	    '----:com.apple.iTunes:LABEL': 'label',
	    '©grp': 'grouping',
	    '----:com.apple.iTunes:SUBTITLE': 'subtitle',
	    '----:com.apple.iTunes:DISCSUBTITLE': 'discsubtitle',
	    cpil: 'compilation',
	    tmpo: 'bpm',
	    '----:com.apple.iTunes:MOOD': 'mood',
	    '----:com.apple.iTunes:MEDIA': 'media',
	    '----:com.apple.iTunes:CATALOGNUMBER': 'catalognumber',
	    tvsh: 'tvShow',
	    tvsn: 'tvSeason',
	    tves: 'tvEpisode',
	    sosn: 'tvShowSort',
	    tven: 'tvEpisodeId',
	    tvnn: 'tvNetwork',
	    pcst: 'podcast',
	    purl: 'podcasturl',
	    '----:com.apple.iTunes:MusicBrainz Album Status': 'releasestatus',
	    '----:com.apple.iTunes:MusicBrainz Album Type': 'releasetype',
	    '----:com.apple.iTunes:MusicBrainz Album Release Country': 'releasecountry',
	    '----:com.apple.iTunes:SCRIPT': 'script',
	    '----:com.apple.iTunes:LANGUAGE': 'language',
	    cprt: 'copyright',
	    '©cpy': 'copyright',
	    '----:com.apple.iTunes:LICENSE': 'license',
	    '©too': 'encodedby',
	    pgap: 'gapless',
	    '----:com.apple.iTunes:BARCODE': 'barcode',
	    '----:com.apple.iTunes:ISRC': 'isrc',
	    '----:com.apple.iTunes:ASIN': 'asin',
	    '----:com.apple.iTunes:NOTES': 'comment',
	    '----:com.apple.iTunes:MusicBrainz Track Id': 'musicbrainz_recordingid',
	    '----:com.apple.iTunes:MusicBrainz Release Track Id': 'musicbrainz_trackid',
	    '----:com.apple.iTunes:MusicBrainz Album Id': 'musicbrainz_albumid',
	    '----:com.apple.iTunes:MusicBrainz Artist Id': 'musicbrainz_artistid',
	    '----:com.apple.iTunes:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',
	    '----:com.apple.iTunes:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',
	    '----:com.apple.iTunes:MusicBrainz Work Id': 'musicbrainz_workid',
	    '----:com.apple.iTunes:MusicBrainz TRM Id': 'musicbrainz_trmid',
	    '----:com.apple.iTunes:MusicBrainz Disc Id': 'musicbrainz_discid',
	    '----:com.apple.iTunes:Acoustid Id': 'acoustid_id',
	    '----:com.apple.iTunes:Acoustid Fingerprint': 'acoustid_fingerprint',
	    '----:com.apple.iTunes:MusicIP PUID': 'musicip_puid',
	    '----:com.apple.iTunes:fingerprint': 'musicip_fingerprint',
	    '----:com.apple.iTunes:replaygain_track_gain': 'replaygain_track_gain',
	    '----:com.apple.iTunes:replaygain_track_peak': 'replaygain_track_peak',
	    '----:com.apple.iTunes:replaygain_album_gain': 'replaygain_album_gain',
	    '----:com.apple.iTunes:replaygain_album_peak': 'replaygain_album_peak',
	    '----:com.apple.iTunes:replaygain_track_minmax': 'replaygain_track_minmax',
	    '----:com.apple.iTunes:replaygain_album_minmax': 'replaygain_album_minmax',
	    '----:com.apple.iTunes:replaygain_undo': 'replaygain_undo',
	    // Additional mappings:
	    gnre: 'genre', // ToDo: check mapping
	    '----:com.apple.iTunes:ALBUMARTISTSORT': 'albumartistsort',
	    '----:com.apple.iTunes:ARTISTS': 'artists',
	    '----:com.apple.iTunes:ORIGINALDATE': 'originaldate',
	    '----:com.apple.iTunes:ORIGINALYEAR': 'originalyear',
	    '----:com.apple.iTunes:RELEASEDATE': 'releasedate',
	    // '----:com.apple.iTunes:PERFORMER': 'performer'
	    desc: 'description',
	    ldes: 'longDescription',
	    '©mvn': 'movement',
	    '©mvi': 'movementIndex',
	    '©mvc': 'movementTotal',
	    '©wrk': 'work',
	    catg: 'category',
	    egid: 'podcastId',
	    hdvd: 'hdVideo',
	    keyw: 'keywords',
	    shwm: 'showMovement',
	    stik: 'stik',
	    rate: 'rating'
	};
	const tagType = 'iTunes';
	class MP4TagMapper extends CaseInsensitiveTagMap {
	    constructor() {
	        super([tagType], mp4TagMap);
	    }
	    postMap(tag, _warnings) {
	        switch (tag.id) {
	            case 'rate':
	                tag.value = {
	                    source: undefined,
	                    rating: Number.parseFloat(tag.value) / 100
	                };
	                break;
	        }
	    }
	}

	/**
	 * Vorbis tag mappings
	 *
	 * Mapping from native header format to one or possibly more 'common' entries
	 * The common entries aim to read the same information from different media files
	 * independent of the underlying format
	 */
	const vorbisTagMap = {
	    TITLE: 'title',
	    ARTIST: 'artist',
	    ARTISTS: 'artists',
	    ALBUMARTIST: 'albumartist',
	    'ALBUM ARTIST': 'albumartist',
	    ALBUM: 'album',
	    DATE: 'date',
	    ORIGINALDATE: 'originaldate',
	    ORIGINALYEAR: 'originalyear',
	    RELEASEDATE: 'releasedate',
	    COMMENT: 'comment',
	    TRACKNUMBER: 'track',
	    DISCNUMBER: 'disk',
	    GENRE: 'genre',
	    METADATA_BLOCK_PICTURE: 'picture',
	    COMPOSER: 'composer',
	    LYRICS: 'lyrics',
	    ALBUMSORT: 'albumsort',
	    TITLESORT: 'titlesort',
	    WORK: 'work',
	    ARTISTSORT: 'artistsort',
	    ALBUMARTISTSORT: 'albumartistsort',
	    COMPOSERSORT: 'composersort',
	    LYRICIST: 'lyricist',
	    WRITER: 'writer',
	    CONDUCTOR: 'conductor',
	    // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
	    REMIXER: 'remixer',
	    ARRANGER: 'arranger',
	    ENGINEER: 'engineer',
	    PRODUCER: 'producer',
	    DJMIXER: 'djmixer',
	    MIXER: 'mixer',
	    LABEL: 'label',
	    GROUPING: 'grouping',
	    SUBTITLE: 'subtitle',
	    DISCSUBTITLE: 'discsubtitle',
	    TRACKTOTAL: 'totaltracks',
	    DISCTOTAL: 'totaldiscs',
	    COMPILATION: 'compilation',
	    RATING: 'rating',
	    BPM: 'bpm',
	    KEY: 'key',
	    MOOD: 'mood',
	    MEDIA: 'media',
	    CATALOGNUMBER: 'catalognumber',
	    RELEASESTATUS: 'releasestatus',
	    RELEASETYPE: 'releasetype',
	    RELEASECOUNTRY: 'releasecountry',
	    SCRIPT: 'script',
	    LANGUAGE: 'language',
	    COPYRIGHT: 'copyright',
	    LICENSE: 'license',
	    ENCODEDBY: 'encodedby',
	    ENCODERSETTINGS: 'encodersettings',
	    BARCODE: 'barcode',
	    ISRC: 'isrc',
	    ASIN: 'asin',
	    MUSICBRAINZ_TRACKID: 'musicbrainz_recordingid',
	    MUSICBRAINZ_RELEASETRACKID: 'musicbrainz_trackid',
	    MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',
	    MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',
	    MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',
	    MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',
	    MUSICBRAINZ_WORKID: 'musicbrainz_workid',
	    MUSICBRAINZ_TRMID: 'musicbrainz_trmid',
	    MUSICBRAINZ_DISCID: 'musicbrainz_discid',
	    ACOUSTID_ID: 'acoustid_id',
	    ACOUSTID_ID_FINGERPRINT: 'acoustid_fingerprint',
	    MUSICIP_PUID: 'musicip_puid',
	    // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
	    WEBSITE: 'website',
	    NOTES: 'notes',
	    TOTALTRACKS: 'totaltracks',
	    TOTALDISCS: 'totaldiscs',
	    // Discogs
	    DISCOGS_ARTIST_ID: 'discogs_artist_id',
	    DISCOGS_ARTISTS: 'artists',
	    DISCOGS_ARTIST_NAME: 'artists',
	    DISCOGS_ALBUM_ARTISTS: 'albumartist',
	    DISCOGS_CATALOG: 'catalognumber',
	    DISCOGS_COUNTRY: 'releasecountry',
	    DISCOGS_DATE: 'originaldate',
	    DISCOGS_LABEL: 'label',
	    DISCOGS_LABEL_ID: 'discogs_label_id',
	    DISCOGS_MASTER_RELEASE_ID: 'discogs_master_release_id',
	    DISCOGS_RATING: 'discogs_rating',
	    DISCOGS_RELEASED: 'date',
	    DISCOGS_RELEASE_ID: 'discogs_release_id',
	    DISCOGS_VOTES: 'discogs_votes',
	    CATALOGID: 'catalognumber',
	    STYLE: 'genre',
	    //
	    REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',
	    REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',
	    REPLAYGAIN_ALBUM_GAIN: 'replaygain_album_gain',
	    REPLAYGAIN_ALBUM_PEAK: 'replaygain_album_peak',
	    // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
	    REPLAYGAIN_MINMAX: 'replaygain_track_minmax',
	    REPLAYGAIN_ALBUM_MINMAX: 'replaygain_album_minmax',
	    REPLAYGAIN_UNDO: 'replaygain_undo'
	};
	class VorbisTagMapper extends CommonTagMapper {
	    static toRating(email, rating, maxScore) {
	        return {
	            source: email ? email.toLowerCase() : undefined,
	            rating: (Number.parseFloat(rating) / maxScore) * CommonTagMapper.maxRatingScore
	        };
	    }
	    constructor() {
	        super(['vorbis'], vorbisTagMap);
	    }
	    postMap(tag) {
	        if (tag.id === 'RATING') {
	            // The way Winamp 5.666 assigns rating
	            tag.value = VorbisTagMapper.toRating(undefined, tag.value, 100);
	        }
	        else if (tag.id.indexOf('RATING:') === 0) {
	            const keys = tag.id.split(':');
	            tag.value = VorbisTagMapper.toRating(keys[1], tag.value, 1);
	            tag.id = keys[0];
	        }
	    }
	}

	/**
	 * RIFF Info Tags; part of the EXIF 2.3
	 * Ref: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html#Info
	 */
	const riffInfoTagMap = {
	    IART: 'artist', // Artist
	    ICRD: 'date', // DateCreated
	    INAM: 'title', // Title
	    TITL: 'title',
	    IPRD: 'album', // Product
	    ITRK: 'track',
	    IPRT: 'track', // Additional tag for track index
	    COMM: 'comment', // Comments
	    ICMT: 'comment', // Country
	    ICNT: 'releasecountry',
	    GNRE: 'genre', // Genre
	    IWRI: 'writer', // WrittenBy
	    RATE: 'rating',
	    YEAR: 'year',
	    ISFT: 'encodedby', // Software
	    CODE: 'encodedby', // EncodedBy
	    TURL: 'website', // URL,
	    IGNR: 'genre', // Genre
	    IENG: 'engineer', // Engineer
	    ITCH: 'technician', // Technician
	    IMED: 'media', // Original Media
	    IRPD: 'album' // Product, where the file was intended for
	};
	class RiffInfoTagMapper extends CommonTagMapper {
	    constructor() {
	        super(['exif'], riffInfoTagMap);
	    }
	}

	/**
	 * EBML Tag map
	 */
	const ebmlTagMap = {
	    'segment:title': 'title',
	    'album:ARTIST': 'albumartist',
	    'album:ARTISTSORT': 'albumartistsort',
	    'album:TITLE': 'album',
	    'album:DATE_RECORDED': 'originaldate',
	    'album:DATE_RELEASED': 'releasedate',
	    'album:PART_NUMBER': 'disk',
	    'album:TOTAL_PARTS': 'totaltracks',
	    'track:ARTIST': 'artist',
	    'track:ARTISTSORT': 'artistsort',
	    'track:TITLE': 'title',
	    'track:PART_NUMBER': 'track',
	    'track:MUSICBRAINZ_TRACKID': 'musicbrainz_recordingid',
	    'track:MUSICBRAINZ_ALBUMID': 'musicbrainz_albumid',
	    'track:MUSICBRAINZ_ARTISTID': 'musicbrainz_artistid',
	    'track:PUBLISHER': 'label',
	    'track:GENRE': 'genre',
	    'track:ENCODER': 'encodedby',
	    'track:ENCODER_OPTIONS': 'encodersettings',
	    'edition:TOTAL_PARTS': 'totaldiscs',
	    picture: 'picture'
	};
	class MatroskaTagMapper extends CaseInsensitiveTagMap {
	    constructor() {
	        super(['matroska'], ebmlTagMap);
	    }
	}

	/**
	 * ID3v1 tag mappings
	 */
	const tagMap = {
	    NAME: 'title',
	    AUTH: 'artist',
	    '(c) ': 'copyright',
	    ANNO: 'comment'
	};
	class AiffTagMapper extends CommonTagMapper {
	    constructor() {
	        super(['AIFF'], tagMap);
	    }
	}

	class CombinedTagMapper {
	    constructor() {
	        this.tagMappers = {};
	        [
	            new ID3v1TagMapper(),
	            new ID3v22TagMapper(),
	            new ID3v24TagMapper(),
	            new MP4TagMapper(),
	            new MP4TagMapper(),
	            new VorbisTagMapper(),
	            new APEv2TagMapper(),
	            new AsfTagMapper(),
	            new RiffInfoTagMapper(),
	            new MatroskaTagMapper(),
	            new AiffTagMapper()
	        ].forEach(mapper => {
	            this.registerTagMapper(mapper);
	        });
	    }
	    /**
	     * Convert native to generic (common) tags
	     * @param tagType Originating tag format
	     * @param tag     Native tag to map to a generic tag id
	     * @param warnings
	     * @return Generic tag result (output of this function)
	     */
	    mapTag(tagType, tag, warnings) {
	        const tagMapper = this.tagMappers[tagType];
	        if (tagMapper) {
	            return this.tagMappers[tagType].mapGenericTag(tag, warnings);
	        }
	        throw new InternalParserError(`No generic tag mapper defined for tag-format: ${tagType}`);
	    }
	    registerTagMapper(genericTagMapper) {
	        for (const tagType of genericTagMapper.tagTypes) {
	            this.tagMappers[tagType] = genericTagMapper;
	        }
	    }
	}

	/**
	 * Parse LRC (Lyrics) formatted text
	 * Ref: https://en.wikipedia.org/wiki/LRC_(file_format)
	 * @param lrcString
	 */
	function parseLrc(lrcString) {
	    const lines = lrcString.split('\n');
	    const syncText = [];
	    // Regular expression to match LRC timestamps (e.g., [00:45.52] or [00:45.520])
	    const timestampRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
	    for (const line of lines) {
	        const match = line.match(timestampRegex);
	        if (match) {
	            const minutes = Number.parseInt(match[1], 10);
	            const seconds = Number.parseInt(match[2], 10);
	            const millisecondsStr = match[3];
	            let milliseconds;
	            if (millisecondsStr.length === 3) {
	                //  (e.g., .521 = 521 millseconds)
	                milliseconds = Number.parseInt(millisecondsStr, 10);
	            }
	            else {
	                //  (e.g., .52 = 520 millseconds)
	                milliseconds = Number.parseInt(millisecondsStr, 10) * 10;
	            }
	            // Convert the timestamp to milliseconds, as per TimestampFormat.milliseconds
	            const timestamp = (minutes * 60 + seconds) * 1000 + milliseconds;
	            // Get the text portion of the line (e.g., "あの蝶は自由になれたかな")
	            const text = line.replace(timestampRegex, '').trim();
	            syncText.push({ timestamp, text });
	        }
	    }
	    // Creating the ILyricsTag object
	    return {
	        contentType: LyricsContentType.lyrics,
	        timeStampFormat: TimestampFormat.milliseconds,
	        syncText,
	    };
	}

	const debug$r = initDebug('music-metadata:collector');
	const TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'AIFF', 'ID3v1'];
	/**
	 * Provided to the parser to uodate the metadata result.
	 * Responsible for triggering async updates
	 */
	class MetadataCollector {
	    constructor(opts) {
	        this.format = {
	            tagTypes: [],
	            trackInfo: []
	        };
	        this.native = {};
	        this.common = {
	            track: { no: null, of: null },
	            disk: { no: null, of: null },
	            movementIndex: { no: null, of: null }
	        };
	        this.quality = {
	            warnings: []
	        };
	        /**
	         * Keeps track of origin priority for each mapped id
	         */
	        this.commonOrigin = {};
	        /**
	         * Maps a tag type to a priority
	         */
	        this.originPriority = {};
	        this.tagMapper = new CombinedTagMapper();
	        this.opts = opts;
	        let priority = 1;
	        for (const tagType of TagPriority) {
	            this.originPriority[tagType] = priority++;
	        }
	        this.originPriority.artificial = 500; // Filled using alternative tags
	        this.originPriority.id3v1 = 600; // Consider as the worst because of the field length limit
	    }
	    /**
	     * @returns {boolean} true if one or more tags have been found
	     */
	    hasAny() {
	        return Object.keys(this.native).length > 0;
	    }
	    addStreamInfo(streamInfo) {
	        debug$r(`streamInfo: type=${streamInfo.type ? TrackTypeValueToKeyMap[streamInfo.type] : '?'}, codec=${streamInfo.codecName}`);
	        this.format.trackInfo.push(streamInfo);
	    }
	    setFormat(key, value) {
	        debug$r(`format: ${key} = ${value}`);
	        this.format[key] = value; // as any to override readonly
	        if (this.opts?.observer) {
	            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });
	        }
	    }
	    setAudioOnly() {
	        this.setFormat('hasAudio', true);
	        this.setFormat('hasVideo', false);
	    }
	    async addTag(tagType, tagId, value) {
	        debug$r(`tag ${tagType}.${tagId} = ${value}`);
	        if (!this.native[tagType]) {
	            this.format.tagTypes.push(tagType);
	            this.native[tagType] = [];
	        }
	        this.native[tagType].push({ id: tagId, value });
	        await this.toCommon(tagType, tagId, value);
	    }
	    addWarning(warning) {
	        this.quality.warnings.push({ message: warning });
	    }
	    async postMap(tagType, tag) {
	        // Common tag (alias) found
	        // check if we need to do something special with common tag
	        // if the event has been aliased then we need to clean it before
	        // it is emitted to the user. e.g. genre (20) -> Electronic
	        switch (tag.id) {
	            case 'artist':
	                if (this.commonOrigin.artist === this.originPriority[tagType]) {
	                    // Assume the artist field is used as artists
	                    return this.postMap('artificial', { id: 'artists', value: tag.value });
	                }
	                if (!this.common.artists) {
	                    // Fill artists using artist source
	                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });
	                }
	                break;
	            case 'artists':
	                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
	                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
	                        // Fill artist using artists source
	                        const artists = (this.common.artists || []).concat([tag.value]);
	                        const value = joinArtists(artists);
	                        const artistTag = { id: 'artist', value };
	                        this.setGenericTag('artificial', artistTag);
	                    }
	                }
	                break;
	            case 'picture':
	                return this.postFixPicture(tag.value).then(picture => {
	                    if (picture !== null) {
	                        tag.value = picture;
	                        this.setGenericTag(tagType, tag);
	                    }
	                });
	            case 'totaltracks':
	                this.common.track.of = CommonTagMapper.toIntOrNull(tag.value);
	                return;
	            case 'totaldiscs':
	                this.common.disk.of = CommonTagMapper.toIntOrNull(tag.value);
	                return;
	            case 'movementTotal':
	                this.common.movementIndex.of = CommonTagMapper.toIntOrNull(tag.value);
	                return;
	            case 'track':
	            case 'disk':
	            case 'movementIndex': {
	                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten
	                this.common[tag.id] = CommonTagMapper.normalizeTrack(tag.value);
	                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
	                return;
	            }
	            case 'bpm':
	            case 'year':
	            case 'originalyear':
	                tag.value = Number.parseInt(tag.value, 10);
	                break;
	            case 'date': {
	                // ToDo: be more strict on 'YYYY...'
	                const year = Number.parseInt(tag.value.substr(0, 4), 10);
	                if (!Number.isNaN(year)) {
	                    this.common.year = year;
	                }
	                break;
	            }
	            case 'discogs_label_id':
	            case 'discogs_release_id':
	            case 'discogs_master_release_id':
	            case 'discogs_artist_id':
	            case 'discogs_votes':
	                tag.value = typeof tag.value === 'string' ? Number.parseInt(tag.value, 10) : tag.value;
	                break;
	            case 'replaygain_track_gain':
	            case 'replaygain_track_peak':
	            case 'replaygain_album_gain':
	            case 'replaygain_album_peak':
	                tag.value = toRatio(tag.value);
	                break;
	            case 'replaygain_track_minmax':
	                tag.value = tag.value.split(',').map(v => Number.parseInt(v, 10));
	                break;
	            case 'replaygain_undo': {
	                const minMix = tag.value.split(',').map(v => Number.parseInt(v, 10));
	                tag.value = {
	                    leftChannel: minMix[0],
	                    rightChannel: minMix[1]
	                };
	                break;
	            }
	            case 'gapless': // iTunes gap-less flag
	            case 'compilation':
	            case 'podcast':
	            case 'showMovement':
	                tag.value = tag.value === '1' || tag.value === 1; // boolean
	                break;
	            case 'isrc': { // Only keep unique values
	                const commonTag = this.common[tag.id];
	                if (commonTag && commonTag.indexOf(tag.value) !== -1)
	                    return;
	                break;
	            }
	            case 'comment':
	                if (typeof tag.value === 'string') {
	                    tag.value = { text: tag.value };
	                }
	                if (tag.value.descriptor === 'iTunPGAP') {
	                    this.setGenericTag(tagType, { id: 'gapless', value: tag.value.text === '1' });
	                }
	                break;
	            case 'lyrics':
	                if (typeof tag.value === 'string') {
	                    tag.value = parseLrc(tag.value);
	                }
	                break;
	            // nothing to do
	        }
	        if (tag.value !== null) {
	            this.setGenericTag(tagType, tag);
	        }
	    }
	    /**
	     * Convert native tags to common tags
	     * @returns {IAudioMetadata} Native + common tags
	     */
	    toCommonMetadata() {
	        return {
	            format: this.format,
	            native: this.native,
	            quality: this.quality,
	            common: this.common
	        };
	    }
	    /**
	     * Fix some common issues with picture object
	     * @param picture Picture
	     */
	    async postFixPicture(picture) {
	        if (picture.data && picture.data.length > 0) {
	            if (!picture.format) {
	                const fileType = await fileTypeFromBuffer(Uint8Array.from(picture.data)); // ToDO: remove Buffer
	                if (fileType) {
	                    picture.format = fileType.mime;
	                }
	                else {
	                    return null;
	                }
	            }
	            picture.format = picture.format.toLocaleLowerCase();
	            switch (picture.format) {
	                case 'image/jpg':
	                    picture.format = 'image/jpeg'; // ToDo: register warning
	            }
	            return picture;
	        }
	        this.addWarning("Empty picture tag found");
	        return null;
	    }
	    /**
	     * Convert native tag to common tags
	     */
	    async toCommon(tagType, tagId, value) {
	        const tag = { id: tagId, value };
	        const genericTag = this.tagMapper.mapTag(tagType, tag, this);
	        if (genericTag) {
	            await this.postMap(tagType, genericTag);
	        }
	    }
	    /**
	     * Set generic tag
	     */
	    setGenericTag(tagType, tag) {
	        debug$r(`common.${tag.id} = ${tag.value}`);
	        const prio0 = this.commonOrigin[tag.id] || 1000;
	        const prio1 = this.originPriority[tagType];
	        if (isSingleton(tag.id)) {
	            if (prio1 <= prio0) {
	                this.common[tag.id] = tag.value;
	                this.commonOrigin[tag.id] = prio1;
	            }
	            else {
	                return debug$r(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);
	            }
	        }
	        else {
	            if (prio1 === prio0) {
	                if (!isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
	                    this.common[tag.id].push(tag.value);
	                }
	                else {
	                    debug$r(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);
	                }
	                // no effect? this.commonOrigin[tag.id] = prio1;
	            }
	            else if (prio1 < prio0) {
	                this.common[tag.id] = [tag.value];
	                this.commonOrigin[tag.id] = prio1;
	            }
	            else {
	                return debug$r(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);
	            }
	        }
	        if (this.opts?.observer) {
	            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });
	        }
	        // ToDo: trigger metadata event
	    }
	}
	function joinArtists(artists) {
	    if (artists.length > 2) {
	        return `${artists.slice(0, artists.length - 1).join(', ')} & ${artists[artists.length - 1]}`;
	    }
	    return artists.join(' & ');
	}

	const mpegParserLoader = {
	    parserType: 'mpeg',
	    extensions: ['.mp2', '.mp3', '.m2a', '.aac', 'aacp'],
	    mimeTypes: ['audio/mpeg', 'audio/mp3', 'audio/aacs', 'audio/aacp'],
	    async load() {
	        return (await Promise.resolve().then(function () { return MpegParser$1; })).MpegParser;
	    }
	};

	const apeParserLoader = {
	    parserType: 'apev2',
	    extensions: ['.ape'],
	    mimeTypes: ['audio/ape', 'audio/monkeys-audio'],
	    async load() {
	        return (await Promise.resolve().then(function () { return APEv2Parser$1; })).APEv2Parser;
	    }
	};

	const asfParserLoader = {
	    parserType: 'asf',
	    extensions: ['.asf'],
	    mimeTypes: ['audio/ms-wma', 'video/ms-wmv', 'audio/ms-asf', 'video/ms-asf', 'application/vnd.ms-asf'],
	    async load() {
	        return (await Promise.resolve().then(function () { return AsfParser$1; })).AsfParser;
	    }
	};

	const dsdiffParserLoader = {
	    parserType: 'dsdiff',
	    extensions: ['.dff'],
	    mimeTypes: ['audio/dsf', 'audio/dsd'],
	    async load() {
	        return (await Promise.resolve().then(function () { return DsdiffParser$1; })).DsdiffParser;
	    }
	};

	const aiffParserLoader = {
	    parserType: 'aiff',
	    extensions: ['.aif', 'aiff', 'aifc'],
	    mimeTypes: ['audio/aiff', 'audio/aif', 'audio/aifc', 'application/aiff'],
	    async load() {
	        return (await Promise.resolve().then(function () { return AiffParser; })).AIFFParser;
	    }
	};

	const dsfParserLoader = {
	    parserType: 'dsf',
	    extensions: ['.dsf'],
	    mimeTypes: ['audio/dsf'],
	    async load() {
	        return (await Promise.resolve().then(function () { return DsfParser$1; })).DsfParser;
	    }
	};

	const flacParserLoader = {
	    parserType: 'flac',
	    extensions: ['.flac'],
	    mimeTypes: ['audio/flac'],
	    async load() {
	        return (await Promise.resolve().then(function () { return FlacParser$1; })).FlacParser;
	    }
	};

	const matroskaParserLoader = {
	    parserType: 'matroska',
	    extensions: ['.mka', '.mkv', '.mk3d', '.mks', 'webm'],
	    mimeTypes: ['audio/matroska', 'video/matroska', 'audio/webm', 'video/webm'],
	    async load() {
	        return (await Promise.resolve().then(function () { return MatroskaParser$1; })).MatroskaParser;
	    }
	};

	const mp4ParserLoader = {
	    parserType: 'mp4',
	    extensions: ['.mp4', '.m4a', '.m4b', '.m4pa', 'm4v', 'm4r', '3gp'],
	    mimeTypes: ['audio/mp4', 'audio/m4a', 'video/m4v', 'video/mp4'],
	    async load() {
	        return (await Promise.resolve().then(function () { return MP4Parser$1; })).MP4Parser;
	    }
	};

	const musepackParserLoader = {
	    parserType: 'musepack',
	    extensions: ['.mpc'],
	    mimeTypes: ['audio/musepack'],
	    async load() {
	        return (await Promise.resolve().then(function () { return MusepackParser$1; })).MusepackParser;
	    }
	};

	const oggParserLoader = {
	    parserType: 'ogg',
	    extensions: ['.ogg', '.ogv', '.oga', '.ogm', '.ogx', '.opus', '.spx'],
	    mimeTypes: ['audio/ogg', 'audio/opus', 'audio/speex', 'video/ogg'], // RFC 7845, RFC 6716, RFC 5574
	    async load() {
	        return (await Promise.resolve().then(function () { return OggParser$1; })).OggParser;
	    }
	};

	const wavpackParserLoader = {
	    parserType: 'wavpack',
	    extensions: ['.wv', '.wvp'],
	    mimeTypes: ['audio/wavpack'],
	    async load() {
	        return (await Promise.resolve().then(function () { return WavPackParser$1; })).WavPackParser;
	    }
	};

	const riffParserLoader = {
	    parserType: 'riff',
	    extensions: ['.wav', 'wave', '.bwf'],
	    mimeTypes: ['audio/vnd.wave', 'audio/wav', 'audio/wave'],
	    async load() {
	        return (await Promise.resolve().then(function () { return WaveParser$1; })).WaveParser;
	    }
	};

	const debug$q = initDebug('music-metadata:parser:factory');
	function parseHttpContentType(contentType$1) {
	    const type = contentType.parse(contentType$1);
	    const mime = parse_1(type.type);
	    return {
	        type: mime.type,
	        subtype: mime.subtype,
	        suffix: mime.suffix,
	        parameters: type.parameters
	    };
	}
	class ParserFactory {
	    constructor() {
	        this.parsers = [];
	        [
	            flacParserLoader,
	            mpegParserLoader,
	            apeParserLoader,
	            mp4ParserLoader,
	            matroskaParserLoader,
	            riffParserLoader,
	            oggParserLoader,
	            asfParserLoader,
	            aiffParserLoader,
	            wavpackParserLoader,
	            musepackParserLoader,
	            dsfParserLoader,
	            dsdiffParserLoader
	        ].forEach(parser => this.registerParser(parser));
	    }
	    registerParser(parser) {
	        this.parsers.push(parser);
	    }
	    async parse(tokenizer, parserLoader, opts) {
	        if (tokenizer.supportsRandomAccess()) {
	            debug$q('tokenizer supports random-access, scanning for appending headers');
	            await scanAppendingHeaders(tokenizer, opts);
	        }
	        else {
	            debug$q('tokenizer does not support random-access, cannot scan for appending headers');
	        }
	        if (!parserLoader) {
	            const buf = new Uint8Array(4100);
	            if (tokenizer.fileInfo.mimeType) {
	                parserLoader = this.findLoaderForContentType(tokenizer.fileInfo.mimeType);
	            }
	            if (!parserLoader && tokenizer.fileInfo.path) {
	                parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);
	            }
	            if (!parserLoader) {
	                // Parser could not be determined on MIME-type or extension
	                debug$q('Guess parser on content...');
	                await tokenizer.peekBuffer(buf, { mayBeLess: true });
	                const guessedType = await fileTypeFromBuffer(buf, { mpegOffsetTolerance: 10 });
	                if (!guessedType || !guessedType.mime) {
	                    throw new CouldNotDetermineFileTypeError('Failed to determine audio format');
	                }
	                debug$q(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
	                parserLoader = this.findLoaderForContentType(guessedType.mime);
	                if (!parserLoader) {
	                    throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);
	                }
	            }
	        }
	        // Parser found, execute parser
	        debug$q(`Loading ${parserLoader.parserType} parser...`);
	        const metadata = new MetadataCollector(opts);
	        const ParserImpl = await parserLoader.load();
	        const parser = new ParserImpl(metadata, tokenizer, opts ?? {});
	        debug$q(`Parser ${parserLoader.parserType} loaded`);
	        await parser.parse();
	        if (metadata.format.trackInfo) {
	            if (metadata.format.hasAudio === undefined) {
	                metadata.setFormat('hasAudio', !!metadata.format.trackInfo.find(track => track.type === TrackType.audio));
	            }
	            if (metadata.format.hasVideo === undefined) {
	                metadata.setFormat('hasVideo', !!metadata.format.trackInfo.find(track => track.type === TrackType.video));
	            }
	        }
	        return metadata.toCommonMetadata();
	    }
	    /**
	     * @param filePath - Path, filename or extension to audio file
	     * @return Parser submodule name
	     */
	    findLoaderForExtension(filePath) {
	        if (!filePath)
	            return;
	        const extension = getExtension(filePath).toLocaleLowerCase() || filePath;
	        return this.parsers.find(parser => parser.extensions.indexOf(extension) !== -1);
	    }
	    findLoaderForContentType(httpContentType) {
	        let mime;
	        if (!httpContentType)
	            return;
	        try {
	            mime = parseHttpContentType(httpContentType);
	        }
	        catch (_err) {
	            debug$q(`Invalid HTTP Content-Type header value: ${httpContentType}`);
	            return;
	        }
	        const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;
	        return this.parsers.find(parser => parser.mimeTypes.find(loader => loader.indexOf(`${mime.type}/${subType}`) !== -1));
	    }
	    getSupportedMimeTypes() {
	        const mimeTypeSet = new Set();
	        this.parsers.forEach(loader => {
	            loader.mimeTypes.forEach(mimeType => {
	                mimeTypeSet.add(mimeType);
	                mimeTypeSet.add(mimeType.replace('/', '/x-'));
	            });
	        });
	        return Array.from(mimeTypeSet);
	    }
	}
	function getExtension(fname) {
	    const i = fname.lastIndexOf('.');
	    return i === -1 ? '' : fname.slice(i);
	}

	class BasicParser {
	    /**
	     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
	     * @param {INativeMetadataCollector} metadata Output
	     * @param {ITokenizer} tokenizer Input
	     * @param {IOptions} options Parsing options
	     */
	    constructor(metadata, tokenizer, options) {
	        this.metadata = metadata;
	        this.tokenizer = tokenizer;
	        this.options = options;
	    }
	}

	const validFourCC = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
	/**
	 * Token for read FourCC
	 * Ref: https://en.wikipedia.org/wiki/FourCC
	 */
	const FourCcToken = {
	    len: 4,
	    get: (buf, off) => {
	        const id = uint8ArrayToString(buf.slice(off, off + FourCcToken.len), 'latin1');
	        if (!id.match(validFourCC)) {
	            throw new FieldDecodingError(`FourCC contains invalid characters: ${a2hex(id)} "${id}"`);
	        }
	        return id;
	    },
	    put: (buffer, offset, id) => {
	        const str = stringToUint8Array(id);
	        if (str.length !== 4)
	            throw new InternalParserError('Invalid length');
	        buffer.set(str, offset);
	        return offset + 4;
	    }
	};

	const DataType$1 = {
	    text_utf8: 0,
	    binary: 1,
	    external_info: 2,
	    reserved: 3
	};
	/**
	 * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum
	 */
	const DescriptorParser = {
	    len: 52,
	    get: (buf, off) => {
	        return {
	            // should equal 'MAC '
	            ID: FourCcToken.get(buf, off),
	            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
	            version: UINT32_LE.get(buf, off + 4) / 1000,
	            // the number of descriptor bytes (allows later expansion of this header)
	            descriptorBytes: UINT32_LE.get(buf, off + 8),
	            // the number of header APE_HEADER bytes
	            headerBytes: UINT32_LE.get(buf, off + 12),
	            // the number of header APE_HEADER bytes
	            seekTableBytes: UINT32_LE.get(buf, off + 16),
	            // the number of header data bytes (from original file)
	            headerDataBytes: UINT32_LE.get(buf, off + 20),
	            // the number of bytes of APE frame data
	            apeFrameDataBytes: UINT32_LE.get(buf, off + 24),
	            // the high order number of APE frame data bytes
	            apeFrameDataBytesHigh: UINT32_LE.get(buf, off + 28),
	            // the terminating data of the file (not including tag data)
	            terminatingDataBytes: UINT32_LE.get(buf, off + 32),
	            // the MD5 hash of the file (see notes for usage... it's a little tricky)
	            fileMD5: new Uint8ArrayType(16).get(buf, off + 36)
	        };
	    }
	};
	/**
	 * APE_HEADER: describes all of the necessary information about the APE file
	 */
	const Header$5 = {
	    len: 24,
	    get: (buf, off) => {
	        return {
	            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
	            compressionLevel: UINT16_LE.get(buf, off),
	            // any format flags (for future use)
	            formatFlags: UINT16_LE.get(buf, off + 2),
	            // the number of audio blocks in one frame
	            blocksPerFrame: UINT32_LE.get(buf, off + 4),
	            // the number of audio blocks in the final frame
	            finalFrameBlocks: UINT32_LE.get(buf, off + 8),
	            // the total number of frames
	            totalFrames: UINT32_LE.get(buf, off + 12),
	            // the bits per sample (typically 16)
	            bitsPerSample: UINT16_LE.get(buf, off + 16),
	            // the number of channels (1 or 2)
	            channel: UINT16_LE.get(buf, off + 18),
	            // the sample rate (typically 44100)
	            sampleRate: UINT32_LE.get(buf, off + 20)
	        };
	    }
	};
	/**
	 * APE Tag Header/Footer Version 2.0
	 * TAG: describes all the properties of the file [optional]
	 */
	const TagFooter = {
	    len: 32,
	    get: (buf, off) => {
	        return {
	            // should equal 'APETAGEX'
	            ID: new StringType(8, 'ascii').get(buf, off),
	            // equals CURRENT_APE_TAG_VERSION
	            version: UINT32_LE.get(buf, off + 8),
	            // the complete size of the tag, including this footer (excludes header)
	            size: UINT32_LE.get(buf, off + 12),
	            // the number of fields in the tag
	            fields: UINT32_LE.get(buf, off + 16),
	            // reserved for later use (must be zero),
	            flags: parseTagFlags(UINT32_LE.get(buf, off + 20))
	        };
	    }
	};
	/**
	 * APE Tag v2.0 Item Header
	 */
	const TagItemHeader = {
	    len: 8,
	    get: (buf, off) => {
	        return {
	            // Length of assigned value in bytes
	            size: UINT32_LE.get(buf, off),
	            // reserved for later use (must be zero),
	            flags: parseTagFlags(UINT32_LE.get(buf, off + 4))
	        };
	    }
	};
	function parseTagFlags(flags) {
	    return {
	        containsHeader: isBitSet$1(flags, 31),
	        containsFooter: isBitSet$1(flags, 30),
	        isHeader: isBitSet$1(flags, 29),
	        readOnly: isBitSet$1(flags, 0),
	        dataType: (flags & 6) >> 1
	    };
	}
	/**
	 * @param num {number}
	 * @param bit 0 is least significant bit (LSB)
	 * @return {boolean} true if bit is 1; otherwise false
	 */
	function isBitSet$1(num, bit) {
	    return (num & 1 << bit) !== 0;
	}

	const debug$p = initDebug('music-metadata:parser:APEv2');
	const tagFormat$1 = 'APEv2';
	const preamble = 'APETAGEX';
	class ApeContentError extends makeUnexpectedFileContentError('APEv2') {
	}
	function tryParseApeHeader(metadata, tokenizer, options) {
	    const apeParser = new APEv2Parser(metadata, tokenizer, options);
	    return apeParser.tryParseApeHeader();
	}
	class APEv2Parser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.ape = {};
	    }
	    /**
	     * Calculate the media file duration
	     * @param ah ApeHeader
	     * @return {number} duration in seconds
	     */
	    static calculateDuration(ah) {
	        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
	        duration += ah.finalFrameBlocks;
	        return duration / ah.sampleRate;
	    }
	    /**
	     * Calculates the APEv1 / APEv2 first field offset
	     * @param tokenizer
	     * @param offset
	     */
	    static async findApeFooterOffset(tokenizer, offset) {
	        // Search for APE footer header at the end of the file
	        const apeBuf = new Uint8Array(TagFooter.len);
	        const position = tokenizer.position;
	        if (offset <= TagFooter.len) {
	            debug$p(`Offset is too small to read APE footer: offset=${offset}`);
	            return undefined;
	        }
	        if (offset > TagFooter.len) {
	            await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });
	            tokenizer.setPosition(position);
	            const tagFooter = TagFooter.get(apeBuf, 0);
	            if (tagFooter.ID === 'APETAGEX') {
	                if (tagFooter.flags.isHeader) {
	                    debug$p(`APE Header found at offset=${offset - TagFooter.len}`);
	                }
	                else {
	                    debug$p(`APE Footer found at offset=${offset - TagFooter.len}`);
	                    offset -= tagFooter.size;
	                }
	                return { footer: tagFooter, offset };
	            }
	        }
	    }
	    static parseTagFooter(metadata, buffer, options) {
	        const footer = TagFooter.get(buffer, buffer.length - TagFooter.len);
	        if (footer.ID !== preamble)
	            throw new ApeContentError('Unexpected APEv2 Footer ID preamble value');
	        fromBuffer(buffer);
	        const apeParser = new APEv2Parser(metadata, fromBuffer(buffer), options);
	        return apeParser.parseTags(footer);
	    }
	    /**
	     * Parse APEv1 / APEv2 header if header signature found
	     */
	    async tryParseApeHeader() {
	        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {
	            debug$p("No APEv2 header found, end-of-file reached");
	            return;
	        }
	        const footer = await this.tokenizer.peekToken(TagFooter);
	        if (footer.ID === preamble) {
	            await this.tokenizer.ignore(TagFooter.len);
	            return this.parseTags(footer);
	        }
	        debug$p(`APEv2 header not found at offset=${this.tokenizer.position}`);
	        if (this.tokenizer.fileInfo.size) {
	            // Try to read the APEv2 header using just the footer-header
	            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account
	            const buffer = new Uint8Array(remaining);
	            await this.tokenizer.readBuffer(buffer);
	            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
	        }
	    }
	    async parse() {
	        const descriptor = await this.tokenizer.readToken(DescriptorParser);
	        if (descriptor.ID !== 'MAC ')
	            throw new ApeContentError('Unexpected descriptor ID');
	        this.ape.descriptor = descriptor;
	        const lenExp = descriptor.descriptorBytes - DescriptorParser.len;
	        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
	        this.metadata.setAudioOnly();
	        await this.tokenizer.ignore(header.forwardBytes);
	        return this.tryParseApeHeader();
	    }
	    async parseTags(footer) {
	        const keyBuffer = new Uint8Array(256); // maximum tag key length
	        let bytesRemaining = footer.size - TagFooter.len;
	        debug$p(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
	        for (let i = 0; i < footer.fields; i++) {
	            if (bytesRemaining < TagItemHeader.len) {
	                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);
	                break;
	            }
	            // Only APEv2 tag has tag item headers
	            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);
	            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;
	            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
	            let zero = findZero(keyBuffer, 0, keyBuffer.length);
	            const key = await this.tokenizer.readToken(new StringType(zero, 'ascii'));
	            await this.tokenizer.ignore(1);
	            bytesRemaining -= key.length + 1;
	            switch (tagItemHeader.flags.dataType) {
	                case DataType$1.text_utf8: { // utf-8 text-string
	                    const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, 'utf8'));
	                    const values = value.split(/\x00/g);
	                    await Promise.all(values.map(val => this.metadata.addTag(tagFormat$1, key, val)));
	                    break;
	                }
	                case DataType$1.binary: // binary (probably artwork)
	                    if (this.options.skipCovers) {
	                        await this.tokenizer.ignore(tagItemHeader.size);
	                    }
	                    else {
	                        const picData = new Uint8Array(tagItemHeader.size);
	                        await this.tokenizer.readBuffer(picData);
	                        zero = findZero(picData, 0, picData.length);
	                        const description = uint8ArrayToString(picData.slice(0, zero));
	                        const data = picData.slice(zero + 1);
	                        await this.metadata.addTag(tagFormat$1, key, {
	                            description,
	                            data
	                        });
	                    }
	                    break;
	                case DataType$1.external_info:
	                    debug$p(`Ignore external info ${key}`);
	                    await this.tokenizer.ignore(tagItemHeader.size);
	                    break;
	                case DataType$1.reserved:
	                    debug$p(`Ignore external info ${key}`);
	                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`);
	                    await this.tokenizer.ignore(tagItemHeader.size);
	                    break;
	            }
	        }
	    }
	    async parseDescriptorExpansion(lenExp) {
	        await this.tokenizer.ignore(lenExp);
	        return this.parseHeader();
	    }
	    async parseHeader() {
	        const header = await this.tokenizer.readToken(Header$5);
	        // ToDo before
	        this.metadata.setFormat('lossless', true);
	        this.metadata.setFormat('container', 'Monkey\'s Audio');
	        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);
	        this.metadata.setFormat('sampleRate', header.sampleRate);
	        this.metadata.setFormat('numberOfChannels', header.channel);
	        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));
	        if (!this.ape.descriptor) {
	            throw new ApeContentError('Missing APE descriptor');
	        }
	        return {
	            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +
	                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
	        };
	    }
	}

	var APEv2Parser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		APEv2Parser: APEv2Parser,
		ApeContentError: ApeContentError,
		tryParseApeHeader: tryParseApeHeader
	});

	const debug$o = initDebug('music-metadata:parser:ID3v1');
	/**
	 * ID3v1 Genre mappings
	 * Ref: https://de.wikipedia.org/wiki/Liste_der_ID3v1-Genres
	 */
	const Genres = [
	    'Blues', 'Classic Rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge', 'Hip-Hop',
	    'Jazz', 'Metal', 'New Age', 'Oldies', 'Other', 'Pop', 'R&B', 'Rap', 'Reggae', 'Rock',
	    'Techno', 'Industrial', 'Alternative', 'Ska', 'Death Metal', 'Pranks', 'Soundtrack',
	    'Euro-Techno', 'Ambient', 'Trip-Hop', 'Vocal', 'Jazz+Funk', 'Fusion', 'Trance',
	    'Classical', 'Instrumental', 'Acid', 'House', 'Game', 'Sound Clip', 'Gospel', 'Noise',
	    'Alt. Rock', 'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental Pop',
	    'Instrumental Rock', 'Ethnic', 'Gothic', 'Darkwave', 'Techno-Industrial',
	    'Electronic', 'Pop-Folk', 'Eurodance', 'Dream', 'Southern Rock', 'Comedy', 'Cult',
	    'Gangsta Rap', 'Top 40', 'Christian Rap', 'Pop/Funk', 'Jungle', 'Native American',
	    'Cabaret', 'New Wave', 'Psychedelic', 'Rave', 'Showtunes', 'Trailer', 'Lo-Fi', 'Tribal',
	    'Acid Punk', 'Acid Jazz', 'Polka', 'Retro', 'Musical', 'Rock & Roll', 'Hard Rock',
	    'Folk', 'Folk/Rock', 'National Folk', 'Swing', 'Fast-Fusion', 'Bebob', 'Latin', 'Revival',
	    'Celtic', 'Bluegrass', 'Avantgarde', 'Gothic Rock', 'Progressive Rock', 'Psychedelic Rock',
	    'Symphonic Rock', 'Slow Rock', 'Big Band', 'Chorus', 'Easy Listening', 'Acoustic', 'Humour',
	    'Speech', 'Chanson', 'Opera', 'Chamber Music', 'Sonata', 'Symphony', 'Booty Bass', 'Primus',
	    'Porn Groove', 'Satire', 'Slow Jam', 'Club', 'Tango', 'Samba', 'Folklore',
	    'Ballad', 'Power Ballad', 'Rhythmic Soul', 'Freestyle', 'Duet', 'Punk Rock', 'Drum Solo',
	    'A Cappella', 'Euro-House', 'Dance Hall', 'Goa', 'Drum & Bass', 'Club-House',
	    'Hardcore', 'Terror', 'Indie', 'BritPop', 'Negerpunk', 'Polsk Punk', 'Beat',
	    'Christian Gangsta Rap', 'Heavy Metal', 'Black Metal', 'Crossover', 'Contemporary Christian',
	    'Christian Rock', 'Merengue', 'Salsa', 'Thrash Metal', 'Anime', 'JPop', 'Synthpop',
	    'Abstract', 'Art Rock', 'Baroque', 'Bhangra', 'Big Beat', 'Breakbeat', 'Chillout',
	    'Downtempo', 'Dub', 'EBM', 'Eclectic', 'Electro', 'Electroclash', 'Emo', 'Experimental',
	    'Garage', 'Global', 'IDM', 'Illbient', 'Industro-Goth', 'Jam Band', 'Krautrock',
	    'Leftfield', 'Lounge', 'Math Rock', 'New Romantic', 'Nu-Breakz', 'Post-Punk', 'Post-Rock',
	    'Psytrance', 'Shoegaze', 'Space Rock', 'Trop Rock', 'World Music', 'Neoclassical', 'Audiobook',
	    'Audio Theatre', 'Neue Deutsche Welle', 'Podcast', 'Indie Rock', 'G-Funk', 'Dubstep',
	    'Garage Rock', 'Psybient'
	];
	/**
	 * Spec: http://id3.org/ID3v1
	 * Wiki: https://en.wikipedia.org/wiki/ID3
	 */
	const Iid3v1Token = {
	    len: 128,
	    /**
	     * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
	     * @param off Offset in buffer in bytes
	     * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
	     */
	    get: (buf, off) => {
	        const header = new Id3v1StringType(3).get(buf, off);
	        return header === 'TAG' ? {
	            header,
	            title: new Id3v1StringType(30).get(buf, off + 3),
	            artist: new Id3v1StringType(30).get(buf, off + 33),
	            album: new Id3v1StringType(30).get(buf, off + 63),
	            year: new Id3v1StringType(4).get(buf, off + 93),
	            comment: new Id3v1StringType(28).get(buf, off + 97),
	            // ID3v1.1 separator for track
	            zeroByte: UINT8.get(buf, off + 127),
	            // track: ID3v1.1 field added by Michael Mutschler
	            track: UINT8.get(buf, off + 126),
	            genre: UINT8.get(buf, off + 127)
	        } : null;
	    }
	};
	class Id3v1StringType {
	    constructor(len) {
	        this.len = len;
	        this.stringType = new StringType(len, 'latin1');
	    }
	    get(buf, off) {
	        let value = this.stringType.get(buf, off);
	        value = trimRightNull(value);
	        value = value.trim();
	        return value.length > 0 ? value : undefined;
	    }
	}
	class ID3v1Parser extends BasicParser {
	    constructor(metadata, tokenizer, options) {
	        super(metadata, tokenizer, options);
	        this.apeHeader = options.apeHeader;
	    }
	    static getGenre(genreIndex) {
	        if (genreIndex < Genres.length) {
	            return Genres[genreIndex];
	        }
	        return undefined; // ToDO: generate warning
	    }
	    async parse() {
	        if (!this.tokenizer.fileInfo.size) {
	            debug$o('Skip checking for ID3v1 because the file-size is unknown');
	            return;
	        }
	        if (this.apeHeader) {
	            this.tokenizer.ignore(this.apeHeader.offset - this.tokenizer.position);
	            const apeParser = new APEv2Parser(this.metadata, this.tokenizer, this.options);
	            await apeParser.parseTags(this.apeHeader.footer);
	        }
	        const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
	        if (this.tokenizer.position > offset) {
	            debug$o('Already consumed the last 128 bytes');
	            return;
	        }
	        const header = await this.tokenizer.readToken(Iid3v1Token, offset);
	        if (header) {
	            debug$o('ID3v1 header found at: pos=%s', this.tokenizer.fileInfo.size - Iid3v1Token.len);
	            const props = ['title', 'artist', 'album', 'comment', 'track', 'year'];
	            for (const id of props) {
	                if (header[id] && header[id] !== '')
	                    await this.addTag(id, header[id]);
	            }
	            const genre = ID3v1Parser.getGenre(header.genre);
	            if (genre)
	                await this.addTag('genre', genre);
	        }
	        else {
	            debug$o('ID3v1 header not found at: pos=%s', this.tokenizer.fileInfo.size - Iid3v1Token.len);
	        }
	    }
	    async addTag(id, value) {
	        await this.metadata.addTag('ID3v1', id, value);
	    }
	}
	async function hasID3v1Header(tokenizer) {
	    if (tokenizer.fileInfo.size >= 128) {
	        const tag = new Uint8Array(3);
	        const position = tokenizer.position;
	        await tokenizer.readBuffer(tag, { position: tokenizer.fileInfo.size - 128 });
	        tokenizer.setPosition(position); // Restore tokenizer position
	        return new TextDecoder('latin1').decode(tag) === 'TAG';
	    }
	    return false;
	}

	const endTag2 = 'LYRICS200';
	async function getLyricsHeaderLength(tokenizer) {
	    const fileSize = tokenizer.fileInfo.size;
	    if (fileSize >= 143) {
	        const buf = new Uint8Array(15);
	        const position = tokenizer.position;
	        await tokenizer.readBuffer(buf, { position: fileSize - 143 });
	        tokenizer.setPosition(position); // Restore position
	        const txt = new TextDecoder('latin1').decode(buf);
	        const tag = txt.slice(6);
	        if (tag === endTag2) {
	            return Number.parseInt(txt.slice(0, 6), 10) + 15;
	        }
	    }
	    return 0;
	}

	/**
	 * Primary entry point, Node.js specific entry point is MusepackParser.ts
	 */
	/**
	 * Parse Web API File
	 * Requires Blob to be able to stream using a ReadableStreamBYOBReader, only available since Node.js ≥ 20
	 * @param blob - Blob to parse
	 * @param options - Parsing options
	 * @returns Metadata
	 */
	async function parseBlob(blob, options = {}) {
	    const fileInfo = { mimeType: blob.type, size: blob.size };
	    if (blob instanceof File) {
	        fileInfo.path = blob.name;
	    }
	    return parseWebStream(blob.stream(), fileInfo, options);
	}
	/**
	 * Parse audio from Web Stream.Readable
	 * @param webStream - WebStream to read the audio track from
	 * @param options - Parsing options
	 * @param fileInfo - File information object or MIME-type string
	 * @returns Metadata
	 */
	async function parseWebStream(webStream, fileInfo, options = {}) {
	    const tokenizer = fromWebStream(webStream, { fileInfo: typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo });
	    try {
	        return await parseFromTokenizer(tokenizer, options);
	    }
	    finally {
	        await tokenizer.close();
	    }
	}
	/**
	 * Parse audio from memory
	 * @param uint8Array - Uint8Array holding audio data
	 * @param fileInfo - File information object or MIME-type string
	 * @param options - Parsing options
	 * @returns Metadata
	 * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15
	 */
	async function parseBuffer(uint8Array, fileInfo, options = {}) {
	    const tokenizer = fromBuffer(uint8Array, { fileInfo: typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo });
	    return parseFromTokenizer(tokenizer, options);
	}
	/**
	 * Parse audio from ITokenizer source
	 * @param tokenizer - Audio source implementing the tokenizer interface
	 * @param options - Parsing options
	 * @returns Metadata
	 */
	function parseFromTokenizer(tokenizer, options) {
	    const parserFactory = new ParserFactory();
	    return parserFactory.parse(tokenizer, undefined, options);
	}
	/**
	 * Create a dictionary ordered by their tag id (key)
	 * @param nativeTags list of tags
	 * @returns tags indexed by id
	 */
	function orderTags(nativeTags) {
	    const tags = {};
	    for (const { id, value } of nativeTags) {
	        (tags[id] || (tags[id] = [])).push(value);
	    }
	    return tags;
	}
	/**
	 * Convert rating to 1-5 star rating
	 * @param rating Normalized rating [0..1] (common.rating[n].rating)
	 * @returns Number of stars: 1, 2, 3, 4 or 5 stars
	 */
	function ratingToStars(rating) {
	    return rating === undefined ? 0 : 1 + Math.round(rating * 4);
	}
	/**
	 * Select most likely cover image.
	 * @param pictures Usually metadata.common.picture
	 * @return Cover image, if any, otherwise null
	 */
	function selectCover(pictures) {
	    return pictures ? pictures.reduce((acc, cur) => {
	        if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)'])
	            return cur;
	        return acc;
	    }) : null;
	}
	async function scanAppendingHeaders(tokenizer, options = {}) {
	    let apeOffset = tokenizer.fileInfo.size;
	    if (await hasID3v1Header(tokenizer)) {
	        apeOffset -= 128;
	        const lyricsLen = await getLyricsHeaderLength(tokenizer);
	        apeOffset -= lyricsLen;
	    }
	    options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);
	}
	/**
	 * Implementation only available when loaded as Node.js
	 * This method will throw an Error, always.
	 */
	async function parseFile(_filePath, _options = {}) {
	    throw new Error('This function require a Node engine. To load Web API File objects use parseBlob instead.');
	}
	/**
	 * Implementation only available when loaded as Node.js
	 * This method will throw an Error, always.
	 */
	async function parseStream(_stream, _fileInfo, _options = {}) {
	    throw new Error('This function require a Node engine.');
	}
	/**
	 * Return a list of supported mime-types
	 */
	function getSupportedMimeTypes() {
	    return new ParserFactory().getSupportedMimeTypes();
	}

	var musicMetadata = /*#__PURE__*/Object.freeze({
		__proto__: null,
		CouldNotDetermineFileTypeError: CouldNotDetermineFileTypeError,
		FieldDecodingError: FieldDecodingError,
		InternalParserError: InternalParserError,
		LyricsContentType: LyricsContentType,
		TimestampFormat: TimestampFormat,
		UnsupportedFileTypeError: UnsupportedFileTypeError,
		getSupportedMimeTypes: getSupportedMimeTypes,
		makeParseError: makeParseError,
		makeUnexpectedFileContentError: makeUnexpectedFileContentError,
		orderTags: orderTags,
		parseBlob: parseBlob,
		parseBuffer: parseBuffer,
		parseFile: parseFile,
		parseFromTokenizer: parseFromTokenizer,
		parseStream: parseStream,
		parseWebStream: parseWebStream,
		ratingToStars: ratingToStars,
		scanAppendingHeaders: scanAppendingHeaders,
		selectCover: selectCover
	});

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production = {};

	/**
	 * @license React
	 * react-jsx-runtime.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"),
	  REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment");
	function jsxProd(type, config, maybeKey) {
	  var key = null;
	  void 0 !== maybeKey && (key = "" + maybeKey);
	  void 0 !== config.key && (key = "" + config.key);
	  if ("key" in config) {
	    maybeKey = {};
	    for (var propName in config)
	      "key" !== propName && (maybeKey[propName] = config[propName]);
	  } else maybeKey = config;
	  config = maybeKey.ref;
	  return {
	    $$typeof: REACT_ELEMENT_TYPE$2,
	    type: type,
	    key: key,
	    ref: void 0 !== config ? config : null,
	    props: maybeKey
	  };
	}
	reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE$2;
	reactJsxRuntime_production.jsx = jsxProd;
	reactJsxRuntime_production.jsxs = jsxProd;

	{
	  jsxRuntime.exports = reactJsxRuntime_production;
	}

	var jsxRuntimeExports = jsxRuntime.exports;

	var client = {exports: {}};

	var reactDomClient_production = {};

	var scheduler = {exports: {}};

	var scheduler_production = {};

	/**
	 * @license React
	 * scheduler.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	(function (exports) {
		function push(heap, node) {
		  var index = heap.length;
		  heap.push(node);
		  a: for (; 0 < index; ) {
		    var parentIndex = (index - 1) >>> 1,
		      parent = heap[parentIndex];
		    if (0 < compare(parent, node))
		      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
		    else break a;
		  }
		}
		function peek(heap) {
		  return 0 === heap.length ? null : heap[0];
		}
		function pop(heap) {
		  if (0 === heap.length) return null;
		  var first = heap[0],
		    last = heap.pop();
		  if (last !== first) {
		    heap[0] = last;
		    a: for (
		      var index = 0, length = heap.length, halfLength = length >>> 1;
		      index < halfLength;

		    ) {
		      var leftIndex = 2 * (index + 1) - 1,
		        left = heap[leftIndex],
		        rightIndex = leftIndex + 1,
		        right = heap[rightIndex];
		      if (0 > compare(left, last))
		        rightIndex < length && 0 > compare(right, left)
		          ? ((heap[index] = right),
		            (heap[rightIndex] = last),
		            (index = rightIndex))
		          : ((heap[index] = left),
		            (heap[leftIndex] = last),
		            (index = leftIndex));
		      else if (rightIndex < length && 0 > compare(right, last))
		        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
		      else break a;
		    }
		  }
		  return first;
		}
		function compare(a, b) {
		  var diff = a.sortIndex - b.sortIndex;
		  return 0 !== diff ? diff : a.id - b.id;
		}
		exports.unstable_now = void 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
		  var localPerformance = performance;
		  exports.unstable_now = function () {
		    return localPerformance.now();
		  };
		} else {
		  var localDate = Date,
		    initialTime = localDate.now();
		  exports.unstable_now = function () {
		    return localDate.now() - initialTime;
		  };
		}
		var taskQueue = [],
		  timerQueue = [],
		  taskIdCounter = 1,
		  currentTask = null,
		  currentPriorityLevel = 3,
		  isPerformingWork = !1,
		  isHostCallbackScheduled = !1,
		  isHostTimeoutScheduled = !1,
		  needsPaint = !1,
		  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
		  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
		function advanceTimers(currentTime) {
		  for (var timer = peek(timerQueue); null !== timer; ) {
		    if (null === timer.callback) pop(timerQueue);
		    else if (timer.startTime <= currentTime)
		      pop(timerQueue),
		        (timer.sortIndex = timer.expirationTime),
		        push(taskQueue, timer);
		    else break;
		    timer = peek(timerQueue);
		  }
		}
		function handleTimeout(currentTime) {
		  isHostTimeoutScheduled = !1;
		  advanceTimers(currentTime);
		  if (!isHostCallbackScheduled)
		    if (null !== peek(taskQueue))
		      (isHostCallbackScheduled = !0),
		        isMessageLoopRunning ||
		          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
		    else {
		      var firstTimer = peek(timerQueue);
		      null !== firstTimer &&
		        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		    }
		}
		var isMessageLoopRunning = !1,
		  taskTimeoutID = -1,
		  frameInterval = 5,
		  startTime = -1;
		function shouldYieldToHost() {
		  return needsPaint
		    ? !0
		    : exports.unstable_now() - startTime < frameInterval
		      ? !1
		      : !0;
		}
		function performWorkUntilDeadline() {
		  needsPaint = !1;
		  if (isMessageLoopRunning) {
		    var currentTime = exports.unstable_now();
		    startTime = currentTime;
		    var hasMoreWork = !0;
		    try {
		      a: {
		        isHostCallbackScheduled = !1;
		        isHostTimeoutScheduled &&
		          ((isHostTimeoutScheduled = !1),
		          localClearTimeout(taskTimeoutID),
		          (taskTimeoutID = -1));
		        isPerformingWork = !0;
		        var previousPriorityLevel = currentPriorityLevel;
		        try {
		          b: {
		            advanceTimers(currentTime);
		            for (
		              currentTask = peek(taskQueue);
		              null !== currentTask &&
		              !(
		                currentTask.expirationTime > currentTime && shouldYieldToHost()
		              );

		            ) {
		              var callback = currentTask.callback;
		              if ("function" === typeof callback) {
		                currentTask.callback = null;
		                currentPriorityLevel = currentTask.priorityLevel;
		                var continuationCallback = callback(
		                  currentTask.expirationTime <= currentTime
		                );
		                currentTime = exports.unstable_now();
		                if ("function" === typeof continuationCallback) {
		                  currentTask.callback = continuationCallback;
		                  advanceTimers(currentTime);
		                  hasMoreWork = !0;
		                  break b;
		                }
		                currentTask === peek(taskQueue) && pop(taskQueue);
		                advanceTimers(currentTime);
		              } else pop(taskQueue);
		              currentTask = peek(taskQueue);
		            }
		            if (null !== currentTask) hasMoreWork = !0;
		            else {
		              var firstTimer = peek(timerQueue);
		              null !== firstTimer &&
		                requestHostTimeout(
		                  handleTimeout,
		                  firstTimer.startTime - currentTime
		                );
		              hasMoreWork = !1;
		            }
		          }
		          break a;
		        } finally {
		          (currentTask = null),
		            (currentPriorityLevel = previousPriorityLevel),
		            (isPerformingWork = !1);
		        }
		        hasMoreWork = void 0;
		      }
		    } finally {
		      hasMoreWork
		        ? schedulePerformWorkUntilDeadline()
		        : (isMessageLoopRunning = !1);
		    }
		  }
		}
		var schedulePerformWorkUntilDeadline;
		if ("function" === typeof localSetImmediate)
		  schedulePerformWorkUntilDeadline = function () {
		    localSetImmediate(performWorkUntilDeadline);
		  };
		else if ("undefined" !== typeof MessageChannel) {
		  var channel = new MessageChannel(),
		    port = channel.port2;
		  channel.port1.onmessage = performWorkUntilDeadline;
		  schedulePerformWorkUntilDeadline = function () {
		    port.postMessage(null);
		  };
		} else
		  schedulePerformWorkUntilDeadline = function () {
		    localSetTimeout(performWorkUntilDeadline, 0);
		  };
		function requestHostTimeout(callback, ms) {
		  taskTimeoutID = localSetTimeout(function () {
		    callback(exports.unstable_now());
		  }, ms);
		}
		exports.unstable_IdlePriority = 5;
		exports.unstable_ImmediatePriority = 1;
		exports.unstable_LowPriority = 4;
		exports.unstable_NormalPriority = 3;
		exports.unstable_Profiling = null;
		exports.unstable_UserBlockingPriority = 2;
		exports.unstable_cancelCallback = function (task) {
		  task.callback = null;
		};
		exports.unstable_forceFrameRate = function (fps) {
		  0 > fps || 125 < fps
		    ? console.error(
		        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		      )
		    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
		};
		exports.unstable_getCurrentPriorityLevel = function () {
		  return currentPriorityLevel;
		};
		exports.unstable_next = function (eventHandler) {
		  switch (currentPriorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		      var priorityLevel = 3;
		      break;
		    default:
		      priorityLevel = currentPriorityLevel;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_requestPaint = function () {
		  needsPaint = !0;
		};
		exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		  switch (priorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		    case 4:
		    case 5:
		      break;
		    default:
		      priorityLevel = 3;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_scheduleCallback = function (
		  priorityLevel,
		  callback,
		  options
		) {
		  var currentTime = exports.unstable_now();
		  "object" === typeof options && null !== options
		    ? ((options = options.delay),
		      (options =
		        "number" === typeof options && 0 < options
		          ? currentTime + options
		          : currentTime))
		    : (options = currentTime);
		  switch (priorityLevel) {
		    case 1:
		      var timeout = -1;
		      break;
		    case 2:
		      timeout = 250;
		      break;
		    case 5:
		      timeout = 1073741823;
		      break;
		    case 4:
		      timeout = 1e4;
		      break;
		    default:
		      timeout = 5e3;
		  }
		  timeout = options + timeout;
		  priorityLevel = {
		    id: taskIdCounter++,
		    callback: callback,
		    priorityLevel: priorityLevel,
		    startTime: options,
		    expirationTime: timeout,
		    sortIndex: -1
		  };
		  options > currentTime
		    ? ((priorityLevel.sortIndex = options),
		      push(timerQueue, priorityLevel),
		      null === peek(taskQueue) &&
		        priorityLevel === peek(timerQueue) &&
		        (isHostTimeoutScheduled
		          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
		          : (isHostTimeoutScheduled = !0),
		        requestHostTimeout(handleTimeout, options - currentTime)))
		    : ((priorityLevel.sortIndex = timeout),
		      push(taskQueue, priorityLevel),
		      isHostCallbackScheduled ||
		        isPerformingWork ||
		        ((isHostCallbackScheduled = !0),
		        isMessageLoopRunning ||
		          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));
		  return priorityLevel;
		};
		exports.unstable_shouldYield = shouldYieldToHost;
		exports.unstable_wrapCallback = function (callback) {
		  var parentPriorityLevel = currentPriorityLevel;
		  return function () {
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = parentPriorityLevel;
		    try {
		      return callback.apply(this, arguments);
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		}; 
	} (scheduler_production));

	{
	  scheduler.exports = scheduler_production;
	}

	var schedulerExports = scheduler.exports;

	var react = {exports: {}};

	var react_production = {};

	/**
	 * @license React
	 * react.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"),
	  REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"),
	  REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"),
	  REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"),
	  REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"),
	  REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"),
	  REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"),
	  REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"),
	  REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"),
	  REACT_MEMO_TYPE$1 = Symbol.for("react.memo"),
	  REACT_LAZY_TYPE$1 = Symbol.for("react.lazy"),
	  MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator;
	function getIteratorFn$1(maybeIterable) {
	  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
	  maybeIterable =
	    (MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1]) ||
	    maybeIterable["@@iterator"];
	  return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var ReactNoopUpdateQueue = {
	    isMounted: function () {
	      return !1;
	    },
	    enqueueForceUpdate: function () {},
	    enqueueReplaceState: function () {},
	    enqueueSetState: function () {}
	  },
	  assign$1 = Object.assign,
	  emptyObject = {};
	function Component(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	Component.prototype.isReactComponent = {};
	Component.prototype.setState = function (partialState, callback) {
	  if (
	    "object" !== typeof partialState &&
	    "function" !== typeof partialState &&
	    null != partialState
	  )
	    throw Error(
	      "takes an object of state variables to update or a function which returns an object of state variables."
	    );
	  this.updater.enqueueSetState(this, partialState, callback, "setState");
	};
	Component.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	};
	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;
	function PureComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
	pureComponentPrototype.constructor = PureComponent;
	assign$1(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = !0;
	var isArrayImpl$1 = Array.isArray,
	  ReactSharedInternals$2 = { H: null, A: null, T: null, S: null, V: null },
	  hasOwnProperty$3 = Object.prototype.hasOwnProperty;
	function ReactElement(type, key, self, source, owner, props) {
	  self = props.ref;
	  return {
	    $$typeof: REACT_ELEMENT_TYPE$1,
	    type: type,
	    key: key,
	    ref: void 0 !== self ? self : null,
	    props: props
	  };
	}
	function cloneAndReplaceKey(oldElement, newKey) {
	  return ReactElement(
	    oldElement.type,
	    newKey,
	    void 0,
	    void 0,
	    void 0,
	    oldElement.props
	  );
	}
	function isValidElement(object) {
	  return (
	    "object" === typeof object &&
	    null !== object &&
	    object.$$typeof === REACT_ELEMENT_TYPE$1
	  );
	}
	function escape(key) {
	  var escaperLookup = { "=": "=0", ":": "=2" };
	  return (
	    "$" +
	    key.replace(/[=:]/g, function (match) {
	      return escaperLookup[match];
	    })
	  );
	}
	var userProvidedKeyEscapeRegex = /\/+/g;
	function getElementKey(element, index) {
	  return "object" === typeof element && null !== element && null != element.key
	    ? escape("" + element.key)
	    : index.toString(36);
	}
	function noop$1$1() {}
	function resolveThenable(thenable) {
	  switch (thenable.status) {
	    case "fulfilled":
	      return thenable.value;
	    case "rejected":
	      throw thenable.reason;
	    default:
	      switch (
	        ("string" === typeof thenable.status
	          ? thenable.then(noop$1$1, noop$1$1)
	          : ((thenable.status = "pending"),
	            thenable.then(
	              function (fulfilledValue) {
	                "pending" === thenable.status &&
	                  ((thenable.status = "fulfilled"),
	                  (thenable.value = fulfilledValue));
	              },
	              function (error) {
	                "pending" === thenable.status &&
	                  ((thenable.status = "rejected"), (thenable.reason = error));
	              }
	            )),
	        thenable.status)
	      ) {
	        case "fulfilled":
	          return thenable.value;
	        case "rejected":
	          throw thenable.reason;
	      }
	  }
	  throw thenable;
	}
	function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
	  var type = typeof children;
	  if ("undefined" === type || "boolean" === type) children = null;
	  var invokeCallback = !1;
	  if (null === children) invokeCallback = !0;
	  else
	    switch (type) {
	      case "bigint":
	      case "string":
	      case "number":
	        invokeCallback = !0;
	        break;
	      case "object":
	        switch (children.$$typeof) {
	          case REACT_ELEMENT_TYPE$1:
	          case REACT_PORTAL_TYPE$2:
	            invokeCallback = !0;
	            break;
	          case REACT_LAZY_TYPE$1:
	            return (
	              (invokeCallback = children._init),
	              mapIntoArray(
	                invokeCallback(children._payload),
	                array,
	                escapedPrefix,
	                nameSoFar,
	                callback
	              )
	            );
	        }
	    }
	  if (invokeCallback)
	    return (
	      (callback = callback(children)),
	      (invokeCallback =
	        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
	      isArrayImpl$1(callback)
	        ? ((escapedPrefix = ""),
	          null != invokeCallback &&
	            (escapedPrefix =
	              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
	          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
	            return c;
	          }))
	        : null != callback &&
	          (isValidElement(callback) &&
	            (callback = cloneAndReplaceKey(
	              callback,
	              escapedPrefix +
	                (null == callback.key ||
	                (children && children.key === callback.key)
	                  ? ""
	                  : ("" + callback.key).replace(
	                      userProvidedKeyEscapeRegex,
	                      "$&/"
	                    ) + "/") +
	                invokeCallback
	            )),
	          array.push(callback)),
	      1
	    );
	  invokeCallback = 0;
	  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
	  if (isArrayImpl$1(children))
	    for (var i = 0; i < children.length; i++)
	      (nameSoFar = children[i]),
	        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
	        (invokeCallback += mapIntoArray(
	          nameSoFar,
	          array,
	          escapedPrefix,
	          type,
	          callback
	        ));
	  else if (((i = getIteratorFn$1(children)), "function" === typeof i))
	    for (
	      children = i.call(children), i = 0;
	      !(nameSoFar = children.next()).done;

	    )
	      (nameSoFar = nameSoFar.value),
	        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
	        (invokeCallback += mapIntoArray(
	          nameSoFar,
	          array,
	          escapedPrefix,
	          type,
	          callback
	        ));
	  else if ("object" === type) {
	    if ("function" === typeof children.then)
	      return mapIntoArray(
	        resolveThenable(children),
	        array,
	        escapedPrefix,
	        nameSoFar,
	        callback
	      );
	    array = String(children);
	    throw Error(
	      "Objects are not valid as a React child (found: " +
	        ("[object Object]" === array
	          ? "object with keys {" + Object.keys(children).join(", ") + "}"
	          : array) +
	        "). If you meant to render a collection of children, use an array instead."
	    );
	  }
	  return invokeCallback;
	}
	function mapChildren(children, func, context) {
	  if (null == children) return children;
	  var result = [],
	    count = 0;
	  mapIntoArray(children, result, "", "", function (child) {
	    return func.call(context, child, count++);
	  });
	  return result;
	}
	function lazyInitializer(payload) {
	  if (-1 === payload._status) {
	    var ctor = payload._result;
	    ctor = ctor();
	    ctor.then(
	      function (moduleObject) {
	        if (0 === payload._status || -1 === payload._status)
	          (payload._status = 1), (payload._result = moduleObject);
	      },
	      function (error) {
	        if (0 === payload._status || -1 === payload._status)
	          (payload._status = 2), (payload._result = error);
	      }
	    );
	    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
	  }
	  if (1 === payload._status) return payload._result.default;
	  throw payload._result;
	}
	var reportGlobalError$1 =
	  "function" === typeof reportError
	    ? reportError
	    : function (error) {
	        if (
	          "object" === typeof window &&
	          "function" === typeof window.ErrorEvent
	        ) {
	          var event = new window.ErrorEvent("error", {
	            bubbles: !0,
	            cancelable: !0,
	            message:
	              "object" === typeof error &&
	              null !== error &&
	              "string" === typeof error.message
	                ? String(error.message)
	                : String(error),
	            error: error
	          });
	          if (!window.dispatchEvent(event)) return;
	        } else if (
	          "object" === typeof process &&
	          "function" === typeof process.emit
	        ) {
	          process.emit("uncaughtException", error);
	          return;
	        }
	        console.error(error);
	      };
	function noop$6() {}
	react_production.Children = {
	  map: mapChildren,
	  forEach: function (children, forEachFunc, forEachContext) {
	    mapChildren(
	      children,
	      function () {
	        forEachFunc.apply(this, arguments);
	      },
	      forEachContext
	    );
	  },
	  count: function (children) {
	    var n = 0;
	    mapChildren(children, function () {
	      n++;
	    });
	    return n;
	  },
	  toArray: function (children) {
	    return (
	      mapChildren(children, function (child) {
	        return child;
	      }) || []
	    );
	  },
	  only: function (children) {
	    if (!isValidElement(children))
	      throw Error(
	        "React.Children.only expected to receive a single React element child."
	      );
	    return children;
	  }
	};
	react_production.Component = Component;
	react_production.Fragment = REACT_FRAGMENT_TYPE$1;
	react_production.Profiler = REACT_PROFILER_TYPE$1;
	react_production.PureComponent = PureComponent;
	react_production.StrictMode = REACT_STRICT_MODE_TYPE$1;
	react_production.Suspense = REACT_SUSPENSE_TYPE$1;
	react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
	  ReactSharedInternals$2;
	react_production.__COMPILER_RUNTIME = {
	  __proto__: null,
	  c: function (size) {
	    return ReactSharedInternals$2.H.useMemoCache(size);
	  }
	};
	react_production.cache = function (fn) {
	  return function () {
	    return fn.apply(null, arguments);
	  };
	};
	react_production.cloneElement = function (element, config, children) {
	  if (null === element || void 0 === element)
	    throw Error(
	      "The argument must be a React element, but you passed " + element + "."
	    );
	  var props = assign$1({}, element.props),
	    key = element.key,
	    owner = void 0;
	  if (null != config)
	    for (propName in (void 0 !== config.ref && (owner = void 0),
	    void 0 !== config.key && (key = "" + config.key),
	    config))
	      !hasOwnProperty$3.call(config, propName) ||
	        "key" === propName ||
	        "__self" === propName ||
	        "__source" === propName ||
	        ("ref" === propName && void 0 === config.ref) ||
	        (props[propName] = config[propName]);
	  var propName = arguments.length - 2;
	  if (1 === propName) props.children = children;
	  else if (1 < propName) {
	    for (var childArray = Array(propName), i = 0; i < propName; i++)
	      childArray[i] = arguments[i + 2];
	    props.children = childArray;
	  }
	  return ReactElement(element.type, key, void 0, void 0, owner, props);
	};
	react_production.createContext = function (defaultValue) {
	  defaultValue = {
	    $$typeof: REACT_CONTEXT_TYPE$1,
	    _currentValue: defaultValue,
	    _currentValue2: defaultValue,
	    _threadCount: 0,
	    Provider: null,
	    Consumer: null
	  };
	  defaultValue.Provider = defaultValue;
	  defaultValue.Consumer = {
	    $$typeof: REACT_CONSUMER_TYPE$1,
	    _context: defaultValue
	  };
	  return defaultValue;
	};
	react_production.createElement = function (type, config, children) {
	  var propName,
	    props = {},
	    key = null;
	  if (null != config)
	    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
	      hasOwnProperty$3.call(config, propName) &&
	        "key" !== propName &&
	        "__self" !== propName &&
	        "__source" !== propName &&
	        (props[propName] = config[propName]);
	  var childrenLength = arguments.length - 2;
	  if (1 === childrenLength) props.children = children;
	  else if (1 < childrenLength) {
	    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
	      childArray[i] = arguments[i + 2];
	    props.children = childArray;
	  }
	  if (type && type.defaultProps)
	    for (propName in ((childrenLength = type.defaultProps), childrenLength))
	      void 0 === props[propName] &&
	        (props[propName] = childrenLength[propName]);
	  return ReactElement(type, key, void 0, void 0, null, props);
	};
	react_production.createRef = function () {
	  return { current: null };
	};
	react_production.forwardRef = function (render) {
	  return { $$typeof: REACT_FORWARD_REF_TYPE$1, render: render };
	};
	react_production.isValidElement = isValidElement;
	react_production.lazy = function (ctor) {
	  return {
	    $$typeof: REACT_LAZY_TYPE$1,
	    _payload: { _status: -1, _result: ctor },
	    _init: lazyInitializer
	  };
	};
	react_production.memo = function (type, compare) {
	  return {
	    $$typeof: REACT_MEMO_TYPE$1,
	    type: type,
	    compare: void 0 === compare ? null : compare
	  };
	};
	react_production.startTransition = function (scope) {
	  var prevTransition = ReactSharedInternals$2.T,
	    currentTransition = {};
	  ReactSharedInternals$2.T = currentTransition;
	  try {
	    var returnValue = scope(),
	      onStartTransitionFinish = ReactSharedInternals$2.S;
	    null !== onStartTransitionFinish &&
	      onStartTransitionFinish(currentTransition, returnValue);
	    "object" === typeof returnValue &&
	      null !== returnValue &&
	      "function" === typeof returnValue.then &&
	      returnValue.then(noop$6, reportGlobalError$1);
	  } catch (error) {
	    reportGlobalError$1(error);
	  } finally {
	    ReactSharedInternals$2.T = prevTransition;
	  }
	};
	react_production.unstable_useCacheRefresh = function () {
	  return ReactSharedInternals$2.H.useCacheRefresh();
	};
	react_production.use = function (usable) {
	  return ReactSharedInternals$2.H.use(usable);
	};
	react_production.useActionState = function (action, initialState, permalink) {
	  return ReactSharedInternals$2.H.useActionState(action, initialState, permalink);
	};
	react_production.useCallback = function (callback, deps) {
	  return ReactSharedInternals$2.H.useCallback(callback, deps);
	};
	react_production.useContext = function (Context) {
	  return ReactSharedInternals$2.H.useContext(Context);
	};
	react_production.useDebugValue = function () {};
	react_production.useDeferredValue = function (value, initialValue) {
	  return ReactSharedInternals$2.H.useDeferredValue(value, initialValue);
	};
	react_production.useEffect = function (create, createDeps, update) {
	  var dispatcher = ReactSharedInternals$2.H;
	  if ("function" === typeof update)
	    throw Error(
	      "useEffect CRUD overload is not enabled in this build of React."
	    );
	  return dispatcher.useEffect(create, createDeps);
	};
	react_production.useId = function () {
	  return ReactSharedInternals$2.H.useId();
	};
	react_production.useImperativeHandle = function (ref, create, deps) {
	  return ReactSharedInternals$2.H.useImperativeHandle(ref, create, deps);
	};
	react_production.useInsertionEffect = function (create, deps) {
	  return ReactSharedInternals$2.H.useInsertionEffect(create, deps);
	};
	react_production.useLayoutEffect = function (create, deps) {
	  return ReactSharedInternals$2.H.useLayoutEffect(create, deps);
	};
	react_production.useMemo = function (create, deps) {
	  return ReactSharedInternals$2.H.useMemo(create, deps);
	};
	react_production.useOptimistic = function (passthrough, reducer) {
	  return ReactSharedInternals$2.H.useOptimistic(passthrough, reducer);
	};
	react_production.useReducer = function (reducer, initialArg, init) {
	  return ReactSharedInternals$2.H.useReducer(reducer, initialArg, init);
	};
	react_production.useRef = function (initialValue) {
	  return ReactSharedInternals$2.H.useRef(initialValue);
	};
	react_production.useState = function (initialState) {
	  return ReactSharedInternals$2.H.useState(initialState);
	};
	react_production.useSyncExternalStore = function (
	  subscribe,
	  getSnapshot,
	  getServerSnapshot
	) {
	  return ReactSharedInternals$2.H.useSyncExternalStore(
	    subscribe,
	    getSnapshot,
	    getServerSnapshot
	  );
	};
	react_production.useTransition = function () {
	  return ReactSharedInternals$2.H.useTransition();
	};
	react_production.version = "19.1.0";

	{
	  react.exports = react_production;
	}

	var reactExports = react.exports;

	var reactDom = {exports: {}};

	var reactDom_production = {};

	/**
	 * @license React
	 * react-dom.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var React$1 = reactExports;
	function formatProdErrorMessage$2(code) {
	  var url = "https://react.dev/errors/" + code;
	  if (1 < arguments.length) {
	    url += "?args[]=" + encodeURIComponent(arguments[1]);
	    for (var i = 2; i < arguments.length; i++)
	      url += "&args[]=" + encodeURIComponent(arguments[i]);
	  }
	  return (
	    "Minified React error #" +
	    code +
	    "; visit " +
	    url +
	    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
	  );
	}
	function noop$5() {}
	var Internals = {
	    d: {
	      f: noop$5,
	      r: function () {
	        throw Error(formatProdErrorMessage$2(522));
	      },
	      D: noop$5,
	      C: noop$5,
	      L: noop$5,
	      m: noop$5,
	      X: noop$5,
	      S: noop$5,
	      M: noop$5
	    },
	    p: 0,
	    findDOMNode: null
	  },
	  REACT_PORTAL_TYPE$1 = Symbol.for("react.portal");
	function createPortal$1(children, containerInfo, implementation) {
	  var key =
	    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
	  return {
	    $$typeof: REACT_PORTAL_TYPE$1,
	    key: null == key ? null : "" + key,
	    children: children,
	    containerInfo: containerInfo,
	    implementation: implementation
	  };
	}
	var ReactSharedInternals$1 =
	  React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
	function getCrossOriginStringAs(as, input) {
	  if ("font" === as) return "";
	  if ("string" === typeof input)
	    return "use-credentials" === input ? input : "";
	}
	reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
	  Internals;
	reactDom_production.createPortal = function (children, container) {
	  var key =
	    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
	  if (
	    !container ||
	    (1 !== container.nodeType &&
	      9 !== container.nodeType &&
	      11 !== container.nodeType)
	  )
	    throw Error(formatProdErrorMessage$2(299));
	  return createPortal$1(children, container, null, key);
	};
	reactDom_production.flushSync = function (fn) {
	  var previousTransition = ReactSharedInternals$1.T,
	    previousUpdatePriority = Internals.p;
	  try {
	    if (((ReactSharedInternals$1.T = null), (Internals.p = 2), fn)) return fn();
	  } finally {
	    (ReactSharedInternals$1.T = previousTransition),
	      (Internals.p = previousUpdatePriority),
	      Internals.d.f();
	  }
	};
	reactDom_production.preconnect = function (href, options) {
	  "string" === typeof href &&
	    (options
	      ? ((options = options.crossOrigin),
	        (options =
	          "string" === typeof options
	            ? "use-credentials" === options
	              ? options
	              : ""
	            : void 0))
	      : (options = null),
	    Internals.d.C(href, options));
	};
	reactDom_production.prefetchDNS = function (href) {
	  "string" === typeof href && Internals.d.D(href);
	};
	reactDom_production.preinit = function (href, options) {
	  if ("string" === typeof href && options && "string" === typeof options.as) {
	    var as = options.as,
	      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
	      integrity =
	        "string" === typeof options.integrity ? options.integrity : void 0,
	      fetchPriority =
	        "string" === typeof options.fetchPriority
	          ? options.fetchPriority
	          : void 0;
	    "style" === as
	      ? Internals.d.S(
	          href,
	          "string" === typeof options.precedence ? options.precedence : void 0,
	          {
	            crossOrigin: crossOrigin,
	            integrity: integrity,
	            fetchPriority: fetchPriority
	          }
	        )
	      : "script" === as &&
	        Internals.d.X(href, {
	          crossOrigin: crossOrigin,
	          integrity: integrity,
	          fetchPriority: fetchPriority,
	          nonce: "string" === typeof options.nonce ? options.nonce : void 0
	        });
	  }
	};
	reactDom_production.preinitModule = function (href, options) {
	  if ("string" === typeof href)
	    if ("object" === typeof options && null !== options) {
	      if (null == options.as || "script" === options.as) {
	        var crossOrigin = getCrossOriginStringAs(
	          options.as,
	          options.crossOrigin
	        );
	        Internals.d.M(href, {
	          crossOrigin: crossOrigin,
	          integrity:
	            "string" === typeof options.integrity ? options.integrity : void 0,
	          nonce: "string" === typeof options.nonce ? options.nonce : void 0
	        });
	      }
	    } else null == options && Internals.d.M(href);
	};
	reactDom_production.preload = function (href, options) {
	  if (
	    "string" === typeof href &&
	    "object" === typeof options &&
	    null !== options &&
	    "string" === typeof options.as
	  ) {
	    var as = options.as,
	      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
	    Internals.d.L(href, as, {
	      crossOrigin: crossOrigin,
	      integrity:
	        "string" === typeof options.integrity ? options.integrity : void 0,
	      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
	      type: "string" === typeof options.type ? options.type : void 0,
	      fetchPriority:
	        "string" === typeof options.fetchPriority
	          ? options.fetchPriority
	          : void 0,
	      referrerPolicy:
	        "string" === typeof options.referrerPolicy
	          ? options.referrerPolicy
	          : void 0,
	      imageSrcSet:
	        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
	      imageSizes:
	        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
	      media: "string" === typeof options.media ? options.media : void 0
	    });
	  }
	};
	reactDom_production.preloadModule = function (href, options) {
	  if ("string" === typeof href)
	    if (options) {
	      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
	      Internals.d.m(href, {
	        as:
	          "string" === typeof options.as && "script" !== options.as
	            ? options.as
	            : void 0,
	        crossOrigin: crossOrigin,
	        integrity:
	          "string" === typeof options.integrity ? options.integrity : void 0
	      });
	    } else Internals.d.m(href);
	};
	reactDom_production.requestFormReset = function (form) {
	  Internals.d.r(form);
	};
	reactDom_production.unstable_batchedUpdates = function (fn, a) {
	  return fn(a);
	};
	reactDom_production.useFormState = function (action, initialState, permalink) {
	  return ReactSharedInternals$1.H.useFormState(action, initialState, permalink);
	};
	reactDom_production.useFormStatus = function () {
	  return ReactSharedInternals$1.H.useHostTransitionStatus();
	};
	reactDom_production.version = "19.1.0";

	function checkDCE$1() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}

	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE$1();
	  reactDom.exports = reactDom_production;
	}

	var reactDomExports = reactDom.exports;
	var ReactDOM$2 = /*@__PURE__*/getDefaultExportFromCjs(reactDomExports);

	/**
	 * @license React
	 * react-dom-client.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var Scheduler = schedulerExports,
	  React = reactExports,
	  ReactDOM$1 = reactDomExports;
	function formatProdErrorMessage$1(code) {
	  var url = "https://react.dev/errors/" + code;
	  if (1 < arguments.length) {
	    url += "?args[]=" + encodeURIComponent(arguments[1]);
	    for (var i = 2; i < arguments.length; i++)
	      url += "&args[]=" + encodeURIComponent(arguments[i]);
	  }
	  return (
	    "Minified React error #" +
	    code +
	    "; visit " +
	    url +
	    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
	  );
	}
	function isValidContainer(node) {
	  return !(
	    !node ||
	    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
	  );
	}
	function getNearestMountedFiber(fiber) {
	  var node = fiber,
	    nearestMounted = fiber;
	  if (fiber.alternate) for (; node.return; ) node = node.return;
	  else {
	    fiber = node;
	    do
	      (node = fiber),
	        0 !== (node.flags & 4098) && (nearestMounted = node.return),
	        (fiber = node.return);
	    while (fiber);
	  }
	  return 3 === node.tag ? nearestMounted : null;
	}
	function getSuspenseInstanceFromFiber(fiber) {
	  if (13 === fiber.tag) {
	    var suspenseState = fiber.memoizedState;
	    null === suspenseState &&
	      ((fiber = fiber.alternate),
	      null !== fiber && (suspenseState = fiber.memoizedState));
	    if (null !== suspenseState) return suspenseState.dehydrated;
	  }
	  return null;
	}
	function assertIsMounted(fiber) {
	  if (getNearestMountedFiber(fiber) !== fiber)
	    throw Error(formatProdErrorMessage$1(188));
	}
	function findCurrentFiberUsingSlowPath(fiber) {
	  var alternate = fiber.alternate;
	  if (!alternate) {
	    alternate = getNearestMountedFiber(fiber);
	    if (null === alternate) throw Error(formatProdErrorMessage$1(188));
	    return alternate !== fiber ? null : fiber;
	  }
	  for (var a = fiber, b = alternate; ; ) {
	    var parentA = a.return;
	    if (null === parentA) break;
	    var parentB = parentA.alternate;
	    if (null === parentB) {
	      b = parentA.return;
	      if (null !== b) {
	        a = b;
	        continue;
	      }
	      break;
	    }
	    if (parentA.child === parentB.child) {
	      for (parentB = parentA.child; parentB; ) {
	        if (parentB === a) return assertIsMounted(parentA), fiber;
	        if (parentB === b) return assertIsMounted(parentA), alternate;
	        parentB = parentB.sibling;
	      }
	      throw Error(formatProdErrorMessage$1(188));
	    }
	    if (a.return !== b.return) (a = parentA), (b = parentB);
	    else {
	      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
	        if (child$0 === a) {
	          didFindChild = !0;
	          a = parentA;
	          b = parentB;
	          break;
	        }
	        if (child$0 === b) {
	          didFindChild = !0;
	          b = parentA;
	          a = parentB;
	          break;
	        }
	        child$0 = child$0.sibling;
	      }
	      if (!didFindChild) {
	        for (child$0 = parentB.child; child$0; ) {
	          if (child$0 === a) {
	            didFindChild = !0;
	            a = parentB;
	            b = parentA;
	            break;
	          }
	          if (child$0 === b) {
	            didFindChild = !0;
	            b = parentB;
	            a = parentA;
	            break;
	          }
	          child$0 = child$0.sibling;
	        }
	        if (!didFindChild) throw Error(formatProdErrorMessage$1(189));
	      }
	    }
	    if (a.alternate !== b) throw Error(formatProdErrorMessage$1(190));
	  }
	  if (3 !== a.tag) throw Error(formatProdErrorMessage$1(188));
	  return a.stateNode.current === a ? fiber : alternate;
	}
	function findCurrentHostFiberImpl(node) {
	  var tag = node.tag;
	  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
	  for (node = node.child; null !== node; ) {
	    tag = findCurrentHostFiberImpl(node);
	    if (null !== tag) return tag;
	    node = node.sibling;
	  }
	  return null;
	}
	var assign = Object.assign,
	  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
	  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
	  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
	  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
	  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
	  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
	  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
	  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
	  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
	  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
	  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
	  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
	  REACT_MEMO_TYPE = Symbol.for("react.memo"),
	  REACT_LAZY_TYPE = Symbol.for("react.lazy");
	var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
	var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
	var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
	  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
	  maybeIterable =
	    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
	    maybeIterable["@@iterator"];
	  return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
	function getComponentNameFromType(type) {
	  if (null == type) return null;
	  if ("function" === typeof type)
	    return type.$$typeof === REACT_CLIENT_REFERENCE
	      ? null
	      : type.displayName || type.name || null;
	  if ("string" === typeof type) return type;
	  switch (type) {
	    case REACT_FRAGMENT_TYPE:
	      return "Fragment";
	    case REACT_PROFILER_TYPE:
	      return "Profiler";
	    case REACT_STRICT_MODE_TYPE:
	      return "StrictMode";
	    case REACT_SUSPENSE_TYPE:
	      return "Suspense";
	    case REACT_SUSPENSE_LIST_TYPE:
	      return "SuspenseList";
	    case REACT_ACTIVITY_TYPE:
	      return "Activity";
	  }
	  if ("object" === typeof type)
	    switch (type.$$typeof) {
	      case REACT_PORTAL_TYPE:
	        return "Portal";
	      case REACT_CONTEXT_TYPE:
	        return (type.displayName || "Context") + ".Provider";
	      case REACT_CONSUMER_TYPE:
	        return (type._context.displayName || "Context") + ".Consumer";
	      case REACT_FORWARD_REF_TYPE:
	        var innerType = type.render;
	        type = type.displayName;
	        type ||
	          ((type = innerType.displayName || innerType.name || ""),
	          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
	        return type;
	      case REACT_MEMO_TYPE:
	        return (
	          (innerType = type.displayName || null),
	          null !== innerType
	            ? innerType
	            : getComponentNameFromType(type.type) || "Memo"
	        );
	      case REACT_LAZY_TYPE:
	        innerType = type._payload;
	        type = type._init;
	        try {
	          return getComponentNameFromType(type(innerType));
	        } catch (x) {}
	    }
	  return null;
	}
	var isArrayImpl = Array.isArray,
	  ReactSharedInternals =
	    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
	  ReactDOMSharedInternals =
	    ReactDOM$1.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
	  sharedNotPendingObject = {
	    pending: !1,
	    data: null,
	    method: null,
	    action: null
	  },
	  valueStack = [],
	  index = -1;
	function createCursor(defaultValue) {
	  return { current: defaultValue };
	}
	function pop(cursor) {
	  0 > index ||
	    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
	}
	function push(cursor, value) {
	  index++;
	  valueStack[index] = cursor.current;
	  cursor.current = value;
	}
	var contextStackCursor = createCursor(null),
	  contextFiberStackCursor = createCursor(null),
	  rootInstanceStackCursor = createCursor(null),
	  hostTransitionProviderCursor = createCursor(null);
	function pushHostContainer(fiber, nextRootInstance) {
	  push(rootInstanceStackCursor, nextRootInstance);
	  push(contextFiberStackCursor, fiber);
	  push(contextStackCursor, null);
	  switch (nextRootInstance.nodeType) {
	    case 9:
	    case 11:
	      fiber = (fiber = nextRootInstance.documentElement)
	        ? (fiber = fiber.namespaceURI)
	          ? getOwnHostContext(fiber)
	          : 0
	        : 0;
	      break;
	    default:
	      if (
	        ((fiber = nextRootInstance.tagName),
	        (nextRootInstance = nextRootInstance.namespaceURI))
	      )
	        (nextRootInstance = getOwnHostContext(nextRootInstance)),
	          (fiber = getChildHostContextProd(nextRootInstance, fiber));
	      else
	        switch (fiber) {
	          case "svg":
	            fiber = 1;
	            break;
	          case "math":
	            fiber = 2;
	            break;
	          default:
	            fiber = 0;
	        }
	  }
	  pop(contextStackCursor);
	  push(contextStackCursor, fiber);
	}
	function popHostContainer() {
	  pop(contextStackCursor);
	  pop(contextFiberStackCursor);
	  pop(rootInstanceStackCursor);
	}
	function pushHostContext(fiber) {
	  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
	  var context = contextStackCursor.current;
	  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
	  context !== JSCompiler_inline_result &&
	    (push(contextFiberStackCursor, fiber),
	    push(contextStackCursor, JSCompiler_inline_result));
	}
	function popHostContext(fiber) {
	  contextFiberStackCursor.current === fiber &&
	    (pop(contextStackCursor), pop(contextFiberStackCursor));
	  hostTransitionProviderCursor.current === fiber &&
	    (pop(hostTransitionProviderCursor),
	    (HostTransitionContext._currentValue = sharedNotPendingObject));
	}
	var hasOwnProperty$2 = Object.prototype.hasOwnProperty,
	  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
	  cancelCallback$1 = Scheduler.unstable_cancelCallback,
	  shouldYield = Scheduler.unstable_shouldYield,
	  requestPaint = Scheduler.unstable_requestPaint,
	  now = Scheduler.unstable_now,
	  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
	  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
	  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
	  NormalPriority$1 = Scheduler.unstable_NormalPriority,
	  LowPriority = Scheduler.unstable_LowPriority,
	  IdlePriority = Scheduler.unstable_IdlePriority,
	  log$1 = Scheduler.log,
	  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
	  rendererID = null,
	  injectedHook = null;
	function setIsStrictModeForDevtools(newIsStrictMode) {
	  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
	  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
	    try {
	      injectedHook.setStrictMode(rendererID, newIsStrictMode);
	    } catch (err) {}
	}
	var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
	  log = Math.log,
	  LN2 = Math.LN2;
	function clz32Fallback(x) {
	  x >>>= 0;
	  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
	}
	var nextTransitionLane = 256,
	  nextRetryLane = 4194304;
	function getHighestPriorityLanes(lanes) {
	  var pendingSyncLanes = lanes & 42;
	  if (0 !== pendingSyncLanes) return pendingSyncLanes;
	  switch (lanes & -lanes) {
	    case 1:
	      return 1;
	    case 2:
	      return 2;
	    case 4:
	      return 4;
	    case 8:
	      return 8;
	    case 16:
	      return 16;
	    case 32:
	      return 32;
	    case 64:
	      return 64;
	    case 128:
	      return 128;
	    case 256:
	    case 512:
	    case 1024:
	    case 2048:
	    case 4096:
	    case 8192:
	    case 16384:
	    case 32768:
	    case 65536:
	    case 131072:
	    case 262144:
	    case 524288:
	    case 1048576:
	    case 2097152:
	      return lanes & 4194048;
	    case 4194304:
	    case 8388608:
	    case 16777216:
	    case 33554432:
	      return lanes & 62914560;
	    case 67108864:
	      return 67108864;
	    case 134217728:
	      return 134217728;
	    case 268435456:
	      return 268435456;
	    case 536870912:
	      return 536870912;
	    case 1073741824:
	      return 0;
	    default:
	      return lanes;
	  }
	}
	function getNextLanes(root, wipLanes, rootHasPendingCommit) {
	  var pendingLanes = root.pendingLanes;
	  if (0 === pendingLanes) return 0;
	  var nextLanes = 0,
	    suspendedLanes = root.suspendedLanes,
	    pingedLanes = root.pingedLanes;
	  root = root.warmLanes;
	  var nonIdlePendingLanes = pendingLanes & 134217727;
	  0 !== nonIdlePendingLanes
	    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
	      0 !== pendingLanes
	        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
	        : ((pingedLanes &= nonIdlePendingLanes),
	          0 !== pingedLanes
	            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
	            : rootHasPendingCommit ||
	              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
	              0 !== rootHasPendingCommit &&
	                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
	    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
	      0 !== nonIdlePendingLanes
	        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
	        : 0 !== pingedLanes
	          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
	          : rootHasPendingCommit ||
	            ((rootHasPendingCommit = pendingLanes & ~root),
	            0 !== rootHasPendingCommit &&
	              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
	  return 0 === nextLanes
	    ? 0
	    : 0 !== wipLanes &&
	        wipLanes !== nextLanes &&
	        0 === (wipLanes & suspendedLanes) &&
	        ((suspendedLanes = nextLanes & -nextLanes),
	        (rootHasPendingCommit = wipLanes & -wipLanes),
	        suspendedLanes >= rootHasPendingCommit ||
	          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
	      ? wipLanes
	      : nextLanes;
	}
	function checkIfRootIsPrerendering(root, renderLanes) {
	  return (
	    0 ===
	    (root.pendingLanes &
	      ~(root.suspendedLanes & ~root.pingedLanes) &
	      renderLanes)
	  );
	}
	function computeExpirationTime(lane, currentTime) {
	  switch (lane) {
	    case 1:
	    case 2:
	    case 4:
	    case 8:
	    case 64:
	      return currentTime + 250;
	    case 16:
	    case 32:
	    case 128:
	    case 256:
	    case 512:
	    case 1024:
	    case 2048:
	    case 4096:
	    case 8192:
	    case 16384:
	    case 32768:
	    case 65536:
	    case 131072:
	    case 262144:
	    case 524288:
	    case 1048576:
	    case 2097152:
	      return currentTime + 5e3;
	    case 4194304:
	    case 8388608:
	    case 16777216:
	    case 33554432:
	      return -1;
	    case 67108864:
	    case 134217728:
	    case 268435456:
	    case 536870912:
	    case 1073741824:
	      return -1;
	    default:
	      return -1;
	  }
	}
	function claimNextTransitionLane() {
	  var lane = nextTransitionLane;
	  nextTransitionLane <<= 1;
	  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
	  return lane;
	}
	function claimNextRetryLane() {
	  var lane = nextRetryLane;
	  nextRetryLane <<= 1;
	  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
	  return lane;
	}
	function createLaneMap(initial) {
	  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
	  return laneMap;
	}
	function markRootUpdated$1(root, updateLane) {
	  root.pendingLanes |= updateLane;
	  268435456 !== updateLane &&
	    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
	}
	function markRootFinished(
	  root,
	  finishedLanes,
	  remainingLanes,
	  spawnedLane,
	  updatedLanes,
	  suspendedRetryLanes
	) {
	  var previouslyPendingLanes = root.pendingLanes;
	  root.pendingLanes = remainingLanes;
	  root.suspendedLanes = 0;
	  root.pingedLanes = 0;
	  root.warmLanes = 0;
	  root.expiredLanes &= remainingLanes;
	  root.entangledLanes &= remainingLanes;
	  root.errorRecoveryDisabledLanes &= remainingLanes;
	  root.shellSuspendCounter = 0;
	  var entanglements = root.entanglements,
	    expirationTimes = root.expirationTimes,
	    hiddenUpdates = root.hiddenUpdates;
	  for (
	    remainingLanes = previouslyPendingLanes & ~remainingLanes;
	    0 < remainingLanes;

	  ) {
	    var index$5 = 31 - clz32(remainingLanes),
	      lane = 1 << index$5;
	    entanglements[index$5] = 0;
	    expirationTimes[index$5] = -1;
	    var hiddenUpdatesForLane = hiddenUpdates[index$5];
	    if (null !== hiddenUpdatesForLane)
	      for (
	        hiddenUpdates[index$5] = null, index$5 = 0;
	        index$5 < hiddenUpdatesForLane.length;
	        index$5++
	      ) {
	        var update = hiddenUpdatesForLane[index$5];
	        null !== update && (update.lane &= -536870913);
	      }
	    remainingLanes &= ~lane;
	  }
	  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
	  0 !== suspendedRetryLanes &&
	    0 === updatedLanes &&
	    0 !== root.tag &&
	    (root.suspendedLanes |=
	      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
	}
	function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
	  root.pendingLanes |= spawnedLane;
	  root.suspendedLanes &= ~spawnedLane;
	  var spawnedLaneIndex = 31 - clz32(spawnedLane);
	  root.entangledLanes |= spawnedLane;
	  root.entanglements[spawnedLaneIndex] =
	    root.entanglements[spawnedLaneIndex] |
	    1073741824 |
	    (entangledLanes & 4194090);
	}
	function markRootEntangled(root, entangledLanes) {
	  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
	  for (root = root.entanglements; rootEntangledLanes; ) {
	    var index$6 = 31 - clz32(rootEntangledLanes),
	      lane = 1 << index$6;
	    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&
	      (root[index$6] |= entangledLanes);
	    rootEntangledLanes &= ~lane;
	  }
	}
	function getBumpedLaneForHydrationByLane(lane) {
	  switch (lane) {
	    case 2:
	      lane = 1;
	      break;
	    case 8:
	      lane = 4;
	      break;
	    case 32:
	      lane = 16;
	      break;
	    case 256:
	    case 512:
	    case 1024:
	    case 2048:
	    case 4096:
	    case 8192:
	    case 16384:
	    case 32768:
	    case 65536:
	    case 131072:
	    case 262144:
	    case 524288:
	    case 1048576:
	    case 2097152:
	    case 4194304:
	    case 8388608:
	    case 16777216:
	    case 33554432:
	      lane = 128;
	      break;
	    case 268435456:
	      lane = 134217728;
	      break;
	    default:
	      lane = 0;
	  }
	  return lane;
	}
	function lanesToEventPriority(lanes) {
	  lanes &= -lanes;
	  return 2 < lanes
	    ? 8 < lanes
	      ? 0 !== (lanes & 134217727)
	        ? 32
	        : 268435456
	      : 8
	    : 2;
	}
	function resolveUpdatePriority() {
	  var updatePriority = ReactDOMSharedInternals.p;
	  if (0 !== updatePriority) return updatePriority;
	  updatePriority = window.event;
	  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
	}
	function runWithPriority(priority, fn) {
	  var previousPriority = ReactDOMSharedInternals.p;
	  try {
	    return (ReactDOMSharedInternals.p = priority), fn();
	  } finally {
	    ReactDOMSharedInternals.p = previousPriority;
	  }
	}
	var randomKey = Math.random().toString(36).slice(2),
	  internalInstanceKey = "__reactFiber$" + randomKey,
	  internalPropsKey = "__reactProps$" + randomKey,
	  internalContainerInstanceKey = "__reactContainer$" + randomKey,
	  internalEventHandlersKey = "__reactEvents$" + randomKey,
	  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
	  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
	  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
	  internalHoistableMarker = "__reactMarker$" + randomKey;
	function detachDeletedInstance(node) {
	  delete node[internalInstanceKey];
	  delete node[internalPropsKey];
	  delete node[internalEventHandlersKey];
	  delete node[internalEventHandlerListenersKey];
	  delete node[internalEventHandlesSetKey];
	}
	function getClosestInstanceFromNode(targetNode) {
	  var targetInst = targetNode[internalInstanceKey];
	  if (targetInst) return targetInst;
	  for (var parentNode = targetNode.parentNode; parentNode; ) {
	    if (
	      (targetInst =
	        parentNode[internalContainerInstanceKey] ||
	        parentNode[internalInstanceKey])
	    ) {
	      parentNode = targetInst.alternate;
	      if (
	        null !== targetInst.child ||
	        (null !== parentNode && null !== parentNode.child)
	      )
	        for (
	          targetNode = getParentSuspenseInstance(targetNode);
	          null !== targetNode;

	        ) {
	          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
	          targetNode = getParentSuspenseInstance(targetNode);
	        }
	      return targetInst;
	    }
	    targetNode = parentNode;
	    parentNode = targetNode.parentNode;
	  }
	  return null;
	}
	function getInstanceFromNode(node) {
	  if (
	    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
	  ) {
	    var tag = node.tag;
	    if (
	      5 === tag ||
	      6 === tag ||
	      13 === tag ||
	      26 === tag ||
	      27 === tag ||
	      3 === tag
	    )
	      return node;
	  }
	  return null;
	}
	function getNodeFromInstance(inst) {
	  var tag = inst.tag;
	  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
	  throw Error(formatProdErrorMessage$1(33));
	}
	function getResourcesFromRoot(root) {
	  var resources = root[internalRootNodeResourcesKey];
	  resources ||
	    (resources = root[internalRootNodeResourcesKey] =
	      { hoistableStyles: new Map(), hoistableScripts: new Map() });
	  return resources;
	}
	function markNodeAsHoistable(node) {
	  node[internalHoistableMarker] = !0;
	}
	var allNativeEvents = new Set(),
	  registrationNameDependencies = {};
	function registerTwoPhaseEvent(registrationName, dependencies) {
	  registerDirectEvent(registrationName, dependencies);
	  registerDirectEvent(registrationName + "Capture", dependencies);
	}
	function registerDirectEvent(registrationName, dependencies) {
	  registrationNameDependencies[registrationName] = dependencies;
	  for (
	    registrationName = 0;
	    registrationName < dependencies.length;
	    registrationName++
	  )
	    allNativeEvents.add(dependencies[registrationName]);
	}
	var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
	    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	  ),
	  illegalAttributeNameCache = {},
	  validatedAttributeNameCache = {};
	function isAttributeNameSafe(attributeName) {
	  if (hasOwnProperty$2.call(validatedAttributeNameCache, attributeName))
	    return !0;
	  if (hasOwnProperty$2.call(illegalAttributeNameCache, attributeName)) return !1;
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
	    return (validatedAttributeNameCache[attributeName] = !0);
	  illegalAttributeNameCache[attributeName] = !0;
	  return !1;
	}
	function setValueForAttribute(node, name, value) {
	  if (isAttributeNameSafe(name))
	    if (null === value) node.removeAttribute(name);
	    else {
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	          node.removeAttribute(name);
	          return;
	        case "boolean":
	          var prefix$8 = name.toLowerCase().slice(0, 5);
	          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
	            node.removeAttribute(name);
	            return;
	          }
	      }
	      node.setAttribute(name, "" + value);
	    }
	}
	function setValueForKnownAttribute(node, name, value) {
	  if (null === value) node.removeAttribute(name);
	  else {
	    switch (typeof value) {
	      case "undefined":
	      case "function":
	      case "symbol":
	      case "boolean":
	        node.removeAttribute(name);
	        return;
	    }
	    node.setAttribute(name, "" + value);
	  }
	}
	function setValueForNamespacedAttribute(node, namespace, name, value) {
	  if (null === value) node.removeAttribute(name);
	  else {
	    switch (typeof value) {
	      case "undefined":
	      case "function":
	      case "symbol":
	      case "boolean":
	        node.removeAttribute(name);
	        return;
	    }
	    node.setAttributeNS(namespace, name, "" + value);
	  }
	}
	var prefix, suffix;
	function describeBuiltInComponentFrame(name) {
	  if (void 0 === prefix)
	    try {
	      throw Error();
	    } catch (x) {
	      var match = x.stack.trim().match(/\n( *(at )?)/);
	      prefix = (match && match[1]) || "";
	      suffix =
	        -1 < x.stack.indexOf("\n    at")
	          ? " (<anonymous>)"
	          : -1 < x.stack.indexOf("@")
	            ? "@unknown:0:0"
	            : "";
	    }
	  return "\n" + prefix + name + suffix;
	}
	var reentry = !1;
	function describeNativeComponentFrame(fn, construct) {
	  if (!fn || reentry) return "";
	  reentry = !0;
	  var previousPrepareStackTrace = Error.prepareStackTrace;
	  Error.prepareStackTrace = void 0;
	  try {
	    var RunInRootFrame = {
	      DetermineComponentFrameRoot: function () {
	        try {
	          if (construct) {
	            var Fake = function () {
	              throw Error();
	            };
	            Object.defineProperty(Fake.prototype, "props", {
	              set: function () {
	                throw Error();
	              }
	            });
	            if ("object" === typeof Reflect && Reflect.construct) {
	              try {
	                Reflect.construct(Fake, []);
	              } catch (x) {
	                var control = x;
	              }
	              Reflect.construct(fn, [], Fake);
	            } else {
	              try {
	                Fake.call();
	              } catch (x$9) {
	                control = x$9;
	              }
	              fn.call(Fake.prototype);
	            }
	          } else {
	            try {
	              throw Error();
	            } catch (x$10) {
	              control = x$10;
	            }
	            (Fake = fn()) &&
	              "function" === typeof Fake.catch &&
	              Fake.catch(function () {});
	          }
	        } catch (sample) {
	          if (sample && control && "string" === typeof sample.stack)
	            return [sample.stack, control.stack];
	        }
	        return [null, null];
	      }
	    };
	    RunInRootFrame.DetermineComponentFrameRoot.displayName =
	      "DetermineComponentFrameRoot";
	    var namePropDescriptor = Object.getOwnPropertyDescriptor(
	      RunInRootFrame.DetermineComponentFrameRoot,
	      "name"
	    );
	    namePropDescriptor &&
	      namePropDescriptor.configurable &&
	      Object.defineProperty(
	        RunInRootFrame.DetermineComponentFrameRoot,
	        "name",
	        { value: "DetermineComponentFrameRoot" }
	      );
	    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
	      sampleStack = _RunInRootFrame$Deter[0],
	      controlStack = _RunInRootFrame$Deter[1];
	    if (sampleStack && controlStack) {
	      var sampleLines = sampleStack.split("\n"),
	        controlLines = controlStack.split("\n");
	      for (
	        namePropDescriptor = RunInRootFrame = 0;
	        RunInRootFrame < sampleLines.length &&
	        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

	      )
	        RunInRootFrame++;
	      for (
	        ;
	        namePropDescriptor < controlLines.length &&
	        !controlLines[namePropDescriptor].includes(
	          "DetermineComponentFrameRoot"
	        );

	      )
	        namePropDescriptor++;
	      if (
	        RunInRootFrame === sampleLines.length ||
	        namePropDescriptor === controlLines.length
	      )
	        for (
	          RunInRootFrame = sampleLines.length - 1,
	            namePropDescriptor = controlLines.length - 1;
	          1 <= RunInRootFrame &&
	          0 <= namePropDescriptor &&
	          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

	        )
	          namePropDescriptor--;
	      for (
	        ;
	        1 <= RunInRootFrame && 0 <= namePropDescriptor;
	        RunInRootFrame--, namePropDescriptor--
	      )
	        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
	          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
	            do
	              if (
	                (RunInRootFrame--,
	                namePropDescriptor--,
	                0 > namePropDescriptor ||
	                  sampleLines[RunInRootFrame] !==
	                    controlLines[namePropDescriptor])
	              ) {
	                var frame =
	                  "\n" +
	                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
	                fn.displayName &&
	                  frame.includes("<anonymous>") &&
	                  (frame = frame.replace("<anonymous>", fn.displayName));
	                return frame;
	              }
	            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
	          }
	          break;
	        }
	    }
	  } finally {
	    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
	  }
	  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
	    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
	    : "";
	}
	function describeFiber(fiber) {
	  switch (fiber.tag) {
	    case 26:
	    case 27:
	    case 5:
	      return describeBuiltInComponentFrame(fiber.type);
	    case 16:
	      return describeBuiltInComponentFrame("Lazy");
	    case 13:
	      return describeBuiltInComponentFrame("Suspense");
	    case 19:
	      return describeBuiltInComponentFrame("SuspenseList");
	    case 0:
	    case 15:
	      return describeNativeComponentFrame(fiber.type, !1);
	    case 11:
	      return describeNativeComponentFrame(fiber.type.render, !1);
	    case 1:
	      return describeNativeComponentFrame(fiber.type, !0);
	    case 31:
	      return describeBuiltInComponentFrame("Activity");
	    default:
	      return "";
	  }
	}
	function getStackByFiberInDevAndProd(workInProgress) {
	  try {
	    var info = "";
	    do
	      (info += describeFiber(workInProgress)),
	        (workInProgress = workInProgress.return);
	    while (workInProgress);
	    return info;
	  } catch (x) {
	    return "\nError generating stack: " + x.message + "\n" + x.stack;
	  }
	}
	function getToStringValue(value) {
	  switch (typeof value) {
	    case "bigint":
	    case "boolean":
	    case "number":
	    case "string":
	    case "undefined":
	      return value;
	    case "object":
	      return value;
	    default:
	      return "";
	  }
	}
	function isCheckable(elem) {
	  var type = elem.type;
	  return (
	    (elem = elem.nodeName) &&
	    "input" === elem.toLowerCase() &&
	    ("checkbox" === type || "radio" === type)
	  );
	}
	function trackValueOnNode(node) {
	  var valueField = isCheckable(node) ? "checked" : "value",
	    descriptor = Object.getOwnPropertyDescriptor(
	      node.constructor.prototype,
	      valueField
	    ),
	    currentValue = "" + node[valueField];
	  if (
	    !node.hasOwnProperty(valueField) &&
	    "undefined" !== typeof descriptor &&
	    "function" === typeof descriptor.get &&
	    "function" === typeof descriptor.set
	  ) {
	    var get = descriptor.get,
	      set = descriptor.set;
	    Object.defineProperty(node, valueField, {
	      configurable: !0,
	      get: function () {
	        return get.call(this);
	      },
	      set: function (value) {
	        currentValue = "" + value;
	        set.call(this, value);
	      }
	    });
	    Object.defineProperty(node, valueField, {
	      enumerable: descriptor.enumerable
	    });
	    return {
	      getValue: function () {
	        return currentValue;
	      },
	      setValue: function (value) {
	        currentValue = "" + value;
	      },
	      stopTracking: function () {
	        node._valueTracker = null;
	        delete node[valueField];
	      }
	    };
	  }
	}
	function track(node) {
	  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
	}
	function updateValueIfChanged(node) {
	  if (!node) return !1;
	  var tracker = node._valueTracker;
	  if (!tracker) return !0;
	  var lastValue = tracker.getValue();
	  var value = "";
	  node &&
	    (value = isCheckable(node)
	      ? node.checked
	        ? "true"
	        : "false"
	      : node.value);
	  node = value;
	  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
	}
	function getActiveElement(doc) {
	  doc = doc || ("undefined" !== typeof document ? document : void 0);
	  if ("undefined" === typeof doc) return null;
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}
	var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
	function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
	  return value.replace(
	    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
	    function (ch) {
	      return "\\" + ch.charCodeAt(0).toString(16) + " ";
	    }
	  );
	}
	function updateInput(
	  element,
	  value,
	  defaultValue,
	  lastDefaultValue,
	  checked,
	  defaultChecked,
	  type,
	  name
	) {
	  element.name = "";
	  null != type &&
	  "function" !== typeof type &&
	  "symbol" !== typeof type &&
	  "boolean" !== typeof type
	    ? (element.type = type)
	    : element.removeAttribute("type");
	  if (null != value)
	    if ("number" === type) {
	      if ((0 === value && "" === element.value) || element.value != value)
	        element.value = "" + getToStringValue(value);
	    } else
	      element.value !== "" + getToStringValue(value) &&
	        (element.value = "" + getToStringValue(value));
	  else
	    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
	  null != value
	    ? setDefaultValue(element, type, getToStringValue(value))
	    : null != defaultValue
	      ? setDefaultValue(element, type, getToStringValue(defaultValue))
	      : null != lastDefaultValue && element.removeAttribute("value");
	  null == checked &&
	    null != defaultChecked &&
	    (element.defaultChecked = !!defaultChecked);
	  null != checked &&
	    (element.checked =
	      checked && "function" !== typeof checked && "symbol" !== typeof checked);
	  null != name &&
	  "function" !== typeof name &&
	  "symbol" !== typeof name &&
	  "boolean" !== typeof name
	    ? (element.name = "" + getToStringValue(name))
	    : element.removeAttribute("name");
	}
	function initInput(
	  element,
	  value,
	  defaultValue,
	  checked,
	  defaultChecked,
	  type,
	  name,
	  isHydrating
	) {
	  null != type &&
	    "function" !== typeof type &&
	    "symbol" !== typeof type &&
	    "boolean" !== typeof type &&
	    (element.type = type);
	  if (null != value || null != defaultValue) {
	    if (
	      !(
	        ("submit" !== type && "reset" !== type) ||
	        (void 0 !== value && null !== value)
	      )
	    )
	      return;
	    defaultValue =
	      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	    value = null != value ? "" + getToStringValue(value) : defaultValue;
	    isHydrating || value === element.value || (element.value = value);
	    element.defaultValue = value;
	  }
	  checked = null != checked ? checked : defaultChecked;
	  checked =
	    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
	  element.checked = isHydrating ? element.checked : !!checked;
	  element.defaultChecked = !!checked;
	  null != name &&
	    "function" !== typeof name &&
	    "symbol" !== typeof name &&
	    "boolean" !== typeof name &&
	    (element.name = name);
	}
	function setDefaultValue(node, type, value) {
	  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
	    node.defaultValue === "" + value ||
	    (node.defaultValue = "" + value);
	}
	function updateOptions(node, multiple, propValue, setDefaultSelected) {
	  node = node.options;
	  if (multiple) {
	    multiple = {};
	    for (var i = 0; i < propValue.length; i++)
	      multiple["$" + propValue[i]] = !0;
	    for (propValue = 0; propValue < node.length; propValue++)
	      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
	        node[propValue].selected !== i && (node[propValue].selected = i),
	        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
	  } else {
	    propValue = "" + getToStringValue(propValue);
	    multiple = null;
	    for (i = 0; i < node.length; i++) {
	      if (node[i].value === propValue) {
	        node[i].selected = !0;
	        setDefaultSelected && (node[i].defaultSelected = !0);
	        return;
	      }
	      null !== multiple || node[i].disabled || (multiple = node[i]);
	    }
	    null !== multiple && (multiple.selected = !0);
	  }
	}
	function updateTextarea(element, value, defaultValue) {
	  if (
	    null != value &&
	    ((value = "" + getToStringValue(value)),
	    value !== element.value && (element.value = value),
	    null == defaultValue)
	  ) {
	    element.defaultValue !== value && (element.defaultValue = value);
	    return;
	  }
	  element.defaultValue =
	    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	}
	function initTextarea(element, value, defaultValue, children) {
	  if (null == value) {
	    if (null != children) {
	      if (null != defaultValue) throw Error(formatProdErrorMessage$1(92));
	      if (isArrayImpl(children)) {
	        if (1 < children.length) throw Error(formatProdErrorMessage$1(93));
	        children = children[0];
	      }
	      defaultValue = children;
	    }
	    null == defaultValue && (defaultValue = "");
	    value = defaultValue;
	  }
	  defaultValue = getToStringValue(value);
	  element.defaultValue = defaultValue;
	  children = element.textContent;
	  children === defaultValue &&
	    "" !== children &&
	    null !== children &&
	    (element.value = children);
	}
	function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	    if (
	      firstChild &&
	      firstChild === node.lastChild &&
	      3 === firstChild.nodeType
	    ) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	}
	var unitlessNumbers = new Set(
	  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
	    " "
	  )
	);
	function setValueForStyle(style, styleName, value) {
	  var isCustomProperty = 0 === styleName.indexOf("--");
	  null == value || "boolean" === typeof value || "" === value
	    ? isCustomProperty
	      ? style.setProperty(styleName, "")
	      : "float" === styleName
	        ? (style.cssFloat = "")
	        : (style[styleName] = "")
	    : isCustomProperty
	      ? style.setProperty(styleName, value)
	      : "number" !== typeof value ||
	          0 === value ||
	          unitlessNumbers.has(styleName)
	        ? "float" === styleName
	          ? (style.cssFloat = value)
	          : (style[styleName] = ("" + value).trim())
	        : (style[styleName] = value + "px");
	}
	function setValueForStyles(node, styles, prevStyles) {
	  if (null != styles && "object" !== typeof styles)
	    throw Error(formatProdErrorMessage$1(62));
	  node = node.style;
	  if (null != prevStyles) {
	    for (var styleName in prevStyles)
	      !prevStyles.hasOwnProperty(styleName) ||
	        (null != styles && styles.hasOwnProperty(styleName)) ||
	        (0 === styleName.indexOf("--")
	          ? node.setProperty(styleName, "")
	          : "float" === styleName
	            ? (node.cssFloat = "")
	            : (node[styleName] = ""));
	    for (var styleName$16 in styles)
	      (styleName = styles[styleName$16]),
	        styles.hasOwnProperty(styleName$16) &&
	          prevStyles[styleName$16] !== styleName &&
	          setValueForStyle(node, styleName$16, styleName);
	  } else
	    for (var styleName$17 in styles)
	      styles.hasOwnProperty(styleName$17) &&
	        setValueForStyle(node, styleName$17, styles[styleName$17]);
	}
	function isCustomElement(tagName) {
	  if (-1 === tagName.indexOf("-")) return !1;
	  switch (tagName) {
	    case "annotation-xml":
	    case "color-profile":
	    case "font-face":
	    case "font-face-src":
	    case "font-face-uri":
	    case "font-face-format":
	    case "font-face-name":
	    case "missing-glyph":
	      return !1;
	    default:
	      return !0;
	  }
	}
	var aliases = new Map([
	    ["acceptCharset", "accept-charset"],
	    ["htmlFor", "for"],
	    ["httpEquiv", "http-equiv"],
	    ["crossOrigin", "crossorigin"],
	    ["accentHeight", "accent-height"],
	    ["alignmentBaseline", "alignment-baseline"],
	    ["arabicForm", "arabic-form"],
	    ["baselineShift", "baseline-shift"],
	    ["capHeight", "cap-height"],
	    ["clipPath", "clip-path"],
	    ["clipRule", "clip-rule"],
	    ["colorInterpolation", "color-interpolation"],
	    ["colorInterpolationFilters", "color-interpolation-filters"],
	    ["colorProfile", "color-profile"],
	    ["colorRendering", "color-rendering"],
	    ["dominantBaseline", "dominant-baseline"],
	    ["enableBackground", "enable-background"],
	    ["fillOpacity", "fill-opacity"],
	    ["fillRule", "fill-rule"],
	    ["floodColor", "flood-color"],
	    ["floodOpacity", "flood-opacity"],
	    ["fontFamily", "font-family"],
	    ["fontSize", "font-size"],
	    ["fontSizeAdjust", "font-size-adjust"],
	    ["fontStretch", "font-stretch"],
	    ["fontStyle", "font-style"],
	    ["fontVariant", "font-variant"],
	    ["fontWeight", "font-weight"],
	    ["glyphName", "glyph-name"],
	    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
	    ["glyphOrientationVertical", "glyph-orientation-vertical"],
	    ["horizAdvX", "horiz-adv-x"],
	    ["horizOriginX", "horiz-origin-x"],
	    ["imageRendering", "image-rendering"],
	    ["letterSpacing", "letter-spacing"],
	    ["lightingColor", "lighting-color"],
	    ["markerEnd", "marker-end"],
	    ["markerMid", "marker-mid"],
	    ["markerStart", "marker-start"],
	    ["overlinePosition", "overline-position"],
	    ["overlineThickness", "overline-thickness"],
	    ["paintOrder", "paint-order"],
	    ["panose-1", "panose-1"],
	    ["pointerEvents", "pointer-events"],
	    ["renderingIntent", "rendering-intent"],
	    ["shapeRendering", "shape-rendering"],
	    ["stopColor", "stop-color"],
	    ["stopOpacity", "stop-opacity"],
	    ["strikethroughPosition", "strikethrough-position"],
	    ["strikethroughThickness", "strikethrough-thickness"],
	    ["strokeDasharray", "stroke-dasharray"],
	    ["strokeDashoffset", "stroke-dashoffset"],
	    ["strokeLinecap", "stroke-linecap"],
	    ["strokeLinejoin", "stroke-linejoin"],
	    ["strokeMiterlimit", "stroke-miterlimit"],
	    ["strokeOpacity", "stroke-opacity"],
	    ["strokeWidth", "stroke-width"],
	    ["textAnchor", "text-anchor"],
	    ["textDecoration", "text-decoration"],
	    ["textRendering", "text-rendering"],
	    ["transformOrigin", "transform-origin"],
	    ["underlinePosition", "underline-position"],
	    ["underlineThickness", "underline-thickness"],
	    ["unicodeBidi", "unicode-bidi"],
	    ["unicodeRange", "unicode-range"],
	    ["unitsPerEm", "units-per-em"],
	    ["vAlphabetic", "v-alphabetic"],
	    ["vHanging", "v-hanging"],
	    ["vIdeographic", "v-ideographic"],
	    ["vMathematical", "v-mathematical"],
	    ["vectorEffect", "vector-effect"],
	    ["vertAdvY", "vert-adv-y"],
	    ["vertOriginX", "vert-origin-x"],
	    ["vertOriginY", "vert-origin-y"],
	    ["wordSpacing", "word-spacing"],
	    ["writingMode", "writing-mode"],
	    ["xmlnsXlink", "xmlns:xlink"],
	    ["xHeight", "x-height"]
	  ]),
	  isJavaScriptProtocol =
	    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function sanitizeURL(url) {
	  return isJavaScriptProtocol.test("" + url)
	    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
	    : url;
	}
	var currentReplayingEvent = null;
	function getEventTarget(nativeEvent) {
	  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
	  nativeEvent.correspondingUseElement &&
	    (nativeEvent = nativeEvent.correspondingUseElement);
	  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
	}
	var restoreTarget = null,
	  restoreQueue = null;
	function restoreStateOfTarget(target) {
	  var internalInstance = getInstanceFromNode(target);
	  if (internalInstance && (target = internalInstance.stateNode)) {
	    var props = target[internalPropsKey] || null;
	    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
	      case "input":
	        updateInput(
	          target,
	          props.value,
	          props.defaultValue,
	          props.defaultValue,
	          props.checked,
	          props.defaultChecked,
	          props.type,
	          props.name
	        );
	        internalInstance = props.name;
	        if ("radio" === props.type && null != internalInstance) {
	          for (props = target; props.parentNode; ) props = props.parentNode;
	          props = props.querySelectorAll(
	            'input[name="' +
	              escapeSelectorAttributeValueInsideDoubleQuotes(
	                "" + internalInstance
	              ) +
	              '"][type="radio"]'
	          );
	          for (
	            internalInstance = 0;
	            internalInstance < props.length;
	            internalInstance++
	          ) {
	            var otherNode = props[internalInstance];
	            if (otherNode !== target && otherNode.form === target.form) {
	              var otherProps = otherNode[internalPropsKey] || null;
	              if (!otherProps) throw Error(formatProdErrorMessage$1(90));
	              updateInput(
	                otherNode,
	                otherProps.value,
	                otherProps.defaultValue,
	                otherProps.defaultValue,
	                otherProps.checked,
	                otherProps.defaultChecked,
	                otherProps.type,
	                otherProps.name
	              );
	            }
	          }
	          for (
	            internalInstance = 0;
	            internalInstance < props.length;
	            internalInstance++
	          )
	            (otherNode = props[internalInstance]),
	              otherNode.form === target.form && updateValueIfChanged(otherNode);
	        }
	        break a;
	      case "textarea":
	        updateTextarea(target, props.value, props.defaultValue);
	        break a;
	      case "select":
	        (internalInstance = props.value),
	          null != internalInstance &&
	            updateOptions(target, !!props.multiple, internalInstance, !1);
	    }
	  }
	}
	var isInsideEventHandler = !1;
	function batchedUpdates$1(fn, a, b) {
	  if (isInsideEventHandler) return fn(a, b);
	  isInsideEventHandler = !0;
	  try {
	    var JSCompiler_inline_result = fn(a);
	    return JSCompiler_inline_result;
	  } finally {
	    if (
	      ((isInsideEventHandler = !1),
	      null !== restoreTarget || null !== restoreQueue)
	    )
	      if (
	        (flushSyncWork$1(),
	        restoreTarget &&
	          ((a = restoreTarget),
	          (fn = restoreQueue),
	          (restoreQueue = restoreTarget = null),
	          restoreStateOfTarget(a),
	          fn))
	      )
	        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
	  }
	}
	function getListener(inst, registrationName) {
	  var stateNode = inst.stateNode;
	  if (null === stateNode) return null;
	  var props = stateNode[internalPropsKey] || null;
	  if (null === props) return null;
	  stateNode = props[registrationName];
	  a: switch (registrationName) {
	    case "onClick":
	    case "onClickCapture":
	    case "onDoubleClick":
	    case "onDoubleClickCapture":
	    case "onMouseDown":
	    case "onMouseDownCapture":
	    case "onMouseMove":
	    case "onMouseMoveCapture":
	    case "onMouseUp":
	    case "onMouseUpCapture":
	    case "onMouseEnter":
	      (props = !props.disabled) ||
	        ((inst = inst.type),
	        (props = !(
	          "button" === inst ||
	          "input" === inst ||
	          "select" === inst ||
	          "textarea" === inst
	        )));
	      inst = !props;
	      break a;
	    default:
	      inst = !1;
	  }
	  if (inst) return null;
	  if (stateNode && "function" !== typeof stateNode)
	    throw Error(
	      formatProdErrorMessage$1(231, registrationName, typeof stateNode)
	    );
	  return stateNode;
	}
	var canUseDOM$1 = !(
	    "undefined" === typeof window ||
	    "undefined" === typeof window.document ||
	    "undefined" === typeof window.document.createElement
	  ),
	  passiveBrowserEventsSupported = !1;
	if (canUseDOM$1)
	  try {
	    var options = {};
	    Object.defineProperty(options, "passive", {
	      get: function () {
	        passiveBrowserEventsSupported = !0;
	      }
	    });
	    window.addEventListener("test", options, options);
	    window.removeEventListener("test", options, options);
	  } catch (e) {
	    passiveBrowserEventsSupported = !1;
	  }
	var root$2 = null,
	  startText = null,
	  fallbackText = null;
	function getData() {
	  if (fallbackText) return fallbackText;
	  var start,
	    startValue = startText,
	    startLength = startValue.length,
	    end,
	    endValue = "value" in root$2 ? root$2.value : root$2.textContent,
	    endLength = endValue.length;
	  for (
	    start = 0;
	    start < startLength && startValue[start] === endValue[start];
	    start++
	  );
	  var minEnd = startLength - start;
	  for (
	    end = 1;
	    end <= minEnd &&
	    startValue[startLength - end] === endValue[endLength - end];
	    end++
	  );
	  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
	}
	function getEventCharCode(nativeEvent) {
	  var keyCode = nativeEvent.keyCode;
	  "charCode" in nativeEvent
	    ? ((nativeEvent = nativeEvent.charCode),
	      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
	    : (nativeEvent = keyCode);
	  10 === nativeEvent && (nativeEvent = 13);
	  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
	}
	function functionThatReturnsTrue() {
	  return !0;
	}
	function functionThatReturnsFalse() {
	  return !1;
	}
	function createSyntheticEvent(Interface) {
	  function SyntheticBaseEvent(
	    reactName,
	    reactEventType,
	    targetInst,
	    nativeEvent,
	    nativeEventTarget
	  ) {
	    this._reactName = reactName;
	    this._targetInst = targetInst;
	    this.type = reactEventType;
	    this.nativeEvent = nativeEvent;
	    this.target = nativeEventTarget;
	    this.currentTarget = null;
	    for (var propName in Interface)
	      Interface.hasOwnProperty(propName) &&
	        ((reactName = Interface[propName]),
	        (this[propName] = reactName
	          ? reactName(nativeEvent)
	          : nativeEvent[propName]));
	    this.isDefaultPrevented = (
	      null != nativeEvent.defaultPrevented
	        ? nativeEvent.defaultPrevented
	        : !1 === nativeEvent.returnValue
	    )
	      ? functionThatReturnsTrue
	      : functionThatReturnsFalse;
	    this.isPropagationStopped = functionThatReturnsFalse;
	    return this;
	  }
	  assign(SyntheticBaseEvent.prototype, {
	    preventDefault: function () {
	      this.defaultPrevented = !0;
	      var event = this.nativeEvent;
	      event &&
	        (event.preventDefault
	          ? event.preventDefault()
	          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
	        (this.isDefaultPrevented = functionThatReturnsTrue));
	    },
	    stopPropagation: function () {
	      var event = this.nativeEvent;
	      event &&
	        (event.stopPropagation
	          ? event.stopPropagation()
	          : "unknown" !== typeof event.cancelBubble &&
	            (event.cancelBubble = !0),
	        (this.isPropagationStopped = functionThatReturnsTrue));
	    },
	    persist: function () {},
	    isPersistent: functionThatReturnsTrue
	  });
	  return SyntheticBaseEvent;
	}
	var EventInterface = {
	    eventPhase: 0,
	    bubbles: 0,
	    cancelable: 0,
	    timeStamp: function (event) {
	      return event.timeStamp || Date.now();
	    },
	    defaultPrevented: 0,
	    isTrusted: 0
	  },
	  SyntheticEvent = createSyntheticEvent(EventInterface),
	  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
	  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
	  lastMovementX,
	  lastMovementY,
	  lastMouseEvent,
	  MouseEventInterface = assign({}, UIEventInterface, {
	    screenX: 0,
	    screenY: 0,
	    clientX: 0,
	    clientY: 0,
	    pageX: 0,
	    pageY: 0,
	    ctrlKey: 0,
	    shiftKey: 0,
	    altKey: 0,
	    metaKey: 0,
	    getModifierState: getEventModifierState,
	    button: 0,
	    buttons: 0,
	    relatedTarget: function (event) {
	      return void 0 === event.relatedTarget
	        ? event.fromElement === event.srcElement
	          ? event.toElement
	          : event.fromElement
	        : event.relatedTarget;
	    },
	    movementX: function (event) {
	      if ("movementX" in event) return event.movementX;
	      event !== lastMouseEvent &&
	        (lastMouseEvent && "mousemove" === event.type
	          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
	            (lastMovementY = event.screenY - lastMouseEvent.screenY))
	          : (lastMovementY = lastMovementX = 0),
	        (lastMouseEvent = event));
	      return lastMovementX;
	    },
	    movementY: function (event) {
	      return "movementY" in event ? event.movementY : lastMovementY;
	    }
	  }),
	  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
	  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
	  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
	  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
	  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
	  AnimationEventInterface = assign({}, EventInterface, {
	    animationName: 0,
	    elapsedTime: 0,
	    pseudoElement: 0
	  }),
	  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
	  ClipboardEventInterface = assign({}, EventInterface, {
	    clipboardData: function (event) {
	      return "clipboardData" in event
	        ? event.clipboardData
	        : window.clipboardData;
	    }
	  }),
	  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
	  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
	  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
	  normalizeKey = {
	    Esc: "Escape",
	    Spacebar: " ",
	    Left: "ArrowLeft",
	    Up: "ArrowUp",
	    Right: "ArrowRight",
	    Down: "ArrowDown",
	    Del: "Delete",
	    Win: "OS",
	    Menu: "ContextMenu",
	    Apps: "ContextMenu",
	    Scroll: "ScrollLock",
	    MozPrintableKey: "Unidentified"
	  },
	  translateToKey = {
	    8: "Backspace",
	    9: "Tab",
	    12: "Clear",
	    13: "Enter",
	    16: "Shift",
	    17: "Control",
	    18: "Alt",
	    19: "Pause",
	    20: "CapsLock",
	    27: "Escape",
	    32: " ",
	    33: "PageUp",
	    34: "PageDown",
	    35: "End",
	    36: "Home",
	    37: "ArrowLeft",
	    38: "ArrowUp",
	    39: "ArrowRight",
	    40: "ArrowDown",
	    45: "Insert",
	    46: "Delete",
	    112: "F1",
	    113: "F2",
	    114: "F3",
	    115: "F4",
	    116: "F5",
	    117: "F6",
	    118: "F7",
	    119: "F8",
	    120: "F9",
	    121: "F10",
	    122: "F11",
	    123: "F12",
	    144: "NumLock",
	    145: "ScrollLock",
	    224: "Meta"
	  },
	  modifierKeyToProp = {
	    Alt: "altKey",
	    Control: "ctrlKey",
	    Meta: "metaKey",
	    Shift: "shiftKey"
	  };
	function modifierStateGetter(keyArg) {
	  var nativeEvent = this.nativeEvent;
	  return nativeEvent.getModifierState
	    ? nativeEvent.getModifierState(keyArg)
	    : (keyArg = modifierKeyToProp[keyArg])
	      ? !!nativeEvent[keyArg]
	      : !1;
	}
	function getEventModifierState() {
	  return modifierStateGetter;
	}
	var KeyboardEventInterface = assign({}, UIEventInterface, {
	    key: function (nativeEvent) {
	      if (nativeEvent.key) {
	        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	        if ("Unidentified" !== key) return key;
	      }
	      return "keypress" === nativeEvent.type
	        ? ((nativeEvent = getEventCharCode(nativeEvent)),
	          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
	        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
	          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
	          : "";
	    },
	    code: 0,
	    location: 0,
	    ctrlKey: 0,
	    shiftKey: 0,
	    altKey: 0,
	    metaKey: 0,
	    repeat: 0,
	    locale: 0,
	    getModifierState: getEventModifierState,
	    charCode: function (event) {
	      return "keypress" === event.type ? getEventCharCode(event) : 0;
	    },
	    keyCode: function (event) {
	      return "keydown" === event.type || "keyup" === event.type
	        ? event.keyCode
	        : 0;
	    },
	    which: function (event) {
	      return "keypress" === event.type
	        ? getEventCharCode(event)
	        : "keydown" === event.type || "keyup" === event.type
	          ? event.keyCode
	          : 0;
	    }
	  }),
	  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
	  PointerEventInterface = assign({}, MouseEventInterface, {
	    pointerId: 0,
	    width: 0,
	    height: 0,
	    pressure: 0,
	    tangentialPressure: 0,
	    tiltX: 0,
	    tiltY: 0,
	    twist: 0,
	    pointerType: 0,
	    isPrimary: 0
	  }),
	  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
	  TouchEventInterface = assign({}, UIEventInterface, {
	    touches: 0,
	    targetTouches: 0,
	    changedTouches: 0,
	    altKey: 0,
	    metaKey: 0,
	    ctrlKey: 0,
	    shiftKey: 0,
	    getModifierState: getEventModifierState
	  }),
	  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
	  TransitionEventInterface = assign({}, EventInterface, {
	    propertyName: 0,
	    elapsedTime: 0,
	    pseudoElement: 0
	  }),
	  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
	  WheelEventInterface = assign({}, MouseEventInterface, {
	    deltaX: function (event) {
	      return "deltaX" in event
	        ? event.deltaX
	        : "wheelDeltaX" in event
	          ? -event.wheelDeltaX
	          : 0;
	    },
	    deltaY: function (event) {
	      return "deltaY" in event
	        ? event.deltaY
	        : "wheelDeltaY" in event
	          ? -event.wheelDeltaY
	          : "wheelDelta" in event
	            ? -event.wheelDelta
	            : 0;
	    },
	    deltaZ: 0,
	    deltaMode: 0
	  }),
	  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
	  ToggleEventInterface = assign({}, EventInterface, {
	    newState: 0,
	    oldState: 0
	  }),
	  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
	  END_KEYCODES = [9, 13, 27, 32],
	  canUseCompositionEvent = canUseDOM$1 && "CompositionEvent" in window,
	  documentMode = null;
	canUseDOM$1 &&
	  "documentMode" in document &&
	  (documentMode = document.documentMode);
	var canUseTextInputEvent = canUseDOM$1 && "TextEvent" in window && !documentMode,
	  useFallbackCompositionData =
	    canUseDOM$1 &&
	    (!canUseCompositionEvent ||
	      (documentMode && 8 < documentMode && 11 >= documentMode)),
	  SPACEBAR_CHAR = String.fromCharCode(32),
	  hasSpaceKeypress = !1;
	function isFallbackCompositionEnd(domEventName, nativeEvent) {
	  switch (domEventName) {
	    case "keyup":
	      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
	    case "keydown":
	      return 229 !== nativeEvent.keyCode;
	    case "keypress":
	    case "mousedown":
	    case "focusout":
	      return !0;
	    default:
	      return !1;
	  }
	}
	function getDataFromCustomEvent(nativeEvent) {
	  nativeEvent = nativeEvent.detail;
	  return "object" === typeof nativeEvent && "data" in nativeEvent
	    ? nativeEvent.data
	    : null;
	}
	var isComposing = !1;
	function getNativeBeforeInputChars(domEventName, nativeEvent) {
	  switch (domEventName) {
	    case "compositionend":
	      return getDataFromCustomEvent(nativeEvent);
	    case "keypress":
	      if (32 !== nativeEvent.which) return null;
	      hasSpaceKeypress = !0;
	      return SPACEBAR_CHAR;
	    case "textInput":
	      return (
	        (domEventName = nativeEvent.data),
	        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
	      );
	    default:
	      return null;
	  }
	}
	function getFallbackBeforeInputChars(domEventName, nativeEvent) {
	  if (isComposing)
	    return "compositionend" === domEventName ||
	      (!canUseCompositionEvent &&
	        isFallbackCompositionEnd(domEventName, nativeEvent))
	      ? ((domEventName = getData()),
	        (fallbackText = startText = root$2 = null),
	        (isComposing = !1),
	        domEventName)
	      : null;
	  switch (domEventName) {
	    case "paste":
	      return null;
	    case "keypress":
	      if (
	        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
	        (nativeEvent.ctrlKey && nativeEvent.altKey)
	      ) {
	        if (nativeEvent.char && 1 < nativeEvent.char.length)
	          return nativeEvent.char;
	        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case "compositionend":
	      return useFallbackCompositionData && "ko" !== nativeEvent.locale
	        ? null
	        : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	var supportedInputTypes = {
	  color: !0,
	  date: !0,
	  datetime: !0,
	  "datetime-local": !0,
	  email: !0,
	  month: !0,
	  number: !0,
	  password: !0,
	  range: !0,
	  search: !0,
	  tel: !0,
	  text: !0,
	  time: !0,
	  url: !0,
	  week: !0
	};
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return "input" === nodeName
	    ? !!supportedInputTypes[elem.type]
	    : "textarea" === nodeName
	      ? !0
	      : !1;
	}
	function createAndAccumulateChangeEvent(
	  dispatchQueue,
	  inst,
	  nativeEvent,
	  target
	) {
	  restoreTarget
	    ? restoreQueue
	      ? restoreQueue.push(target)
	      : (restoreQueue = [target])
	    : (restoreTarget = target);
	  inst = accumulateTwoPhaseListeners(inst, "onChange");
	  0 < inst.length &&
	    ((nativeEvent = new SyntheticEvent(
	      "onChange",
	      "change",
	      null,
	      nativeEvent,
	      target
	    )),
	    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
	}
	var activeElement$1 = null,
	  activeElementInst$1 = null;
	function runEventInBatch(dispatchQueue) {
	  processDispatchQueue(dispatchQueue, 0);
	}
	function getInstIfValueChanged(targetInst) {
	  var targetNode = getNodeFromInstance(targetInst);
	  if (updateValueIfChanged(targetNode)) return targetInst;
	}
	function getTargetInstForChangeEvent(domEventName, targetInst) {
	  if ("change" === domEventName) return targetInst;
	}
	var isInputEventSupported = !1;
	if (canUseDOM$1) {
	  var JSCompiler_inline_result$jscomp$282;
	  if (canUseDOM$1) {
	    var isSupported$jscomp$inline_417 = "oninput" in document;
	    if (!isSupported$jscomp$inline_417) {
	      var element$jscomp$inline_418 = document.createElement("div");
	      element$jscomp$inline_418.setAttribute("oninput", "return;");
	      isSupported$jscomp$inline_417 =
	        "function" === typeof element$jscomp$inline_418.oninput;
	    }
	    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
	  } else JSCompiler_inline_result$jscomp$282 = !1;
	  isInputEventSupported =
	    JSCompiler_inline_result$jscomp$282 &&
	    (!document.documentMode || 9 < document.documentMode);
	}
	function stopWatchingForValueChange() {
	  activeElement$1 &&
	    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
	    (activeElementInst$1 = activeElement$1 = null));
	}
	function handlePropertyChange(nativeEvent) {
	  if (
	    "value" === nativeEvent.propertyName &&
	    getInstIfValueChanged(activeElementInst$1)
	  ) {
	    var dispatchQueue = [];
	    createAndAccumulateChangeEvent(
	      dispatchQueue,
	      activeElementInst$1,
	      nativeEvent,
	      getEventTarget(nativeEvent)
	    );
	    batchedUpdates$1(runEventInBatch, dispatchQueue);
	  }
	}
	function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
	  "focusin" === domEventName
	    ? (stopWatchingForValueChange(),
	      (activeElement$1 = target),
	      (activeElementInst$1 = targetInst),
	      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
	    : "focusout" === domEventName && stopWatchingForValueChange();
	}
	function getTargetInstForInputEventPolyfill(domEventName) {
	  if (
	    "selectionchange" === domEventName ||
	    "keyup" === domEventName ||
	    "keydown" === domEventName
	  )
	    return getInstIfValueChanged(activeElementInst$1);
	}
	function getTargetInstForClickEvent(domEventName, targetInst) {
	  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
	}
	function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
	  if ("input" === domEventName || "change" === domEventName)
	    return getInstIfValueChanged(targetInst);
	}
	function is(x, y) {
	  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is;
	function shallowEqual(objA, objB) {
	  if (objectIs(objA, objB)) return !0;
	  if (
	    "object" !== typeof objA ||
	    null === objA ||
	    "object" !== typeof objB ||
	    null === objB
	  )
	    return !1;
	  var keysA = Object.keys(objA),
	    keysB = Object.keys(objB);
	  if (keysA.length !== keysB.length) return !1;
	  for (keysB = 0; keysB < keysA.length; keysB++) {
	    var currentKey = keysA[keysB];
	    if (
	      !hasOwnProperty$2.call(objB, currentKey) ||
	      !objectIs(objA[currentKey], objB[currentKey])
	    )
	      return !1;
	  }
	  return !0;
	}
	function getLeafNode(node) {
	  for (; node && node.firstChild; ) node = node.firstChild;
	  return node;
	}
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  root = 0;
	  for (var nodeEnd; node; ) {
	    if (3 === node.nodeType) {
	      nodeEnd = root + node.textContent.length;
	      if (root <= offset && nodeEnd >= offset)
	        return { node: node, offset: offset - root };
	      root = nodeEnd;
	    }
	    a: {
	      for (; node; ) {
	        if (node.nextSibling) {
	          node = node.nextSibling;
	          break a;
	        }
	        node = node.parentNode;
	      }
	      node = void 0;
	    }
	    node = getLeafNode(node);
	  }
	}
	function containsNode(outerNode, innerNode) {
	  return outerNode && innerNode
	    ? outerNode === innerNode
	      ? !0
	      : outerNode && 3 === outerNode.nodeType
	        ? !1
	        : innerNode && 3 === innerNode.nodeType
	          ? containsNode(outerNode, innerNode.parentNode)
	          : "contains" in outerNode
	            ? outerNode.contains(innerNode)
	            : outerNode.compareDocumentPosition
	              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
	              : !1
	    : !1;
	}
	function getActiveElementDeep(containerInfo) {
	  containerInfo =
	    null != containerInfo &&
	    null != containerInfo.ownerDocument &&
	    null != containerInfo.ownerDocument.defaultView
	      ? containerInfo.ownerDocument.defaultView
	      : window;
	  for (
	    var element = getActiveElement(containerInfo.document);
	    element instanceof containerInfo.HTMLIFrameElement;

	  ) {
	    try {
	      var JSCompiler_inline_result =
	        "string" === typeof element.contentWindow.location.href;
	    } catch (err) {
	      JSCompiler_inline_result = !1;
	    }
	    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
	    else break;
	    element = getActiveElement(containerInfo.document);
	  }
	  return element;
	}
	function hasSelectionCapabilities(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return (
	    nodeName &&
	    (("input" === nodeName &&
	      ("text" === elem.type ||
	        "search" === elem.type ||
	        "tel" === elem.type ||
	        "url" === elem.type ||
	        "password" === elem.type)) ||
	      "textarea" === nodeName ||
	      "true" === elem.contentEditable)
	  );
	}
	var skipSelectionChangeEvent =
	    canUseDOM$1 && "documentMode" in document && 11 >= document.documentMode,
	  activeElement = null,
	  activeElementInst = null,
	  lastSelection = null,
	  mouseDown = !1;
	function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
	  var doc =
	    nativeEventTarget.window === nativeEventTarget
	      ? nativeEventTarget.document
	      : 9 === nativeEventTarget.nodeType
	        ? nativeEventTarget
	        : nativeEventTarget.ownerDocument;
	  mouseDown ||
	    null == activeElement ||
	    activeElement !== getActiveElement(doc) ||
	    ((doc = activeElement),
	    "selectionStart" in doc && hasSelectionCapabilities(doc)
	      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
	      : ((doc = (
	          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
	          window
	        ).getSelection()),
	        (doc = {
	          anchorNode: doc.anchorNode,
	          anchorOffset: doc.anchorOffset,
	          focusNode: doc.focusNode,
	          focusOffset: doc.focusOffset
	        })),
	    (lastSelection && shallowEqual(lastSelection, doc)) ||
	      ((lastSelection = doc),
	      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
	      0 < doc.length &&
	        ((nativeEvent = new SyntheticEvent(
	          "onSelect",
	          "select",
	          null,
	          nativeEvent,
	          nativeEventTarget
	        )),
	        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
	        (nativeEvent.target = activeElement))));
	}
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes["Webkit" + styleProp] = "webkit" + eventName;
	  prefixes["Moz" + styleProp] = "moz" + eventName;
	  return prefixes;
	}
	var vendorPrefixes = {
	    animationend: makePrefixMap("Animation", "AnimationEnd"),
	    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
	    animationstart: makePrefixMap("Animation", "AnimationStart"),
	    transitionrun: makePrefixMap("Transition", "TransitionRun"),
	    transitionstart: makePrefixMap("Transition", "TransitionStart"),
	    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
	    transitionend: makePrefixMap("Transition", "TransitionEnd")
	  },
	  prefixedEventNames = {},
	  style = {};
	canUseDOM$1 &&
	  ((style = document.createElement("div").style),
	  "AnimationEvent" in window ||
	    (delete vendorPrefixes.animationend.animation,
	    delete vendorPrefixes.animationiteration.animation,
	    delete vendorPrefixes.animationstart.animation),
	  "TransitionEvent" in window ||
	    delete vendorPrefixes.transitionend.transition);
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
	  if (!vendorPrefixes[eventName]) return eventName;
	  var prefixMap = vendorPrefixes[eventName],
	    styleProp;
	  for (styleProp in prefixMap)
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
	      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
	  return eventName;
	}
	var ANIMATION_END = getVendorPrefixedEventName("animationend"),
	  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
	  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
	  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
	  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
	  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
	  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
	  topLevelEventsToReactNames = new Map(),
	  simpleEventPluginEvents =
	    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
	      " "
	    );
	simpleEventPluginEvents.push("scrollEnd");
	function registerSimpleEvent(domEventName, reactName) {
	  topLevelEventsToReactNames.set(domEventName, reactName);
	  registerTwoPhaseEvent(reactName, [domEventName]);
	}
	var CapturedStacks = new WeakMap();
	function createCapturedValueAtFiber(value, source) {
	  if ("object" === typeof value && null !== value) {
	    var existing = CapturedStacks.get(value);
	    if (void 0 !== existing) return existing;
	    source = {
	      value: value,
	      source: source,
	      stack: getStackByFiberInDevAndProd(source)
	    };
	    CapturedStacks.set(value, source);
	    return source;
	  }
	  return {
	    value: value,
	    source: source,
	    stack: getStackByFiberInDevAndProd(source)
	  };
	}
	var concurrentQueues = [],
	  concurrentQueuesIndex = 0,
	  concurrentlyUpdatedLanes = 0;
	function finishQueueingConcurrentUpdates() {
	  for (
	    var endIndex = concurrentQueuesIndex,
	      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
	    i < endIndex;

	  ) {
	    var fiber = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    var queue = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    var update = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    var lane = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    if (null !== queue && null !== update) {
	      var pending = queue.pending;
	      null === pending
	        ? (update.next = update)
	        : ((update.next = pending.next), (pending.next = update));
	      queue.pending = update;
	    }
	    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
	  }
	}
	function enqueueUpdate$1(fiber, queue, update, lane) {
	  concurrentQueues[concurrentQueuesIndex++] = fiber;
	  concurrentQueues[concurrentQueuesIndex++] = queue;
	  concurrentQueues[concurrentQueuesIndex++] = update;
	  concurrentQueues[concurrentQueuesIndex++] = lane;
	  concurrentlyUpdatedLanes |= lane;
	  fiber.lanes |= lane;
	  fiber = fiber.alternate;
	  null !== fiber && (fiber.lanes |= lane);
	}
	function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
	  enqueueUpdate$1(fiber, queue, update, lane);
	  return getRootForUpdatedFiber(fiber);
	}
	function enqueueConcurrentRenderForLane(fiber, lane) {
	  enqueueUpdate$1(fiber, null, null, lane);
	  return getRootForUpdatedFiber(fiber);
	}
	function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
	  sourceFiber.lanes |= lane;
	  var alternate = sourceFiber.alternate;
	  null !== alternate && (alternate.lanes |= lane);
	  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
	    (parent.childLanes |= lane),
	      (alternate = parent.alternate),
	      null !== alternate && (alternate.childLanes |= lane),
	      22 === parent.tag &&
	        ((sourceFiber = parent.stateNode),
	        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
	      (sourceFiber = parent),
	      (parent = parent.return);
	  return 3 === sourceFiber.tag
	    ? ((parent = sourceFiber.stateNode),
	      isHidden &&
	        null !== update &&
	        ((isHidden = 31 - clz32(lane)),
	        (sourceFiber = parent.hiddenUpdates),
	        (alternate = sourceFiber[isHidden]),
	        null === alternate
	          ? (sourceFiber[isHidden] = [update])
	          : alternate.push(update),
	        (update.lane = lane | 536870912)),
	      parent)
	    : null;
	}
	function getRootForUpdatedFiber(sourceFiber) {
	  if (50 < nestedUpdateCount)
	    throw (
	      ((nestedUpdateCount = 0),
	      (rootWithNestedUpdates = null),
	      Error(formatProdErrorMessage$1(185)))
	    );
	  for (var parent = sourceFiber.return; null !== parent; )
	    (sourceFiber = parent), (parent = sourceFiber.return);
	  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
	}
	var emptyContextObject = {};
	function FiberNode(tag, pendingProps, key, mode) {
	  this.tag = tag;
	  this.key = key;
	  this.sibling =
	    this.child =
	    this.return =
	    this.stateNode =
	    this.type =
	    this.elementType =
	      null;
	  this.index = 0;
	  this.refCleanup = this.ref = null;
	  this.pendingProps = pendingProps;
	  this.dependencies =
	    this.memoizedState =
	    this.updateQueue =
	    this.memoizedProps =
	      null;
	  this.mode = mode;
	  this.subtreeFlags = this.flags = 0;
	  this.deletions = null;
	  this.childLanes = this.lanes = 0;
	  this.alternate = null;
	}
	function createFiberImplClass(tag, pendingProps, key, mode) {
	  return new FiberNode(tag, pendingProps, key, mode);
	}
	function shouldConstruct(Component) {
	  Component = Component.prototype;
	  return !(!Component || !Component.isReactComponent);
	}
	function createWorkInProgress(current, pendingProps) {
	  var workInProgress = current.alternate;
	  null === workInProgress
	    ? ((workInProgress = createFiberImplClass(
	        current.tag,
	        pendingProps,
	        current.key,
	        current.mode
	      )),
	      (workInProgress.elementType = current.elementType),
	      (workInProgress.type = current.type),
	      (workInProgress.stateNode = current.stateNode),
	      (workInProgress.alternate = current),
	      (current.alternate = workInProgress))
	    : ((workInProgress.pendingProps = pendingProps),
	      (workInProgress.type = current.type),
	      (workInProgress.flags = 0),
	      (workInProgress.subtreeFlags = 0),
	      (workInProgress.deletions = null));
	  workInProgress.flags = current.flags & 65011712;
	  workInProgress.childLanes = current.childLanes;
	  workInProgress.lanes = current.lanes;
	  workInProgress.child = current.child;
	  workInProgress.memoizedProps = current.memoizedProps;
	  workInProgress.memoizedState = current.memoizedState;
	  workInProgress.updateQueue = current.updateQueue;
	  pendingProps = current.dependencies;
	  workInProgress.dependencies =
	    null === pendingProps
	      ? null
	      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
	  workInProgress.sibling = current.sibling;
	  workInProgress.index = current.index;
	  workInProgress.ref = current.ref;
	  workInProgress.refCleanup = current.refCleanup;
	  return workInProgress;
	}
	function resetWorkInProgress(workInProgress, renderLanes) {
	  workInProgress.flags &= 65011714;
	  var current = workInProgress.alternate;
	  null === current
	    ? ((workInProgress.childLanes = 0),
	      (workInProgress.lanes = renderLanes),
	      (workInProgress.child = null),
	      (workInProgress.subtreeFlags = 0),
	      (workInProgress.memoizedProps = null),
	      (workInProgress.memoizedState = null),
	      (workInProgress.updateQueue = null),
	      (workInProgress.dependencies = null),
	      (workInProgress.stateNode = null))
	    : ((workInProgress.childLanes = current.childLanes),
	      (workInProgress.lanes = current.lanes),
	      (workInProgress.child = current.child),
	      (workInProgress.subtreeFlags = 0),
	      (workInProgress.deletions = null),
	      (workInProgress.memoizedProps = current.memoizedProps),
	      (workInProgress.memoizedState = current.memoizedState),
	      (workInProgress.updateQueue = current.updateQueue),
	      (workInProgress.type = current.type),
	      (renderLanes = current.dependencies),
	      (workInProgress.dependencies =
	        null === renderLanes
	          ? null
	          : {
	              lanes: renderLanes.lanes,
	              firstContext: renderLanes.firstContext
	            }));
	  return workInProgress;
	}
	function createFiberFromTypeAndProps(
	  type,
	  key,
	  pendingProps,
	  owner,
	  mode,
	  lanes
	) {
	  var fiberTag = 0;
	  owner = type;
	  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
	  else if ("string" === typeof type)
	    fiberTag = isHostHoistableType(
	      type,
	      pendingProps,
	      contextStackCursor.current
	    )
	      ? 26
	      : "html" === type || "head" === type || "body" === type
	        ? 27
	        : 5;
	  else
	    a: switch (type) {
	      case REACT_ACTIVITY_TYPE:
	        return (
	          (type = createFiberImplClass(31, pendingProps, key, mode)),
	          (type.elementType = REACT_ACTIVITY_TYPE),
	          (type.lanes = lanes),
	          type
	        );
	      case REACT_FRAGMENT_TYPE:
	        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
	      case REACT_STRICT_MODE_TYPE:
	        fiberTag = 8;
	        mode |= 24;
	        break;
	      case REACT_PROFILER_TYPE:
	        return (
	          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
	          (type.elementType = REACT_PROFILER_TYPE),
	          (type.lanes = lanes),
	          type
	        );
	      case REACT_SUSPENSE_TYPE:
	        return (
	          (type = createFiberImplClass(13, pendingProps, key, mode)),
	          (type.elementType = REACT_SUSPENSE_TYPE),
	          (type.lanes = lanes),
	          type
	        );
	      case REACT_SUSPENSE_LIST_TYPE:
	        return (
	          (type = createFiberImplClass(19, pendingProps, key, mode)),
	          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
	          (type.lanes = lanes),
	          type
	        );
	      default:
	        if ("object" === typeof type && null !== type)
	          switch (type.$$typeof) {
	            case REACT_PROVIDER_TYPE:
	            case REACT_CONTEXT_TYPE:
	              fiberTag = 10;
	              break a;
	            case REACT_CONSUMER_TYPE:
	              fiberTag = 9;
	              break a;
	            case REACT_FORWARD_REF_TYPE:
	              fiberTag = 11;
	              break a;
	            case REACT_MEMO_TYPE:
	              fiberTag = 14;
	              break a;
	            case REACT_LAZY_TYPE:
	              fiberTag = 16;
	              owner = null;
	              break a;
	          }
	        fiberTag = 29;
	        pendingProps = Error(
	          formatProdErrorMessage$1(130, null === type ? "null" : typeof type, "")
	        );
	        owner = null;
	    }
	  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
	  key.elementType = type;
	  key.type = owner;
	  key.lanes = lanes;
	  return key;
	}
	function createFiberFromFragment(elements, mode, lanes, key) {
	  elements = createFiberImplClass(7, elements, key, mode);
	  elements.lanes = lanes;
	  return elements;
	}
	function createFiberFromText(content, mode, lanes) {
	  content = createFiberImplClass(6, content, null, mode);
	  content.lanes = lanes;
	  return content;
	}
	function createFiberFromPortal(portal, mode, lanes) {
	  mode = createFiberImplClass(
	    4,
	    null !== portal.children ? portal.children : [],
	    portal.key,
	    mode
	  );
	  mode.lanes = lanes;
	  mode.stateNode = {
	    containerInfo: portal.containerInfo,
	    pendingChildren: null,
	    implementation: portal.implementation
	  };
	  return mode;
	}
	var forkStack = [],
	  forkStackIndex = 0,
	  treeForkProvider = null,
	  treeForkCount = 0,
	  idStack = [],
	  idStackIndex = 0,
	  treeContextProvider = null,
	  treeContextId = 1,
	  treeContextOverflow = "";
	function pushTreeFork(workInProgress, totalChildren) {
	  forkStack[forkStackIndex++] = treeForkCount;
	  forkStack[forkStackIndex++] = treeForkProvider;
	  treeForkProvider = workInProgress;
	  treeForkCount = totalChildren;
	}
	function pushTreeId(workInProgress, totalChildren, index) {
	  idStack[idStackIndex++] = treeContextId;
	  idStack[idStackIndex++] = treeContextOverflow;
	  idStack[idStackIndex++] = treeContextProvider;
	  treeContextProvider = workInProgress;
	  var baseIdWithLeadingBit = treeContextId;
	  workInProgress = treeContextOverflow;
	  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
	  baseIdWithLeadingBit &= ~(1 << baseLength);
	  index += 1;
	  var length = 32 - clz32(totalChildren) + baseLength;
	  if (30 < length) {
	    var numberOfOverflowBits = baseLength - (baseLength % 5);
	    length = (
	      baseIdWithLeadingBit &
	      ((1 << numberOfOverflowBits) - 1)
	    ).toString(32);
	    baseIdWithLeadingBit >>= numberOfOverflowBits;
	    baseLength -= numberOfOverflowBits;
	    treeContextId =
	      (1 << (32 - clz32(totalChildren) + baseLength)) |
	      (index << baseLength) |
	      baseIdWithLeadingBit;
	    treeContextOverflow = length + workInProgress;
	  } else
	    (treeContextId =
	      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
	      (treeContextOverflow = workInProgress);
	}
	function pushMaterializedTreeId(workInProgress) {
	  null !== workInProgress.return &&
	    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
	}
	function popTreeContext(workInProgress) {
	  for (; workInProgress === treeForkProvider; )
	    (treeForkProvider = forkStack[--forkStackIndex]),
	      (forkStack[forkStackIndex] = null),
	      (treeForkCount = forkStack[--forkStackIndex]),
	      (forkStack[forkStackIndex] = null);
	  for (; workInProgress === treeContextProvider; )
	    (treeContextProvider = idStack[--idStackIndex]),
	      (idStack[idStackIndex] = null),
	      (treeContextOverflow = idStack[--idStackIndex]),
	      (idStack[idStackIndex] = null),
	      (treeContextId = idStack[--idStackIndex]),
	      (idStack[idStackIndex] = null);
	}
	var hydrationParentFiber = null,
	  nextHydratableInstance = null,
	  isHydrating = !1,
	  hydrationErrors = null,
	  rootOrSingletonContext = !1,
	  HydrationMismatchException = Error(formatProdErrorMessage$1(519));
	function throwOnHydrationMismatch(fiber) {
	  var error = Error(formatProdErrorMessage$1(418, ""));
	  queueHydrationError(createCapturedValueAtFiber(error, fiber));
	  throw HydrationMismatchException;
	}
	function prepareToHydrateHostInstance(fiber) {
	  var instance = fiber.stateNode,
	    type = fiber.type,
	    props = fiber.memoizedProps;
	  instance[internalInstanceKey] = fiber;
	  instance[internalPropsKey] = props;
	  switch (type) {
	    case "dialog":
	      listenToNonDelegatedEvent("cancel", instance);
	      listenToNonDelegatedEvent("close", instance);
	      break;
	    case "iframe":
	    case "object":
	    case "embed":
	      listenToNonDelegatedEvent("load", instance);
	      break;
	    case "video":
	    case "audio":
	      for (type = 0; type < mediaEventTypes.length; type++)
	        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
	      break;
	    case "source":
	      listenToNonDelegatedEvent("error", instance);
	      break;
	    case "img":
	    case "image":
	    case "link":
	      listenToNonDelegatedEvent("error", instance);
	      listenToNonDelegatedEvent("load", instance);
	      break;
	    case "details":
	      listenToNonDelegatedEvent("toggle", instance);
	      break;
	    case "input":
	      listenToNonDelegatedEvent("invalid", instance);
	      initInput(
	        instance,
	        props.value,
	        props.defaultValue,
	        props.checked,
	        props.defaultChecked,
	        props.type,
	        props.name,
	        !0
	      );
	      track(instance);
	      break;
	    case "select":
	      listenToNonDelegatedEvent("invalid", instance);
	      break;
	    case "textarea":
	      listenToNonDelegatedEvent("invalid", instance),
	        initTextarea(instance, props.value, props.defaultValue, props.children),
	        track(instance);
	  }
	  type = props.children;
	  ("string" !== typeof type &&
	    "number" !== typeof type &&
	    "bigint" !== typeof type) ||
	  instance.textContent === "" + type ||
	  !0 === props.suppressHydrationWarning ||
	  checkForUnmatchedText(instance.textContent, type)
	    ? (null != props.popover &&
	        (listenToNonDelegatedEvent("beforetoggle", instance),
	        listenToNonDelegatedEvent("toggle", instance)),
	      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
	      null != props.onScrollEnd &&
	        listenToNonDelegatedEvent("scrollend", instance),
	      null != props.onClick && (instance.onclick = noop$1),
	      (instance = !0))
	    : (instance = !1);
	  instance || throwOnHydrationMismatch(fiber);
	}
	function popToNextHostParent(fiber) {
	  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
	    switch (hydrationParentFiber.tag) {
	      case 5:
	      case 13:
	        rootOrSingletonContext = !1;
	        return;
	      case 27:
	      case 3:
	        rootOrSingletonContext = !0;
	        return;
	      default:
	        hydrationParentFiber = hydrationParentFiber.return;
	    }
	}
	function popHydrationState(fiber) {
	  if (fiber !== hydrationParentFiber) return !1;
	  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
	  var tag = fiber.tag,
	    JSCompiler_temp;
	  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
	    if ((JSCompiler_temp = 5 === tag))
	      (JSCompiler_temp = fiber.type),
	        (JSCompiler_temp =
	          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
	          shouldSetTextContent(fiber.type, fiber.memoizedProps));
	    JSCompiler_temp = !JSCompiler_temp;
	  }
	  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
	  popToNextHostParent(fiber);
	  if (13 === tag) {
	    fiber = fiber.memoizedState;
	    fiber = null !== fiber ? fiber.dehydrated : null;
	    if (!fiber) throw Error(formatProdErrorMessage$1(317));
	    a: {
	      fiber = fiber.nextSibling;
	      for (tag = 0; fiber; ) {
	        if (8 === fiber.nodeType)
	          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
	            if (0 === tag) {
	              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
	              break a;
	            }
	            tag--;
	          } else
	            ("$" !== JSCompiler_temp &&
	              "$!" !== JSCompiler_temp &&
	              "$?" !== JSCompiler_temp) ||
	              tag++;
	        fiber = fiber.nextSibling;
	      }
	      nextHydratableInstance = null;
	    }
	  } else
	    27 === tag
	      ? ((tag = nextHydratableInstance),
	        isSingletonScope(fiber.type)
	          ? ((fiber = previousHydratableOnEnteringScopedSingleton),
	            (previousHydratableOnEnteringScopedSingleton = null),
	            (nextHydratableInstance = fiber))
	          : (nextHydratableInstance = tag))
	      : (nextHydratableInstance = hydrationParentFiber
	          ? getNextHydratable(fiber.stateNode.nextSibling)
	          : null);
	  return !0;
	}
	function resetHydrationState() {
	  nextHydratableInstance = hydrationParentFiber = null;
	  isHydrating = !1;
	}
	function upgradeHydrationErrorsToRecoverable() {
	  var queuedErrors = hydrationErrors;
	  null !== queuedErrors &&
	    (null === workInProgressRootRecoverableErrors
	      ? (workInProgressRootRecoverableErrors = queuedErrors)
	      : workInProgressRootRecoverableErrors.push.apply(
	          workInProgressRootRecoverableErrors,
	          queuedErrors
	        ),
	    (hydrationErrors = null));
	  return queuedErrors;
	}
	function queueHydrationError(error) {
	  null === hydrationErrors
	    ? (hydrationErrors = [error])
	    : hydrationErrors.push(error);
	}
	var valueCursor = createCursor(null),
	  currentlyRenderingFiber$1 = null,
	  lastContextDependency = null;
	function pushProvider(providerFiber, context, nextValue) {
	  push(valueCursor, context._currentValue);
	  context._currentValue = nextValue;
	}
	function popProvider(context) {
	  context._currentValue = valueCursor.current;
	  pop(valueCursor);
	}
	function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
	  for (; null !== parent; ) {
	    var alternate = parent.alternate;
	    (parent.childLanes & renderLanes) !== renderLanes
	      ? ((parent.childLanes |= renderLanes),
	        null !== alternate && (alternate.childLanes |= renderLanes))
	      : null !== alternate &&
	        (alternate.childLanes & renderLanes) !== renderLanes &&
	        (alternate.childLanes |= renderLanes);
	    if (parent === propagationRoot) break;
	    parent = parent.return;
	  }
	}
	function propagateContextChanges(
	  workInProgress,
	  contexts,
	  renderLanes,
	  forcePropagateEntireTree
	) {
	  var fiber = workInProgress.child;
	  null !== fiber && (fiber.return = workInProgress);
	  for (; null !== fiber; ) {
	    var list = fiber.dependencies;
	    if (null !== list) {
	      var nextFiber = fiber.child;
	      list = list.firstContext;
	      a: for (; null !== list; ) {
	        var dependency = list;
	        list = fiber;
	        for (var i = 0; i < contexts.length; i++)
	          if (dependency.context === contexts[i]) {
	            list.lanes |= renderLanes;
	            dependency = list.alternate;
	            null !== dependency && (dependency.lanes |= renderLanes);
	            scheduleContextWorkOnParentPath(
	              list.return,
	              renderLanes,
	              workInProgress
	            );
	            forcePropagateEntireTree || (nextFiber = null);
	            break a;
	          }
	        list = dependency.next;
	      }
	    } else if (18 === fiber.tag) {
	      nextFiber = fiber.return;
	      if (null === nextFiber) throw Error(formatProdErrorMessage$1(341));
	      nextFiber.lanes |= renderLanes;
	      list = nextFiber.alternate;
	      null !== list && (list.lanes |= renderLanes);
	      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
	      nextFiber = null;
	    } else nextFiber = fiber.child;
	    if (null !== nextFiber) nextFiber.return = fiber;
	    else
	      for (nextFiber = fiber; null !== nextFiber; ) {
	        if (nextFiber === workInProgress) {
	          nextFiber = null;
	          break;
	        }
	        fiber = nextFiber.sibling;
	        if (null !== fiber) {
	          fiber.return = nextFiber.return;
	          nextFiber = fiber;
	          break;
	        }
	        nextFiber = nextFiber.return;
	      }
	    fiber = nextFiber;
	  }
	}
	function propagateParentContextChanges(
	  current,
	  workInProgress,
	  renderLanes,
	  forcePropagateEntireTree
	) {
	  current = null;
	  for (
	    var parent = workInProgress, isInsidePropagationBailout = !1;
	    null !== parent;

	  ) {
	    if (!isInsidePropagationBailout)
	      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
	      else if (0 !== (parent.flags & 262144)) break;
	    if (10 === parent.tag) {
	      var currentParent = parent.alternate;
	      if (null === currentParent) throw Error(formatProdErrorMessage$1(387));
	      currentParent = currentParent.memoizedProps;
	      if (null !== currentParent) {
	        var context = parent.type;
	        objectIs(parent.pendingProps.value, currentParent.value) ||
	          (null !== current ? current.push(context) : (current = [context]));
	      }
	    } else if (parent === hostTransitionProviderCursor.current) {
	      currentParent = parent.alternate;
	      if (null === currentParent) throw Error(formatProdErrorMessage$1(387));
	      currentParent.memoizedState.memoizedState !==
	        parent.memoizedState.memoizedState &&
	        (null !== current
	          ? current.push(HostTransitionContext)
	          : (current = [HostTransitionContext]));
	    }
	    parent = parent.return;
	  }
	  null !== current &&
	    propagateContextChanges(
	      workInProgress,
	      current,
	      renderLanes,
	      forcePropagateEntireTree
	    );
	  workInProgress.flags |= 262144;
	}
	function checkIfContextChanged(currentDependencies) {
	  for (
	    currentDependencies = currentDependencies.firstContext;
	    null !== currentDependencies;

	  ) {
	    if (
	      !objectIs(
	        currentDependencies.context._currentValue,
	        currentDependencies.memoizedValue
	      )
	    )
	      return !0;
	    currentDependencies = currentDependencies.next;
	  }
	  return !1;
	}
	function prepareToReadContext(workInProgress) {
	  currentlyRenderingFiber$1 = workInProgress;
	  lastContextDependency = null;
	  workInProgress = workInProgress.dependencies;
	  null !== workInProgress && (workInProgress.firstContext = null);
	}
	function readContext(context) {
	  return readContextForConsumer(currentlyRenderingFiber$1, context);
	}
	function readContextDuringReconciliation(consumer, context) {
	  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
	  return readContextForConsumer(consumer, context);
	}
	function readContextForConsumer(consumer, context) {
	  var value = context._currentValue;
	  context = { context: context, memoizedValue: value, next: null };
	  if (null === lastContextDependency) {
	    if (null === consumer) throw Error(formatProdErrorMessage$1(308));
	    lastContextDependency = context;
	    consumer.dependencies = { lanes: 0, firstContext: context };
	    consumer.flags |= 524288;
	  } else lastContextDependency = lastContextDependency.next = context;
	  return value;
	}
	var AbortControllerLocal =
	    "undefined" !== typeof AbortController
	      ? AbortController
	      : function () {
	          var listeners = [],
	            signal = (this.signal = {
	              aborted: !1,
	              addEventListener: function (type, listener) {
	                listeners.push(listener);
	              }
	            });
	          this.abort = function () {
	            signal.aborted = !0;
	            listeners.forEach(function (listener) {
	              return listener();
	            });
	          };
	        },
	  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
	  NormalPriority = Scheduler.unstable_NormalPriority,
	  CacheContext = {
	    $$typeof: REACT_CONTEXT_TYPE,
	    Consumer: null,
	    Provider: null,
	    _currentValue: null,
	    _currentValue2: null,
	    _threadCount: 0
	  };
	function createCache() {
	  return {
	    controller: new AbortControllerLocal(),
	    data: new Map(),
	    refCount: 0
	  };
	}
	function releaseCache(cache) {
	  cache.refCount--;
	  0 === cache.refCount &&
	    scheduleCallback$2(NormalPriority, function () {
	      cache.controller.abort();
	    });
	}
	var currentEntangledListeners = null,
	  currentEntangledPendingCount = 0,
	  currentEntangledLane = 0,
	  currentEntangledActionThenable = null;
	function entangleAsyncAction(transition, thenable) {
	  if (null === currentEntangledListeners) {
	    var entangledListeners = (currentEntangledListeners = []);
	    currentEntangledPendingCount = 0;
	    currentEntangledLane = requestTransitionLane();
	    currentEntangledActionThenable = {
	      status: "pending",
	      value: void 0,
	      then: function (resolve) {
	        entangledListeners.push(resolve);
	      }
	    };
	  }
	  currentEntangledPendingCount++;
	  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
	  return thenable;
	}
	function pingEngtangledActionScope() {
	  if (
	    0 === --currentEntangledPendingCount &&
	    null !== currentEntangledListeners
	  ) {
	    null !== currentEntangledActionThenable &&
	      (currentEntangledActionThenable.status = "fulfilled");
	    var listeners = currentEntangledListeners;
	    currentEntangledListeners = null;
	    currentEntangledLane = 0;
	    currentEntangledActionThenable = null;
	    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
	  }
	}
	function chainThenableValue(thenable, result) {
	  var listeners = [],
	    thenableWithOverride = {
	      status: "pending",
	      value: null,
	      reason: null,
	      then: function (resolve) {
	        listeners.push(resolve);
	      }
	    };
	  thenable.then(
	    function () {
	      thenableWithOverride.status = "fulfilled";
	      thenableWithOverride.value = result;
	      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
	    },
	    function (error) {
	      thenableWithOverride.status = "rejected";
	      thenableWithOverride.reason = error;
	      for (error = 0; error < listeners.length; error++)
	        (0, listeners[error])(void 0);
	    }
	  );
	  return thenableWithOverride;
	}
	var prevOnStartTransitionFinish = ReactSharedInternals.S;
	ReactSharedInternals.S = function (transition, returnValue) {
	  "object" === typeof returnValue &&
	    null !== returnValue &&
	    "function" === typeof returnValue.then &&
	    entangleAsyncAction(transition, returnValue);
	  null !== prevOnStartTransitionFinish &&
	    prevOnStartTransitionFinish(transition, returnValue);
	};
	var resumedCache = createCursor(null);
	function peekCacheFromPool() {
	  var cacheResumedFromPreviousRender = resumedCache.current;
	  return null !== cacheResumedFromPreviousRender
	    ? cacheResumedFromPreviousRender
	    : workInProgressRoot.pooledCache;
	}
	function pushTransition(offscreenWorkInProgress, prevCachePool) {
	  null === prevCachePool
	    ? push(resumedCache, resumedCache.current)
	    : push(resumedCache, prevCachePool.pool);
	}
	function getSuspendedCache() {
	  var cacheFromPool = peekCacheFromPool();
	  return null === cacheFromPool
	    ? null
	    : { parent: CacheContext._currentValue, pool: cacheFromPool };
	}
	var SuspenseException = Error(formatProdErrorMessage$1(460)),
	  SuspenseyCommitException = Error(formatProdErrorMessage$1(474)),
	  SuspenseActionException = Error(formatProdErrorMessage$1(542)),
	  noopSuspenseyCommitThenable = { then: function () {} };
	function isThenableResolved(thenable) {
	  thenable = thenable.status;
	  return "fulfilled" === thenable || "rejected" === thenable;
	}
	function noop$3() {}
	function trackUsedThenable(thenableState, thenable, index) {
	  index = thenableState[index];
	  void 0 === index
	    ? thenableState.push(thenable)
	    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
	  switch (thenable.status) {
	    case "fulfilled":
	      return thenable.value;
	    case "rejected":
	      throw (
	        ((thenableState = thenable.reason),
	        checkIfUseWrappedInAsyncCatch(thenableState),
	        thenableState)
	      );
	    default:
	      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
	      else {
	        thenableState = workInProgressRoot;
	        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
	          throw Error(formatProdErrorMessage$1(482));
	        thenableState = thenable;
	        thenableState.status = "pending";
	        thenableState.then(
	          function (fulfilledValue) {
	            if ("pending" === thenable.status) {
	              var fulfilledThenable = thenable;
	              fulfilledThenable.status = "fulfilled";
	              fulfilledThenable.value = fulfilledValue;
	            }
	          },
	          function (error) {
	            if ("pending" === thenable.status) {
	              var rejectedThenable = thenable;
	              rejectedThenable.status = "rejected";
	              rejectedThenable.reason = error;
	            }
	          }
	        );
	      }
	      switch (thenable.status) {
	        case "fulfilled":
	          return thenable.value;
	        case "rejected":
	          throw (
	            ((thenableState = thenable.reason),
	            checkIfUseWrappedInAsyncCatch(thenableState),
	            thenableState)
	          );
	      }
	      suspendedThenable = thenable;
	      throw SuspenseException;
	  }
	}
	var suspendedThenable = null;
	function getSuspendedThenable() {
	  if (null === suspendedThenable) throw Error(formatProdErrorMessage$1(459));
	  var thenable = suspendedThenable;
	  suspendedThenable = null;
	  return thenable;
	}
	function checkIfUseWrappedInAsyncCatch(rejectedReason) {
	  if (
	    rejectedReason === SuspenseException ||
	    rejectedReason === SuspenseActionException
	  )
	    throw Error(formatProdErrorMessage$1(483));
	}
	var hasForceUpdate = !1;
	function initializeUpdateQueue(fiber) {
	  fiber.updateQueue = {
	    baseState: fiber.memoizedState,
	    firstBaseUpdate: null,
	    lastBaseUpdate: null,
	    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
	    callbacks: null
	  };
	}
	function cloneUpdateQueue(current, workInProgress) {
	  current = current.updateQueue;
	  workInProgress.updateQueue === current &&
	    (workInProgress.updateQueue = {
	      baseState: current.baseState,
	      firstBaseUpdate: current.firstBaseUpdate,
	      lastBaseUpdate: current.lastBaseUpdate,
	      shared: current.shared,
	      callbacks: null
	    });
	}
	function createUpdate(lane) {
	  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
	}
	function enqueueUpdate(fiber, update, lane) {
	  var updateQueue = fiber.updateQueue;
	  if (null === updateQueue) return null;
	  updateQueue = updateQueue.shared;
	  if (0 !== (executionContext & 2)) {
	    var pending = updateQueue.pending;
	    null === pending
	      ? (update.next = update)
	      : ((update.next = pending.next), (pending.next = update));
	    updateQueue.pending = update;
	    update = getRootForUpdatedFiber(fiber);
	    markUpdateLaneFromFiberToRoot(fiber, null, lane);
	    return update;
	  }
	  enqueueUpdate$1(fiber, updateQueue, update, lane);
	  return getRootForUpdatedFiber(fiber);
	}
	function entangleTransitions(root, fiber, lane) {
	  fiber = fiber.updateQueue;
	  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
	    var queueLanes = fiber.lanes;
	    queueLanes &= root.pendingLanes;
	    lane |= queueLanes;
	    fiber.lanes = lane;
	    markRootEntangled(root, lane);
	  }
	}
	function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
	  var queue = workInProgress.updateQueue,
	    current = workInProgress.alternate;
	  if (
	    null !== current &&
	    ((current = current.updateQueue), queue === current)
	  ) {
	    var newFirst = null,
	      newLast = null;
	    queue = queue.firstBaseUpdate;
	    if (null !== queue) {
	      do {
	        var clone = {
	          lane: queue.lane,
	          tag: queue.tag,
	          payload: queue.payload,
	          callback: null,
	          next: null
	        };
	        null === newLast
	          ? (newFirst = newLast = clone)
	          : (newLast = newLast.next = clone);
	        queue = queue.next;
	      } while (null !== queue);
	      null === newLast
	        ? (newFirst = newLast = capturedUpdate)
	        : (newLast = newLast.next = capturedUpdate);
	    } else newFirst = newLast = capturedUpdate;
	    queue = {
	      baseState: current.baseState,
	      firstBaseUpdate: newFirst,
	      lastBaseUpdate: newLast,
	      shared: current.shared,
	      callbacks: current.callbacks
	    };
	    workInProgress.updateQueue = queue;
	    return;
	  }
	  workInProgress = queue.lastBaseUpdate;
	  null === workInProgress
	    ? (queue.firstBaseUpdate = capturedUpdate)
	    : (workInProgress.next = capturedUpdate);
	  queue.lastBaseUpdate = capturedUpdate;
	}
	var didReadFromEntangledAsyncAction = !1;
	function suspendIfUpdateReadFromEntangledAsyncAction() {
	  if (didReadFromEntangledAsyncAction) {
	    var entangledActionThenable = currentEntangledActionThenable;
	    if (null !== entangledActionThenable) throw entangledActionThenable;
	  }
	}
	function processUpdateQueue(
	  workInProgress$jscomp$0,
	  props,
	  instance$jscomp$0,
	  renderLanes
	) {
	  didReadFromEntangledAsyncAction = !1;
	  var queue = workInProgress$jscomp$0.updateQueue;
	  hasForceUpdate = !1;
	  var firstBaseUpdate = queue.firstBaseUpdate,
	    lastBaseUpdate = queue.lastBaseUpdate,
	    pendingQueue = queue.shared.pending;
	  if (null !== pendingQueue) {
	    queue.shared.pending = null;
	    var lastPendingUpdate = pendingQueue,
	      firstPendingUpdate = lastPendingUpdate.next;
	    lastPendingUpdate.next = null;
	    null === lastBaseUpdate
	      ? (firstBaseUpdate = firstPendingUpdate)
	      : (lastBaseUpdate.next = firstPendingUpdate);
	    lastBaseUpdate = lastPendingUpdate;
	    var current = workInProgress$jscomp$0.alternate;
	    null !== current &&
	      ((current = current.updateQueue),
	      (pendingQueue = current.lastBaseUpdate),
	      pendingQueue !== lastBaseUpdate &&
	        (null === pendingQueue
	          ? (current.firstBaseUpdate = firstPendingUpdate)
	          : (pendingQueue.next = firstPendingUpdate),
	        (current.lastBaseUpdate = lastPendingUpdate)));
	  }
	  if (null !== firstBaseUpdate) {
	    var newState = queue.baseState;
	    lastBaseUpdate = 0;
	    current = firstPendingUpdate = lastPendingUpdate = null;
	    pendingQueue = firstBaseUpdate;
	    do {
	      var updateLane = pendingQueue.lane & -536870913,
	        isHiddenUpdate = updateLane !== pendingQueue.lane;
	      if (
	        isHiddenUpdate
	          ? (workInProgressRootRenderLanes & updateLane) === updateLane
	          : (renderLanes & updateLane) === updateLane
	      ) {
	        0 !== updateLane &&
	          updateLane === currentEntangledLane &&
	          (didReadFromEntangledAsyncAction = !0);
	        null !== current &&
	          (current = current.next =
	            {
	              lane: 0,
	              tag: pendingQueue.tag,
	              payload: pendingQueue.payload,
	              callback: null,
	              next: null
	            });
	        a: {
	          var workInProgress = workInProgress$jscomp$0,
	            update = pendingQueue;
	          updateLane = props;
	          var instance = instance$jscomp$0;
	          switch (update.tag) {
	            case 1:
	              workInProgress = update.payload;
	              if ("function" === typeof workInProgress) {
	                newState = workInProgress.call(instance, newState, updateLane);
	                break a;
	              }
	              newState = workInProgress;
	              break a;
	            case 3:
	              workInProgress.flags = (workInProgress.flags & -65537) | 128;
	            case 0:
	              workInProgress = update.payload;
	              updateLane =
	                "function" === typeof workInProgress
	                  ? workInProgress.call(instance, newState, updateLane)
	                  : workInProgress;
	              if (null === updateLane || void 0 === updateLane) break a;
	              newState = assign({}, newState, updateLane);
	              break a;
	            case 2:
	              hasForceUpdate = !0;
	          }
	        }
	        updateLane = pendingQueue.callback;
	        null !== updateLane &&
	          ((workInProgress$jscomp$0.flags |= 64),
	          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
	          (isHiddenUpdate = queue.callbacks),
	          null === isHiddenUpdate
	            ? (queue.callbacks = [updateLane])
	            : isHiddenUpdate.push(updateLane));
	      } else
	        (isHiddenUpdate = {
	          lane: updateLane,
	          tag: pendingQueue.tag,
	          payload: pendingQueue.payload,
	          callback: pendingQueue.callback,
	          next: null
	        }),
	          null === current
	            ? ((firstPendingUpdate = current = isHiddenUpdate),
	              (lastPendingUpdate = newState))
	            : (current = current.next = isHiddenUpdate),
	          (lastBaseUpdate |= updateLane);
	      pendingQueue = pendingQueue.next;
	      if (null === pendingQueue)
	        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
	          break;
	        else
	          (isHiddenUpdate = pendingQueue),
	            (pendingQueue = isHiddenUpdate.next),
	            (isHiddenUpdate.next = null),
	            (queue.lastBaseUpdate = isHiddenUpdate),
	            (queue.shared.pending = null);
	    } while (1);
	    null === current && (lastPendingUpdate = newState);
	    queue.baseState = lastPendingUpdate;
	    queue.firstBaseUpdate = firstPendingUpdate;
	    queue.lastBaseUpdate = current;
	    null === firstBaseUpdate && (queue.shared.lanes = 0);
	    workInProgressRootSkippedLanes |= lastBaseUpdate;
	    workInProgress$jscomp$0.lanes = lastBaseUpdate;
	    workInProgress$jscomp$0.memoizedState = newState;
	  }
	}
	function callCallback(callback, context) {
	  if ("function" !== typeof callback)
	    throw Error(formatProdErrorMessage$1(191, callback));
	  callback.call(context);
	}
	function commitCallbacks(updateQueue, context) {
	  var callbacks = updateQueue.callbacks;
	  if (null !== callbacks)
	    for (
	      updateQueue.callbacks = null, updateQueue = 0;
	      updateQueue < callbacks.length;
	      updateQueue++
	    )
	      callCallback(callbacks[updateQueue], context);
	}
	var currentTreeHiddenStackCursor = createCursor(null),
	  prevEntangledRenderLanesCursor = createCursor(0);
	function pushHiddenContext(fiber, context) {
	  fiber = entangledRenderLanes;
	  push(prevEntangledRenderLanesCursor, fiber);
	  push(currentTreeHiddenStackCursor, context);
	  entangledRenderLanes = fiber | context.baseLanes;
	}
	function reuseHiddenContextOnStack() {
	  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
	  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
	}
	function popHiddenContext() {
	  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
	  pop(currentTreeHiddenStackCursor);
	  pop(prevEntangledRenderLanesCursor);
	}
	var renderLanes = 0,
	  currentlyRenderingFiber = null,
	  currentHook = null,
	  workInProgressHook = null,
	  didScheduleRenderPhaseUpdate = !1,
	  didScheduleRenderPhaseUpdateDuringThisPass = !1,
	  shouldDoubleInvokeUserFnsInHooksDEV = !1,
	  localIdCounter = 0,
	  thenableIndexCounter$1 = 0,
	  thenableState$1 = null,
	  globalClientIdCounter = 0;
	function throwInvalidHookError() {
	  throw Error(formatProdErrorMessage$1(321));
	}
	function areHookInputsEqual(nextDeps, prevDeps) {
	  if (null === prevDeps) return !1;
	  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
	    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
	  return !0;
	}
	function renderWithHooks(
	  current,
	  workInProgress,
	  Component,
	  props,
	  secondArg,
	  nextRenderLanes
	) {
	  renderLanes = nextRenderLanes;
	  currentlyRenderingFiber = workInProgress;
	  workInProgress.memoizedState = null;
	  workInProgress.updateQueue = null;
	  workInProgress.lanes = 0;
	  ReactSharedInternals.H =
	    null === current || null === current.memoizedState
	      ? HooksDispatcherOnMount
	      : HooksDispatcherOnUpdate;
	  shouldDoubleInvokeUserFnsInHooksDEV = !1;
	  nextRenderLanes = Component(props, secondArg);
	  shouldDoubleInvokeUserFnsInHooksDEV = !1;
	  didScheduleRenderPhaseUpdateDuringThisPass &&
	    (nextRenderLanes = renderWithHooksAgain(
	      workInProgress,
	      Component,
	      props,
	      secondArg
	    ));
	  finishRenderingHooks(current);
	  return nextRenderLanes;
	}
	function finishRenderingHooks(current) {
	  ReactSharedInternals.H = ContextOnlyDispatcher;
	  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
	  renderLanes = 0;
	  workInProgressHook = currentHook = currentlyRenderingFiber = null;
	  didScheduleRenderPhaseUpdate = !1;
	  thenableIndexCounter$1 = 0;
	  thenableState$1 = null;
	  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage$1(300));
	  null === current ||
	    didReceiveUpdate ||
	    ((current = current.dependencies),
	    null !== current &&
	      checkIfContextChanged(current) &&
	      (didReceiveUpdate = !0));
	}
	function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
	  currentlyRenderingFiber = workInProgress;
	  var numberOfReRenders = 0;
	  do {
	    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
	    thenableIndexCounter$1 = 0;
	    didScheduleRenderPhaseUpdateDuringThisPass = !1;
	    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage$1(301));
	    numberOfReRenders += 1;
	    workInProgressHook = currentHook = null;
	    if (null != workInProgress.updateQueue) {
	      var children = workInProgress.updateQueue;
	      children.lastEffect = null;
	      children.events = null;
	      children.stores = null;
	      null != children.memoCache && (children.memoCache.index = 0);
	    }
	    ReactSharedInternals.H = HooksDispatcherOnRerender;
	    children = Component(props, secondArg);
	  } while (didScheduleRenderPhaseUpdateDuringThisPass);
	  return children;
	}
	function TransitionAwareHostComponent() {
	  var dispatcher = ReactSharedInternals.H,
	    maybeThenable = dispatcher.useState()[0];
	  maybeThenable =
	    "function" === typeof maybeThenable.then
	      ? useThenable(maybeThenable)
	      : maybeThenable;
	  dispatcher = dispatcher.useState()[0];
	  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
	    (currentlyRenderingFiber.flags |= 1024);
	  return maybeThenable;
	}
	function checkDidRenderIdHook() {
	  var didRenderIdHook = 0 !== localIdCounter;
	  localIdCounter = 0;
	  return didRenderIdHook;
	}
	function bailoutHooks(current, workInProgress, lanes) {
	  workInProgress.updateQueue = current.updateQueue;
	  workInProgress.flags &= -2053;
	  current.lanes &= ~lanes;
	}
	function resetHooksOnUnwind(workInProgress) {
	  if (didScheduleRenderPhaseUpdate) {
	    for (
	      workInProgress = workInProgress.memoizedState;
	      null !== workInProgress;

	    ) {
	      var queue = workInProgress.queue;
	      null !== queue && (queue.pending = null);
	      workInProgress = workInProgress.next;
	    }
	    didScheduleRenderPhaseUpdate = !1;
	  }
	  renderLanes = 0;
	  workInProgressHook = currentHook = currentlyRenderingFiber = null;
	  didScheduleRenderPhaseUpdateDuringThisPass = !1;
	  thenableIndexCounter$1 = localIdCounter = 0;
	  thenableState$1 = null;
	}
	function mountWorkInProgressHook() {
	  var hook = {
	    memoizedState: null,
	    baseState: null,
	    baseQueue: null,
	    queue: null,
	    next: null
	  };
	  null === workInProgressHook
	    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
	    : (workInProgressHook = workInProgressHook.next = hook);
	  return workInProgressHook;
	}
	function updateWorkInProgressHook() {
	  if (null === currentHook) {
	    var nextCurrentHook = currentlyRenderingFiber.alternate;
	    nextCurrentHook =
	      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
	  } else nextCurrentHook = currentHook.next;
	  var nextWorkInProgressHook =
	    null === workInProgressHook
	      ? currentlyRenderingFiber.memoizedState
	      : workInProgressHook.next;
	  if (null !== nextWorkInProgressHook)
	    (workInProgressHook = nextWorkInProgressHook),
	      (currentHook = nextCurrentHook);
	  else {
	    if (null === nextCurrentHook) {
	      if (null === currentlyRenderingFiber.alternate)
	        throw Error(formatProdErrorMessage$1(467));
	      throw Error(formatProdErrorMessage$1(310));
	    }
	    currentHook = nextCurrentHook;
	    nextCurrentHook = {
	      memoizedState: currentHook.memoizedState,
	      baseState: currentHook.baseState,
	      baseQueue: currentHook.baseQueue,
	      queue: currentHook.queue,
	      next: null
	    };
	    null === workInProgressHook
	      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
	          nextCurrentHook)
	      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
	  }
	  return workInProgressHook;
	}
	function createFunctionComponentUpdateQueue() {
	  return { lastEffect: null, events: null, stores: null, memoCache: null };
	}
	function useThenable(thenable) {
	  var index = thenableIndexCounter$1;
	  thenableIndexCounter$1 += 1;
	  null === thenableState$1 && (thenableState$1 = []);
	  thenable = trackUsedThenable(thenableState$1, thenable, index);
	  index = currentlyRenderingFiber;
	  null ===
	    (null === workInProgressHook
	      ? index.memoizedState
	      : workInProgressHook.next) &&
	    ((index = index.alternate),
	    (ReactSharedInternals.H =
	      null === index || null === index.memoizedState
	        ? HooksDispatcherOnMount
	        : HooksDispatcherOnUpdate));
	  return thenable;
	}
	function use(usable) {
	  if (null !== usable && "object" === typeof usable) {
	    if ("function" === typeof usable.then) return useThenable(usable);
	    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
	  }
	  throw Error(formatProdErrorMessage$1(438, String(usable)));
	}
	function useMemoCache(size) {
	  var memoCache = null,
	    updateQueue = currentlyRenderingFiber.updateQueue;
	  null !== updateQueue && (memoCache = updateQueue.memoCache);
	  if (null == memoCache) {
	    var current = currentlyRenderingFiber.alternate;
	    null !== current &&
	      ((current = current.updateQueue),
	      null !== current &&
	        ((current = current.memoCache),
	        null != current &&
	          (memoCache = {
	            data: current.data.map(function (array) {
	              return array.slice();
	            }),
	            index: 0
	          })));
	  }
	  null == memoCache && (memoCache = { data: [], index: 0 });
	  null === updateQueue &&
	    ((updateQueue = createFunctionComponentUpdateQueue()),
	    (currentlyRenderingFiber.updateQueue = updateQueue));
	  updateQueue.memoCache = memoCache;
	  updateQueue = memoCache.data[memoCache.index];
	  if (void 0 === updateQueue)
	    for (
	      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
	      current < size;
	      current++
	    )
	      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
	  memoCache.index++;
	  return updateQueue;
	}
	function basicStateReducer(state, action) {
	  return "function" === typeof action ? action(state) : action;
	}
	function updateReducer(reducer) {
	  var hook = updateWorkInProgressHook();
	  return updateReducerImpl(hook, currentHook, reducer);
	}
	function updateReducerImpl(hook, current, reducer) {
	  var queue = hook.queue;
	  if (null === queue) throw Error(formatProdErrorMessage$1(311));
	  queue.lastRenderedReducer = reducer;
	  var baseQueue = hook.baseQueue,
	    pendingQueue = queue.pending;
	  if (null !== pendingQueue) {
	    if (null !== baseQueue) {
	      var baseFirst = baseQueue.next;
	      baseQueue.next = pendingQueue.next;
	      pendingQueue.next = baseFirst;
	    }
	    current.baseQueue = baseQueue = pendingQueue;
	    queue.pending = null;
	  }
	  pendingQueue = hook.baseState;
	  if (null === baseQueue) hook.memoizedState = pendingQueue;
	  else {
	    current = baseQueue.next;
	    var newBaseQueueFirst = (baseFirst = null),
	      newBaseQueueLast = null,
	      update = current,
	      didReadFromEntangledAsyncAction$32 = !1;
	    do {
	      var updateLane = update.lane & -536870913;
	      if (
	        updateLane !== update.lane
	          ? (workInProgressRootRenderLanes & updateLane) === updateLane
	          : (renderLanes & updateLane) === updateLane
	      ) {
	        var revertLane = update.revertLane;
	        if (0 === revertLane)
	          null !== newBaseQueueLast &&
	            (newBaseQueueLast = newBaseQueueLast.next =
	              {
	                lane: 0,
	                revertLane: 0,
	                action: update.action,
	                hasEagerState: update.hasEagerState,
	                eagerState: update.eagerState,
	                next: null
	              }),
	            updateLane === currentEntangledLane &&
	              (didReadFromEntangledAsyncAction$32 = !0);
	        else if ((renderLanes & revertLane) === revertLane) {
	          update = update.next;
	          revertLane === currentEntangledLane &&
	            (didReadFromEntangledAsyncAction$32 = !0);
	          continue;
	        } else
	          (updateLane = {
	            lane: 0,
	            revertLane: update.revertLane,
	            action: update.action,
	            hasEagerState: update.hasEagerState,
	            eagerState: update.eagerState,
	            next: null
	          }),
	            null === newBaseQueueLast
	              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
	                (baseFirst = pendingQueue))
	              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
	            (currentlyRenderingFiber.lanes |= revertLane),
	            (workInProgressRootSkippedLanes |= revertLane);
	        updateLane = update.action;
	        shouldDoubleInvokeUserFnsInHooksDEV &&
	          reducer(pendingQueue, updateLane);
	        pendingQueue = update.hasEagerState
	          ? update.eagerState
	          : reducer(pendingQueue, updateLane);
	      } else
	        (revertLane = {
	          lane: updateLane,
	          revertLane: update.revertLane,
	          action: update.action,
	          hasEagerState: update.hasEagerState,
	          eagerState: update.eagerState,
	          next: null
	        }),
	          null === newBaseQueueLast
	            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
	              (baseFirst = pendingQueue))
	            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
	          (currentlyRenderingFiber.lanes |= updateLane),
	          (workInProgressRootSkippedLanes |= updateLane);
	      update = update.next;
	    } while (null !== update && update !== current);
	    null === newBaseQueueLast
	      ? (baseFirst = pendingQueue)
	      : (newBaseQueueLast.next = newBaseQueueFirst);
	    if (
	      !objectIs(pendingQueue, hook.memoizedState) &&
	      ((didReceiveUpdate = !0),
	      didReadFromEntangledAsyncAction$32 &&
	        ((reducer = currentEntangledActionThenable), null !== reducer))
	    )
	      throw reducer;
	    hook.memoizedState = pendingQueue;
	    hook.baseState = baseFirst;
	    hook.baseQueue = newBaseQueueLast;
	    queue.lastRenderedState = pendingQueue;
	  }
	  null === baseQueue && (queue.lanes = 0);
	  return [hook.memoizedState, queue.dispatch];
	}
	function rerenderReducer(reducer) {
	  var hook = updateWorkInProgressHook(),
	    queue = hook.queue;
	  if (null === queue) throw Error(formatProdErrorMessage$1(311));
	  queue.lastRenderedReducer = reducer;
	  var dispatch = queue.dispatch,
	    lastRenderPhaseUpdate = queue.pending,
	    newState = hook.memoizedState;
	  if (null !== lastRenderPhaseUpdate) {
	    queue.pending = null;
	    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
	    do (newState = reducer(newState, update.action)), (update = update.next);
	    while (update !== lastRenderPhaseUpdate);
	    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
	    hook.memoizedState = newState;
	    null === hook.baseQueue && (hook.baseState = newState);
	    queue.lastRenderedState = newState;
	  }
	  return [newState, dispatch];
	}
	function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	  var fiber = currentlyRenderingFiber,
	    hook = updateWorkInProgressHook(),
	    isHydrating$jscomp$0 = isHydrating;
	  if (isHydrating$jscomp$0) {
	    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage$1(407));
	    getServerSnapshot = getServerSnapshot();
	  } else getServerSnapshot = getSnapshot();
	  var snapshotChanged = !objectIs(
	    (currentHook || hook).memoizedState,
	    getServerSnapshot
	  );
	  snapshotChanged &&
	    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
	  hook = hook.queue;
	  var create = subscribeToStore.bind(null, fiber, hook, subscribe);
	  updateEffectImpl(2048, 8, create, [subscribe]);
	  if (
	    hook.getSnapshot !== getSnapshot ||
	    snapshotChanged ||
	    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
	  ) {
	    fiber.flags |= 2048;
	    pushSimpleEffect(
	      9,
	      createEffectInstance(),
	      updateStoreInstance.bind(
	        null,
	        fiber,
	        hook,
	        getServerSnapshot,
	        getSnapshot
	      ),
	      null
	    );
	    if (null === workInProgressRoot) throw Error(formatProdErrorMessage$1(349));
	    isHydrating$jscomp$0 ||
	      0 !== (renderLanes & 124) ||
	      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
	  }
	  return getServerSnapshot;
	}
	function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
	  fiber.flags |= 16384;
	  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
	  getSnapshot = currentlyRenderingFiber.updateQueue;
	  null === getSnapshot
	    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
	      (currentlyRenderingFiber.updateQueue = getSnapshot),
	      (getSnapshot.stores = [fiber]))
	    : ((renderedSnapshot = getSnapshot.stores),
	      null === renderedSnapshot
	        ? (getSnapshot.stores = [fiber])
	        : renderedSnapshot.push(fiber));
	}
	function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
	  inst.value = nextSnapshot;
	  inst.getSnapshot = getSnapshot;
	  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	}
	function subscribeToStore(fiber, inst, subscribe) {
	  return subscribe(function () {
	    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	  });
	}
	function checkIfSnapshotChanged(inst) {
	  var latestGetSnapshot = inst.getSnapshot;
	  inst = inst.value;
	  try {
	    var nextValue = latestGetSnapshot();
	    return !objectIs(inst, nextValue);
	  } catch (error) {
	    return !0;
	  }
	}
	function forceStoreRerender(fiber) {
	  var root = enqueueConcurrentRenderForLane(fiber, 2);
	  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
	}
	function mountStateImpl(initialState) {
	  var hook = mountWorkInProgressHook();
	  if ("function" === typeof initialState) {
	    var initialStateInitializer = initialState;
	    initialState = initialStateInitializer();
	    if (shouldDoubleInvokeUserFnsInHooksDEV) {
	      setIsStrictModeForDevtools(!0);
	      try {
	        initialStateInitializer();
	      } finally {
	        setIsStrictModeForDevtools(!1);
	      }
	    }
	  }
	  hook.memoizedState = hook.baseState = initialState;
	  hook.queue = {
	    pending: null,
	    lanes: 0,
	    dispatch: null,
	    lastRenderedReducer: basicStateReducer,
	    lastRenderedState: initialState
	  };
	  return hook;
	}
	function updateOptimisticImpl(hook, current, passthrough, reducer) {
	  hook.baseState = passthrough;
	  return updateReducerImpl(
	    hook,
	    currentHook,
	    "function" === typeof reducer ? reducer : basicStateReducer
	  );
	}
	function dispatchActionState(
	  fiber,
	  actionQueue,
	  setPendingState,
	  setState,
	  payload
	) {
	  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage$1(485));
	  fiber = actionQueue.action;
	  if (null !== fiber) {
	    var actionNode = {
	      payload: payload,
	      action: fiber,
	      next: null,
	      isTransition: !0,
	      status: "pending",
	      value: null,
	      reason: null,
	      listeners: [],
	      then: function (listener) {
	        actionNode.listeners.push(listener);
	      }
	    };
	    null !== ReactSharedInternals.T
	      ? setPendingState(!0)
	      : (actionNode.isTransition = !1);
	    setState(actionNode);
	    setPendingState = actionQueue.pending;
	    null === setPendingState
	      ? ((actionNode.next = actionQueue.pending = actionNode),
	        runActionStateAction(actionQueue, actionNode))
	      : ((actionNode.next = setPendingState.next),
	        (actionQueue.pending = setPendingState.next = actionNode));
	  }
	}
	function runActionStateAction(actionQueue, node) {
	  var action = node.action,
	    payload = node.payload,
	    prevState = actionQueue.state;
	  if (node.isTransition) {
	    var prevTransition = ReactSharedInternals.T,
	      currentTransition = {};
	    ReactSharedInternals.T = currentTransition;
	    try {
	      var returnValue = action(prevState, payload),
	        onStartTransitionFinish = ReactSharedInternals.S;
	      null !== onStartTransitionFinish &&
	        onStartTransitionFinish(currentTransition, returnValue);
	      handleActionReturnValue(actionQueue, node, returnValue);
	    } catch (error) {
	      onActionError(actionQueue, node, error);
	    } finally {
	      ReactSharedInternals.T = prevTransition;
	    }
	  } else
	    try {
	      (prevTransition = action(prevState, payload)),
	        handleActionReturnValue(actionQueue, node, prevTransition);
	    } catch (error$38) {
	      onActionError(actionQueue, node, error$38);
	    }
	}
	function handleActionReturnValue(actionQueue, node, returnValue) {
	  null !== returnValue &&
	  "object" === typeof returnValue &&
	  "function" === typeof returnValue.then
	    ? returnValue.then(
	        function (nextState) {
	          onActionSuccess(actionQueue, node, nextState);
	        },
	        function (error) {
	          return onActionError(actionQueue, node, error);
	        }
	      )
	    : onActionSuccess(actionQueue, node, returnValue);
	}
	function onActionSuccess(actionQueue, actionNode, nextState) {
	  actionNode.status = "fulfilled";
	  actionNode.value = nextState;
	  notifyActionListeners(actionNode);
	  actionQueue.state = nextState;
	  actionNode = actionQueue.pending;
	  null !== actionNode &&
	    ((nextState = actionNode.next),
	    nextState === actionNode
	      ? (actionQueue.pending = null)
	      : ((nextState = nextState.next),
	        (actionNode.next = nextState),
	        runActionStateAction(actionQueue, nextState)));
	}
	function onActionError(actionQueue, actionNode, error) {
	  var last = actionQueue.pending;
	  actionQueue.pending = null;
	  if (null !== last) {
	    last = last.next;
	    do
	      (actionNode.status = "rejected"),
	        (actionNode.reason = error),
	        notifyActionListeners(actionNode),
	        (actionNode = actionNode.next);
	    while (actionNode !== last);
	  }
	  actionQueue.action = null;
	}
	function notifyActionListeners(actionNode) {
	  actionNode = actionNode.listeners;
	  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
	}
	function actionStateReducer(oldState, newState) {
	  return newState;
	}
	function mountActionState(action, initialStateProp) {
	  if (isHydrating) {
	    var ssrFormState = workInProgressRoot.formState;
	    if (null !== ssrFormState) {
	      a: {
	        var JSCompiler_inline_result = currentlyRenderingFiber;
	        if (isHydrating) {
	          if (nextHydratableInstance) {
	            b: {
	              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
	              for (
	                var inRootOrSingleton = rootOrSingletonContext;
	                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

	              ) {
	                if (!inRootOrSingleton) {
	                  JSCompiler_inline_result$jscomp$0 = null;
	                  break b;
	                }
	                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
	                  JSCompiler_inline_result$jscomp$0.nextSibling
	                );
	                if (null === JSCompiler_inline_result$jscomp$0) {
	                  JSCompiler_inline_result$jscomp$0 = null;
	                  break b;
	                }
	              }
	              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
	              JSCompiler_inline_result$jscomp$0 =
	                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
	                  ? JSCompiler_inline_result$jscomp$0
	                  : null;
	            }
	            if (JSCompiler_inline_result$jscomp$0) {
	              nextHydratableInstance = getNextHydratable(
	                JSCompiler_inline_result$jscomp$0.nextSibling
	              );
	              JSCompiler_inline_result =
	                "F!" === JSCompiler_inline_result$jscomp$0.data;
	              break a;
	            }
	          }
	          throwOnHydrationMismatch(JSCompiler_inline_result);
	        }
	        JSCompiler_inline_result = !1;
	      }
	      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
	    }
	  }
	  ssrFormState = mountWorkInProgressHook();
	  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
	  JSCompiler_inline_result = {
	    pending: null,
	    lanes: 0,
	    dispatch: null,
	    lastRenderedReducer: actionStateReducer,
	    lastRenderedState: initialStateProp
	  };
	  ssrFormState.queue = JSCompiler_inline_result;
	  ssrFormState = dispatchSetState.bind(
	    null,
	    currentlyRenderingFiber,
	    JSCompiler_inline_result
	  );
	  JSCompiler_inline_result.dispatch = ssrFormState;
	  JSCompiler_inline_result = mountStateImpl(!1);
	  inRootOrSingleton = dispatchOptimisticSetState.bind(
	    null,
	    currentlyRenderingFiber,
	    !1,
	    JSCompiler_inline_result.queue
	  );
	  JSCompiler_inline_result = mountWorkInProgressHook();
	  JSCompiler_inline_result$jscomp$0 = {
	    state: initialStateProp,
	    dispatch: null,
	    action: action,
	    pending: null
	  };
	  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
	  ssrFormState = dispatchActionState.bind(
	    null,
	    currentlyRenderingFiber,
	    JSCompiler_inline_result$jscomp$0,
	    inRootOrSingleton,
	    ssrFormState
	  );
	  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
	  JSCompiler_inline_result.memoizedState = action;
	  return [initialStateProp, ssrFormState, !1];
	}
	function updateActionState(action) {
	  var stateHook = updateWorkInProgressHook();
	  return updateActionStateImpl(stateHook, currentHook, action);
	}
	function updateActionStateImpl(stateHook, currentStateHook, action) {
	  currentStateHook = updateReducerImpl(
	    stateHook,
	    currentStateHook,
	    actionStateReducer
	  )[0];
	  stateHook = updateReducer(basicStateReducer)[0];
	  if (
	    "object" === typeof currentStateHook &&
	    null !== currentStateHook &&
	    "function" === typeof currentStateHook.then
	  )
	    try {
	      var state = useThenable(currentStateHook);
	    } catch (x) {
	      if (x === SuspenseException) throw SuspenseActionException;
	      throw x;
	    }
	  else state = currentStateHook;
	  currentStateHook = updateWorkInProgressHook();
	  var actionQueue = currentStateHook.queue,
	    dispatch = actionQueue.dispatch;
	  action !== currentStateHook.memoizedState &&
	    ((currentlyRenderingFiber.flags |= 2048),
	    pushSimpleEffect(
	      9,
	      createEffectInstance(),
	      actionStateActionEffect.bind(null, actionQueue, action),
	      null
	    ));
	  return [state, dispatch, stateHook];
	}
	function actionStateActionEffect(actionQueue, action) {
	  actionQueue.action = action;
	}
	function rerenderActionState(action) {
	  var stateHook = updateWorkInProgressHook(),
	    currentStateHook = currentHook;
	  if (null !== currentStateHook)
	    return updateActionStateImpl(stateHook, currentStateHook, action);
	  updateWorkInProgressHook();
	  stateHook = stateHook.memoizedState;
	  currentStateHook = updateWorkInProgressHook();
	  var dispatch = currentStateHook.queue.dispatch;
	  currentStateHook.memoizedState = action;
	  return [stateHook, dispatch, !1];
	}
	function pushSimpleEffect(tag, inst, create, createDeps) {
	  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };
	  inst = currentlyRenderingFiber.updateQueue;
	  null === inst &&
	    ((inst = createFunctionComponentUpdateQueue()),
	    (currentlyRenderingFiber.updateQueue = inst));
	  create = inst.lastEffect;
	  null === create
	    ? (inst.lastEffect = tag.next = tag)
	    : ((createDeps = create.next),
	      (create.next = tag),
	      (tag.next = createDeps),
	      (inst.lastEffect = tag));
	  return tag;
	}
	function createEffectInstance() {
	  return { destroy: void 0, resource: void 0 };
	}
	function updateRef() {
	  return updateWorkInProgressHook().memoizedState;
	}
	function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
	  var hook = mountWorkInProgressHook();
	  createDeps = void 0 === createDeps ? null : createDeps;
	  currentlyRenderingFiber.flags |= fiberFlags;
	  hook.memoizedState = pushSimpleEffect(
	    1 | hookFlags,
	    createEffectInstance(),
	    create,
	    createDeps
	  );
	}
	function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
	  var hook = updateWorkInProgressHook();
	  deps = void 0 === deps ? null : deps;
	  var inst = hook.memoizedState.inst;
	  null !== currentHook &&
	  null !== deps &&
	  areHookInputsEqual(deps, currentHook.memoizedState.deps)
	    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
	    : ((currentlyRenderingFiber.flags |= fiberFlags),
	      (hook.memoizedState = pushSimpleEffect(
	        1 | hookFlags,
	        inst,
	        create,
	        deps
	      )));
	}
	function mountEffect(create, createDeps) {
	  mountEffectImpl(8390656, 8, create, createDeps);
	}
	function updateEffect(create, createDeps) {
	  updateEffectImpl(2048, 8, create, createDeps);
	}
	function updateInsertionEffect(create, deps) {
	  return updateEffectImpl(4, 2, create, deps);
	}
	function updateLayoutEffect(create, deps) {
	  return updateEffectImpl(4, 4, create, deps);
	}
	function imperativeHandleEffect(create, ref) {
	  if ("function" === typeof ref) {
	    create = create();
	    var refCleanup = ref(create);
	    return function () {
	      "function" === typeof refCleanup ? refCleanup() : ref(null);
	    };
	  }
	  if (null !== ref && void 0 !== ref)
	    return (
	      (create = create()),
	      (ref.current = create),
	      function () {
	        ref.current = null;
	      }
	    );
	}
	function updateImperativeHandle(ref, create, deps) {
	  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
	  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
	}
	function mountDebugValue() {}
	function updateCallback(callback, deps) {
	  var hook = updateWorkInProgressHook();
	  deps = void 0 === deps ? null : deps;
	  var prevState = hook.memoizedState;
	  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
	    return prevState[0];
	  hook.memoizedState = [callback, deps];
	  return callback;
	}
	function updateMemo(nextCreate, deps) {
	  var hook = updateWorkInProgressHook();
	  deps = void 0 === deps ? null : deps;
	  var prevState = hook.memoizedState;
	  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
	    return prevState[0];
	  prevState = nextCreate();
	  if (shouldDoubleInvokeUserFnsInHooksDEV) {
	    setIsStrictModeForDevtools(!0);
	    try {
	      nextCreate();
	    } finally {
	      setIsStrictModeForDevtools(!1);
	    }
	  }
	  hook.memoizedState = [prevState, deps];
	  return prevState;
	}
	function mountDeferredValueImpl(hook, value, initialValue) {
	  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
	    return (hook.memoizedState = value);
	  hook.memoizedState = initialValue;
	  hook = requestDeferredLane();
	  currentlyRenderingFiber.lanes |= hook;
	  workInProgressRootSkippedLanes |= hook;
	  return initialValue;
	}
	function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
	  if (objectIs(value, prevValue)) return value;
	  if (null !== currentTreeHiddenStackCursor.current)
	    return (
	      (hook = mountDeferredValueImpl(hook, value, initialValue)),
	      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
	      hook
	    );
	  if (0 === (renderLanes & 42))
	    return (didReceiveUpdate = !0), (hook.memoizedState = value);
	  hook = requestDeferredLane();
	  currentlyRenderingFiber.lanes |= hook;
	  workInProgressRootSkippedLanes |= hook;
	  return prevValue;
	}
	function startTransition(fiber, queue, pendingState, finishedState, callback) {
	  var previousPriority = ReactDOMSharedInternals.p;
	  ReactDOMSharedInternals.p =
	    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
	  var prevTransition = ReactSharedInternals.T,
	    currentTransition = {};
	  ReactSharedInternals.T = currentTransition;
	  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
	  try {
	    var returnValue = callback(),
	      onStartTransitionFinish = ReactSharedInternals.S;
	    null !== onStartTransitionFinish &&
	      onStartTransitionFinish(currentTransition, returnValue);
	    if (
	      null !== returnValue &&
	      "object" === typeof returnValue &&
	      "function" === typeof returnValue.then
	    ) {
	      var thenableForFinishedState = chainThenableValue(
	        returnValue,
	        finishedState
	      );
	      dispatchSetStateInternal(
	        fiber,
	        queue,
	        thenableForFinishedState,
	        requestUpdateLane()
	      );
	    } else
	      dispatchSetStateInternal(
	        fiber,
	        queue,
	        finishedState,
	        requestUpdateLane()
	      );
	  } catch (error) {
	    dispatchSetStateInternal(
	      fiber,
	      queue,
	      { then: function () {}, status: "rejected", reason: error },
	      requestUpdateLane()
	    );
	  } finally {
	    (ReactDOMSharedInternals.p = previousPriority),
	      (ReactSharedInternals.T = prevTransition);
	  }
	}
	function noop$2() {}
	function startHostTransition(formFiber, pendingState, action, formData) {
	  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage$1(476));
	  var queue = ensureFormComponentIsStateful(formFiber).queue;
	  startTransition(
	    formFiber,
	    queue,
	    pendingState,
	    sharedNotPendingObject,
	    null === action
	      ? noop$2
	      : function () {
	          requestFormReset$1(formFiber);
	          return action(formData);
	        }
	  );
	}
	function ensureFormComponentIsStateful(formFiber) {
	  var existingStateHook = formFiber.memoizedState;
	  if (null !== existingStateHook) return existingStateHook;
	  existingStateHook = {
	    memoizedState: sharedNotPendingObject,
	    baseState: sharedNotPendingObject,
	    baseQueue: null,
	    queue: {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: basicStateReducer,
	      lastRenderedState: sharedNotPendingObject
	    },
	    next: null
	  };
	  var initialResetState = {};
	  existingStateHook.next = {
	    memoizedState: initialResetState,
	    baseState: initialResetState,
	    baseQueue: null,
	    queue: {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: basicStateReducer,
	      lastRenderedState: initialResetState
	    },
	    next: null
	  };
	  formFiber.memoizedState = existingStateHook;
	  formFiber = formFiber.alternate;
	  null !== formFiber && (formFiber.memoizedState = existingStateHook);
	  return existingStateHook;
	}
	function requestFormReset$1(formFiber) {
	  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
	  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
	}
	function useHostTransitionStatus() {
	  return readContext(HostTransitionContext);
	}
	function updateId() {
	  return updateWorkInProgressHook().memoizedState;
	}
	function updateRefresh() {
	  return updateWorkInProgressHook().memoizedState;
	}
	function refreshCache(fiber) {
	  for (var provider = fiber.return; null !== provider; ) {
	    switch (provider.tag) {
	      case 24:
	      case 3:
	        var lane = requestUpdateLane();
	        fiber = createUpdate(lane);
	        var root$41 = enqueueUpdate(provider, fiber, lane);
	        null !== root$41 &&
	          (scheduleUpdateOnFiber(root$41, provider, lane),
	          entangleTransitions(root$41, provider, lane));
	        provider = { cache: createCache() };
	        fiber.payload = provider;
	        return;
	    }
	    provider = provider.return;
	  }
	}
	function dispatchReducerAction(fiber, queue, action) {
	  var lane = requestUpdateLane();
	  action = {
	    lane: lane,
	    revertLane: 0,
	    action: action,
	    hasEagerState: !1,
	    eagerState: null,
	    next: null
	  };
	  isRenderPhaseUpdate(fiber)
	    ? enqueueRenderPhaseUpdate(queue, action)
	    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
	      null !== action &&
	        (scheduleUpdateOnFiber(action, fiber, lane),
	        entangleTransitionUpdate(action, queue, lane)));
	}
	function dispatchSetState(fiber, queue, action) {
	  var lane = requestUpdateLane();
	  dispatchSetStateInternal(fiber, queue, action, lane);
	}
	function dispatchSetStateInternal(fiber, queue, action, lane) {
	  var update = {
	    lane: lane,
	    revertLane: 0,
	    action: action,
	    hasEagerState: !1,
	    eagerState: null,
	    next: null
	  };
	  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
	  else {
	    var alternate = fiber.alternate;
	    if (
	      0 === fiber.lanes &&
	      (null === alternate || 0 === alternate.lanes) &&
	      ((alternate = queue.lastRenderedReducer), null !== alternate)
	    )
	      try {
	        var currentState = queue.lastRenderedState,
	          eagerState = alternate(currentState, action);
	        update.hasEagerState = !0;
	        update.eagerState = eagerState;
	        if (objectIs(eagerState, currentState))
	          return (
	            enqueueUpdate$1(fiber, queue, update, 0),
	            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
	            !1
	          );
	      } catch (error) {
	      } finally {
	      }
	    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
	    if (null !== action)
	      return (
	        scheduleUpdateOnFiber(action, fiber, lane),
	        entangleTransitionUpdate(action, queue, lane),
	        !0
	      );
	  }
	  return !1;
	}
	function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
	  action = {
	    lane: 2,
	    revertLane: requestTransitionLane(),
	    action: action,
	    hasEagerState: !1,
	    eagerState: null,
	    next: null
	  };
	  if (isRenderPhaseUpdate(fiber)) {
	    if (throwIfDuringRender) throw Error(formatProdErrorMessage$1(479));
	  } else
	    (throwIfDuringRender = enqueueConcurrentHookUpdate(
	      fiber,
	      queue,
	      action,
	      2
	    )),
	      null !== throwIfDuringRender &&
	        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
	}
	function isRenderPhaseUpdate(fiber) {
	  var alternate = fiber.alternate;
	  return (
	    fiber === currentlyRenderingFiber ||
	    (null !== alternate && alternate === currentlyRenderingFiber)
	  );
	}
	function enqueueRenderPhaseUpdate(queue, update) {
	  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
	    !0;
	  var pending = queue.pending;
	  null === pending
	    ? (update.next = update)
	    : ((update.next = pending.next), (pending.next = update));
	  queue.pending = update;
	}
	function entangleTransitionUpdate(root, queue, lane) {
	  if (0 !== (lane & 4194048)) {
	    var queueLanes = queue.lanes;
	    queueLanes &= root.pendingLanes;
	    lane |= queueLanes;
	    queue.lanes = lane;
	    markRootEntangled(root, lane);
	  }
	}
	var ContextOnlyDispatcher = {
	    readContext: readContext,
	    use: use,
	    useCallback: throwInvalidHookError,
	    useContext: throwInvalidHookError,
	    useEffect: throwInvalidHookError,
	    useImperativeHandle: throwInvalidHookError,
	    useLayoutEffect: throwInvalidHookError,
	    useInsertionEffect: throwInvalidHookError,
	    useMemo: throwInvalidHookError,
	    useReducer: throwInvalidHookError,
	    useRef: throwInvalidHookError,
	    useState: throwInvalidHookError,
	    useDebugValue: throwInvalidHookError,
	    useDeferredValue: throwInvalidHookError,
	    useTransition: throwInvalidHookError,
	    useSyncExternalStore: throwInvalidHookError,
	    useId: throwInvalidHookError,
	    useHostTransitionStatus: throwInvalidHookError,
	    useFormState: throwInvalidHookError,
	    useActionState: throwInvalidHookError,
	    useOptimistic: throwInvalidHookError,
	    useMemoCache: throwInvalidHookError,
	    useCacheRefresh: throwInvalidHookError
	  },
	  HooksDispatcherOnMount = {
	    readContext: readContext,
	    use: use,
	    useCallback: function (callback, deps) {
	      mountWorkInProgressHook().memoizedState = [
	        callback,
	        void 0 === deps ? null : deps
	      ];
	      return callback;
	    },
	    useContext: readContext,
	    useEffect: mountEffect,
	    useImperativeHandle: function (ref, create, deps) {
	      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
	      mountEffectImpl(
	        4194308,
	        4,
	        imperativeHandleEffect.bind(null, create, ref),
	        deps
	      );
	    },
	    useLayoutEffect: function (create, deps) {
	      return mountEffectImpl(4194308, 4, create, deps);
	    },
	    useInsertionEffect: function (create, deps) {
	      mountEffectImpl(4, 2, create, deps);
	    },
	    useMemo: function (nextCreate, deps) {
	      var hook = mountWorkInProgressHook();
	      deps = void 0 === deps ? null : deps;
	      var nextValue = nextCreate();
	      if (shouldDoubleInvokeUserFnsInHooksDEV) {
	        setIsStrictModeForDevtools(!0);
	        try {
	          nextCreate();
	        } finally {
	          setIsStrictModeForDevtools(!1);
	        }
	      }
	      hook.memoizedState = [nextValue, deps];
	      return nextValue;
	    },
	    useReducer: function (reducer, initialArg, init) {
	      var hook = mountWorkInProgressHook();
	      if (void 0 !== init) {
	        var initialState = init(initialArg);
	        if (shouldDoubleInvokeUserFnsInHooksDEV) {
	          setIsStrictModeForDevtools(!0);
	          try {
	            init(initialArg);
	          } finally {
	            setIsStrictModeForDevtools(!1);
	          }
	        }
	      } else initialState = initialArg;
	      hook.memoizedState = hook.baseState = initialState;
	      reducer = {
	        pending: null,
	        lanes: 0,
	        dispatch: null,
	        lastRenderedReducer: reducer,
	        lastRenderedState: initialState
	      };
	      hook.queue = reducer;
	      reducer = reducer.dispatch = dispatchReducerAction.bind(
	        null,
	        currentlyRenderingFiber,
	        reducer
	      );
	      return [hook.memoizedState, reducer];
	    },
	    useRef: function (initialValue) {
	      var hook = mountWorkInProgressHook();
	      initialValue = { current: initialValue };
	      return (hook.memoizedState = initialValue);
	    },
	    useState: function (initialState) {
	      initialState = mountStateImpl(initialState);
	      var queue = initialState.queue,
	        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
	      queue.dispatch = dispatch;
	      return [initialState.memoizedState, dispatch];
	    },
	    useDebugValue: mountDebugValue,
	    useDeferredValue: function (value, initialValue) {
	      var hook = mountWorkInProgressHook();
	      return mountDeferredValueImpl(hook, value, initialValue);
	    },
	    useTransition: function () {
	      var stateHook = mountStateImpl(!1);
	      stateHook = startTransition.bind(
	        null,
	        currentlyRenderingFiber,
	        stateHook.queue,
	        !0,
	        !1
	      );
	      mountWorkInProgressHook().memoizedState = stateHook;
	      return [!1, stateHook];
	    },
	    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
	      var fiber = currentlyRenderingFiber,
	        hook = mountWorkInProgressHook();
	      if (isHydrating) {
	        if (void 0 === getServerSnapshot)
	          throw Error(formatProdErrorMessage$1(407));
	        getServerSnapshot = getServerSnapshot();
	      } else {
	        getServerSnapshot = getSnapshot();
	        if (null === workInProgressRoot)
	          throw Error(formatProdErrorMessage$1(349));
	        0 !== (workInProgressRootRenderLanes & 124) ||
	          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
	      }
	      hook.memoizedState = getServerSnapshot;
	      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
	      hook.queue = inst;
	      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
	        subscribe
	      ]);
	      fiber.flags |= 2048;
	      pushSimpleEffect(
	        9,
	        createEffectInstance(),
	        updateStoreInstance.bind(
	          null,
	          fiber,
	          inst,
	          getServerSnapshot,
	          getSnapshot
	        ),
	        null
	      );
	      return getServerSnapshot;
	    },
	    useId: function () {
	      var hook = mountWorkInProgressHook(),
	        identifierPrefix = workInProgressRoot.identifierPrefix;
	      if (isHydrating) {
	        var JSCompiler_inline_result = treeContextOverflow;
	        var idWithLeadingBit = treeContextId;
	        JSCompiler_inline_result =
	          (
	            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
	          ).toString(32) + JSCompiler_inline_result;
	        identifierPrefix =
	          "\u00ab" + identifierPrefix + "R" + JSCompiler_inline_result;
	        JSCompiler_inline_result = localIdCounter++;
	        0 < JSCompiler_inline_result &&
	          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
	        identifierPrefix += "\u00bb";
	      } else
	        (JSCompiler_inline_result = globalClientIdCounter++),
	          (identifierPrefix =
	            "\u00ab" +
	            identifierPrefix +
	            "r" +
	            JSCompiler_inline_result.toString(32) +
	            "\u00bb");
	      return (hook.memoizedState = identifierPrefix);
	    },
	    useHostTransitionStatus: useHostTransitionStatus,
	    useFormState: mountActionState,
	    useActionState: mountActionState,
	    useOptimistic: function (passthrough) {
	      var hook = mountWorkInProgressHook();
	      hook.memoizedState = hook.baseState = passthrough;
	      var queue = {
	        pending: null,
	        lanes: 0,
	        dispatch: null,
	        lastRenderedReducer: null,
	        lastRenderedState: null
	      };
	      hook.queue = queue;
	      hook = dispatchOptimisticSetState.bind(
	        null,
	        currentlyRenderingFiber,
	        !0,
	        queue
	      );
	      queue.dispatch = hook;
	      return [passthrough, hook];
	    },
	    useMemoCache: useMemoCache,
	    useCacheRefresh: function () {
	      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
	        null,
	        currentlyRenderingFiber
	      ));
	    }
	  },
	  HooksDispatcherOnUpdate = {
	    readContext: readContext,
	    use: use,
	    useCallback: updateCallback,
	    useContext: readContext,
	    useEffect: updateEffect,
	    useImperativeHandle: updateImperativeHandle,
	    useInsertionEffect: updateInsertionEffect,
	    useLayoutEffect: updateLayoutEffect,
	    useMemo: updateMemo,
	    useReducer: updateReducer,
	    useRef: updateRef,
	    useState: function () {
	      return updateReducer(basicStateReducer);
	    },
	    useDebugValue: mountDebugValue,
	    useDeferredValue: function (value, initialValue) {
	      var hook = updateWorkInProgressHook();
	      return updateDeferredValueImpl(
	        hook,
	        currentHook.memoizedState,
	        value,
	        initialValue
	      );
	    },
	    useTransition: function () {
	      var booleanOrThenable = updateReducer(basicStateReducer)[0],
	        start = updateWorkInProgressHook().memoizedState;
	      return [
	        "boolean" === typeof booleanOrThenable
	          ? booleanOrThenable
	          : useThenable(booleanOrThenable),
	        start
	      ];
	    },
	    useSyncExternalStore: updateSyncExternalStore,
	    useId: updateId,
	    useHostTransitionStatus: useHostTransitionStatus,
	    useFormState: updateActionState,
	    useActionState: updateActionState,
	    useOptimistic: function (passthrough, reducer) {
	      var hook = updateWorkInProgressHook();
	      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
	    },
	    useMemoCache: useMemoCache,
	    useCacheRefresh: updateRefresh
	  },
	  HooksDispatcherOnRerender = {
	    readContext: readContext,
	    use: use,
	    useCallback: updateCallback,
	    useContext: readContext,
	    useEffect: updateEffect,
	    useImperativeHandle: updateImperativeHandle,
	    useInsertionEffect: updateInsertionEffect,
	    useLayoutEffect: updateLayoutEffect,
	    useMemo: updateMemo,
	    useReducer: rerenderReducer,
	    useRef: updateRef,
	    useState: function () {
	      return rerenderReducer(basicStateReducer);
	    },
	    useDebugValue: mountDebugValue,
	    useDeferredValue: function (value, initialValue) {
	      var hook = updateWorkInProgressHook();
	      return null === currentHook
	        ? mountDeferredValueImpl(hook, value, initialValue)
	        : updateDeferredValueImpl(
	            hook,
	            currentHook.memoizedState,
	            value,
	            initialValue
	          );
	    },
	    useTransition: function () {
	      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
	        start = updateWorkInProgressHook().memoizedState;
	      return [
	        "boolean" === typeof booleanOrThenable
	          ? booleanOrThenable
	          : useThenable(booleanOrThenable),
	        start
	      ];
	    },
	    useSyncExternalStore: updateSyncExternalStore,
	    useId: updateId,
	    useHostTransitionStatus: useHostTransitionStatus,
	    useFormState: rerenderActionState,
	    useActionState: rerenderActionState,
	    useOptimistic: function (passthrough, reducer) {
	      var hook = updateWorkInProgressHook();
	      if (null !== currentHook)
	        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
	      hook.baseState = passthrough;
	      return [passthrough, hook.queue.dispatch];
	    },
	    useMemoCache: useMemoCache,
	    useCacheRefresh: updateRefresh
	  },
	  thenableState = null,
	  thenableIndexCounter = 0;
	function unwrapThenable(thenable) {
	  var index = thenableIndexCounter;
	  thenableIndexCounter += 1;
	  null === thenableState && (thenableState = []);
	  return trackUsedThenable(thenableState, thenable, index);
	}
	function coerceRef(workInProgress, element) {
	  element = element.props.ref;
	  workInProgress.ref = void 0 !== element ? element : null;
	}
	function throwOnInvalidObjectType(returnFiber, newChild) {
	  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
	    throw Error(formatProdErrorMessage$1(525));
	  returnFiber = Object.prototype.toString.call(newChild);
	  throw Error(
	    formatProdErrorMessage$1(
	      31,
	      "[object Object]" === returnFiber
	        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
	        : returnFiber
	    )
	  );
	}
	function resolveLazy(lazyType) {
	  var init = lazyType._init;
	  return init(lazyType._payload);
	}
	function createChildReconciler(shouldTrackSideEffects) {
	  function deleteChild(returnFiber, childToDelete) {
	    if (shouldTrackSideEffects) {
	      var deletions = returnFiber.deletions;
	      null === deletions
	        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
	        : deletions.push(childToDelete);
	    }
	  }
	  function deleteRemainingChildren(returnFiber, currentFirstChild) {
	    if (!shouldTrackSideEffects) return null;
	    for (; null !== currentFirstChild; )
	      deleteChild(returnFiber, currentFirstChild),
	        (currentFirstChild = currentFirstChild.sibling);
	    return null;
	  }
	  function mapRemainingChildren(currentFirstChild) {
	    for (var existingChildren = new Map(); null !== currentFirstChild; )
	      null !== currentFirstChild.key
	        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
	        : existingChildren.set(currentFirstChild.index, currentFirstChild),
	        (currentFirstChild = currentFirstChild.sibling);
	    return existingChildren;
	  }
	  function useFiber(fiber, pendingProps) {
	    fiber = createWorkInProgress(fiber, pendingProps);
	    fiber.index = 0;
	    fiber.sibling = null;
	    return fiber;
	  }
	  function placeChild(newFiber, lastPlacedIndex, newIndex) {
	    newFiber.index = newIndex;
	    if (!shouldTrackSideEffects)
	      return (newFiber.flags |= 1048576), lastPlacedIndex;
	    newIndex = newFiber.alternate;
	    if (null !== newIndex)
	      return (
	        (newIndex = newIndex.index),
	        newIndex < lastPlacedIndex
	          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
	          : newIndex
	      );
	    newFiber.flags |= 67108866;
	    return lastPlacedIndex;
	  }
	  function placeSingleChild(newFiber) {
	    shouldTrackSideEffects &&
	      null === newFiber.alternate &&
	      (newFiber.flags |= 67108866);
	    return newFiber;
	  }
	  function updateTextNode(returnFiber, current, textContent, lanes) {
	    if (null === current || 6 !== current.tag)
	      return (
	        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
	        (current.return = returnFiber),
	        current
	      );
	    current = useFiber(current, textContent);
	    current.return = returnFiber;
	    return current;
	  }
	  function updateElement(returnFiber, current, element, lanes) {
	    var elementType = element.type;
	    if (elementType === REACT_FRAGMENT_TYPE)
	      return updateFragment(
	        returnFiber,
	        current,
	        element.props.children,
	        lanes,
	        element.key
	      );
	    if (
	      null !== current &&
	      (current.elementType === elementType ||
	        ("object" === typeof elementType &&
	          null !== elementType &&
	          elementType.$$typeof === REACT_LAZY_TYPE &&
	          resolveLazy(elementType) === current.type))
	    )
	      return (
	        (current = useFiber(current, element.props)),
	        coerceRef(current, element),
	        (current.return = returnFiber),
	        current
	      );
	    current = createFiberFromTypeAndProps(
	      element.type,
	      element.key,
	      element.props,
	      null,
	      returnFiber.mode,
	      lanes
	    );
	    coerceRef(current, element);
	    current.return = returnFiber;
	    return current;
	  }
	  function updatePortal(returnFiber, current, portal, lanes) {
	    if (
	      null === current ||
	      4 !== current.tag ||
	      current.stateNode.containerInfo !== portal.containerInfo ||
	      current.stateNode.implementation !== portal.implementation
	    )
	      return (
	        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
	        (current.return = returnFiber),
	        current
	      );
	    current = useFiber(current, portal.children || []);
	    current.return = returnFiber;
	    return current;
	  }
	  function updateFragment(returnFiber, current, fragment, lanes, key) {
	    if (null === current || 7 !== current.tag)
	      return (
	        (current = createFiberFromFragment(
	          fragment,
	          returnFiber.mode,
	          lanes,
	          key
	        )),
	        (current.return = returnFiber),
	        current
	      );
	    current = useFiber(current, fragment);
	    current.return = returnFiber;
	    return current;
	  }
	  function createChild(returnFiber, newChild, lanes) {
	    if (
	      ("string" === typeof newChild && "" !== newChild) ||
	      "number" === typeof newChild ||
	      "bigint" === typeof newChild
	    )
	      return (
	        (newChild = createFiberFromText(
	          "" + newChild,
	          returnFiber.mode,
	          lanes
	        )),
	        (newChild.return = returnFiber),
	        newChild
	      );
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return (
	            (lanes = createFiberFromTypeAndProps(
	              newChild.type,
	              newChild.key,
	              newChild.props,
	              null,
	              returnFiber.mode,
	              lanes
	            )),
	            coerceRef(lanes, newChild),
	            (lanes.return = returnFiber),
	            lanes
	          );
	        case REACT_PORTAL_TYPE:
	          return (
	            (newChild = createFiberFromPortal(
	              newChild,
	              returnFiber.mode,
	              lanes
	            )),
	            (newChild.return = returnFiber),
	            newChild
	          );
	        case REACT_LAZY_TYPE:
	          var init = newChild._init;
	          newChild = init(newChild._payload);
	          return createChild(returnFiber, newChild, lanes);
	      }
	      if (isArrayImpl(newChild) || getIteratorFn(newChild))
	        return (
	          (newChild = createFiberFromFragment(
	            newChild,
	            returnFiber.mode,
	            lanes,
	            null
	          )),
	          (newChild.return = returnFiber),
	          newChild
	        );
	      if ("function" === typeof newChild.then)
	        return createChild(returnFiber, unwrapThenable(newChild), lanes);
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return createChild(
	          returnFiber,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return null;
	  }
	  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
	    var key = null !== oldFiber ? oldFiber.key : null;
	    if (
	      ("string" === typeof newChild && "" !== newChild) ||
	      "number" === typeof newChild ||
	      "bigint" === typeof newChild
	    )
	      return null !== key
	        ? null
	        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return newChild.key === key
	            ? updateElement(returnFiber, oldFiber, newChild, lanes)
	            : null;
	        case REACT_PORTAL_TYPE:
	          return newChild.key === key
	            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
	            : null;
	        case REACT_LAZY_TYPE:
	          return (
	            (key = newChild._init),
	            (newChild = key(newChild._payload)),
	            updateSlot(returnFiber, oldFiber, newChild, lanes)
	          );
	      }
	      if (isArrayImpl(newChild) || getIteratorFn(newChild))
	        return null !== key
	          ? null
	          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
	      if ("function" === typeof newChild.then)
	        return updateSlot(
	          returnFiber,
	          oldFiber,
	          unwrapThenable(newChild),
	          lanes
	        );
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return updateSlot(
	          returnFiber,
	          oldFiber,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return null;
	  }
	  function updateFromMap(
	    existingChildren,
	    returnFiber,
	    newIdx,
	    newChild,
	    lanes
	  ) {
	    if (
	      ("string" === typeof newChild && "" !== newChild) ||
	      "number" === typeof newChild ||
	      "bigint" === typeof newChild
	    )
	      return (
	        (existingChildren = existingChildren.get(newIdx) || null),
	        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
	      );
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return (
	            (existingChildren =
	              existingChildren.get(
	                null === newChild.key ? newIdx : newChild.key
	              ) || null),
	            updateElement(returnFiber, existingChildren, newChild, lanes)
	          );
	        case REACT_PORTAL_TYPE:
	          return (
	            (existingChildren =
	              existingChildren.get(
	                null === newChild.key ? newIdx : newChild.key
	              ) || null),
	            updatePortal(returnFiber, existingChildren, newChild, lanes)
	          );
	        case REACT_LAZY_TYPE:
	          var init = newChild._init;
	          newChild = init(newChild._payload);
	          return updateFromMap(
	            existingChildren,
	            returnFiber,
	            newIdx,
	            newChild,
	            lanes
	          );
	      }
	      if (isArrayImpl(newChild) || getIteratorFn(newChild))
	        return (
	          (existingChildren = existingChildren.get(newIdx) || null),
	          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
	        );
	      if ("function" === typeof newChild.then)
	        return updateFromMap(
	          existingChildren,
	          returnFiber,
	          newIdx,
	          unwrapThenable(newChild),
	          lanes
	        );
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return updateFromMap(
	          existingChildren,
	          returnFiber,
	          newIdx,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return null;
	  }
	  function reconcileChildrenArray(
	    returnFiber,
	    currentFirstChild,
	    newChildren,
	    lanes
	  ) {
	    for (
	      var resultingFirstChild = null,
	        previousNewFiber = null,
	        oldFiber = currentFirstChild,
	        newIdx = (currentFirstChild = 0),
	        nextOldFiber = null;
	      null !== oldFiber && newIdx < newChildren.length;
	      newIdx++
	    ) {
	      oldFiber.index > newIdx
	        ? ((nextOldFiber = oldFiber), (oldFiber = null))
	        : (nextOldFiber = oldFiber.sibling);
	      var newFiber = updateSlot(
	        returnFiber,
	        oldFiber,
	        newChildren[newIdx],
	        lanes
	      );
	      if (null === newFiber) {
	        null === oldFiber && (oldFiber = nextOldFiber);
	        break;
	      }
	      shouldTrackSideEffects &&
	        oldFiber &&
	        null === newFiber.alternate &&
	        deleteChild(returnFiber, oldFiber);
	      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
	      null === previousNewFiber
	        ? (resultingFirstChild = newFiber)
	        : (previousNewFiber.sibling = newFiber);
	      previousNewFiber = newFiber;
	      oldFiber = nextOldFiber;
	    }
	    if (newIdx === newChildren.length)
	      return (
	        deleteRemainingChildren(returnFiber, oldFiber),
	        isHydrating && pushTreeFork(returnFiber, newIdx),
	        resultingFirstChild
	      );
	    if (null === oldFiber) {
	      for (; newIdx < newChildren.length; newIdx++)
	        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
	          null !== oldFiber &&
	            ((currentFirstChild = placeChild(
	              oldFiber,
	              currentFirstChild,
	              newIdx
	            )),
	            null === previousNewFiber
	              ? (resultingFirstChild = oldFiber)
	              : (previousNewFiber.sibling = oldFiber),
	            (previousNewFiber = oldFiber));
	      isHydrating && pushTreeFork(returnFiber, newIdx);
	      return resultingFirstChild;
	    }
	    for (
	      oldFiber = mapRemainingChildren(oldFiber);
	      newIdx < newChildren.length;
	      newIdx++
	    )
	      (nextOldFiber = updateFromMap(
	        oldFiber,
	        returnFiber,
	        newIdx,
	        newChildren[newIdx],
	        lanes
	      )),
	        null !== nextOldFiber &&
	          (shouldTrackSideEffects &&
	            null !== nextOldFiber.alternate &&
	            oldFiber.delete(
	              null === nextOldFiber.key ? newIdx : nextOldFiber.key
	            ),
	          (currentFirstChild = placeChild(
	            nextOldFiber,
	            currentFirstChild,
	            newIdx
	          )),
	          null === previousNewFiber
	            ? (resultingFirstChild = nextOldFiber)
	            : (previousNewFiber.sibling = nextOldFiber),
	          (previousNewFiber = nextOldFiber));
	    shouldTrackSideEffects &&
	      oldFiber.forEach(function (child) {
	        return deleteChild(returnFiber, child);
	      });
	    isHydrating && pushTreeFork(returnFiber, newIdx);
	    return resultingFirstChild;
	  }
	  function reconcileChildrenIterator(
	    returnFiber,
	    currentFirstChild,
	    newChildren,
	    lanes
	  ) {
	    if (null == newChildren) throw Error(formatProdErrorMessage$1(151));
	    for (
	      var resultingFirstChild = null,
	        previousNewFiber = null,
	        oldFiber = currentFirstChild,
	        newIdx = (currentFirstChild = 0),
	        nextOldFiber = null,
	        step = newChildren.next();
	      null !== oldFiber && !step.done;
	      newIdx++, step = newChildren.next()
	    ) {
	      oldFiber.index > newIdx
	        ? ((nextOldFiber = oldFiber), (oldFiber = null))
	        : (nextOldFiber = oldFiber.sibling);
	      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
	      if (null === newFiber) {
	        null === oldFiber && (oldFiber = nextOldFiber);
	        break;
	      }
	      shouldTrackSideEffects &&
	        oldFiber &&
	        null === newFiber.alternate &&
	        deleteChild(returnFiber, oldFiber);
	      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
	      null === previousNewFiber
	        ? (resultingFirstChild = newFiber)
	        : (previousNewFiber.sibling = newFiber);
	      previousNewFiber = newFiber;
	      oldFiber = nextOldFiber;
	    }
	    if (step.done)
	      return (
	        deleteRemainingChildren(returnFiber, oldFiber),
	        isHydrating && pushTreeFork(returnFiber, newIdx),
	        resultingFirstChild
	      );
	    if (null === oldFiber) {
	      for (; !step.done; newIdx++, step = newChildren.next())
	        (step = createChild(returnFiber, step.value, lanes)),
	          null !== step &&
	            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
	            null === previousNewFiber
	              ? (resultingFirstChild = step)
	              : (previousNewFiber.sibling = step),
	            (previousNewFiber = step));
	      isHydrating && pushTreeFork(returnFiber, newIdx);
	      return resultingFirstChild;
	    }
	    for (
	      oldFiber = mapRemainingChildren(oldFiber);
	      !step.done;
	      newIdx++, step = newChildren.next()
	    )
	      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
	        null !== step &&
	          (shouldTrackSideEffects &&
	            null !== step.alternate &&
	            oldFiber.delete(null === step.key ? newIdx : step.key),
	          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
	          null === previousNewFiber
	            ? (resultingFirstChild = step)
	            : (previousNewFiber.sibling = step),
	          (previousNewFiber = step));
	    shouldTrackSideEffects &&
	      oldFiber.forEach(function (child) {
	        return deleteChild(returnFiber, child);
	      });
	    isHydrating && pushTreeFork(returnFiber, newIdx);
	    return resultingFirstChild;
	  }
	  function reconcileChildFibersImpl(
	    returnFiber,
	    currentFirstChild,
	    newChild,
	    lanes
	  ) {
	    "object" === typeof newChild &&
	      null !== newChild &&
	      newChild.type === REACT_FRAGMENT_TYPE &&
	      null === newChild.key &&
	      (newChild = newChild.props.children);
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          a: {
	            for (var key = newChild.key; null !== currentFirstChild; ) {
	              if (currentFirstChild.key === key) {
	                key = newChild.type;
	                if (key === REACT_FRAGMENT_TYPE) {
	                  if (7 === currentFirstChild.tag) {
	                    deleteRemainingChildren(
	                      returnFiber,
	                      currentFirstChild.sibling
	                    );
	                    lanes = useFiber(
	                      currentFirstChild,
	                      newChild.props.children
	                    );
	                    lanes.return = returnFiber;
	                    returnFiber = lanes;
	                    break a;
	                  }
	                } else if (
	                  currentFirstChild.elementType === key ||
	                  ("object" === typeof key &&
	                    null !== key &&
	                    key.$$typeof === REACT_LAZY_TYPE &&
	                    resolveLazy(key) === currentFirstChild.type)
	                ) {
	                  deleteRemainingChildren(
	                    returnFiber,
	                    currentFirstChild.sibling
	                  );
	                  lanes = useFiber(currentFirstChild, newChild.props);
	                  coerceRef(lanes, newChild);
	                  lanes.return = returnFiber;
	                  returnFiber = lanes;
	                  break a;
	                }
	                deleteRemainingChildren(returnFiber, currentFirstChild);
	                break;
	              } else deleteChild(returnFiber, currentFirstChild);
	              currentFirstChild = currentFirstChild.sibling;
	            }
	            newChild.type === REACT_FRAGMENT_TYPE
	              ? ((lanes = createFiberFromFragment(
	                  newChild.props.children,
	                  returnFiber.mode,
	                  lanes,
	                  newChild.key
	                )),
	                (lanes.return = returnFiber),
	                (returnFiber = lanes))
	              : ((lanes = createFiberFromTypeAndProps(
	                  newChild.type,
	                  newChild.key,
	                  newChild.props,
	                  null,
	                  returnFiber.mode,
	                  lanes
	                )),
	                coerceRef(lanes, newChild),
	                (lanes.return = returnFiber),
	                (returnFiber = lanes));
	          }
	          return placeSingleChild(returnFiber);
	        case REACT_PORTAL_TYPE:
	          a: {
	            for (key = newChild.key; null !== currentFirstChild; ) {
	              if (currentFirstChild.key === key)
	                if (
	                  4 === currentFirstChild.tag &&
	                  currentFirstChild.stateNode.containerInfo ===
	                    newChild.containerInfo &&
	                  currentFirstChild.stateNode.implementation ===
	                    newChild.implementation
	                ) {
	                  deleteRemainingChildren(
	                    returnFiber,
	                    currentFirstChild.sibling
	                  );
	                  lanes = useFiber(currentFirstChild, newChild.children || []);
	                  lanes.return = returnFiber;
	                  returnFiber = lanes;
	                  break a;
	                } else {
	                  deleteRemainingChildren(returnFiber, currentFirstChild);
	                  break;
	                }
	              else deleteChild(returnFiber, currentFirstChild);
	              currentFirstChild = currentFirstChild.sibling;
	            }
	            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
	            lanes.return = returnFiber;
	            returnFiber = lanes;
	          }
	          return placeSingleChild(returnFiber);
	        case REACT_LAZY_TYPE:
	          return (
	            (key = newChild._init),
	            (newChild = key(newChild._payload)),
	            reconcileChildFibersImpl(
	              returnFiber,
	              currentFirstChild,
	              newChild,
	              lanes
	            )
	          );
	      }
	      if (isArrayImpl(newChild))
	        return reconcileChildrenArray(
	          returnFiber,
	          currentFirstChild,
	          newChild,
	          lanes
	        );
	      if (getIteratorFn(newChild)) {
	        key = getIteratorFn(newChild);
	        if ("function" !== typeof key) throw Error(formatProdErrorMessage$1(150));
	        newChild = key.call(newChild);
	        return reconcileChildrenIterator(
	          returnFiber,
	          currentFirstChild,
	          newChild,
	          lanes
	        );
	      }
	      if ("function" === typeof newChild.then)
	        return reconcileChildFibersImpl(
	          returnFiber,
	          currentFirstChild,
	          unwrapThenable(newChild),
	          lanes
	        );
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return reconcileChildFibersImpl(
	          returnFiber,
	          currentFirstChild,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return ("string" === typeof newChild && "" !== newChild) ||
	      "number" === typeof newChild ||
	      "bigint" === typeof newChild
	      ? ((newChild = "" + newChild),
	        null !== currentFirstChild && 6 === currentFirstChild.tag
	          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
	            (lanes = useFiber(currentFirstChild, newChild)),
	            (lanes.return = returnFiber),
	            (returnFiber = lanes))
	          : (deleteRemainingChildren(returnFiber, currentFirstChild),
	            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
	            (lanes.return = returnFiber),
	            (returnFiber = lanes)),
	        placeSingleChild(returnFiber))
	      : deleteRemainingChildren(returnFiber, currentFirstChild);
	  }
	  return function (returnFiber, currentFirstChild, newChild, lanes) {
	    try {
	      thenableIndexCounter = 0;
	      var firstChildFiber = reconcileChildFibersImpl(
	        returnFiber,
	        currentFirstChild,
	        newChild,
	        lanes
	      );
	      thenableState = null;
	      return firstChildFiber;
	    } catch (x) {
	      if (x === SuspenseException || x === SuspenseActionException) throw x;
	      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
	      fiber.lanes = lanes;
	      fiber.return = returnFiber;
	      return fiber;
	    } finally {
	    }
	  };
	}
	var reconcileChildFibers = createChildReconciler(!0),
	  mountChildFibers = createChildReconciler(!1),
	  suspenseHandlerStackCursor = createCursor(null),
	  shellBoundary = null;
	function pushPrimaryTreeSuspenseHandler(handler) {
	  var current = handler.alternate;
	  push(suspenseStackCursor, suspenseStackCursor.current & 1);
	  push(suspenseHandlerStackCursor, handler);
	  null === shellBoundary &&
	    (null === current || null !== currentTreeHiddenStackCursor.current
	      ? (shellBoundary = handler)
	      : null !== current.memoizedState && (shellBoundary = handler));
	}
	function pushOffscreenSuspenseHandler(fiber) {
	  if (22 === fiber.tag) {
	    if (
	      (push(suspenseStackCursor, suspenseStackCursor.current),
	      push(suspenseHandlerStackCursor, fiber),
	      null === shellBoundary)
	    ) {
	      var current = fiber.alternate;
	      null !== current &&
	        null !== current.memoizedState &&
	        (shellBoundary = fiber);
	    }
	  } else reuseSuspenseHandlerOnStack();
	}
	function reuseSuspenseHandlerOnStack() {
	  push(suspenseStackCursor, suspenseStackCursor.current);
	  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
	}
	function popSuspenseHandler(fiber) {
	  pop(suspenseHandlerStackCursor);
	  shellBoundary === fiber && (shellBoundary = null);
	  pop(suspenseStackCursor);
	}
	var suspenseStackCursor = createCursor(0);
	function findFirstSuspended(row) {
	  for (var node = row; null !== node; ) {
	    if (13 === node.tag) {
	      var state = node.memoizedState;
	      if (
	        null !== state &&
	        ((state = state.dehydrated),
	        null === state ||
	          "$?" === state.data ||
	          isSuspenseInstanceFallback(state))
	      )
	        return node;
	    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
	      if (0 !== (node.flags & 128)) return node;
	    } else if (null !== node.child) {
	      node.child.return = node;
	      node = node.child;
	      continue;
	    }
	    if (node === row) break;
	    for (; null === node.sibling; ) {
	      if (null === node.return || node.return === row) return null;
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	  return null;
	}
	function applyDerivedStateFromProps(
	  workInProgress,
	  ctor,
	  getDerivedStateFromProps,
	  nextProps
	) {
	  ctor = workInProgress.memoizedState;
	  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
	  getDerivedStateFromProps =
	    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
	      ? ctor
	      : assign({}, ctor, getDerivedStateFromProps);
	  workInProgress.memoizedState = getDerivedStateFromProps;
	  0 === workInProgress.lanes &&
	    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
	}
	var classComponentUpdater = {
	  enqueueSetState: function (inst, payload, callback) {
	    inst = inst._reactInternals;
	    var lane = requestUpdateLane(),
	      update = createUpdate(lane);
	    update.payload = payload;
	    void 0 !== callback && null !== callback && (update.callback = callback);
	    payload = enqueueUpdate(inst, update, lane);
	    null !== payload &&
	      (scheduleUpdateOnFiber(payload, inst, lane),
	      entangleTransitions(payload, inst, lane));
	  },
	  enqueueReplaceState: function (inst, payload, callback) {
	    inst = inst._reactInternals;
	    var lane = requestUpdateLane(),
	      update = createUpdate(lane);
	    update.tag = 1;
	    update.payload = payload;
	    void 0 !== callback && null !== callback && (update.callback = callback);
	    payload = enqueueUpdate(inst, update, lane);
	    null !== payload &&
	      (scheduleUpdateOnFiber(payload, inst, lane),
	      entangleTransitions(payload, inst, lane));
	  },
	  enqueueForceUpdate: function (inst, callback) {
	    inst = inst._reactInternals;
	    var lane = requestUpdateLane(),
	      update = createUpdate(lane);
	    update.tag = 2;
	    void 0 !== callback && null !== callback && (update.callback = callback);
	    callback = enqueueUpdate(inst, update, lane);
	    null !== callback &&
	      (scheduleUpdateOnFiber(callback, inst, lane),
	      entangleTransitions(callback, inst, lane));
	  }
	};
	function checkShouldComponentUpdate(
	  workInProgress,
	  ctor,
	  oldProps,
	  newProps,
	  oldState,
	  newState,
	  nextContext
	) {
	  workInProgress = workInProgress.stateNode;
	  return "function" === typeof workInProgress.shouldComponentUpdate
	    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
	    : ctor.prototype && ctor.prototype.isPureReactComponent
	      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
	      : !0;
	}
	function callComponentWillReceiveProps(
	  workInProgress,
	  instance,
	  newProps,
	  nextContext
	) {
	  workInProgress = instance.state;
	  "function" === typeof instance.componentWillReceiveProps &&
	    instance.componentWillReceiveProps(newProps, nextContext);
	  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
	    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
	  instance.state !== workInProgress &&
	    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	}
	function resolveClassComponentProps(Component, baseProps) {
	  var newProps = baseProps;
	  if ("ref" in baseProps) {
	    newProps = {};
	    for (var propName in baseProps)
	      "ref" !== propName && (newProps[propName] = baseProps[propName]);
	  }
	  if ((Component = Component.defaultProps)) {
	    newProps === baseProps && (newProps = assign({}, newProps));
	    for (var propName$73 in Component)
	      void 0 === newProps[propName$73] &&
	        (newProps[propName$73] = Component[propName$73]);
	  }
	  return newProps;
	}
	var reportGlobalError =
	  "function" === typeof reportError
	    ? reportError
	    : function (error) {
	        if (
	          "object" === typeof window &&
	          "function" === typeof window.ErrorEvent
	        ) {
	          var event = new window.ErrorEvent("error", {
	            bubbles: !0,
	            cancelable: !0,
	            message:
	              "object" === typeof error &&
	              null !== error &&
	              "string" === typeof error.message
	                ? String(error.message)
	                : String(error),
	            error: error
	          });
	          if (!window.dispatchEvent(event)) return;
	        } else if (
	          "object" === typeof process &&
	          "function" === typeof process.emit
	        ) {
	          process.emit("uncaughtException", error);
	          return;
	        }
	        console.error(error);
	      };
	function defaultOnUncaughtError(error) {
	  reportGlobalError(error);
	}
	function defaultOnCaughtError(error) {
	  console.error(error);
	}
	function defaultOnRecoverableError(error) {
	  reportGlobalError(error);
	}
	function logUncaughtError(root, errorInfo) {
	  try {
	    var onUncaughtError = root.onUncaughtError;
	    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
	  } catch (e$74) {
	    setTimeout(function () {
	      throw e$74;
	    });
	  }
	}
	function logCaughtError(root, boundary, errorInfo) {
	  try {
	    var onCaughtError = root.onCaughtError;
	    onCaughtError(errorInfo.value, {
	      componentStack: errorInfo.stack,
	      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
	    });
	  } catch (e$75) {
	    setTimeout(function () {
	      throw e$75;
	    });
	  }
	}
	function createRootErrorUpdate(root, errorInfo, lane) {
	  lane = createUpdate(lane);
	  lane.tag = 3;
	  lane.payload = { element: null };
	  lane.callback = function () {
	    logUncaughtError(root, errorInfo);
	  };
	  return lane;
	}
	function createClassErrorUpdate(lane) {
	  lane = createUpdate(lane);
	  lane.tag = 3;
	  return lane;
	}
	function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
	  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
	  if ("function" === typeof getDerivedStateFromError) {
	    var error = errorInfo.value;
	    update.payload = function () {
	      return getDerivedStateFromError(error);
	    };
	    update.callback = function () {
	      logCaughtError(root, fiber, errorInfo);
	    };
	  }
	  var inst = fiber.stateNode;
	  null !== inst &&
	    "function" === typeof inst.componentDidCatch &&
	    (update.callback = function () {
	      logCaughtError(root, fiber, errorInfo);
	      "function" !== typeof getDerivedStateFromError &&
	        (null === legacyErrorBoundariesThatAlreadyFailed
	          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
	          : legacyErrorBoundariesThatAlreadyFailed.add(this));
	      var stack = errorInfo.stack;
	      this.componentDidCatch(errorInfo.value, {
	        componentStack: null !== stack ? stack : ""
	      });
	    });
	}
	function throwException(
	  root,
	  returnFiber,
	  sourceFiber,
	  value,
	  rootRenderLanes
	) {
	  sourceFiber.flags |= 32768;
	  if (
	    null !== value &&
	    "object" === typeof value &&
	    "function" === typeof value.then
	  ) {
	    returnFiber = sourceFiber.alternate;
	    null !== returnFiber &&
	      propagateParentContextChanges(
	        returnFiber,
	        sourceFiber,
	        rootRenderLanes,
	        !0
	      );
	    sourceFiber = suspenseHandlerStackCursor.current;
	    if (null !== sourceFiber) {
	      switch (sourceFiber.tag) {
	        case 13:
	          return (
	            null === shellBoundary
	              ? renderDidSuspendDelayIfPossible()
	              : null === sourceFiber.alternate &&
	                0 === workInProgressRootExitStatus &&
	                (workInProgressRootExitStatus = 3),
	            (sourceFiber.flags &= -257),
	            (sourceFiber.flags |= 65536),
	            (sourceFiber.lanes = rootRenderLanes),
	            value === noopSuspenseyCommitThenable
	              ? (sourceFiber.flags |= 16384)
	              : ((returnFiber = sourceFiber.updateQueue),
	                null === returnFiber
	                  ? (sourceFiber.updateQueue = new Set([value]))
	                  : returnFiber.add(value),
	                attachPingListener(root, value, rootRenderLanes)),
	            !1
	          );
	        case 22:
	          return (
	            (sourceFiber.flags |= 65536),
	            value === noopSuspenseyCommitThenable
	              ? (sourceFiber.flags |= 16384)
	              : ((returnFiber = sourceFiber.updateQueue),
	                null === returnFiber
	                  ? ((returnFiber = {
	                      transitions: null,
	                      markerInstances: null,
	                      retryQueue: new Set([value])
	                    }),
	                    (sourceFiber.updateQueue = returnFiber))
	                  : ((sourceFiber = returnFiber.retryQueue),
	                    null === sourceFiber
	                      ? (returnFiber.retryQueue = new Set([value]))
	                      : sourceFiber.add(value)),
	                attachPingListener(root, value, rootRenderLanes)),
	            !1
	          );
	      }
	      throw Error(formatProdErrorMessage$1(435, sourceFiber.tag));
	    }
	    attachPingListener(root, value, rootRenderLanes);
	    renderDidSuspendDelayIfPossible();
	    return !1;
	  }
	  if (isHydrating)
	    return (
	      (returnFiber = suspenseHandlerStackCursor.current),
	      null !== returnFiber
	        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
	          (returnFiber.flags |= 65536),
	          (returnFiber.lanes = rootRenderLanes),
	          value !== HydrationMismatchException &&
	            ((root = Error(formatProdErrorMessage$1(422), { cause: value })),
	            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
	        : (value !== HydrationMismatchException &&
	            ((returnFiber = Error(formatProdErrorMessage$1(423), {
	              cause: value
	            })),
	            queueHydrationError(
	              createCapturedValueAtFiber(returnFiber, sourceFiber)
	            )),
	          (root = root.current.alternate),
	          (root.flags |= 65536),
	          (rootRenderLanes &= -rootRenderLanes),
	          (root.lanes |= rootRenderLanes),
	          (value = createCapturedValueAtFiber(value, sourceFiber)),
	          (rootRenderLanes = createRootErrorUpdate(
	            root.stateNode,
	            value,
	            rootRenderLanes
	          )),
	          enqueueCapturedUpdate(root, rootRenderLanes),
	          4 !== workInProgressRootExitStatus &&
	            (workInProgressRootExitStatus = 2)),
	      !1
	    );
	  var wrapperError = Error(formatProdErrorMessage$1(520), { cause: value });
	  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
	  null === workInProgressRootConcurrentErrors
	    ? (workInProgressRootConcurrentErrors = [wrapperError])
	    : workInProgressRootConcurrentErrors.push(wrapperError);
	  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
	  if (null === returnFiber) return !0;
	  value = createCapturedValueAtFiber(value, sourceFiber);
	  sourceFiber = returnFiber;
	  do {
	    switch (sourceFiber.tag) {
	      case 3:
	        return (
	          (sourceFiber.flags |= 65536),
	          (root = rootRenderLanes & -rootRenderLanes),
	          (sourceFiber.lanes |= root),
	          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
	          enqueueCapturedUpdate(sourceFiber, root),
	          !1
	        );
	      case 1:
	        if (
	          ((returnFiber = sourceFiber.type),
	          (wrapperError = sourceFiber.stateNode),
	          0 === (sourceFiber.flags & 128) &&
	            ("function" === typeof returnFiber.getDerivedStateFromError ||
	              (null !== wrapperError &&
	                "function" === typeof wrapperError.componentDidCatch &&
	                (null === legacyErrorBoundariesThatAlreadyFailed ||
	                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
	        )
	          return (
	            (sourceFiber.flags |= 65536),
	            (rootRenderLanes &= -rootRenderLanes),
	            (sourceFiber.lanes |= rootRenderLanes),
	            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
	            initializeClassErrorUpdate(
	              rootRenderLanes,
	              root,
	              sourceFiber,
	              value
	            ),
	            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
	            !1
	          );
	    }
	    sourceFiber = sourceFiber.return;
	  } while (null !== sourceFiber);
	  return !1;
	}
	var SelectiveHydrationException = Error(formatProdErrorMessage$1(461)),
	  didReceiveUpdate = !1;
	function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
	  workInProgress.child =
	    null === current
	      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
	      : reconcileChildFibers(
	          workInProgress,
	          current.child,
	          nextChildren,
	          renderLanes
	        );
	}
	function updateForwardRef(
	  current,
	  workInProgress,
	  Component,
	  nextProps,
	  renderLanes
	) {
	  Component = Component.render;
	  var ref = workInProgress.ref;
	  if ("ref" in nextProps) {
	    var propsWithoutRef = {};
	    for (var key in nextProps)
	      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
	  } else propsWithoutRef = nextProps;
	  prepareToReadContext(workInProgress);
	  nextProps = renderWithHooks(
	    current,
	    workInProgress,
	    Component,
	    propsWithoutRef,
	    ref,
	    renderLanes
	  );
	  key = checkDidRenderIdHook();
	  if (null !== current && !didReceiveUpdate)
	    return (
	      bailoutHooks(current, workInProgress, renderLanes),
	      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	    );
	  isHydrating && key && pushMaterializedTreeId(workInProgress);
	  workInProgress.flags |= 1;
	  reconcileChildren(current, workInProgress, nextProps, renderLanes);
	  return workInProgress.child;
	}
	function updateMemoComponent(
	  current,
	  workInProgress,
	  Component,
	  nextProps,
	  renderLanes
	) {
	  if (null === current) {
	    var type = Component.type;
	    if (
	      "function" === typeof type &&
	      !shouldConstruct(type) &&
	      void 0 === type.defaultProps &&
	      null === Component.compare
	    )
	      return (
	        (workInProgress.tag = 15),
	        (workInProgress.type = type),
	        updateSimpleMemoComponent(
	          current,
	          workInProgress,
	          type,
	          nextProps,
	          renderLanes
	        )
	      );
	    current = createFiberFromTypeAndProps(
	      Component.type,
	      null,
	      nextProps,
	      workInProgress,
	      workInProgress.mode,
	      renderLanes
	    );
	    current.ref = workInProgress.ref;
	    current.return = workInProgress;
	    return (workInProgress.child = current);
	  }
	  type = current.child;
	  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
	    var prevProps = type.memoizedProps;
	    Component = Component.compare;
	    Component = null !== Component ? Component : shallowEqual;
	    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
	      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
	  }
	  workInProgress.flags |= 1;
	  current = createWorkInProgress(type, nextProps);
	  current.ref = workInProgress.ref;
	  current.return = workInProgress;
	  return (workInProgress.child = current);
	}
	function updateSimpleMemoComponent(
	  current,
	  workInProgress,
	  Component,
	  nextProps,
	  renderLanes
	) {
	  if (null !== current) {
	    var prevProps = current.memoizedProps;
	    if (
	      shallowEqual(prevProps, nextProps) &&
	      current.ref === workInProgress.ref
	    )
	      if (
	        ((didReceiveUpdate = !1),
	        (workInProgress.pendingProps = nextProps = prevProps),
	        checkScheduledUpdateOrContext(current, renderLanes))
	      )
	        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
	      else
	        return (
	          (workInProgress.lanes = current.lanes),
	          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	        );
	  }
	  return updateFunctionComponent(
	    current,
	    workInProgress,
	    Component,
	    nextProps,
	    renderLanes
	  );
	}
	function updateOffscreenComponent(current, workInProgress, renderLanes) {
	  var nextProps = workInProgress.pendingProps,
	    nextChildren = nextProps.children,
	    prevState = null !== current ? current.memoizedState : null;
	  if ("hidden" === nextProps.mode) {
	    if (0 !== (workInProgress.flags & 128)) {
	      nextProps =
	        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
	      if (null !== current) {
	        nextChildren = workInProgress.child = current.child;
	        for (prevState = 0; null !== nextChildren; )
	          (prevState =
	            prevState | nextChildren.lanes | nextChildren.childLanes),
	            (nextChildren = nextChildren.sibling);
	        workInProgress.childLanes = prevState & ~nextProps;
	      } else (workInProgress.childLanes = 0), (workInProgress.child = null);
	      return deferHiddenOffscreenComponent(
	        current,
	        workInProgress,
	        nextProps,
	        renderLanes
	      );
	    }
	    if (0 !== (renderLanes & 536870912))
	      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
	        null !== current &&
	          pushTransition(
	            workInProgress,
	            null !== prevState ? prevState.cachePool : null
	          ),
	        null !== prevState
	          ? pushHiddenContext(workInProgress, prevState)
	          : reuseHiddenContextOnStack(),
	        pushOffscreenSuspenseHandler(workInProgress);
	    else
	      return (
	        (workInProgress.lanes = workInProgress.childLanes = 536870912),
	        deferHiddenOffscreenComponent(
	          current,
	          workInProgress,
	          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
	          renderLanes
	        )
	      );
	  } else
	    null !== prevState
	      ? (pushTransition(workInProgress, prevState.cachePool),
	        pushHiddenContext(workInProgress, prevState),
	        reuseSuspenseHandlerOnStack(),
	        (workInProgress.memoizedState = null))
	      : (null !== current && pushTransition(workInProgress, null),
	        reuseHiddenContextOnStack(),
	        reuseSuspenseHandlerOnStack());
	  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
	  return workInProgress.child;
	}
	function deferHiddenOffscreenComponent(
	  current,
	  workInProgress,
	  nextBaseLanes,
	  renderLanes
	) {
	  var JSCompiler_inline_result = peekCacheFromPool();
	  JSCompiler_inline_result =
	    null === JSCompiler_inline_result
	      ? null
	      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
	  workInProgress.memoizedState = {
	    baseLanes: nextBaseLanes,
	    cachePool: JSCompiler_inline_result
	  };
	  null !== current && pushTransition(workInProgress, null);
	  reuseHiddenContextOnStack();
	  pushOffscreenSuspenseHandler(workInProgress);
	  null !== current &&
	    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
	  return null;
	}
	function markRef(current, workInProgress) {
	  var ref = workInProgress.ref;
	  if (null === ref)
	    null !== current &&
	      null !== current.ref &&
	      (workInProgress.flags |= 4194816);
	  else {
	    if ("function" !== typeof ref && "object" !== typeof ref)
	      throw Error(formatProdErrorMessage$1(284));
	    if (null === current || current.ref !== ref)
	      workInProgress.flags |= 4194816;
	  }
	}
	function updateFunctionComponent(
	  current,
	  workInProgress,
	  Component,
	  nextProps,
	  renderLanes
	) {
	  prepareToReadContext(workInProgress);
	  Component = renderWithHooks(
	    current,
	    workInProgress,
	    Component,
	    nextProps,
	    void 0,
	    renderLanes
	  );
	  nextProps = checkDidRenderIdHook();
	  if (null !== current && !didReceiveUpdate)
	    return (
	      bailoutHooks(current, workInProgress, renderLanes),
	      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	    );
	  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
	  workInProgress.flags |= 1;
	  reconcileChildren(current, workInProgress, Component, renderLanes);
	  return workInProgress.child;
	}
	function replayFunctionComponent(
	  current,
	  workInProgress,
	  nextProps,
	  Component,
	  secondArg,
	  renderLanes
	) {
	  prepareToReadContext(workInProgress);
	  workInProgress.updateQueue = null;
	  nextProps = renderWithHooksAgain(
	    workInProgress,
	    Component,
	    nextProps,
	    secondArg
	  );
	  finishRenderingHooks(current);
	  Component = checkDidRenderIdHook();
	  if (null !== current && !didReceiveUpdate)
	    return (
	      bailoutHooks(current, workInProgress, renderLanes),
	      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	    );
	  isHydrating && Component && pushMaterializedTreeId(workInProgress);
	  workInProgress.flags |= 1;
	  reconcileChildren(current, workInProgress, nextProps, renderLanes);
	  return workInProgress.child;
	}
	function updateClassComponent(
	  current,
	  workInProgress,
	  Component,
	  nextProps,
	  renderLanes
	) {
	  prepareToReadContext(workInProgress);
	  if (null === workInProgress.stateNode) {
	    var context = emptyContextObject,
	      contextType = Component.contextType;
	    "object" === typeof contextType &&
	      null !== contextType &&
	      (context = readContext(contextType));
	    context = new Component(nextProps, context);
	    workInProgress.memoizedState =
	      null !== context.state && void 0 !== context.state ? context.state : null;
	    context.updater = classComponentUpdater;
	    workInProgress.stateNode = context;
	    context._reactInternals = workInProgress;
	    context = workInProgress.stateNode;
	    context.props = nextProps;
	    context.state = workInProgress.memoizedState;
	    context.refs = {};
	    initializeUpdateQueue(workInProgress);
	    contextType = Component.contextType;
	    context.context =
	      "object" === typeof contextType && null !== contextType
	        ? readContext(contextType)
	        : emptyContextObject;
	    context.state = workInProgress.memoizedState;
	    contextType = Component.getDerivedStateFromProps;
	    "function" === typeof contextType &&
	      (applyDerivedStateFromProps(
	        workInProgress,
	        Component,
	        contextType,
	        nextProps
	      ),
	      (context.state = workInProgress.memoizedState));
	    "function" === typeof Component.getDerivedStateFromProps ||
	      "function" === typeof context.getSnapshotBeforeUpdate ||
	      ("function" !== typeof context.UNSAFE_componentWillMount &&
	        "function" !== typeof context.componentWillMount) ||
	      ((contextType = context.state),
	      "function" === typeof context.componentWillMount &&
	        context.componentWillMount(),
	      "function" === typeof context.UNSAFE_componentWillMount &&
	        context.UNSAFE_componentWillMount(),
	      contextType !== context.state &&
	        classComponentUpdater.enqueueReplaceState(context, context.state, null),
	      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
	      suspendIfUpdateReadFromEntangledAsyncAction(),
	      (context.state = workInProgress.memoizedState));
	    "function" === typeof context.componentDidMount &&
	      (workInProgress.flags |= 4194308);
	    nextProps = !0;
	  } else if (null === current) {
	    context = workInProgress.stateNode;
	    var unresolvedOldProps = workInProgress.memoizedProps,
	      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
	    context.props = oldProps;
	    var oldContext = context.context,
	      contextType$jscomp$0 = Component.contextType;
	    contextType = emptyContextObject;
	    "object" === typeof contextType$jscomp$0 &&
	      null !== contextType$jscomp$0 &&
	      (contextType = readContext(contextType$jscomp$0));
	    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
	    contextType$jscomp$0 =
	      "function" === typeof getDerivedStateFromProps ||
	      "function" === typeof context.getSnapshotBeforeUpdate;
	    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
	    contextType$jscomp$0 ||
	      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
	        "function" !== typeof context.componentWillReceiveProps) ||
	      ((unresolvedOldProps || oldContext !== contextType) &&
	        callComponentWillReceiveProps(
	          workInProgress,
	          context,
	          nextProps,
	          contextType
	        ));
	    hasForceUpdate = !1;
	    var oldState = workInProgress.memoizedState;
	    context.state = oldState;
	    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
	    suspendIfUpdateReadFromEntangledAsyncAction();
	    oldContext = workInProgress.memoizedState;
	    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
	      ? ("function" === typeof getDerivedStateFromProps &&
	          (applyDerivedStateFromProps(
	            workInProgress,
	            Component,
	            getDerivedStateFromProps,
	            nextProps
	          ),
	          (oldContext = workInProgress.memoizedState)),
	        (oldProps =
	          hasForceUpdate ||
	          checkShouldComponentUpdate(
	            workInProgress,
	            Component,
	            oldProps,
	            nextProps,
	            oldState,
	            oldContext,
	            contextType
	          ))
	          ? (contextType$jscomp$0 ||
	              ("function" !== typeof context.UNSAFE_componentWillMount &&
	                "function" !== typeof context.componentWillMount) ||
	              ("function" === typeof context.componentWillMount &&
	                context.componentWillMount(),
	              "function" === typeof context.UNSAFE_componentWillMount &&
	                context.UNSAFE_componentWillMount()),
	            "function" === typeof context.componentDidMount &&
	              (workInProgress.flags |= 4194308))
	          : ("function" === typeof context.componentDidMount &&
	              (workInProgress.flags |= 4194308),
	            (workInProgress.memoizedProps = nextProps),
	            (workInProgress.memoizedState = oldContext)),
	        (context.props = nextProps),
	        (context.state = oldContext),
	        (context.context = contextType),
	        (nextProps = oldProps))
	      : ("function" === typeof context.componentDidMount &&
	          (workInProgress.flags |= 4194308),
	        (nextProps = !1));
	  } else {
	    context = workInProgress.stateNode;
	    cloneUpdateQueue(current, workInProgress);
	    contextType = workInProgress.memoizedProps;
	    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
	    context.props = contextType$jscomp$0;
	    getDerivedStateFromProps = workInProgress.pendingProps;
	    oldState = context.context;
	    oldContext = Component.contextType;
	    oldProps = emptyContextObject;
	    "object" === typeof oldContext &&
	      null !== oldContext &&
	      (oldProps = readContext(oldContext));
	    unresolvedOldProps = Component.getDerivedStateFromProps;
	    (oldContext =
	      "function" === typeof unresolvedOldProps ||
	      "function" === typeof context.getSnapshotBeforeUpdate) ||
	      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
	        "function" !== typeof context.componentWillReceiveProps) ||
	      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
	        callComponentWillReceiveProps(
	          workInProgress,
	          context,
	          nextProps,
	          oldProps
	        ));
	    hasForceUpdate = !1;
	    oldState = workInProgress.memoizedState;
	    context.state = oldState;
	    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
	    suspendIfUpdateReadFromEntangledAsyncAction();
	    var newState = workInProgress.memoizedState;
	    contextType !== getDerivedStateFromProps ||
	    oldState !== newState ||
	    hasForceUpdate ||
	    (null !== current &&
	      null !== current.dependencies &&
	      checkIfContextChanged(current.dependencies))
	      ? ("function" === typeof unresolvedOldProps &&
	          (applyDerivedStateFromProps(
	            workInProgress,
	            Component,
	            unresolvedOldProps,
	            nextProps
	          ),
	          (newState = workInProgress.memoizedState)),
	        (contextType$jscomp$0 =
	          hasForceUpdate ||
	          checkShouldComponentUpdate(
	            workInProgress,
	            Component,
	            contextType$jscomp$0,
	            nextProps,
	            oldState,
	            newState,
	            oldProps
	          ) ||
	          (null !== current &&
	            null !== current.dependencies &&
	            checkIfContextChanged(current.dependencies)))
	          ? (oldContext ||
	              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
	                "function" !== typeof context.componentWillUpdate) ||
	              ("function" === typeof context.componentWillUpdate &&
	                context.componentWillUpdate(nextProps, newState, oldProps),
	              "function" === typeof context.UNSAFE_componentWillUpdate &&
	                context.UNSAFE_componentWillUpdate(
	                  nextProps,
	                  newState,
	                  oldProps
	                )),
	            "function" === typeof context.componentDidUpdate &&
	              (workInProgress.flags |= 4),
	            "function" === typeof context.getSnapshotBeforeUpdate &&
	              (workInProgress.flags |= 1024))
	          : ("function" !== typeof context.componentDidUpdate ||
	              (contextType === current.memoizedProps &&
	                oldState === current.memoizedState) ||
	              (workInProgress.flags |= 4),
	            "function" !== typeof context.getSnapshotBeforeUpdate ||
	              (contextType === current.memoizedProps &&
	                oldState === current.memoizedState) ||
	              (workInProgress.flags |= 1024),
	            (workInProgress.memoizedProps = nextProps),
	            (workInProgress.memoizedState = newState)),
	        (context.props = nextProps),
	        (context.state = newState),
	        (context.context = oldProps),
	        (nextProps = contextType$jscomp$0))
	      : ("function" !== typeof context.componentDidUpdate ||
	          (contextType === current.memoizedProps &&
	            oldState === current.memoizedState) ||
	          (workInProgress.flags |= 4),
	        "function" !== typeof context.getSnapshotBeforeUpdate ||
	          (contextType === current.memoizedProps &&
	            oldState === current.memoizedState) ||
	          (workInProgress.flags |= 1024),
	        (nextProps = !1));
	  }
	  context = nextProps;
	  markRef(current, workInProgress);
	  nextProps = 0 !== (workInProgress.flags & 128);
	  context || nextProps
	    ? ((context = workInProgress.stateNode),
	      (Component =
	        nextProps && "function" !== typeof Component.getDerivedStateFromError
	          ? null
	          : context.render()),
	      (workInProgress.flags |= 1),
	      null !== current && nextProps
	        ? ((workInProgress.child = reconcileChildFibers(
	            workInProgress,
	            current.child,
	            null,
	            renderLanes
	          )),
	          (workInProgress.child = reconcileChildFibers(
	            workInProgress,
	            null,
	            Component,
	            renderLanes
	          )))
	        : reconcileChildren(current, workInProgress, Component, renderLanes),
	      (workInProgress.memoizedState = context.state),
	      (current = workInProgress.child))
	    : (current = bailoutOnAlreadyFinishedWork(
	        current,
	        workInProgress,
	        renderLanes
	      ));
	  return current;
	}
	function mountHostRootWithoutHydrating(
	  current,
	  workInProgress,
	  nextChildren,
	  renderLanes
	) {
	  resetHydrationState();
	  workInProgress.flags |= 256;
	  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
	  return workInProgress.child;
	}
	var SUSPENDED_MARKER = {
	  dehydrated: null,
	  treeContext: null,
	  retryLane: 0,
	  hydrationErrors: null
	};
	function mountSuspenseOffscreenState(renderLanes) {
	  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
	}
	function getRemainingWorkInPrimaryTree(
	  current,
	  primaryTreeDidDefer,
	  renderLanes
	) {
	  current = null !== current ? current.childLanes & ~renderLanes : 0;
	  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
	  return current;
	}
	function updateSuspenseComponent(current, workInProgress, renderLanes) {
	  var nextProps = workInProgress.pendingProps,
	    showFallback = !1,
	    didSuspend = 0 !== (workInProgress.flags & 128),
	    JSCompiler_temp;
	  (JSCompiler_temp = didSuspend) ||
	    (JSCompiler_temp =
	      null !== current && null === current.memoizedState
	        ? !1
	        : 0 !== (suspenseStackCursor.current & 2));
	  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
	  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
	  workInProgress.flags &= -33;
	  if (null === current) {
	    if (isHydrating) {
	      showFallback
	        ? pushPrimaryTreeSuspenseHandler(workInProgress)
	        : reuseSuspenseHandlerOnStack();
	      if (isHydrating) {
	        var nextInstance = nextHydratableInstance,
	          JSCompiler_temp$jscomp$0;
	        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
	          c: {
	            JSCompiler_temp$jscomp$0 = nextInstance;
	            for (
	              nextInstance = rootOrSingletonContext;
	              8 !== JSCompiler_temp$jscomp$0.nodeType;

	            ) {
	              if (!nextInstance) {
	                nextInstance = null;
	                break c;
	              }
	              JSCompiler_temp$jscomp$0 = getNextHydratable(
	                JSCompiler_temp$jscomp$0.nextSibling
	              );
	              if (null === JSCompiler_temp$jscomp$0) {
	                nextInstance = null;
	                break c;
	              }
	            }
	            nextInstance = JSCompiler_temp$jscomp$0;
	          }
	          null !== nextInstance
	            ? ((workInProgress.memoizedState = {
	                dehydrated: nextInstance,
	                treeContext:
	                  null !== treeContextProvider
	                    ? { id: treeContextId, overflow: treeContextOverflow }
	                    : null,
	                retryLane: 536870912,
	                hydrationErrors: null
	              }),
	              (JSCompiler_temp$jscomp$0 = createFiberImplClass(
	                18,
	                null,
	                null,
	                0
	              )),
	              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
	              (JSCompiler_temp$jscomp$0.return = workInProgress),
	              (workInProgress.child = JSCompiler_temp$jscomp$0),
	              (hydrationParentFiber = workInProgress),
	              (nextHydratableInstance = null),
	              (JSCompiler_temp$jscomp$0 = !0))
	            : (JSCompiler_temp$jscomp$0 = !1);
	        }
	        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
	      }
	      nextInstance = workInProgress.memoizedState;
	      if (
	        null !== nextInstance &&
	        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
	      )
	        return (
	          isSuspenseInstanceFallback(nextInstance)
	            ? (workInProgress.lanes = 32)
	            : (workInProgress.lanes = 536870912),
	          null
	        );
	      popSuspenseHandler(workInProgress);
	    }
	    nextInstance = nextProps.children;
	    nextProps = nextProps.fallback;
	    if (showFallback)
	      return (
	        reuseSuspenseHandlerOnStack(),
	        (showFallback = workInProgress.mode),
	        (nextInstance = mountWorkInProgressOffscreenFiber(
	          { mode: "hidden", children: nextInstance },
	          showFallback
	        )),
	        (nextProps = createFiberFromFragment(
	          nextProps,
	          showFallback,
	          renderLanes,
	          null
	        )),
	        (nextInstance.return = workInProgress),
	        (nextProps.return = workInProgress),
	        (nextInstance.sibling = nextProps),
	        (workInProgress.child = nextInstance),
	        (showFallback = workInProgress.child),
	        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
	        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
	          current,
	          JSCompiler_temp,
	          renderLanes
	        )),
	        (workInProgress.memoizedState = SUSPENDED_MARKER),
	        nextProps
	      );
	    pushPrimaryTreeSuspenseHandler(workInProgress);
	    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
	  }
	  JSCompiler_temp$jscomp$0 = current.memoizedState;
	  if (
	    null !== JSCompiler_temp$jscomp$0 &&
	    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
	    null !== nextInstance)
	  ) {
	    if (didSuspend)
	      workInProgress.flags & 256
	        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
	          (workInProgress.flags &= -257),
	          (workInProgress = retrySuspenseComponentWithoutHydrating(
	            current,
	            workInProgress,
	            renderLanes
	          )))
	        : null !== workInProgress.memoizedState
	          ? (reuseSuspenseHandlerOnStack(),
	            (workInProgress.child = current.child),
	            (workInProgress.flags |= 128),
	            (workInProgress = null))
	          : (reuseSuspenseHandlerOnStack(),
	            (showFallback = nextProps.fallback),
	            (nextInstance = workInProgress.mode),
	            (nextProps = mountWorkInProgressOffscreenFiber(
	              { mode: "visible", children: nextProps.children },
	              nextInstance
	            )),
	            (showFallback = createFiberFromFragment(
	              showFallback,
	              nextInstance,
	              renderLanes,
	              null
	            )),
	            (showFallback.flags |= 2),
	            (nextProps.return = workInProgress),
	            (showFallback.return = workInProgress),
	            (nextProps.sibling = showFallback),
	            (workInProgress.child = nextProps),
	            reconcileChildFibers(
	              workInProgress,
	              current.child,
	              null,
	              renderLanes
	            ),
	            (nextProps = workInProgress.child),
	            (nextProps.memoizedState =
	              mountSuspenseOffscreenState(renderLanes)),
	            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
	              current,
	              JSCompiler_temp,
	              renderLanes
	            )),
	            (workInProgress.memoizedState = SUSPENDED_MARKER),
	            (workInProgress = showFallback));
	    else if (
	      (pushPrimaryTreeSuspenseHandler(workInProgress),
	      isSuspenseInstanceFallback(nextInstance))
	    ) {
	      JSCompiler_temp =
	        nextInstance.nextSibling && nextInstance.nextSibling.dataset;
	      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
	      JSCompiler_temp = digest;
	      nextProps = Error(formatProdErrorMessage$1(419));
	      nextProps.stack = "";
	      nextProps.digest = JSCompiler_temp;
	      queueHydrationError({ value: nextProps, source: null, stack: null });
	      workInProgress = retrySuspenseComponentWithoutHydrating(
	        current,
	        workInProgress,
	        renderLanes
	      );
	    } else if (
	      (didReceiveUpdate ||
	        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
	      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
	      didReceiveUpdate || JSCompiler_temp)
	    ) {
	      JSCompiler_temp = workInProgressRoot;
	      if (
	        null !== JSCompiler_temp &&
	        ((nextProps = renderLanes & -renderLanes),
	        (nextProps =
	          0 !== (nextProps & 42)
	            ? 1
	            : getBumpedLaneForHydrationByLane(nextProps)),
	        (nextProps =
	          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
	            ? 0
	            : nextProps),
	        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
	      )
	        throw (
	          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
	          enqueueConcurrentRenderForLane(current, nextProps),
	          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
	          SelectiveHydrationException)
	        );
	      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
	      workInProgress = retrySuspenseComponentWithoutHydrating(
	        current,
	        workInProgress,
	        renderLanes
	      );
	    } else
	      "$?" === nextInstance.data
	        ? ((workInProgress.flags |= 192),
	          (workInProgress.child = current.child),
	          (workInProgress = null))
	        : ((current = JSCompiler_temp$jscomp$0.treeContext),
	          (nextHydratableInstance = getNextHydratable(
	            nextInstance.nextSibling
	          )),
	          (hydrationParentFiber = workInProgress),
	          (isHydrating = !0),
	          (hydrationErrors = null),
	          (rootOrSingletonContext = !1),
	          null !== current &&
	            ((idStack[idStackIndex++] = treeContextId),
	            (idStack[idStackIndex++] = treeContextOverflow),
	            (idStack[idStackIndex++] = treeContextProvider),
	            (treeContextId = current.id),
	            (treeContextOverflow = current.overflow),
	            (treeContextProvider = workInProgress)),
	          (workInProgress = mountSuspensePrimaryChildren(
	            workInProgress,
	            nextProps.children
	          )),
	          (workInProgress.flags |= 4096));
	    return workInProgress;
	  }
	  if (showFallback)
	    return (
	      reuseSuspenseHandlerOnStack(),
	      (showFallback = nextProps.fallback),
	      (nextInstance = workInProgress.mode),
	      (JSCompiler_temp$jscomp$0 = current.child),
	      (digest = JSCompiler_temp$jscomp$0.sibling),
	      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
	        mode: "hidden",
	        children: nextProps.children
	      })),
	      (nextProps.subtreeFlags =
	        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),
	      null !== digest
	        ? (showFallback = createWorkInProgress(digest, showFallback))
	        : ((showFallback = createFiberFromFragment(
	            showFallback,
	            nextInstance,
	            renderLanes,
	            null
	          )),
	          (showFallback.flags |= 2)),
	      (showFallback.return = workInProgress),
	      (nextProps.return = workInProgress),
	      (nextProps.sibling = showFallback),
	      (workInProgress.child = nextProps),
	      (nextProps = showFallback),
	      (showFallback = workInProgress.child),
	      (nextInstance = current.child.memoizedState),
	      null === nextInstance
	        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
	        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
	          null !== JSCompiler_temp$jscomp$0
	            ? ((digest = CacheContext._currentValue),
	              (JSCompiler_temp$jscomp$0 =
	                JSCompiler_temp$jscomp$0.parent !== digest
	                  ? { parent: digest, pool: digest }
	                  : JSCompiler_temp$jscomp$0))
	            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
	          (nextInstance = {
	            baseLanes: nextInstance.baseLanes | renderLanes,
	            cachePool: JSCompiler_temp$jscomp$0
	          })),
	      (showFallback.memoizedState = nextInstance),
	      (showFallback.childLanes = getRemainingWorkInPrimaryTree(
	        current,
	        JSCompiler_temp,
	        renderLanes
	      )),
	      (workInProgress.memoizedState = SUSPENDED_MARKER),
	      nextProps
	    );
	  pushPrimaryTreeSuspenseHandler(workInProgress);
	  renderLanes = current.child;
	  current = renderLanes.sibling;
	  renderLanes = createWorkInProgress(renderLanes, {
	    mode: "visible",
	    children: nextProps.children
	  });
	  renderLanes.return = workInProgress;
	  renderLanes.sibling = null;
	  null !== current &&
	    ((JSCompiler_temp = workInProgress.deletions),
	    null === JSCompiler_temp
	      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
	      : JSCompiler_temp.push(current));
	  workInProgress.child = renderLanes;
	  workInProgress.memoizedState = null;
	  return renderLanes;
	}
	function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
	  primaryChildren = mountWorkInProgressOffscreenFiber(
	    { mode: "visible", children: primaryChildren },
	    workInProgress.mode
	  );
	  primaryChildren.return = workInProgress;
	  return (workInProgress.child = primaryChildren);
	}
	function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
	  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
	  offscreenProps.lanes = 0;
	  offscreenProps.stateNode = {
	    _visibility: 1,
	    _pendingMarkers: null,
	    _retryCache: null,
	    _transitions: null
	  };
	  return offscreenProps;
	}
	function retrySuspenseComponentWithoutHydrating(
	  current,
	  workInProgress,
	  renderLanes
	) {
	  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
	  current = mountSuspensePrimaryChildren(
	    workInProgress,
	    workInProgress.pendingProps.children
	  );
	  current.flags |= 2;
	  workInProgress.memoizedState = null;
	  return current;
	}
	function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
	  fiber.lanes |= renderLanes;
	  var alternate = fiber.alternate;
	  null !== alternate && (alternate.lanes |= renderLanes);
	  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
	}
	function initSuspenseListRenderState(
	  workInProgress,
	  isBackwards,
	  tail,
	  lastContentRow,
	  tailMode
	) {
	  var renderState = workInProgress.memoizedState;
	  null === renderState
	    ? (workInProgress.memoizedState = {
	        isBackwards: isBackwards,
	        rendering: null,
	        renderingStartTime: 0,
	        last: lastContentRow,
	        tail: tail,
	        tailMode: tailMode
	      })
	    : ((renderState.isBackwards = isBackwards),
	      (renderState.rendering = null),
	      (renderState.renderingStartTime = 0),
	      (renderState.last = lastContentRow),
	      (renderState.tail = tail),
	      (renderState.tailMode = tailMode));
	}
	function updateSuspenseListComponent(current, workInProgress, renderLanes) {
	  var nextProps = workInProgress.pendingProps,
	    revealOrder = nextProps.revealOrder,
	    tailMode = nextProps.tail;
	  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
	  nextProps = suspenseStackCursor.current;
	  if (0 !== (nextProps & 2))
	    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
	  else {
	    if (null !== current && 0 !== (current.flags & 128))
	      a: for (current = workInProgress.child; null !== current; ) {
	        if (13 === current.tag)
	          null !== current.memoizedState &&
	            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
	        else if (19 === current.tag)
	          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
	        else if (null !== current.child) {
	          current.child.return = current;
	          current = current.child;
	          continue;
	        }
	        if (current === workInProgress) break a;
	        for (; null === current.sibling; ) {
	          if (null === current.return || current.return === workInProgress)
	            break a;
	          current = current.return;
	        }
	        current.sibling.return = current.return;
	        current = current.sibling;
	      }
	    nextProps &= 1;
	  }
	  push(suspenseStackCursor, nextProps);
	  switch (revealOrder) {
	    case "forwards":
	      renderLanes = workInProgress.child;
	      for (revealOrder = null; null !== renderLanes; )
	        (current = renderLanes.alternate),
	          null !== current &&
	            null === findFirstSuspended(current) &&
	            (revealOrder = renderLanes),
	          (renderLanes = renderLanes.sibling);
	      renderLanes = revealOrder;
	      null === renderLanes
	        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
	        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
	      initSuspenseListRenderState(
	        workInProgress,
	        !1,
	        revealOrder,
	        renderLanes,
	        tailMode
	      );
	      break;
	    case "backwards":
	      renderLanes = null;
	      revealOrder = workInProgress.child;
	      for (workInProgress.child = null; null !== revealOrder; ) {
	        current = revealOrder.alternate;
	        if (null !== current && null === findFirstSuspended(current)) {
	          workInProgress.child = revealOrder;
	          break;
	        }
	        current = revealOrder.sibling;
	        revealOrder.sibling = renderLanes;
	        renderLanes = revealOrder;
	        revealOrder = current;
	      }
	      initSuspenseListRenderState(
	        workInProgress,
	        !0,
	        renderLanes,
	        null,
	        tailMode
	      );
	      break;
	    case "together":
	      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
	      break;
	    default:
	      workInProgress.memoizedState = null;
	  }
	  return workInProgress.child;
	}
	function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
	  null !== current && (workInProgress.dependencies = current.dependencies);
	  workInProgressRootSkippedLanes |= workInProgress.lanes;
	  if (0 === (renderLanes & workInProgress.childLanes))
	    if (null !== current) {
	      if (
	        (propagateParentContextChanges(
	          current,
	          workInProgress,
	          renderLanes,
	          !1
	        ),
	        0 === (renderLanes & workInProgress.childLanes))
	      )
	        return null;
	    } else return null;
	  if (null !== current && workInProgress.child !== current.child)
	    throw Error(formatProdErrorMessage$1(153));
	  if (null !== workInProgress.child) {
	    current = workInProgress.child;
	    renderLanes = createWorkInProgress(current, current.pendingProps);
	    workInProgress.child = renderLanes;
	    for (renderLanes.return = workInProgress; null !== current.sibling; )
	      (current = current.sibling),
	        (renderLanes = renderLanes.sibling =
	          createWorkInProgress(current, current.pendingProps)),
	        (renderLanes.return = workInProgress);
	    renderLanes.sibling = null;
	  }
	  return workInProgress.child;
	}
	function checkScheduledUpdateOrContext(current, renderLanes) {
	  if (0 !== (current.lanes & renderLanes)) return !0;
	  current = current.dependencies;
	  return null !== current && checkIfContextChanged(current) ? !0 : !1;
	}
	function attemptEarlyBailoutIfNoScheduledUpdate(
	  current,
	  workInProgress,
	  renderLanes
	) {
	  switch (workInProgress.tag) {
	    case 3:
	      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
	      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
	      resetHydrationState();
	      break;
	    case 27:
	    case 5:
	      pushHostContext(workInProgress);
	      break;
	    case 4:
	      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
	      break;
	    case 10:
	      pushProvider(
	        workInProgress,
	        workInProgress.type,
	        workInProgress.memoizedProps.value
	      );
	      break;
	    case 13:
	      var state = workInProgress.memoizedState;
	      if (null !== state) {
	        if (null !== state.dehydrated)
	          return (
	            pushPrimaryTreeSuspenseHandler(workInProgress),
	            (workInProgress.flags |= 128),
	            null
	          );
	        if (0 !== (renderLanes & workInProgress.child.childLanes))
	          return updateSuspenseComponent(current, workInProgress, renderLanes);
	        pushPrimaryTreeSuspenseHandler(workInProgress);
	        current = bailoutOnAlreadyFinishedWork(
	          current,
	          workInProgress,
	          renderLanes
	        );
	        return null !== current ? current.sibling : null;
	      }
	      pushPrimaryTreeSuspenseHandler(workInProgress);
	      break;
	    case 19:
	      var didSuspendBefore = 0 !== (current.flags & 128);
	      state = 0 !== (renderLanes & workInProgress.childLanes);
	      state ||
	        (propagateParentContextChanges(
	          current,
	          workInProgress,
	          renderLanes,
	          !1
	        ),
	        (state = 0 !== (renderLanes & workInProgress.childLanes)));
	      if (didSuspendBefore) {
	        if (state)
	          return updateSuspenseListComponent(
	            current,
	            workInProgress,
	            renderLanes
	          );
	        workInProgress.flags |= 128;
	      }
	      didSuspendBefore = workInProgress.memoizedState;
	      null !== didSuspendBefore &&
	        ((didSuspendBefore.rendering = null),
	        (didSuspendBefore.tail = null),
	        (didSuspendBefore.lastEffect = null));
	      push(suspenseStackCursor, suspenseStackCursor.current);
	      if (state) break;
	      else return null;
	    case 22:
	    case 23:
	      return (
	        (workInProgress.lanes = 0),
	        updateOffscreenComponent(current, workInProgress, renderLanes)
	      );
	    case 24:
	      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
	  }
	  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
	}
	function beginWork(current, workInProgress, renderLanes) {
	  if (null !== current)
	    if (current.memoizedProps !== workInProgress.pendingProps)
	      didReceiveUpdate = !0;
	    else {
	      if (
	        !checkScheduledUpdateOrContext(current, renderLanes) &&
	        0 === (workInProgress.flags & 128)
	      )
	        return (
	          (didReceiveUpdate = !1),
	          attemptEarlyBailoutIfNoScheduledUpdate(
	            current,
	            workInProgress,
	            renderLanes
	          )
	        );
	      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
	    }
	  else
	    (didReceiveUpdate = !1),
	      isHydrating &&
	        0 !== (workInProgress.flags & 1048576) &&
	        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
	  workInProgress.lanes = 0;
	  switch (workInProgress.tag) {
	    case 16:
	      a: {
	        current = workInProgress.pendingProps;
	        var lazyComponent = workInProgress.elementType,
	          init = lazyComponent._init;
	        lazyComponent = init(lazyComponent._payload);
	        workInProgress.type = lazyComponent;
	        if ("function" === typeof lazyComponent)
	          shouldConstruct(lazyComponent)
	            ? ((current = resolveClassComponentProps(lazyComponent, current)),
	              (workInProgress.tag = 1),
	              (workInProgress = updateClassComponent(
	                null,
	                workInProgress,
	                lazyComponent,
	                current,
	                renderLanes
	              )))
	            : ((workInProgress.tag = 0),
	              (workInProgress = updateFunctionComponent(
	                null,
	                workInProgress,
	                lazyComponent,
	                current,
	                renderLanes
	              )));
	        else {
	          if (void 0 !== lazyComponent && null !== lazyComponent)
	            if (
	              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)
	            ) {
	              workInProgress.tag = 11;
	              workInProgress = updateForwardRef(
	                null,
	                workInProgress,
	                lazyComponent,
	                current,
	                renderLanes
	              );
	              break a;
	            } else if (init === REACT_MEMO_TYPE) {
	              workInProgress.tag = 14;
	              workInProgress = updateMemoComponent(
	                null,
	                workInProgress,
	                lazyComponent,
	                current,
	                renderLanes
	              );
	              break a;
	            }
	          workInProgress =
	            getComponentNameFromType(lazyComponent) || lazyComponent;
	          throw Error(formatProdErrorMessage$1(306, workInProgress, ""));
	        }
	      }
	      return workInProgress;
	    case 0:
	      return updateFunctionComponent(
	        current,
	        workInProgress,
	        workInProgress.type,
	        workInProgress.pendingProps,
	        renderLanes
	      );
	    case 1:
	      return (
	        (lazyComponent = workInProgress.type),
	        (init = resolveClassComponentProps(
	          lazyComponent,
	          workInProgress.pendingProps
	        )),
	        updateClassComponent(
	          current,
	          workInProgress,
	          lazyComponent,
	          init,
	          renderLanes
	        )
	      );
	    case 3:
	      a: {
	        pushHostContainer(
	          workInProgress,
	          workInProgress.stateNode.containerInfo
	        );
	        if (null === current) throw Error(formatProdErrorMessage$1(387));
	        lazyComponent = workInProgress.pendingProps;
	        var prevState = workInProgress.memoizedState;
	        init = prevState.element;
	        cloneUpdateQueue(current, workInProgress);
	        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);
	        var nextState = workInProgress.memoizedState;
	        lazyComponent = nextState.cache;
	        pushProvider(workInProgress, CacheContext, lazyComponent);
	        lazyComponent !== prevState.cache &&
	          propagateContextChanges(
	            workInProgress,
	            [CacheContext],
	            renderLanes,
	            !0
	          );
	        suspendIfUpdateReadFromEntangledAsyncAction();
	        lazyComponent = nextState.element;
	        if (prevState.isDehydrated)
	          if (
	            ((prevState = {
	              element: lazyComponent,
	              isDehydrated: !1,
	              cache: nextState.cache
	            }),
	            (workInProgress.updateQueue.baseState = prevState),
	            (workInProgress.memoizedState = prevState),
	            workInProgress.flags & 256)
	          ) {
	            workInProgress = mountHostRootWithoutHydrating(
	              current,
	              workInProgress,
	              lazyComponent,
	              renderLanes
	            );
	            break a;
	          } else if (lazyComponent !== init) {
	            init = createCapturedValueAtFiber(
	              Error(formatProdErrorMessage$1(424)),
	              workInProgress
	            );
	            queueHydrationError(init);
	            workInProgress = mountHostRootWithoutHydrating(
	              current,
	              workInProgress,
	              lazyComponent,
	              renderLanes
	            );
	            break a;
	          } else {
	            current = workInProgress.stateNode.containerInfo;
	            switch (current.nodeType) {
	              case 9:
	                current = current.body;
	                break;
	              default:
	                current =
	                  "HTML" === current.nodeName
	                    ? current.ownerDocument.body
	                    : current;
	            }
	            nextHydratableInstance = getNextHydratable(current.firstChild);
	            hydrationParentFiber = workInProgress;
	            isHydrating = !0;
	            hydrationErrors = null;
	            rootOrSingletonContext = !0;
	            renderLanes = mountChildFibers(
	              workInProgress,
	              null,
	              lazyComponent,
	              renderLanes
	            );
	            for (workInProgress.child = renderLanes; renderLanes; )
	              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
	                (renderLanes = renderLanes.sibling);
	          }
	        else {
	          resetHydrationState();
	          if (lazyComponent === init) {
	            workInProgress = bailoutOnAlreadyFinishedWork(
	              current,
	              workInProgress,
	              renderLanes
	            );
	            break a;
	          }
	          reconcileChildren(
	            current,
	            workInProgress,
	            lazyComponent,
	            renderLanes
	          );
	        }
	        workInProgress = workInProgress.child;
	      }
	      return workInProgress;
	    case 26:
	      return (
	        markRef(current, workInProgress),
	        null === current
	          ? (renderLanes = getResource(
	              workInProgress.type,
	              null,
	              workInProgress.pendingProps,
	              null
	            ))
	            ? (workInProgress.memoizedState = renderLanes)
	            : isHydrating ||
	              ((renderLanes = workInProgress.type),
	              (current = workInProgress.pendingProps),
	              (lazyComponent = getOwnerDocumentFromRootContainer(
	                rootInstanceStackCursor.current
	              ).createElement(renderLanes)),
	              (lazyComponent[internalInstanceKey] = workInProgress),
	              (lazyComponent[internalPropsKey] = current),
	              setInitialProperties(lazyComponent, renderLanes, current),
	              markNodeAsHoistable(lazyComponent),
	              (workInProgress.stateNode = lazyComponent))
	          : (workInProgress.memoizedState = getResource(
	              workInProgress.type,
	              current.memoizedProps,
	              workInProgress.pendingProps,
	              current.memoizedState
	            )),
	        null
	      );
	    case 27:
	      return (
	        pushHostContext(workInProgress),
	        null === current &&
	          isHydrating &&
	          ((lazyComponent = workInProgress.stateNode =
	            resolveSingletonInstance(
	              workInProgress.type,
	              workInProgress.pendingProps,
	              rootInstanceStackCursor.current
	            )),
	          (hydrationParentFiber = workInProgress),
	          (rootOrSingletonContext = !0),
	          (init = nextHydratableInstance),
	          isSingletonScope(workInProgress.type)
	            ? ((previousHydratableOnEnteringScopedSingleton = init),
	              (nextHydratableInstance = getNextHydratable(
	                lazyComponent.firstChild
	              )))
	            : (nextHydratableInstance = init)),
	        reconcileChildren(
	          current,
	          workInProgress,
	          workInProgress.pendingProps.children,
	          renderLanes
	        ),
	        markRef(current, workInProgress),
	        null === current && (workInProgress.flags |= 4194304),
	        workInProgress.child
	      );
	    case 5:
	      if (null === current && isHydrating) {
	        if ((init = lazyComponent = nextHydratableInstance))
	          (lazyComponent = canHydrateInstance(
	            lazyComponent,
	            workInProgress.type,
	            workInProgress.pendingProps,
	            rootOrSingletonContext
	          )),
	            null !== lazyComponent
	              ? ((workInProgress.stateNode = lazyComponent),
	                (hydrationParentFiber = workInProgress),
	                (nextHydratableInstance = getNextHydratable(
	                  lazyComponent.firstChild
	                )),
	                (rootOrSingletonContext = !1),
	                (init = !0))
	              : (init = !1);
	        init || throwOnHydrationMismatch(workInProgress);
	      }
	      pushHostContext(workInProgress);
	      init = workInProgress.type;
	      prevState = workInProgress.pendingProps;
	      nextState = null !== current ? current.memoizedProps : null;
	      lazyComponent = prevState.children;
	      shouldSetTextContent(init, prevState)
	        ? (lazyComponent = null)
	        : null !== nextState &&
	          shouldSetTextContent(init, nextState) &&
	          (workInProgress.flags |= 32);
	      null !== workInProgress.memoizedState &&
	        ((init = renderWithHooks(
	          current,
	          workInProgress,
	          TransitionAwareHostComponent,
	          null,
	          null,
	          renderLanes
	        )),
	        (HostTransitionContext._currentValue = init));
	      markRef(current, workInProgress);
	      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
	      return workInProgress.child;
	    case 6:
	      if (null === current && isHydrating) {
	        if ((current = renderLanes = nextHydratableInstance))
	          (renderLanes = canHydrateTextInstance(
	            renderLanes,
	            workInProgress.pendingProps,
	            rootOrSingletonContext
	          )),
	            null !== renderLanes
	              ? ((workInProgress.stateNode = renderLanes),
	                (hydrationParentFiber = workInProgress),
	                (nextHydratableInstance = null),
	                (current = !0))
	              : (current = !1);
	        current || throwOnHydrationMismatch(workInProgress);
	      }
	      return null;
	    case 13:
	      return updateSuspenseComponent(current, workInProgress, renderLanes);
	    case 4:
	      return (
	        pushHostContainer(
	          workInProgress,
	          workInProgress.stateNode.containerInfo
	        ),
	        (lazyComponent = workInProgress.pendingProps),
	        null === current
	          ? (workInProgress.child = reconcileChildFibers(
	              workInProgress,
	              null,
	              lazyComponent,
	              renderLanes
	            ))
	          : reconcileChildren(
	              current,
	              workInProgress,
	              lazyComponent,
	              renderLanes
	            ),
	        workInProgress.child
	      );
	    case 11:
	      return updateForwardRef(
	        current,
	        workInProgress,
	        workInProgress.type,
	        workInProgress.pendingProps,
	        renderLanes
	      );
	    case 7:
	      return (
	        reconcileChildren(
	          current,
	          workInProgress,
	          workInProgress.pendingProps,
	          renderLanes
	        ),
	        workInProgress.child
	      );
	    case 8:
	      return (
	        reconcileChildren(
	          current,
	          workInProgress,
	          workInProgress.pendingProps.children,
	          renderLanes
	        ),
	        workInProgress.child
	      );
	    case 12:
	      return (
	        reconcileChildren(
	          current,
	          workInProgress,
	          workInProgress.pendingProps.children,
	          renderLanes
	        ),
	        workInProgress.child
	      );
	    case 10:
	      return (
	        (lazyComponent = workInProgress.pendingProps),
	        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
	        reconcileChildren(
	          current,
	          workInProgress,
	          lazyComponent.children,
	          renderLanes
	        ),
	        workInProgress.child
	      );
	    case 9:
	      return (
	        (init = workInProgress.type._context),
	        (lazyComponent = workInProgress.pendingProps.children),
	        prepareToReadContext(workInProgress),
	        (init = readContext(init)),
	        (lazyComponent = lazyComponent(init)),
	        (workInProgress.flags |= 1),
	        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
	        workInProgress.child
	      );
	    case 14:
	      return updateMemoComponent(
	        current,
	        workInProgress,
	        workInProgress.type,
	        workInProgress.pendingProps,
	        renderLanes
	      );
	    case 15:
	      return updateSimpleMemoComponent(
	        current,
	        workInProgress,
	        workInProgress.type,
	        workInProgress.pendingProps,
	        renderLanes
	      );
	    case 19:
	      return updateSuspenseListComponent(current, workInProgress, renderLanes);
	    case 31:
	      return (
	        (lazyComponent = workInProgress.pendingProps),
	        (renderLanes = workInProgress.mode),
	        (lazyComponent = {
	          mode: lazyComponent.mode,
	          children: lazyComponent.children
	        }),
	        null === current
	          ? ((renderLanes = mountWorkInProgressOffscreenFiber(
	              lazyComponent,
	              renderLanes
	            )),
	            (renderLanes.ref = workInProgress.ref),
	            (workInProgress.child = renderLanes),
	            (renderLanes.return = workInProgress),
	            (workInProgress = renderLanes))
	          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),
	            (renderLanes.ref = workInProgress.ref),
	            (workInProgress.child = renderLanes),
	            (renderLanes.return = workInProgress),
	            (workInProgress = renderLanes)),
	        workInProgress
	      );
	    case 22:
	      return updateOffscreenComponent(current, workInProgress, renderLanes);
	    case 24:
	      return (
	        prepareToReadContext(workInProgress),
	        (lazyComponent = readContext(CacheContext)),
	        null === current
	          ? ((init = peekCacheFromPool()),
	            null === init &&
	              ((init = workInProgressRoot),
	              (prevState = createCache()),
	              (init.pooledCache = prevState),
	              prevState.refCount++,
	              null !== prevState && (init.pooledCacheLanes |= renderLanes),
	              (init = prevState)),
	            (workInProgress.memoizedState = {
	              parent: lazyComponent,
	              cache: init
	            }),
	            initializeUpdateQueue(workInProgress),
	            pushProvider(workInProgress, CacheContext, init))
	          : (0 !== (current.lanes & renderLanes) &&
	              (cloneUpdateQueue(current, workInProgress),
	              processUpdateQueue(workInProgress, null, null, renderLanes),
	              suspendIfUpdateReadFromEntangledAsyncAction()),
	            (init = current.memoizedState),
	            (prevState = workInProgress.memoizedState),
	            init.parent !== lazyComponent
	              ? ((init = { parent: lazyComponent, cache: lazyComponent }),
	                (workInProgress.memoizedState = init),
	                0 === workInProgress.lanes &&
	                  (workInProgress.memoizedState =
	                    workInProgress.updateQueue.baseState =
	                      init),
	                pushProvider(workInProgress, CacheContext, lazyComponent))
	              : ((lazyComponent = prevState.cache),
	                pushProvider(workInProgress, CacheContext, lazyComponent),
	                lazyComponent !== init.cache &&
	                  propagateContextChanges(
	                    workInProgress,
	                    [CacheContext],
	                    renderLanes,
	                    !0
	                  ))),
	        reconcileChildren(
	          current,
	          workInProgress,
	          workInProgress.pendingProps.children,
	          renderLanes
	        ),
	        workInProgress.child
	      );
	    case 29:
	      throw workInProgress.pendingProps;
	  }
	  throw Error(formatProdErrorMessage$1(156, workInProgress.tag));
	}
	function markUpdate(workInProgress) {
	  workInProgress.flags |= 4;
	}
	function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
	  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
	    workInProgress.flags &= -16777217;
	  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
	    resource = suspenseHandlerStackCursor.current;
	    if (
	      null !== resource &&
	      ((workInProgressRootRenderLanes & 4194048) ===
	      workInProgressRootRenderLanes
	        ? null !== shellBoundary
	        : ((workInProgressRootRenderLanes & 62914560) !==
	            workInProgressRootRenderLanes &&
	            0 === (workInProgressRootRenderLanes & 536870912)) ||
	          resource !== shellBoundary)
	    )
	      throw (
	        ((suspendedThenable = noopSuspenseyCommitThenable),
	        SuspenseyCommitException)
	      );
	    workInProgress.flags |= 8192;
	  }
	}
	function scheduleRetryEffect(workInProgress, retryQueue) {
	  null !== retryQueue && (workInProgress.flags |= 4);
	  workInProgress.flags & 16384 &&
	    ((retryQueue =
	      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
	    (workInProgress.lanes |= retryQueue),
	    (workInProgressSuspendedRetryLanes |= retryQueue));
	}
	function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
	  if (!isHydrating)
	    switch (renderState.tailMode) {
	      case "hidden":
	        hasRenderedATailFallback = renderState.tail;
	        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
	          null !== hasRenderedATailFallback.alternate &&
	            (lastTailNode = hasRenderedATailFallback),
	            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
	        null === lastTailNode
	          ? (renderState.tail = null)
	          : (lastTailNode.sibling = null);
	        break;
	      case "collapsed":
	        lastTailNode = renderState.tail;
	        for (var lastTailNode$113 = null; null !== lastTailNode; )
	          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),
	            (lastTailNode = lastTailNode.sibling);
	        null === lastTailNode$113
	          ? hasRenderedATailFallback || null === renderState.tail
	            ? (renderState.tail = null)
	            : (renderState.tail.sibling = null)
	          : (lastTailNode$113.sibling = null);
	    }
	}
	function bubbleProperties(completedWork) {
	  var didBailout =
	      null !== completedWork.alternate &&
	      completedWork.alternate.child === completedWork.child,
	    newChildLanes = 0,
	    subtreeFlags = 0;
	  if (didBailout)
	    for (var child$114 = completedWork.child; null !== child$114; )
	      (newChildLanes |= child$114.lanes | child$114.childLanes),
	        (subtreeFlags |= child$114.subtreeFlags & 65011712),
	        (subtreeFlags |= child$114.flags & 65011712),
	        (child$114.return = completedWork),
	        (child$114 = child$114.sibling);
	  else
	    for (child$114 = completedWork.child; null !== child$114; )
	      (newChildLanes |= child$114.lanes | child$114.childLanes),
	        (subtreeFlags |= child$114.subtreeFlags),
	        (subtreeFlags |= child$114.flags),
	        (child$114.return = completedWork),
	        (child$114 = child$114.sibling);
	  completedWork.subtreeFlags |= subtreeFlags;
	  completedWork.childLanes = newChildLanes;
	  return didBailout;
	}
	function completeWork(current, workInProgress, renderLanes) {
	  var newProps = workInProgress.pendingProps;
	  popTreeContext(workInProgress);
	  switch (workInProgress.tag) {
	    case 31:
	    case 16:
	    case 15:
	    case 0:
	    case 11:
	    case 7:
	    case 8:
	    case 12:
	    case 9:
	    case 14:
	      return bubbleProperties(workInProgress), null;
	    case 1:
	      return bubbleProperties(workInProgress), null;
	    case 3:
	      renderLanes = workInProgress.stateNode;
	      newProps = null;
	      null !== current && (newProps = current.memoizedState.cache);
	      workInProgress.memoizedState.cache !== newProps &&
	        (workInProgress.flags |= 2048);
	      popProvider(CacheContext);
	      popHostContainer();
	      renderLanes.pendingContext &&
	        ((renderLanes.context = renderLanes.pendingContext),
	        (renderLanes.pendingContext = null));
	      if (null === current || null === current.child)
	        popHydrationState(workInProgress)
	          ? markUpdate(workInProgress)
	          : null === current ||
	            (current.memoizedState.isDehydrated &&
	              0 === (workInProgress.flags & 256)) ||
	            ((workInProgress.flags |= 1024),
	            upgradeHydrationErrorsToRecoverable());
	      bubbleProperties(workInProgress);
	      return null;
	    case 26:
	      return (
	        (renderLanes = workInProgress.memoizedState),
	        null === current
	          ? (markUpdate(workInProgress),
	            null !== renderLanes
	              ? (bubbleProperties(workInProgress),
	                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
	              : (bubbleProperties(workInProgress),
	                (workInProgress.flags &= -16777217)))
	          : renderLanes
	            ? renderLanes !== current.memoizedState
	              ? (markUpdate(workInProgress),
	                bubbleProperties(workInProgress),
	                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
	              : (bubbleProperties(workInProgress),
	                (workInProgress.flags &= -16777217))
	            : (current.memoizedProps !== newProps && markUpdate(workInProgress),
	              bubbleProperties(workInProgress),
	              (workInProgress.flags &= -16777217)),
	        null
	      );
	    case 27:
	      popHostContext(workInProgress);
	      renderLanes = rootInstanceStackCursor.current;
	      var type = workInProgress.type;
	      if (null !== current && null != workInProgress.stateNode)
	        current.memoizedProps !== newProps && markUpdate(workInProgress);
	      else {
	        if (!newProps) {
	          if (null === workInProgress.stateNode)
	            throw Error(formatProdErrorMessage$1(166));
	          bubbleProperties(workInProgress);
	          return null;
	        }
	        current = contextStackCursor.current;
	        popHydrationState(workInProgress)
	          ? prepareToHydrateHostInstance(workInProgress)
	          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
	            (workInProgress.stateNode = current),
	            markUpdate(workInProgress));
	      }
	      bubbleProperties(workInProgress);
	      return null;
	    case 5:
	      popHostContext(workInProgress);
	      renderLanes = workInProgress.type;
	      if (null !== current && null != workInProgress.stateNode)
	        current.memoizedProps !== newProps && markUpdate(workInProgress);
	      else {
	        if (!newProps) {
	          if (null === workInProgress.stateNode)
	            throw Error(formatProdErrorMessage$1(166));
	          bubbleProperties(workInProgress);
	          return null;
	        }
	        current = contextStackCursor.current;
	        if (popHydrationState(workInProgress))
	          prepareToHydrateHostInstance(workInProgress);
	        else {
	          type = getOwnerDocumentFromRootContainer(
	            rootInstanceStackCursor.current
	          );
	          switch (current) {
	            case 1:
	              current = type.createElementNS(
	                "http://www.w3.org/2000/svg",
	                renderLanes
	              );
	              break;
	            case 2:
	              current = type.createElementNS(
	                "http://www.w3.org/1998/Math/MathML",
	                renderLanes
	              );
	              break;
	            default:
	              switch (renderLanes) {
	                case "svg":
	                  current = type.createElementNS(
	                    "http://www.w3.org/2000/svg",
	                    renderLanes
	                  );
	                  break;
	                case "math":
	                  current = type.createElementNS(
	                    "http://www.w3.org/1998/Math/MathML",
	                    renderLanes
	                  );
	                  break;
	                case "script":
	                  current = type.createElement("div");
	                  current.innerHTML = "<script>\x3c/script>";
	                  current = current.removeChild(current.firstChild);
	                  break;
	                case "select":
	                  current =
	                    "string" === typeof newProps.is
	                      ? type.createElement("select", { is: newProps.is })
	                      : type.createElement("select");
	                  newProps.multiple
	                    ? (current.multiple = !0)
	                    : newProps.size && (current.size = newProps.size);
	                  break;
	                default:
	                  current =
	                    "string" === typeof newProps.is
	                      ? type.createElement(renderLanes, { is: newProps.is })
	                      : type.createElement(renderLanes);
	              }
	          }
	          current[internalInstanceKey] = workInProgress;
	          current[internalPropsKey] = newProps;
	          a: for (type = workInProgress.child; null !== type; ) {
	            if (5 === type.tag || 6 === type.tag)
	              current.appendChild(type.stateNode);
	            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
	              type.child.return = type;
	              type = type.child;
	              continue;
	            }
	            if (type === workInProgress) break a;
	            for (; null === type.sibling; ) {
	              if (null === type.return || type.return === workInProgress)
	                break a;
	              type = type.return;
	            }
	            type.sibling.return = type.return;
	            type = type.sibling;
	          }
	          workInProgress.stateNode = current;
	          a: switch (
	            (setInitialProperties(current, renderLanes, newProps), renderLanes)
	          ) {
	            case "button":
	            case "input":
	            case "select":
	            case "textarea":
	              current = !!newProps.autoFocus;
	              break a;
	            case "img":
	              current = !0;
	              break a;
	            default:
	              current = !1;
	          }
	          current && markUpdate(workInProgress);
	        }
	      }
	      bubbleProperties(workInProgress);
	      workInProgress.flags &= -16777217;
	      return null;
	    case 6:
	      if (current && null != workInProgress.stateNode)
	        current.memoizedProps !== newProps && markUpdate(workInProgress);
	      else {
	        if ("string" !== typeof newProps && null === workInProgress.stateNode)
	          throw Error(formatProdErrorMessage$1(166));
	        current = rootInstanceStackCursor.current;
	        if (popHydrationState(workInProgress)) {
	          current = workInProgress.stateNode;
	          renderLanes = workInProgress.memoizedProps;
	          newProps = null;
	          type = hydrationParentFiber;
	          if (null !== type)
	            switch (type.tag) {
	              case 27:
	              case 5:
	                newProps = type.memoizedProps;
	            }
	          current[internalInstanceKey] = workInProgress;
	          current =
	            current.nodeValue === renderLanes ||
	            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
	            checkForUnmatchedText(current.nodeValue, renderLanes)
	              ? !0
	              : !1;
	          current || throwOnHydrationMismatch(workInProgress);
	        } else
	          (current =
	            getOwnerDocumentFromRootContainer(current).createTextNode(
	              newProps
	            )),
	            (current[internalInstanceKey] = workInProgress),
	            (workInProgress.stateNode = current);
	      }
	      bubbleProperties(workInProgress);
	      return null;
	    case 13:
	      newProps = workInProgress.memoizedState;
	      if (
	        null === current ||
	        (null !== current.memoizedState &&
	          null !== current.memoizedState.dehydrated)
	      ) {
	        type = popHydrationState(workInProgress);
	        if (null !== newProps && null !== newProps.dehydrated) {
	          if (null === current) {
	            if (!type) throw Error(formatProdErrorMessage$1(318));
	            type = workInProgress.memoizedState;
	            type = null !== type ? type.dehydrated : null;
	            if (!type) throw Error(formatProdErrorMessage$1(317));
	            type[internalInstanceKey] = workInProgress;
	          } else
	            resetHydrationState(),
	              0 === (workInProgress.flags & 128) &&
	                (workInProgress.memoizedState = null),
	              (workInProgress.flags |= 4);
	          bubbleProperties(workInProgress);
	          type = !1;
	        } else
	          (type = upgradeHydrationErrorsToRecoverable()),
	            null !== current &&
	              null !== current.memoizedState &&
	              (current.memoizedState.hydrationErrors = type),
	            (type = !0);
	        if (!type) {
	          if (workInProgress.flags & 256)
	            return popSuspenseHandler(workInProgress), workInProgress;
	          popSuspenseHandler(workInProgress);
	          return null;
	        }
	      }
	      popSuspenseHandler(workInProgress);
	      if (0 !== (workInProgress.flags & 128))
	        return (workInProgress.lanes = renderLanes), workInProgress;
	      renderLanes = null !== newProps;
	      current = null !== current && null !== current.memoizedState;
	      if (renderLanes) {
	        newProps = workInProgress.child;
	        type = null;
	        null !== newProps.alternate &&
	          null !== newProps.alternate.memoizedState &&
	          null !== newProps.alternate.memoizedState.cachePool &&
	          (type = newProps.alternate.memoizedState.cachePool.pool);
	        var cache$127 = null;
	        null !== newProps.memoizedState &&
	          null !== newProps.memoizedState.cachePool &&
	          (cache$127 = newProps.memoizedState.cachePool.pool);
	        cache$127 !== type && (newProps.flags |= 2048);
	      }
	      renderLanes !== current &&
	        renderLanes &&
	        (workInProgress.child.flags |= 8192);
	      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
	      bubbleProperties(workInProgress);
	      return null;
	    case 4:
	      return (
	        popHostContainer(),
	        null === current &&
	          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
	        bubbleProperties(workInProgress),
	        null
	      );
	    case 10:
	      return (
	        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
	      );
	    case 19:
	      pop(suspenseStackCursor);
	      type = workInProgress.memoizedState;
	      if (null === type) return bubbleProperties(workInProgress), null;
	      newProps = 0 !== (workInProgress.flags & 128);
	      cache$127 = type.rendering;
	      if (null === cache$127)
	        if (newProps) cutOffTailIfNeeded(type, !1);
	        else {
	          if (
	            0 !== workInProgressRootExitStatus ||
	            (null !== current && 0 !== (current.flags & 128))
	          )
	            for (current = workInProgress.child; null !== current; ) {
	              cache$127 = findFirstSuspended(current);
	              if (null !== cache$127) {
	                workInProgress.flags |= 128;
	                cutOffTailIfNeeded(type, !1);
	                current = cache$127.updateQueue;
	                workInProgress.updateQueue = current;
	                scheduleRetryEffect(workInProgress, current);
	                workInProgress.subtreeFlags = 0;
	                current = renderLanes;
	                for (renderLanes = workInProgress.child; null !== renderLanes; )
	                  resetWorkInProgress(renderLanes, current),
	                    (renderLanes = renderLanes.sibling);
	                push(
	                  suspenseStackCursor,
	                  (suspenseStackCursor.current & 1) | 2
	                );
	                return workInProgress.child;
	              }
	              current = current.sibling;
	            }
	          null !== type.tail &&
	            now() > workInProgressRootRenderTargetTime &&
	            ((workInProgress.flags |= 128),
	            (newProps = !0),
	            cutOffTailIfNeeded(type, !1),
	            (workInProgress.lanes = 4194304));
	        }
	      else {
	        if (!newProps)
	          if (((current = findFirstSuspended(cache$127)), null !== current)) {
	            if (
	              ((workInProgress.flags |= 128),
	              (newProps = !0),
	              (current = current.updateQueue),
	              (workInProgress.updateQueue = current),
	              scheduleRetryEffect(workInProgress, current),
	              cutOffTailIfNeeded(type, !0),
	              null === type.tail &&
	                "hidden" === type.tailMode &&
	                !cache$127.alternate &&
	                !isHydrating)
	            )
	              return bubbleProperties(workInProgress), null;
	          } else
	            2 * now() - type.renderingStartTime >
	              workInProgressRootRenderTargetTime &&
	              536870912 !== renderLanes &&
	              ((workInProgress.flags |= 128),
	              (newProps = !0),
	              cutOffTailIfNeeded(type, !1),
	              (workInProgress.lanes = 4194304));
	        type.isBackwards
	          ? ((cache$127.sibling = workInProgress.child),
	            (workInProgress.child = cache$127))
	          : ((current = type.last),
	            null !== current
	              ? (current.sibling = cache$127)
	              : (workInProgress.child = cache$127),
	            (type.last = cache$127));
	      }
	      if (null !== type.tail)
	        return (
	          (workInProgress = type.tail),
	          (type.rendering = workInProgress),
	          (type.tail = workInProgress.sibling),
	          (type.renderingStartTime = now()),
	          (workInProgress.sibling = null),
	          (current = suspenseStackCursor.current),
	          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
	          workInProgress
	        );
	      bubbleProperties(workInProgress);
	      return null;
	    case 22:
	    case 23:
	      return (
	        popSuspenseHandler(workInProgress),
	        popHiddenContext(),
	        (newProps = null !== workInProgress.memoizedState),
	        null !== current
	          ? (null !== current.memoizedState) !== newProps &&
	            (workInProgress.flags |= 8192)
	          : newProps && (workInProgress.flags |= 8192),
	        newProps
	          ? 0 !== (renderLanes & 536870912) &&
	            0 === (workInProgress.flags & 128) &&
	            (bubbleProperties(workInProgress),
	            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
	          : bubbleProperties(workInProgress),
	        (renderLanes = workInProgress.updateQueue),
	        null !== renderLanes &&
	          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
	        (renderLanes = null),
	        null !== current &&
	          null !== current.memoizedState &&
	          null !== current.memoizedState.cachePool &&
	          (renderLanes = current.memoizedState.cachePool.pool),
	        (newProps = null),
	        null !== workInProgress.memoizedState &&
	          null !== workInProgress.memoizedState.cachePool &&
	          (newProps = workInProgress.memoizedState.cachePool.pool),
	        newProps !== renderLanes && (workInProgress.flags |= 2048),
	        null !== current && pop(resumedCache),
	        null
	      );
	    case 24:
	      return (
	        (renderLanes = null),
	        null !== current && (renderLanes = current.memoizedState.cache),
	        workInProgress.memoizedState.cache !== renderLanes &&
	          (workInProgress.flags |= 2048),
	        popProvider(CacheContext),
	        bubbleProperties(workInProgress),
	        null
	      );
	    case 25:
	      return null;
	    case 30:
	      return null;
	  }
	  throw Error(formatProdErrorMessage$1(156, workInProgress.tag));
	}
	function unwindWork(current, workInProgress) {
	  popTreeContext(workInProgress);
	  switch (workInProgress.tag) {
	    case 1:
	      return (
	        (current = workInProgress.flags),
	        current & 65536
	          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
	          : null
	      );
	    case 3:
	      return (
	        popProvider(CacheContext),
	        popHostContainer(),
	        (current = workInProgress.flags),
	        0 !== (current & 65536) && 0 === (current & 128)
	          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
	          : null
	      );
	    case 26:
	    case 27:
	    case 5:
	      return popHostContext(workInProgress), null;
	    case 13:
	      popSuspenseHandler(workInProgress);
	      current = workInProgress.memoizedState;
	      if (null !== current && null !== current.dehydrated) {
	        if (null === workInProgress.alternate)
	          throw Error(formatProdErrorMessage$1(340));
	        resetHydrationState();
	      }
	      current = workInProgress.flags;
	      return current & 65536
	        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
	        : null;
	    case 19:
	      return pop(suspenseStackCursor), null;
	    case 4:
	      return popHostContainer(), null;
	    case 10:
	      return popProvider(workInProgress.type), null;
	    case 22:
	    case 23:
	      return (
	        popSuspenseHandler(workInProgress),
	        popHiddenContext(),
	        null !== current && pop(resumedCache),
	        (current = workInProgress.flags),
	        current & 65536
	          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
	          : null
	      );
	    case 24:
	      return popProvider(CacheContext), null;
	    case 25:
	      return null;
	    default:
	      return null;
	  }
	}
	function unwindInterruptedWork(current, interruptedWork) {
	  popTreeContext(interruptedWork);
	  switch (interruptedWork.tag) {
	    case 3:
	      popProvider(CacheContext);
	      popHostContainer();
	      break;
	    case 26:
	    case 27:
	    case 5:
	      popHostContext(interruptedWork);
	      break;
	    case 4:
	      popHostContainer();
	      break;
	    case 13:
	      popSuspenseHandler(interruptedWork);
	      break;
	    case 19:
	      pop(suspenseStackCursor);
	      break;
	    case 10:
	      popProvider(interruptedWork.type);
	      break;
	    case 22:
	    case 23:
	      popSuspenseHandler(interruptedWork);
	      popHiddenContext();
	      null !== current && pop(resumedCache);
	      break;
	    case 24:
	      popProvider(CacheContext);
	  }
	}
	function commitHookEffectListMount(flags, finishedWork) {
	  try {
	    var updateQueue = finishedWork.updateQueue,
	      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
	    if (null !== lastEffect) {
	      var firstEffect = lastEffect.next;
	      updateQueue = firstEffect;
	      do {
	        if ((updateQueue.tag & flags) === flags) {
	          lastEffect = void 0;
	          var create = updateQueue.create,
	            inst = updateQueue.inst;
	          lastEffect = create();
	          inst.destroy = lastEffect;
	        }
	        updateQueue = updateQueue.next;
	      } while (updateQueue !== firstEffect);
	    }
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function commitHookEffectListUnmount(
	  flags,
	  finishedWork,
	  nearestMountedAncestor$jscomp$0
	) {
	  try {
	    var updateQueue = finishedWork.updateQueue,
	      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
	    if (null !== lastEffect) {
	      var firstEffect = lastEffect.next;
	      updateQueue = firstEffect;
	      do {
	        if ((updateQueue.tag & flags) === flags) {
	          var inst = updateQueue.inst,
	            destroy = inst.destroy;
	          if (void 0 !== destroy) {
	            inst.destroy = void 0;
	            lastEffect = finishedWork;
	            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
	              destroy_ = destroy;
	            try {
	              destroy_();
	            } catch (error) {
	              captureCommitPhaseError(
	                lastEffect,
	                nearestMountedAncestor,
	                error
	              );
	            }
	          }
	        }
	        updateQueue = updateQueue.next;
	      } while (updateQueue !== firstEffect);
	    }
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function commitClassCallbacks(finishedWork) {
	  var updateQueue = finishedWork.updateQueue;
	  if (null !== updateQueue) {
	    var instance = finishedWork.stateNode;
	    try {
	      commitCallbacks(updateQueue, instance);
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	}
	function safelyCallComponentWillUnmount(
	  current,
	  nearestMountedAncestor,
	  instance
	) {
	  instance.props = resolveClassComponentProps(
	    current.type,
	    current.memoizedProps
	  );
	  instance.state = current.memoizedState;
	  try {
	    instance.componentWillUnmount();
	  } catch (error) {
	    captureCommitPhaseError(current, nearestMountedAncestor, error);
	  }
	}
	function safelyAttachRef(current, nearestMountedAncestor) {
	  try {
	    var ref = current.ref;
	    if (null !== ref) {
	      switch (current.tag) {
	        case 26:
	        case 27:
	        case 5:
	          var instanceToUse = current.stateNode;
	          break;
	        case 30:
	          instanceToUse = current.stateNode;
	          break;
	        default:
	          instanceToUse = current.stateNode;
	      }
	      "function" === typeof ref
	        ? (current.refCleanup = ref(instanceToUse))
	        : (ref.current = instanceToUse);
	    }
	  } catch (error) {
	    captureCommitPhaseError(current, nearestMountedAncestor, error);
	  }
	}
	function safelyDetachRef(current, nearestMountedAncestor) {
	  var ref = current.ref,
	    refCleanup = current.refCleanup;
	  if (null !== ref)
	    if ("function" === typeof refCleanup)
	      try {
	        refCleanup();
	      } catch (error) {
	        captureCommitPhaseError(current, nearestMountedAncestor, error);
	      } finally {
	        (current.refCleanup = null),
	          (current = current.alternate),
	          null != current && (current.refCleanup = null);
	      }
	    else if ("function" === typeof ref)
	      try {
	        ref(null);
	      } catch (error$143) {
	        captureCommitPhaseError(current, nearestMountedAncestor, error$143);
	      }
	    else ref.current = null;
	}
	function commitHostMount(finishedWork) {
	  var type = finishedWork.type,
	    props = finishedWork.memoizedProps,
	    instance = finishedWork.stateNode;
	  try {
	    a: switch (type) {
	      case "button":
	      case "input":
	      case "select":
	      case "textarea":
	        props.autoFocus && instance.focus();
	        break a;
	      case "img":
	        props.src
	          ? (instance.src = props.src)
	          : props.srcSet && (instance.srcset = props.srcSet);
	    }
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function commitHostUpdate(finishedWork, newProps, oldProps) {
	  try {
	    var domElement = finishedWork.stateNode;
	    updateProperties(domElement, finishedWork.type, oldProps, newProps);
	    domElement[internalPropsKey] = newProps;
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function isHostParent(fiber) {
	  return (
	    5 === fiber.tag ||
	    3 === fiber.tag ||
	    26 === fiber.tag ||
	    (27 === fiber.tag && isSingletonScope(fiber.type)) ||
	    4 === fiber.tag
	  );
	}
	function getHostSibling(fiber) {
	  a: for (;;) {
	    for (; null === fiber.sibling; ) {
	      if (null === fiber.return || isHostParent(fiber.return)) return null;
	      fiber = fiber.return;
	    }
	    fiber.sibling.return = fiber.return;
	    for (
	      fiber = fiber.sibling;
	      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

	    ) {
	      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
	      if (fiber.flags & 2) continue a;
	      if (null === fiber.child || 4 === fiber.tag) continue a;
	      else (fiber.child.return = fiber), (fiber = fiber.child);
	    }
	    if (!(fiber.flags & 2)) return fiber.stateNode;
	  }
	}
	function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
	  var tag = node.tag;
	  if (5 === tag || 6 === tag)
	    (node = node.stateNode),
	      before
	        ? (9 === parent.nodeType
	            ? parent.body
	            : "HTML" === parent.nodeName
	              ? parent.ownerDocument.body
	              : parent
	          ).insertBefore(node, before)
	        : ((before =
	            9 === parent.nodeType
	              ? parent.body
	              : "HTML" === parent.nodeName
	                ? parent.ownerDocument.body
	                : parent),
	          before.appendChild(node),
	          (parent = parent._reactRootContainer),
	          (null !== parent && void 0 !== parent) ||
	            null !== before.onclick ||
	            (before.onclick = noop$1));
	  else if (
	    4 !== tag &&
	    (27 === tag &&
	      isSingletonScope(node.type) &&
	      ((parent = node.stateNode), (before = null)),
	    (node = node.child),
	    null !== node)
	  )
	    for (
	      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
	        node = node.sibling;
	      null !== node;

	    )
	      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
	        (node = node.sibling);
	}
	function insertOrAppendPlacementNode(node, before, parent) {
	  var tag = node.tag;
	  if (5 === tag || 6 === tag)
	    (node = node.stateNode),
	      before ? parent.insertBefore(node, before) : parent.appendChild(node);
	  else if (
	    4 !== tag &&
	    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
	    (node = node.child),
	    null !== node)
	  )
	    for (
	      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
	      null !== node;

	    )
	      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
	}
	function commitHostSingletonAcquisition(finishedWork) {
	  var singleton = finishedWork.stateNode,
	    props = finishedWork.memoizedProps;
	  try {
	    for (
	      var type = finishedWork.type, attributes = singleton.attributes;
	      attributes.length;

	    )
	      singleton.removeAttributeNode(attributes[0]);
	    setInitialProperties(singleton, type, props);
	    singleton[internalInstanceKey] = finishedWork;
	    singleton[internalPropsKey] = props;
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	var offscreenSubtreeIsHidden = !1,
	  offscreenSubtreeWasHidden = !1,
	  needsFormReset = !1,
	  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
	  nextEffect = null;
	function commitBeforeMutationEffects(root, firstChild) {
	  root = root.containerInfo;
	  eventsEnabled = _enabled;
	  root = getActiveElementDeep(root);
	  if (hasSelectionCapabilities(root)) {
	    if ("selectionStart" in root)
	      var JSCompiler_temp = {
	        start: root.selectionStart,
	        end: root.selectionEnd
	      };
	    else
	      {
	        JSCompiler_temp =
	          ((JSCompiler_temp = root.ownerDocument) &&
	            JSCompiler_temp.defaultView) ||
	          window;
	        var selection =
	          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
	        if (selection && 0 !== selection.rangeCount) {
	          JSCompiler_temp = selection.anchorNode;
	          var anchorOffset = selection.anchorOffset,
	            focusNode = selection.focusNode;
	          selection = selection.focusOffset;
	          var length = 0,
	            start = -1,
	            end = -1,
	            indexWithinAnchor = 0,
	            indexWithinFocus = 0,
	            node = root,
	            parentNode = null;
	          b: for (;;) {
	            for (var next; ; ) {
	              node !== JSCompiler_temp ||
	                (0 !== anchorOffset && 3 !== node.nodeType) ||
	                (start = length + anchorOffset);
	              node !== focusNode ||
	                (0 !== selection && 3 !== node.nodeType) ||
	                (end = length + selection);
	              3 === node.nodeType && (length += node.nodeValue.length);
	              if (null === (next = node.firstChild)) break;
	              parentNode = node;
	              node = next;
	            }
	            for (;;) {
	              if (node === root) break b;
	              parentNode === JSCompiler_temp &&
	                ++indexWithinAnchor === anchorOffset &&
	                (start = length);
	              parentNode === focusNode &&
	                ++indexWithinFocus === selection &&
	                (end = length);
	              if (null !== (next = node.nextSibling)) break;
	              node = parentNode;
	              parentNode = node.parentNode;
	            }
	            node = next;
	          }
	          JSCompiler_temp =
	            -1 === start || -1 === end ? null : { start: start, end: end };
	        } else JSCompiler_temp = null;
	      }
	    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
	  } else JSCompiler_temp = null;
	  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
	  _enabled = !1;
	  for (nextEffect = firstChild; null !== nextEffect; )
	    if (
	      ((firstChild = nextEffect),
	      (root = firstChild.child),
	      0 !== (firstChild.subtreeFlags & 1024) && null !== root)
	    )
	      (root.return = firstChild), (nextEffect = root);
	    else
	      for (; null !== nextEffect; ) {
	        firstChild = nextEffect;
	        focusNode = firstChild.alternate;
	        root = firstChild.flags;
	        switch (firstChild.tag) {
	          case 0:
	            break;
	          case 11:
	          case 15:
	            break;
	          case 1:
	            if (0 !== (root & 1024) && null !== focusNode) {
	              root = void 0;
	              JSCompiler_temp = firstChild;
	              anchorOffset = focusNode.memoizedProps;
	              focusNode = focusNode.memoizedState;
	              selection = JSCompiler_temp.stateNode;
	              try {
	                var resolvedPrevProps = resolveClassComponentProps(
	                  JSCompiler_temp.type,
	                  anchorOffset);
	                root = selection.getSnapshotBeforeUpdate(
	                  resolvedPrevProps,
	                  focusNode
	                );
	                selection.__reactInternalSnapshotBeforeUpdate = root;
	              } catch (error) {
	                captureCommitPhaseError(
	                  JSCompiler_temp,
	                  JSCompiler_temp.return,
	                  error
	                );
	              }
	            }
	            break;
	          case 3:
	            if (0 !== (root & 1024))
	              if (
	                ((root = firstChild.stateNode.containerInfo),
	                (JSCompiler_temp = root.nodeType),
	                9 === JSCompiler_temp)
	              )
	                clearContainerSparingly(root);
	              else if (1 === JSCompiler_temp)
	                switch (root.nodeName) {
	                  case "HEAD":
	                  case "HTML":
	                  case "BODY":
	                    clearContainerSparingly(root);
	                    break;
	                  default:
	                    root.textContent = "";
	                }
	            break;
	          case 5:
	          case 26:
	          case 27:
	          case 6:
	          case 4:
	          case 17:
	            break;
	          default:
	            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage$1(163));
	        }
	        root = firstChild.sibling;
	        if (null !== root) {
	          root.return = firstChild.return;
	          nextEffect = root;
	          break;
	        }
	        nextEffect = firstChild.return;
	      }
	}
	function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
	  var flags = finishedWork.flags;
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 15:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      flags & 4 && commitHookEffectListMount(5, finishedWork);
	      break;
	    case 1:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      if (flags & 4)
	        if (((finishedRoot = finishedWork.stateNode), null === current))
	          try {
	            finishedRoot.componentDidMount();
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        else {
	          var prevProps = resolveClassComponentProps(
	            finishedWork.type,
	            current.memoizedProps
	          );
	          current = current.memoizedState;
	          try {
	            finishedRoot.componentDidUpdate(
	              prevProps,
	              current,
	              finishedRoot.__reactInternalSnapshotBeforeUpdate
	            );
	          } catch (error$142) {
	            captureCommitPhaseError(
	              finishedWork,
	              finishedWork.return,
	              error$142
	            );
	          }
	        }
	      flags & 64 && commitClassCallbacks(finishedWork);
	      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
	      break;
	    case 3:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      if (
	        flags & 64 &&
	        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
	      ) {
	        current = null;
	        if (null !== finishedWork.child)
	          switch (finishedWork.child.tag) {
	            case 27:
	            case 5:
	              current = finishedWork.child.stateNode;
	              break;
	            case 1:
	              current = finishedWork.child.stateNode;
	          }
	        try {
	          commitCallbacks(finishedRoot, current);
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      }
	      break;
	    case 27:
	      null === current &&
	        flags & 4 &&
	        commitHostSingletonAcquisition(finishedWork);
	    case 26:
	    case 5:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      null === current && flags & 4 && commitHostMount(finishedWork);
	      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
	      break;
	    case 12:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      break;
	    case 13:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
	      flags & 64 &&
	        ((finishedRoot = finishedWork.memoizedState),
	        null !== finishedRoot &&
	          ((finishedRoot = finishedRoot.dehydrated),
	          null !== finishedRoot &&
	            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
	              null,
	              finishedWork
	            )),
	            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
	      break;
	    case 22:
	      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
	      if (!flags) {
	        current =
	          (null !== current && null !== current.memoizedState) ||
	          offscreenSubtreeWasHidden;
	        prevProps = offscreenSubtreeIsHidden;
	        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
	        offscreenSubtreeIsHidden = flags;
	        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
	          ? recursivelyTraverseReappearLayoutEffects(
	              finishedRoot,
	              finishedWork,
	              0 !== (finishedWork.subtreeFlags & 8772)
	            )
	          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        offscreenSubtreeIsHidden = prevProps;
	        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
	      }
	      break;
	    case 30:
	      break;
	    default:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	  }
	}
	function detachFiberAfterEffects(fiber) {
	  var alternate = fiber.alternate;
	  null !== alternate &&
	    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
	  fiber.child = null;
	  fiber.deletions = null;
	  fiber.sibling = null;
	  5 === fiber.tag &&
	    ((alternate = fiber.stateNode),
	    null !== alternate && detachDeletedInstance(alternate));
	  fiber.stateNode = null;
	  fiber.return = null;
	  fiber.dependencies = null;
	  fiber.memoizedProps = null;
	  fiber.memoizedState = null;
	  fiber.pendingProps = null;
	  fiber.stateNode = null;
	  fiber.updateQueue = null;
	}
	var hostParent = null,
	  hostParentIsContainer = !1;
	function recursivelyTraverseDeletionEffects(
	  finishedRoot,
	  nearestMountedAncestor,
	  parent
	) {
	  for (parent = parent.child; null !== parent; )
	    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
	      (parent = parent.sibling);
	}
	function commitDeletionEffectsOnFiber(
	  finishedRoot,
	  nearestMountedAncestor,
	  deletedFiber
	) {
	  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
	    try {
	      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
	    } catch (err) {}
	  switch (deletedFiber.tag) {
	    case 26:
	      offscreenSubtreeWasHidden ||
	        safelyDetachRef(deletedFiber, nearestMountedAncestor);
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      deletedFiber.memoizedState
	        ? deletedFiber.memoizedState.count--
	        : deletedFiber.stateNode &&
	          ((deletedFiber = deletedFiber.stateNode),
	          deletedFiber.parentNode.removeChild(deletedFiber));
	      break;
	    case 27:
	      offscreenSubtreeWasHidden ||
	        safelyDetachRef(deletedFiber, nearestMountedAncestor);
	      var prevHostParent = hostParent,
	        prevHostParentIsContainer = hostParentIsContainer;
	      isSingletonScope(deletedFiber.type) &&
	        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      releaseSingletonInstance(deletedFiber.stateNode);
	      hostParent = prevHostParent;
	      hostParentIsContainer = prevHostParentIsContainer;
	      break;
	    case 5:
	      offscreenSubtreeWasHidden ||
	        safelyDetachRef(deletedFiber, nearestMountedAncestor);
	    case 6:
	      prevHostParent = hostParent;
	      prevHostParentIsContainer = hostParentIsContainer;
	      hostParent = null;
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      hostParent = prevHostParent;
	      hostParentIsContainer = prevHostParentIsContainer;
	      if (null !== hostParent)
	        if (hostParentIsContainer)
	          try {
	            (9 === hostParent.nodeType
	              ? hostParent.body
	              : "HTML" === hostParent.nodeName
	                ? hostParent.ownerDocument.body
	                : hostParent
	            ).removeChild(deletedFiber.stateNode);
	          } catch (error) {
	            captureCommitPhaseError(
	              deletedFiber,
	              nearestMountedAncestor,
	              error
	            );
	          }
	        else
	          try {
	            hostParent.removeChild(deletedFiber.stateNode);
	          } catch (error) {
	            captureCommitPhaseError(
	              deletedFiber,
	              nearestMountedAncestor,
	              error
	            );
	          }
	      break;
	    case 18:
	      null !== hostParent &&
	        (hostParentIsContainer
	          ? ((finishedRoot = hostParent),
	            clearSuspenseBoundary(
	              9 === finishedRoot.nodeType
	                ? finishedRoot.body
	                : "HTML" === finishedRoot.nodeName
	                  ? finishedRoot.ownerDocument.body
	                  : finishedRoot,
	              deletedFiber.stateNode
	            ),
	            retryIfBlockedOn(finishedRoot))
	          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
	      break;
	    case 4:
	      prevHostParent = hostParent;
	      prevHostParentIsContainer = hostParentIsContainer;
	      hostParent = deletedFiber.stateNode.containerInfo;
	      hostParentIsContainer = !0;
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      hostParent = prevHostParent;
	      hostParentIsContainer = prevHostParentIsContainer;
	      break;
	    case 0:
	    case 11:
	    case 14:
	    case 15:
	      offscreenSubtreeWasHidden ||
	        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
	      offscreenSubtreeWasHidden ||
	        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      break;
	    case 1:
	      offscreenSubtreeWasHidden ||
	        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
	        (prevHostParent = deletedFiber.stateNode),
	        "function" === typeof prevHostParent.componentWillUnmount &&
	          safelyCallComponentWillUnmount(
	            deletedFiber,
	            nearestMountedAncestor,
	            prevHostParent
	          ));
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      break;
	    case 21:
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      break;
	    case 22:
	      offscreenSubtreeWasHidden =
	        (prevHostParent = offscreenSubtreeWasHidden) ||
	        null !== deletedFiber.memoizedState;
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      offscreenSubtreeWasHidden = prevHostParent;
	      break;
	    default:
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	  }
	}
	function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
	  if (
	    null === finishedWork.memoizedState &&
	    ((finishedRoot = finishedWork.alternate),
	    null !== finishedRoot &&
	      ((finishedRoot = finishedRoot.memoizedState),
	      null !== finishedRoot &&
	        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
	  )
	    try {
	      retryIfBlockedOn(finishedRoot);
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	}
	function getRetryCache(finishedWork) {
	  switch (finishedWork.tag) {
	    case 13:
	    case 19:
	      var retryCache = finishedWork.stateNode;
	      null === retryCache &&
	        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
	      return retryCache;
	    case 22:
	      return (
	        (finishedWork = finishedWork.stateNode),
	        (retryCache = finishedWork._retryCache),
	        null === retryCache &&
	          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
	        retryCache
	      );
	    default:
	      throw Error(formatProdErrorMessage$1(435, finishedWork.tag));
	  }
	}
	function attachSuspenseRetryListeners(finishedWork, wakeables) {
	  var retryCache = getRetryCache(finishedWork);
	  wakeables.forEach(function (wakeable) {
	    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
	    retryCache.has(wakeable) ||
	      (retryCache.add(wakeable), wakeable.then(retry, retry));
	  });
	}
	function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
	  var deletions = parentFiber.deletions;
	  if (null !== deletions)
	    for (var i = 0; i < deletions.length; i++) {
	      var childToDelete = deletions[i],
	        root = root$jscomp$0,
	        returnFiber = parentFiber,
	        parent = returnFiber;
	      a: for (; null !== parent; ) {
	        switch (parent.tag) {
	          case 27:
	            if (isSingletonScope(parent.type)) {
	              hostParent = parent.stateNode;
	              hostParentIsContainer = !1;
	              break a;
	            }
	            break;
	          case 5:
	            hostParent = parent.stateNode;
	            hostParentIsContainer = !1;
	            break a;
	          case 3:
	          case 4:
	            hostParent = parent.stateNode.containerInfo;
	            hostParentIsContainer = !0;
	            break a;
	        }
	        parent = parent.return;
	      }
	      if (null === hostParent) throw Error(formatProdErrorMessage$1(160));
	      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
	      hostParent = null;
	      hostParentIsContainer = !1;
	      root = childToDelete.alternate;
	      null !== root && (root.return = null);
	      childToDelete.return = null;
	    }
	  if (parentFiber.subtreeFlags & 13878)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
	        (parentFiber = parentFiber.sibling);
	}
	var currentHoistableRoot = null;
	function commitMutationEffectsOnFiber(finishedWork, root) {
	  var current = finishedWork.alternate,
	    flags = finishedWork.flags;
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 14:
	    case 15:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 4 &&
	        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
	        commitHookEffectListMount(3, finishedWork),
	        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
	      break;
	    case 1:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 &&
	        (offscreenSubtreeWasHidden ||
	          null === current ||
	          safelyDetachRef(current, current.return));
	      flags & 64 &&
	        offscreenSubtreeIsHidden &&
	        ((finishedWork = finishedWork.updateQueue),
	        null !== finishedWork &&
	          ((flags = finishedWork.callbacks),
	          null !== flags &&
	            ((current = finishedWork.shared.hiddenCallbacks),
	            (finishedWork.shared.hiddenCallbacks =
	              null === current ? flags : current.concat(flags)))));
	      break;
	    case 26:
	      var hoistableRoot = currentHoistableRoot;
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 &&
	        (offscreenSubtreeWasHidden ||
	          null === current ||
	          safelyDetachRef(current, current.return));
	      if (flags & 4) {
	        var currentResource = null !== current ? current.memoizedState : null;
	        flags = finishedWork.memoizedState;
	        if (null === current)
	          if (null === flags)
	            if (null === finishedWork.stateNode) {
	              a: {
	                flags = finishedWork.type;
	                current = finishedWork.memoizedProps;
	                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	                b: switch (flags) {
	                  case "title":
	                    currentResource =
	                      hoistableRoot.getElementsByTagName("title")[0];
	                    if (
	                      !currentResource ||
	                      currentResource[internalHoistableMarker] ||
	                      currentResource[internalInstanceKey] ||
	                      "http://www.w3.org/2000/svg" ===
	                        currentResource.namespaceURI ||
	                      currentResource.hasAttribute("itemprop")
	                    )
	                      (currentResource = hoistableRoot.createElement(flags)),
	                        hoistableRoot.head.insertBefore(
	                          currentResource,
	                          hoistableRoot.querySelector("head > title")
	                        );
	                    setInitialProperties(currentResource, flags, current);
	                    currentResource[internalInstanceKey] = finishedWork;
	                    markNodeAsHoistable(currentResource);
	                    flags = currentResource;
	                    break a;
	                  case "link":
	                    var maybeNodes = getHydratableHoistableCache(
	                      "link",
	                      "href",
	                      hoistableRoot
	                    ).get(flags + (current.href || ""));
	                    if (maybeNodes)
	                      for (var i = 0; i < maybeNodes.length; i++)
	                        if (
	                          ((currentResource = maybeNodes[i]),
	                          currentResource.getAttribute("href") ===
	                            (null == current.href || "" === current.href
	                              ? null
	                              : current.href) &&
	                            currentResource.getAttribute("rel") ===
	                              (null == current.rel ? null : current.rel) &&
	                            currentResource.getAttribute("title") ===
	                              (null == current.title ? null : current.title) &&
	                            currentResource.getAttribute("crossorigin") ===
	                              (null == current.crossOrigin
	                                ? null
	                                : current.crossOrigin))
	                        ) {
	                          maybeNodes.splice(i, 1);
	                          break b;
	                        }
	                    currentResource = hoistableRoot.createElement(flags);
	                    setInitialProperties(currentResource, flags, current);
	                    hoistableRoot.head.appendChild(currentResource);
	                    break;
	                  case "meta":
	                    if (
	                      (maybeNodes = getHydratableHoistableCache(
	                        "meta",
	                        "content",
	                        hoistableRoot
	                      ).get(flags + (current.content || "")))
	                    )
	                      for (i = 0; i < maybeNodes.length; i++)
	                        if (
	                          ((currentResource = maybeNodes[i]),
	                          currentResource.getAttribute("content") ===
	                            (null == current.content
	                              ? null
	                              : "" + current.content) &&
	                            currentResource.getAttribute("name") ===
	                              (null == current.name ? null : current.name) &&
	                            currentResource.getAttribute("property") ===
	                              (null == current.property
	                                ? null
	                                : current.property) &&
	                            currentResource.getAttribute("http-equiv") ===
	                              (null == current.httpEquiv
	                                ? null
	                                : current.httpEquiv) &&
	                            currentResource.getAttribute("charset") ===
	                              (null == current.charSet
	                                ? null
	                                : current.charSet))
	                        ) {
	                          maybeNodes.splice(i, 1);
	                          break b;
	                        }
	                    currentResource = hoistableRoot.createElement(flags);
	                    setInitialProperties(currentResource, flags, current);
	                    hoistableRoot.head.appendChild(currentResource);
	                    break;
	                  default:
	                    throw Error(formatProdErrorMessage$1(468, flags));
	                }
	                currentResource[internalInstanceKey] = finishedWork;
	                markNodeAsHoistable(currentResource);
	                flags = currentResource;
	              }
	              finishedWork.stateNode = flags;
	            } else
	              mountHoistable(
	                hoistableRoot,
	                finishedWork.type,
	                finishedWork.stateNode
	              );
	          else
	            finishedWork.stateNode = acquireResource(
	              hoistableRoot,
	              flags,
	              finishedWork.memoizedProps
	            );
	        else
	          currentResource !== flags
	            ? (null === currentResource
	                ? null !== current.stateNode &&
	                  ((current = current.stateNode),
	                  current.parentNode.removeChild(current))
	                : currentResource.count--,
	              null === flags
	                ? mountHoistable(
	                    hoistableRoot,
	                    finishedWork.type,
	                    finishedWork.stateNode
	                  )
	                : acquireResource(
	                    hoistableRoot,
	                    flags,
	                    finishedWork.memoizedProps
	                  ))
	            : null === flags &&
	              null !== finishedWork.stateNode &&
	              commitHostUpdate(
	                finishedWork,
	                finishedWork.memoizedProps,
	                current.memoizedProps
	              );
	      }
	      break;
	    case 27:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 &&
	        (offscreenSubtreeWasHidden ||
	          null === current ||
	          safelyDetachRef(current, current.return));
	      null !== current &&
	        flags & 4 &&
	        commitHostUpdate(
	          finishedWork,
	          finishedWork.memoizedProps,
	          current.memoizedProps
	        );
	      break;
	    case 5:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 &&
	        (offscreenSubtreeWasHidden ||
	          null === current ||
	          safelyDetachRef(current, current.return));
	      if (finishedWork.flags & 32) {
	        hoistableRoot = finishedWork.stateNode;
	        try {
	          setTextContent(hoistableRoot, "");
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      }
	      flags & 4 &&
	        null != finishedWork.stateNode &&
	        ((hoistableRoot = finishedWork.memoizedProps),
	        commitHostUpdate(
	          finishedWork,
	          hoistableRoot,
	          null !== current ? current.memoizedProps : hoistableRoot
	        ));
	      flags & 1024 && (needsFormReset = !0);
	      break;
	    case 6:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      if (flags & 4) {
	        if (null === finishedWork.stateNode)
	          throw Error(formatProdErrorMessage$1(162));
	        flags = finishedWork.memoizedProps;
	        current = finishedWork.stateNode;
	        try {
	          current.nodeValue = flags;
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      }
	      break;
	    case 3:
	      tagCaches = null;
	      hoistableRoot = currentHoistableRoot;
	      currentHoistableRoot = getHoistableRoot(root.containerInfo);
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      currentHoistableRoot = hoistableRoot;
	      commitReconciliationEffects(finishedWork);
	      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
	        try {
	          retryIfBlockedOn(root.containerInfo);
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      needsFormReset &&
	        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
	      break;
	    case 4:
	      flags = currentHoistableRoot;
	      currentHoistableRoot = getHoistableRoot(
	        finishedWork.stateNode.containerInfo
	      );
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      currentHoistableRoot = flags;
	      break;
	    case 12:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      break;
	    case 13:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      finishedWork.child.flags & 8192 &&
	        (null !== finishedWork.memoizedState) !==
	          (null !== current && null !== current.memoizedState) &&
	        (globalMostRecentFallbackTime = now());
	      flags & 4 &&
	        ((flags = finishedWork.updateQueue),
	        null !== flags &&
	          ((finishedWork.updateQueue = null),
	          attachSuspenseRetryListeners(finishedWork, flags)));
	      break;
	    case 22:
	      hoistableRoot = null !== finishedWork.memoizedState;
	      var wasHidden = null !== current && null !== current.memoizedState,
	        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
	        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
	      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
	      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
	      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
	      commitReconciliationEffects(finishedWork);
	      if (flags & 8192)
	        a: for (
	          root = finishedWork.stateNode,
	            root._visibility = hoistableRoot
	              ? root._visibility & -2
	              : root._visibility | 1,
	            hoistableRoot &&
	              (null === current ||
	                wasHidden ||
	                offscreenSubtreeIsHidden ||
	                offscreenSubtreeWasHidden ||
	                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
	            current = null,
	            root = finishedWork;
	          ;

	        ) {
	          if (5 === root.tag || 26 === root.tag) {
	            if (null === current) {
	              wasHidden = current = root;
	              try {
	                if (((currentResource = wasHidden.stateNode), hoistableRoot))
	                  (maybeNodes = currentResource.style),
	                    "function" === typeof maybeNodes.setProperty
	                      ? maybeNodes.setProperty("display", "none", "important")
	                      : (maybeNodes.display = "none");
	                else {
	                  i = wasHidden.stateNode;
	                  var styleProp = wasHidden.memoizedProps.style,
	                    display =
	                      void 0 !== styleProp &&
	                      null !== styleProp &&
	                      styleProp.hasOwnProperty("display")
	                        ? styleProp.display
	                        : null;
	                  i.style.display =
	                    null == display || "boolean" === typeof display
	                      ? ""
	                      : ("" + display).trim();
	                }
	              } catch (error) {
	                captureCommitPhaseError(wasHidden, wasHidden.return, error);
	              }
	            }
	          } else if (6 === root.tag) {
	            if (null === current) {
	              wasHidden = root;
	              try {
	                wasHidden.stateNode.nodeValue = hoistableRoot
	                  ? ""
	                  : wasHidden.memoizedProps;
	              } catch (error) {
	                captureCommitPhaseError(wasHidden, wasHidden.return, error);
	              }
	            }
	          } else if (
	            ((22 !== root.tag && 23 !== root.tag) ||
	              null === root.memoizedState ||
	              root === finishedWork) &&
	            null !== root.child
	          ) {
	            root.child.return = root;
	            root = root.child;
	            continue;
	          }
	          if (root === finishedWork) break a;
	          for (; null === root.sibling; ) {
	            if (null === root.return || root.return === finishedWork) break a;
	            current === root && (current = null);
	            root = root.return;
	          }
	          current === root && (current = null);
	          root.sibling.return = root.return;
	          root = root.sibling;
	        }
	      flags & 4 &&
	        ((flags = finishedWork.updateQueue),
	        null !== flags &&
	          ((current = flags.retryQueue),
	          null !== current &&
	            ((flags.retryQueue = null),
	            attachSuspenseRetryListeners(finishedWork, current))));
	      break;
	    case 19:
	      recursivelyTraverseMutationEffects(root, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 4 &&
	        ((flags = finishedWork.updateQueue),
	        null !== flags &&
	          ((finishedWork.updateQueue = null),
	          attachSuspenseRetryListeners(finishedWork, flags)));
	      break;
	    case 30:
	      break;
	    case 21:
	      break;
	    default:
	      recursivelyTraverseMutationEffects(root, finishedWork),
	        commitReconciliationEffects(finishedWork);
	  }
	}
	function commitReconciliationEffects(finishedWork) {
	  var flags = finishedWork.flags;
	  if (flags & 2) {
	    try {
	      for (
	        var hostParentFiber, parentFiber = finishedWork.return;
	        null !== parentFiber;

	      ) {
	        if (isHostParent(parentFiber)) {
	          hostParentFiber = parentFiber;
	          break;
	        }
	        parentFiber = parentFiber.return;
	      }
	      if (null == hostParentFiber) throw Error(formatProdErrorMessage$1(160));
	      switch (hostParentFiber.tag) {
	        case 27:
	          var parent = hostParentFiber.stateNode,
	            before = getHostSibling(finishedWork);
	          insertOrAppendPlacementNode(finishedWork, before, parent);
	          break;
	        case 5:
	          var parent$144 = hostParentFiber.stateNode;
	          hostParentFiber.flags & 32 &&
	            (setTextContent(parent$144, ""), (hostParentFiber.flags &= -33));
	          var before$145 = getHostSibling(finishedWork);
	          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
	          break;
	        case 3:
	        case 4:
	          var parent$146 = hostParentFiber.stateNode.containerInfo,
	            before$147 = getHostSibling(finishedWork);
	          insertOrAppendPlacementNodeIntoContainer(
	            finishedWork,
	            before$147,
	            parent$146
	          );
	          break;
	        default:
	          throw Error(formatProdErrorMessage$1(161));
	      }
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	    finishedWork.flags &= -3;
	  }
	  flags & 4096 && (finishedWork.flags &= -4097);
	}
	function recursivelyResetForms(parentFiber) {
	  if (parentFiber.subtreeFlags & 1024)
	    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	      var fiber = parentFiber;
	      recursivelyResetForms(fiber);
	      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
	      parentFiber = parentFiber.sibling;
	    }
	}
	function recursivelyTraverseLayoutEffects(root, parentFiber) {
	  if (parentFiber.subtreeFlags & 8772)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
	        (parentFiber = parentFiber.sibling);
	}
	function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    var finishedWork = parentFiber;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 14:
	      case 15:
	        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 1:
	        safelyDetachRef(finishedWork, finishedWork.return);
	        var instance = finishedWork.stateNode;
	        "function" === typeof instance.componentWillUnmount &&
	          safelyCallComponentWillUnmount(
	            finishedWork,
	            finishedWork.return,
	            instance
	          );
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 27:
	        releaseSingletonInstance(finishedWork.stateNode);
	      case 26:
	      case 5:
	        safelyDetachRef(finishedWork, finishedWork.return);
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 22:
	        null === finishedWork.memoizedState &&
	          recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 30:
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      default:
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function recursivelyTraverseReappearLayoutEffects(
	  finishedRoot$jscomp$0,
	  parentFiber,
	  includeWorkInProgressEffects
	) {
	  includeWorkInProgressEffects =
	    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    var current = parentFiber.alternate,
	      finishedRoot = finishedRoot$jscomp$0,
	      finishedWork = parentFiber,
	      flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        commitHookEffectListMount(4, finishedWork);
	        break;
	      case 1:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        current = finishedWork;
	        finishedRoot = current.stateNode;
	        if ("function" === typeof finishedRoot.componentDidMount)
	          try {
	            finishedRoot.componentDidMount();
	          } catch (error) {
	            captureCommitPhaseError(current, current.return, error);
	          }
	        current = finishedWork;
	        finishedRoot = current.updateQueue;
	        if (null !== finishedRoot) {
	          var instance = current.stateNode;
	          try {
	            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
	            if (null !== hiddenCallbacks)
	              for (
	                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
	                finishedRoot < hiddenCallbacks.length;
	                finishedRoot++
	              )
	                callCallback(hiddenCallbacks[finishedRoot], instance);
	          } catch (error) {
	            captureCommitPhaseError(current, current.return, error);
	          }
	        }
	        includeWorkInProgressEffects &&
	          flags & 64 &&
	          commitClassCallbacks(finishedWork);
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 27:
	        commitHostSingletonAcquisition(finishedWork);
	      case 26:
	      case 5:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects &&
	          null === current &&
	          flags & 4 &&
	          commitHostMount(finishedWork);
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 12:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        break;
	      case 13:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects &&
	          flags & 4 &&
	          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
	        break;
	      case 22:
	        null === finishedWork.memoizedState &&
	          recursivelyTraverseReappearLayoutEffects(
	            finishedRoot,
	            finishedWork,
	            includeWorkInProgressEffects
	          );
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 30:
	        break;
	      default:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function commitOffscreenPassiveMountEffects(current, finishedWork) {
	  var previousCache = null;
	  null !== current &&
	    null !== current.memoizedState &&
	    null !== current.memoizedState.cachePool &&
	    (previousCache = current.memoizedState.cachePool.pool);
	  current = null;
	  null !== finishedWork.memoizedState &&
	    null !== finishedWork.memoizedState.cachePool &&
	    (current = finishedWork.memoizedState.cachePool.pool);
	  current !== previousCache &&
	    (null != current && current.refCount++,
	    null != previousCache && releaseCache(previousCache));
	}
	function commitCachePassiveMountEffect(current, finishedWork) {
	  current = null;
	  null !== finishedWork.alternate &&
	    (current = finishedWork.alternate.memoizedState.cache);
	  finishedWork = finishedWork.memoizedState.cache;
	  finishedWork !== current &&
	    (finishedWork.refCount++, null != current && releaseCache(current));
	}
	function recursivelyTraversePassiveMountEffects(
	  root,
	  parentFiber,
	  committedLanes,
	  committedTransitions
	) {
	  if (parentFiber.subtreeFlags & 10256)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitPassiveMountOnFiber(
	        root,
	        parentFiber,
	        committedLanes,
	        committedTransitions
	      ),
	        (parentFiber = parentFiber.sibling);
	}
	function commitPassiveMountOnFiber(
	  finishedRoot,
	  finishedWork,
	  committedLanes,
	  committedTransitions
	) {
	  var flags = finishedWork.flags;
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 15:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      flags & 2048 && commitHookEffectListMount(9, finishedWork);
	      break;
	    case 1:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      break;
	    case 3:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      flags & 2048 &&
	        ((finishedRoot = null),
	        null !== finishedWork.alternate &&
	          (finishedRoot = finishedWork.alternate.memoizedState.cache),
	        (finishedWork = finishedWork.memoizedState.cache),
	        finishedWork !== finishedRoot &&
	          (finishedWork.refCount++,
	          null != finishedRoot && releaseCache(finishedRoot)));
	      break;
	    case 12:
	      if (flags & 2048) {
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        finishedRoot = finishedWork.stateNode;
	        try {
	          var _finishedWork$memoize2 = finishedWork.memoizedProps,
	            id = _finishedWork$memoize2.id,
	            onPostCommit = _finishedWork$memoize2.onPostCommit;
	          "function" === typeof onPostCommit &&
	            onPostCommit(
	              id,
	              null === finishedWork.alternate ? "mount" : "update",
	              finishedRoot.passiveEffectDuration,
	              -0
	            );
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      } else
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	      break;
	    case 13:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      break;
	    case 23:
	      break;
	    case 22:
	      _finishedWork$memoize2 = finishedWork.stateNode;
	      id = finishedWork.alternate;
	      null !== finishedWork.memoizedState
	        ? _finishedWork$memoize2._visibility & 2
	          ? recursivelyTraversePassiveMountEffects(
	              finishedRoot,
	              finishedWork,
	              committedLanes,
	              committedTransitions
	            )
	          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
	        : _finishedWork$memoize2._visibility & 2
	          ? recursivelyTraversePassiveMountEffects(
	              finishedRoot,
	              finishedWork,
	              committedLanes,
	              committedTransitions
	            )
	          : ((_finishedWork$memoize2._visibility |= 2),
	            recursivelyTraverseReconnectPassiveEffects(
	              finishedRoot,
	              finishedWork,
	              committedLanes,
	              committedTransitions,
	              0 !== (finishedWork.subtreeFlags & 10256)
	            ));
	      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
	      break;
	    case 24:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      flags & 2048 &&
	        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	      break;
	    default:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	  }
	}
	function recursivelyTraverseReconnectPassiveEffects(
	  finishedRoot$jscomp$0,
	  parentFiber,
	  committedLanes$jscomp$0,
	  committedTransitions$jscomp$0,
	  includeWorkInProgressEffects
	) {
	  includeWorkInProgressEffects =
	    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    var finishedRoot = finishedRoot$jscomp$0,
	      finishedWork = parentFiber,
	      committedLanes = committedLanes$jscomp$0,
	      committedTransitions = committedTransitions$jscomp$0,
	      flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	        commitHookEffectListMount(8, finishedWork);
	        break;
	      case 23:
	        break;
	      case 22:
	        var instance = finishedWork.stateNode;
	        null !== finishedWork.memoizedState
	          ? instance._visibility & 2
	            ? recursivelyTraverseReconnectPassiveEffects(
	                finishedRoot,
	                finishedWork,
	                committedLanes,
	                committedTransitions,
	                includeWorkInProgressEffects
	              )
	            : recursivelyTraverseAtomicPassiveEffects(
	                finishedRoot,
	                finishedWork
	              )
	          : ((instance._visibility |= 2),
	            recursivelyTraverseReconnectPassiveEffects(
	              finishedRoot,
	              finishedWork,
	              committedLanes,
	              committedTransitions,
	              includeWorkInProgressEffects
	            ));
	        includeWorkInProgressEffects &&
	          flags & 2048 &&
	          commitOffscreenPassiveMountEffects(
	            finishedWork.alternate,
	            finishedWork
	          );
	        break;
	      case 24:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects &&
	          flags & 2048 &&
	          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	        break;
	      default:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function recursivelyTraverseAtomicPassiveEffects(
	  finishedRoot$jscomp$0,
	  parentFiber
	) {
	  if (parentFiber.subtreeFlags & 10256)
	    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	      var finishedRoot = finishedRoot$jscomp$0,
	        finishedWork = parentFiber,
	        flags = finishedWork.flags;
	      switch (finishedWork.tag) {
	        case 22:
	          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
	          flags & 2048 &&
	            commitOffscreenPassiveMountEffects(
	              finishedWork.alternate,
	              finishedWork
	            );
	          break;
	        case 24:
	          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
	          flags & 2048 &&
	            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	          break;
	        default:
	          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
	      }
	      parentFiber = parentFiber.sibling;
	    }
	}
	var suspenseyCommitFlag = 8192;
	function recursivelyAccumulateSuspenseyCommit(parentFiber) {
	  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      accumulateSuspenseyCommitOnFiber(parentFiber),
	        (parentFiber = parentFiber.sibling);
	}
	function accumulateSuspenseyCommitOnFiber(fiber) {
	  switch (fiber.tag) {
	    case 26:
	      recursivelyAccumulateSuspenseyCommit(fiber);
	      fiber.flags & suspenseyCommitFlag &&
	        null !== fiber.memoizedState &&
	        suspendResource(
	          currentHoistableRoot,
	          fiber.memoizedState,
	          fiber.memoizedProps
	        );
	      break;
	    case 5:
	      recursivelyAccumulateSuspenseyCommit(fiber);
	      break;
	    case 3:
	    case 4:
	      var previousHoistableRoot = currentHoistableRoot;
	      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
	      recursivelyAccumulateSuspenseyCommit(fiber);
	      currentHoistableRoot = previousHoistableRoot;
	      break;
	    case 22:
	      null === fiber.memoizedState &&
	        ((previousHoistableRoot = fiber.alternate),
	        null !== previousHoistableRoot &&
	        null !== previousHoistableRoot.memoizedState
	          ? ((previousHoistableRoot = suspenseyCommitFlag),
	            (suspenseyCommitFlag = 16777216),
	            recursivelyAccumulateSuspenseyCommit(fiber),
	            (suspenseyCommitFlag = previousHoistableRoot))
	          : recursivelyAccumulateSuspenseyCommit(fiber));
	      break;
	    default:
	      recursivelyAccumulateSuspenseyCommit(fiber);
	  }
	}
	function detachAlternateSiblings(parentFiber) {
	  var previousFiber = parentFiber.alternate;
	  if (
	    null !== previousFiber &&
	    ((parentFiber = previousFiber.child), null !== parentFiber)
	  ) {
	    previousFiber.child = null;
	    do
	      (previousFiber = parentFiber.sibling),
	        (parentFiber.sibling = null),
	        (parentFiber = previousFiber);
	    while (null !== parentFiber);
	  }
	}
	function recursivelyTraversePassiveUnmountEffects(parentFiber) {
	  var deletions = parentFiber.deletions;
	  if (0 !== (parentFiber.flags & 16)) {
	    if (null !== deletions)
	      for (var i = 0; i < deletions.length; i++) {
	        var childToDelete = deletions[i];
	        nextEffect = childToDelete;
	        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	          childToDelete,
	          parentFiber
	        );
	      }
	    detachAlternateSiblings(parentFiber);
	  }
	  if (parentFiber.subtreeFlags & 10256)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitPassiveUnmountOnFiber(parentFiber),
	        (parentFiber = parentFiber.sibling);
	}
	function commitPassiveUnmountOnFiber(finishedWork) {
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 15:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	      finishedWork.flags & 2048 &&
	        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
	      break;
	    case 3:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	      break;
	    case 12:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	      break;
	    case 22:
	      var instance = finishedWork.stateNode;
	      null !== finishedWork.memoizedState &&
	      instance._visibility & 2 &&
	      (null === finishedWork.return || 13 !== finishedWork.return.tag)
	        ? ((instance._visibility &= -3),
	          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
	        : recursivelyTraversePassiveUnmountEffects(finishedWork);
	      break;
	    default:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	  }
	}
	function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
	  var deletions = parentFiber.deletions;
	  if (0 !== (parentFiber.flags & 16)) {
	    if (null !== deletions)
	      for (var i = 0; i < deletions.length; i++) {
	        var childToDelete = deletions[i];
	        nextEffect = childToDelete;
	        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	          childToDelete,
	          parentFiber
	        );
	      }
	    detachAlternateSiblings(parentFiber);
	  }
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    deletions = parentFiber;
	    switch (deletions.tag) {
	      case 0:
	      case 11:
	      case 15:
	        commitHookEffectListUnmount(8, deletions, deletions.return);
	        recursivelyTraverseDisconnectPassiveEffects(deletions);
	        break;
	      case 22:
	        i = deletions.stateNode;
	        i._visibility & 2 &&
	          ((i._visibility &= -3),
	          recursivelyTraverseDisconnectPassiveEffects(deletions));
	        break;
	      default:
	        recursivelyTraverseDisconnectPassiveEffects(deletions);
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	  deletedSubtreeRoot,
	  nearestMountedAncestor
	) {
	  for (; null !== nextEffect; ) {
	    var fiber = nextEffect;
	    switch (fiber.tag) {
	      case 0:
	      case 11:
	      case 15:
	        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
	        break;
	      case 23:
	      case 22:
	        if (
	          null !== fiber.memoizedState &&
	          null !== fiber.memoizedState.cachePool
	        ) {
	          var cache = fiber.memoizedState.cachePool.pool;
	          null != cache && cache.refCount++;
	        }
	        break;
	      case 24:
	        releaseCache(fiber.memoizedState.cache);
	    }
	    cache = fiber.child;
	    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
	    else
	      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
	        cache = nextEffect;
	        var sibling = cache.sibling,
	          returnFiber = cache.return;
	        detachFiberAfterEffects(cache);
	        if (cache === fiber) {
	          nextEffect = null;
	          break a;
	        }
	        if (null !== sibling) {
	          sibling.return = returnFiber;
	          nextEffect = sibling;
	          break a;
	        }
	        nextEffect = returnFiber;
	      }
	  }
	}
	var DefaultAsyncDispatcher = {
	    getCacheForType: function (resourceType) {
	      var cache = readContext(CacheContext),
	        cacheForType = cache.data.get(resourceType);
	      void 0 === cacheForType &&
	        ((cacheForType = resourceType()),
	        cache.data.set(resourceType, cacheForType));
	      return cacheForType;
	    }
	  },
	  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
	  executionContext = 0,
	  workInProgressRoot = null,
	  workInProgress = null,
	  workInProgressRootRenderLanes = 0,
	  workInProgressSuspendedReason = 0,
	  workInProgressThrownValue = null,
	  workInProgressRootDidSkipSuspendedSiblings = !1,
	  workInProgressRootIsPrerendering = !1,
	  workInProgressRootDidAttachPingListener = !1,
	  entangledRenderLanes = 0,
	  workInProgressRootExitStatus = 0,
	  workInProgressRootSkippedLanes = 0,
	  workInProgressRootInterleavedUpdatedLanes = 0,
	  workInProgressRootPingedLanes = 0,
	  workInProgressDeferredLane = 0,
	  workInProgressSuspendedRetryLanes = 0,
	  workInProgressRootConcurrentErrors = null,
	  workInProgressRootRecoverableErrors = null,
	  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
	  globalMostRecentFallbackTime = 0,
	  workInProgressRootRenderTargetTime = Infinity,
	  workInProgressTransitions = null,
	  legacyErrorBoundariesThatAlreadyFailed = null,
	  pendingEffectsStatus = 0,
	  pendingEffectsRoot = null,
	  pendingFinishedWork = null,
	  pendingEffectsLanes = 0,
	  pendingEffectsRemainingLanes = 0,
	  pendingPassiveTransitions = null,
	  pendingRecoverableErrors = null,
	  nestedUpdateCount = 0,
	  rootWithNestedUpdates = null;
	function requestUpdateLane() {
	  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
	    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
	  if (null !== ReactSharedInternals.T) {
	    var actionScopeLane = currentEntangledLane;
	    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
	  }
	  return resolveUpdatePriority();
	}
	function requestDeferredLane() {
	  0 === workInProgressDeferredLane &&
	    (workInProgressDeferredLane =
	      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
	        ? claimNextTransitionLane()
	        : 536870912);
	  var suspenseHandler = suspenseHandlerStackCursor.current;
	  null !== suspenseHandler && (suspenseHandler.flags |= 32);
	  return workInProgressDeferredLane;
	}
	function scheduleUpdateOnFiber(root, fiber, lane) {
	  if (
	    (root === workInProgressRoot &&
	      (2 === workInProgressSuspendedReason ||
	        9 === workInProgressSuspendedReason)) ||
	    null !== root.cancelPendingCommit
	  )
	    prepareFreshStack(root, 0),
	      markRootSuspended(
	        root,
	        workInProgressRootRenderLanes,
	        workInProgressDeferredLane,
	        !1
	      );
	  markRootUpdated$1(root, lane);
	  if (0 === (executionContext & 2) || root !== workInProgressRoot)
	    root === workInProgressRoot &&
	      (0 === (executionContext & 2) &&
	        (workInProgressRootInterleavedUpdatedLanes |= lane),
	      4 === workInProgressRootExitStatus &&
	        markRootSuspended(
	          root,
	          workInProgressRootRenderLanes,
	          workInProgressDeferredLane,
	          !1
	        )),
	      ensureRootIsScheduled(root);
	}
	function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
	  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage$1(327));
	  var shouldTimeSlice =
	      (!forceSync &&
	        0 === (lanes & 124) &&
	        0 === (lanes & root$jscomp$0.expiredLanes)) ||
	      checkIfRootIsPrerendering(root$jscomp$0, lanes),
	    exitStatus = shouldTimeSlice
	      ? renderRootConcurrent(root$jscomp$0, lanes)
	      : renderRootSync(root$jscomp$0, lanes, !0),
	    renderWasConcurrent = shouldTimeSlice;
	  do {
	    if (0 === exitStatus) {
	      workInProgressRootIsPrerendering &&
	        !shouldTimeSlice &&
	        markRootSuspended(root$jscomp$0, lanes, 0, !1);
	      break;
	    } else {
	      forceSync = root$jscomp$0.current.alternate;
	      if (
	        renderWasConcurrent &&
	        !isRenderConsistentWithExternalStores(forceSync)
	      ) {
	        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
	        renderWasConcurrent = !1;
	        continue;
	      }
	      if (2 === exitStatus) {
	        renderWasConcurrent = lanes;
	        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
	          var JSCompiler_inline_result = 0;
	        else
	          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
	            (JSCompiler_inline_result =
	              0 !== JSCompiler_inline_result
	                ? JSCompiler_inline_result
	                : JSCompiler_inline_result & 536870912
	                  ? 536870912
	                  : 0);
	        if (0 !== JSCompiler_inline_result) {
	          lanes = JSCompiler_inline_result;
	          a: {
	            var root = root$jscomp$0;
	            exitStatus = workInProgressRootConcurrentErrors;
	            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
	            wasRootDehydrated &&
	              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
	            JSCompiler_inline_result = renderRootSync(
	              root,
	              JSCompiler_inline_result,
	              !1
	            );
	            if (2 !== JSCompiler_inline_result) {
	              if (
	                workInProgressRootDidAttachPingListener &&
	                !wasRootDehydrated
	              ) {
	                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
	                workInProgressRootInterleavedUpdatedLanes |=
	                  renderWasConcurrent;
	                exitStatus = 4;
	                break a;
	              }
	              renderWasConcurrent = workInProgressRootRecoverableErrors;
	              workInProgressRootRecoverableErrors = exitStatus;
	              null !== renderWasConcurrent &&
	                (null === workInProgressRootRecoverableErrors
	                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
	                  : workInProgressRootRecoverableErrors.push.apply(
	                      workInProgressRootRecoverableErrors,
	                      renderWasConcurrent
	                    ));
	            }
	            exitStatus = JSCompiler_inline_result;
	          }
	          renderWasConcurrent = !1;
	          if (2 !== exitStatus) continue;
	        }
	      }
	      if (1 === exitStatus) {
	        prepareFreshStack(root$jscomp$0, 0);
	        markRootSuspended(root$jscomp$0, lanes, 0, !0);
	        break;
	      }
	      a: {
	        shouldTimeSlice = root$jscomp$0;
	        renderWasConcurrent = exitStatus;
	        switch (renderWasConcurrent) {
	          case 0:
	          case 1:
	            throw Error(formatProdErrorMessage$1(345));
	          case 4:
	            if ((lanes & 4194048) !== lanes) break;
	          case 6:
	            markRootSuspended(
	              shouldTimeSlice,
	              lanes,
	              workInProgressDeferredLane,
	              !workInProgressRootDidSkipSuspendedSiblings
	            );
	            break a;
	          case 2:
	            workInProgressRootRecoverableErrors = null;
	            break;
	          case 3:
	          case 5:
	            break;
	          default:
	            throw Error(formatProdErrorMessage$1(329));
	        }
	        if (
	          (lanes & 62914560) === lanes &&
	          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
	          10 < exitStatus)
	        ) {
	          markRootSuspended(
	            shouldTimeSlice,
	            lanes,
	            workInProgressDeferredLane,
	            !workInProgressRootDidSkipSuspendedSiblings
	          );
	          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
	          shouldTimeSlice.timeoutHandle = scheduleTimeout(
	            commitRootWhenReady.bind(
	              null,
	              shouldTimeSlice,
	              forceSync,
	              workInProgressRootRecoverableErrors,
	              workInProgressTransitions,
	              workInProgressRootDidIncludeRecursiveRenderUpdate,
	              lanes,
	              workInProgressDeferredLane,
	              workInProgressRootInterleavedUpdatedLanes,
	              workInProgressSuspendedRetryLanes,
	              workInProgressRootDidSkipSuspendedSiblings,
	              renderWasConcurrent,
	              2,
	              -0,
	              0
	            ),
	            exitStatus
	          );
	          break a;
	        }
	        commitRootWhenReady(
	          shouldTimeSlice,
	          forceSync,
	          workInProgressRootRecoverableErrors,
	          workInProgressTransitions,
	          workInProgressRootDidIncludeRecursiveRenderUpdate,
	          lanes,
	          workInProgressDeferredLane,
	          workInProgressRootInterleavedUpdatedLanes,
	          workInProgressSuspendedRetryLanes,
	          workInProgressRootDidSkipSuspendedSiblings,
	          renderWasConcurrent,
	          0,
	          -0,
	          0
	        );
	      }
	    }
	    break;
	  } while (1);
	  ensureRootIsScheduled(root$jscomp$0);
	}
	function commitRootWhenReady(
	  root,
	  finishedWork,
	  recoverableErrors,
	  transitions,
	  didIncludeRenderPhaseUpdate,
	  lanes,
	  spawnedLane,
	  updatedLanes,
	  suspendedRetryLanes,
	  didSkipSuspendedSiblings,
	  exitStatus,
	  suspendedCommitReason,
	  completedRenderStartTime,
	  completedRenderEndTime
	) {
	  root.timeoutHandle = -1;
	  suspendedCommitReason = finishedWork.subtreeFlags;
	  if (
	    suspendedCommitReason & 8192 ||
	    16785408 === (suspendedCommitReason & 16785408)
	  )
	    if (
	      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop$4 }),
	      accumulateSuspenseyCommitOnFiber(finishedWork),
	      (suspendedCommitReason = waitForCommitToBeReady()),
	      null !== suspendedCommitReason)
	    ) {
	      root.cancelPendingCommit = suspendedCommitReason(
	        commitRoot.bind(
	          null,
	          root,
	          finishedWork,
	          lanes,
	          recoverableErrors,
	          transitions,
	          didIncludeRenderPhaseUpdate,
	          spawnedLane,
	          updatedLanes,
	          suspendedRetryLanes,
	          exitStatus,
	          1,
	          completedRenderStartTime,
	          completedRenderEndTime
	        )
	      );
	      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
	      return;
	    }
	  commitRoot(
	    root,
	    finishedWork,
	    lanes,
	    recoverableErrors,
	    transitions,
	    didIncludeRenderPhaseUpdate,
	    spawnedLane,
	    updatedLanes,
	    suspendedRetryLanes
	  );
	}
	function isRenderConsistentWithExternalStores(finishedWork) {
	  for (var node = finishedWork; ; ) {
	    var tag = node.tag;
	    if (
	      (0 === tag || 11 === tag || 15 === tag) &&
	      node.flags & 16384 &&
	      ((tag = node.updateQueue),
	      null !== tag && ((tag = tag.stores), null !== tag))
	    )
	      for (var i = 0; i < tag.length; i++) {
	        var check = tag[i],
	          getSnapshot = check.getSnapshot;
	        check = check.value;
	        try {
	          if (!objectIs(getSnapshot(), check)) return !1;
	        } catch (error) {
	          return !1;
	        }
	      }
	    tag = node.child;
	    if (node.subtreeFlags & 16384 && null !== tag)
	      (tag.return = node), (node = tag);
	    else {
	      if (node === finishedWork) break;
	      for (; null === node.sibling; ) {
	        if (null === node.return || node.return === finishedWork) return !0;
	        node = node.return;
	      }
	      node.sibling.return = node.return;
	      node = node.sibling;
	    }
	  }
	  return !0;
	}
	function markRootSuspended(
	  root,
	  suspendedLanes,
	  spawnedLane,
	  didAttemptEntireTree
	) {
	  suspendedLanes &= ~workInProgressRootPingedLanes;
	  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
	  root.suspendedLanes |= suspendedLanes;
	  root.pingedLanes &= ~suspendedLanes;
	  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
	  didAttemptEntireTree = root.expirationTimes;
	  for (var lanes = suspendedLanes; 0 < lanes; ) {
	    var index$4 = 31 - clz32(lanes),
	      lane = 1 << index$4;
	    didAttemptEntireTree[index$4] = -1;
	    lanes &= ~lane;
	  }
	  0 !== spawnedLane &&
	    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
	}
	function flushSyncWork$1() {
	  return 0 === (executionContext & 6)
	    ? (flushSyncWorkAcrossRoots_impl(0), !1)
	    : !0;
	}
	function resetWorkInProgressStack() {
	  if (null !== workInProgress) {
	    if (0 === workInProgressSuspendedReason)
	      var interruptedWork = workInProgress.return;
	    else
	      (interruptedWork = workInProgress),
	        (lastContextDependency = currentlyRenderingFiber$1 = null),
	        resetHooksOnUnwind(interruptedWork),
	        (thenableState = null),
	        (thenableIndexCounter = 0),
	        (interruptedWork = workInProgress);
	    for (; null !== interruptedWork; )
	      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
	        (interruptedWork = interruptedWork.return);
	    workInProgress = null;
	  }
	}
	function prepareFreshStack(root, lanes) {
	  var timeoutHandle = root.timeoutHandle;
	  -1 !== timeoutHandle &&
	    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
	  timeoutHandle = root.cancelPendingCommit;
	  null !== timeoutHandle &&
	    ((root.cancelPendingCommit = null), timeoutHandle());
	  resetWorkInProgressStack();
	  workInProgressRoot = root;
	  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
	  workInProgressRootRenderLanes = lanes;
	  workInProgressSuspendedReason = 0;
	  workInProgressThrownValue = null;
	  workInProgressRootDidSkipSuspendedSiblings = !1;
	  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
	  workInProgressRootDidAttachPingListener = !1;
	  workInProgressSuspendedRetryLanes =
	    workInProgressDeferredLane =
	    workInProgressRootPingedLanes =
	    workInProgressRootInterleavedUpdatedLanes =
	    workInProgressRootSkippedLanes =
	    workInProgressRootExitStatus =
	      0;
	  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
	    null;
	  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
	  0 !== (lanes & 8) && (lanes |= lanes & 32);
	  var allEntangledLanes = root.entangledLanes;
	  if (0 !== allEntangledLanes)
	    for (
	      root = root.entanglements, allEntangledLanes &= lanes;
	      0 < allEntangledLanes;

	    ) {
	      var index$2 = 31 - clz32(allEntangledLanes),
	        lane = 1 << index$2;
	      lanes |= root[index$2];
	      allEntangledLanes &= ~lane;
	    }
	  entangledRenderLanes = lanes;
	  finishQueueingConcurrentUpdates();
	  return timeoutHandle;
	}
	function handleThrow(root, thrownValue) {
	  currentlyRenderingFiber = null;
	  ReactSharedInternals.H = ContextOnlyDispatcher;
	  thrownValue === SuspenseException || thrownValue === SuspenseActionException
	    ? ((thrownValue = getSuspendedThenable()),
	      (workInProgressSuspendedReason = 3))
	    : thrownValue === SuspenseyCommitException
	      ? ((thrownValue = getSuspendedThenable()),
	        (workInProgressSuspendedReason = 4))
	      : (workInProgressSuspendedReason =
	          thrownValue === SelectiveHydrationException
	            ? 8
	            : null !== thrownValue &&
	                "object" === typeof thrownValue &&
	                "function" === typeof thrownValue.then
	              ? 6
	              : 1);
	  workInProgressThrownValue = thrownValue;
	  null === workInProgress &&
	    ((workInProgressRootExitStatus = 1),
	    logUncaughtError(
	      root,
	      createCapturedValueAtFiber(thrownValue, root.current)
	    ));
	}
	function pushDispatcher() {
	  var prevDispatcher = ReactSharedInternals.H;
	  ReactSharedInternals.H = ContextOnlyDispatcher;
	  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
	}
	function pushAsyncDispatcher() {
	  var prevAsyncDispatcher = ReactSharedInternals.A;
	  ReactSharedInternals.A = DefaultAsyncDispatcher;
	  return prevAsyncDispatcher;
	}
	function renderDidSuspendDelayIfPossible() {
	  workInProgressRootExitStatus = 4;
	  workInProgressRootDidSkipSuspendedSiblings ||
	    ((workInProgressRootRenderLanes & 4194048) !==
	      workInProgressRootRenderLanes &&
	      null !== suspenseHandlerStackCursor.current) ||
	    (workInProgressRootIsPrerendering = !0);
	  (0 === (workInProgressRootSkippedLanes & 134217727) &&
	    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
	    null === workInProgressRoot ||
	    markRootSuspended(
	      workInProgressRoot,
	      workInProgressRootRenderLanes,
	      workInProgressDeferredLane,
	      !1
	    );
	}
	function renderRootSync(root, lanes, shouldYieldForPrerendering) {
	  var prevExecutionContext = executionContext;
	  executionContext |= 2;
	  var prevDispatcher = pushDispatcher(),
	    prevAsyncDispatcher = pushAsyncDispatcher();
	  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
	    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
	  lanes = !1;
	  var exitStatus = workInProgressRootExitStatus;
	  a: do
	    try {
	      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
	        var unitOfWork = workInProgress,
	          thrownValue = workInProgressThrownValue;
	        switch (workInProgressSuspendedReason) {
	          case 8:
	            resetWorkInProgressStack();
	            exitStatus = 6;
	            break a;
	          case 3:
	          case 2:
	          case 9:
	          case 6:
	            null === suspenseHandlerStackCursor.current && (lanes = !0);
	            var reason = workInProgressSuspendedReason;
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
	            if (
	              shouldYieldForPrerendering &&
	              workInProgressRootIsPrerendering
	            ) {
	              exitStatus = 0;
	              break a;
	            }
	            break;
	          default:
	            (reason = workInProgressSuspendedReason),
	              (workInProgressSuspendedReason = 0),
	              (workInProgressThrownValue = null),
	              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
	        }
	      }
	      workLoopSync();
	      exitStatus = workInProgressRootExitStatus;
	      break;
	    } catch (thrownValue$167) {
	      handleThrow(root, thrownValue$167);
	    }
	  while (1);
	  lanes && root.shellSuspendCounter++;
	  lastContextDependency = currentlyRenderingFiber$1 = null;
	  executionContext = prevExecutionContext;
	  ReactSharedInternals.H = prevDispatcher;
	  ReactSharedInternals.A = prevAsyncDispatcher;
	  null === workInProgress &&
	    ((workInProgressRoot = null),
	    (workInProgressRootRenderLanes = 0),
	    finishQueueingConcurrentUpdates());
	  return exitStatus;
	}
	function workLoopSync() {
	  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
	}
	function renderRootConcurrent(root, lanes) {
	  var prevExecutionContext = executionContext;
	  executionContext |= 2;
	  var prevDispatcher = pushDispatcher(),
	    prevAsyncDispatcher = pushAsyncDispatcher();
	  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
	    ? ((workInProgressTransitions = null),
	      (workInProgressRootRenderTargetTime = now() + 500),
	      prepareFreshStack(root, lanes))
	    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
	        root,
	        lanes
	      ));
	  a: do
	    try {
	      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
	        lanes = workInProgress;
	        var thrownValue = workInProgressThrownValue;
	        b: switch (workInProgressSuspendedReason) {
	          case 1:
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
	            break;
	          case 2:
	          case 9:
	            if (isThenableResolved(thrownValue)) {
	              workInProgressSuspendedReason = 0;
	              workInProgressThrownValue = null;
	              replaySuspendedUnitOfWork(lanes);
	              break;
	            }
	            lanes = function () {
	              (2 !== workInProgressSuspendedReason &&
	                9 !== workInProgressSuspendedReason) ||
	                workInProgressRoot !== root ||
	                (workInProgressSuspendedReason = 7);
	              ensureRootIsScheduled(root);
	            };
	            thrownValue.then(lanes, lanes);
	            break a;
	          case 3:
	            workInProgressSuspendedReason = 7;
	            break a;
	          case 4:
	            workInProgressSuspendedReason = 5;
	            break a;
	          case 7:
	            isThenableResolved(thrownValue)
	              ? ((workInProgressSuspendedReason = 0),
	                (workInProgressThrownValue = null),
	                replaySuspendedUnitOfWork(lanes))
	              : ((workInProgressSuspendedReason = 0),
	                (workInProgressThrownValue = null),
	                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
	            break;
	          case 5:
	            var resource = null;
	            switch (workInProgress.tag) {
	              case 26:
	                resource = workInProgress.memoizedState;
	              case 5:
	              case 27:
	                var hostFiber = workInProgress;
	                if (resource ? preloadResource(resource) : 1) {
	                  workInProgressSuspendedReason = 0;
	                  workInProgressThrownValue = null;
	                  var sibling = hostFiber.sibling;
	                  if (null !== sibling) workInProgress = sibling;
	                  else {
	                    var returnFiber = hostFiber.return;
	                    null !== returnFiber
	                      ? ((workInProgress = returnFiber),
	                        completeUnitOfWork(returnFiber))
	                      : (workInProgress = null);
	                  }
	                  break b;
	                }
	            }
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
	            break;
	          case 6:
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
	            break;
	          case 8:
	            resetWorkInProgressStack();
	            workInProgressRootExitStatus = 6;
	            break a;
	          default:
	            throw Error(formatProdErrorMessage$1(462));
	        }
	      }
	      workLoopConcurrentByScheduler();
	      break;
	    } catch (thrownValue$169) {
	      handleThrow(root, thrownValue$169);
	    }
	  while (1);
	  lastContextDependency = currentlyRenderingFiber$1 = null;
	  ReactSharedInternals.H = prevDispatcher;
	  ReactSharedInternals.A = prevAsyncDispatcher;
	  executionContext = prevExecutionContext;
	  if (null !== workInProgress) return 0;
	  workInProgressRoot = null;
	  workInProgressRootRenderLanes = 0;
	  finishQueueingConcurrentUpdates();
	  return workInProgressRootExitStatus;
	}
	function workLoopConcurrentByScheduler() {
	  for (; null !== workInProgress && !shouldYield(); )
	    performUnitOfWork(workInProgress);
	}
	function performUnitOfWork(unitOfWork) {
	  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
	  unitOfWork.memoizedProps = unitOfWork.pendingProps;
	  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
	}
	function replaySuspendedUnitOfWork(unitOfWork) {
	  var next = unitOfWork;
	  var current = next.alternate;
	  switch (next.tag) {
	    case 15:
	    case 0:
	      next = replayFunctionComponent(
	        current,
	        next,
	        next.pendingProps,
	        next.type,
	        void 0,
	        workInProgressRootRenderLanes
	      );
	      break;
	    case 11:
	      next = replayFunctionComponent(
	        current,
	        next,
	        next.pendingProps,
	        next.type.render,
	        next.ref,
	        workInProgressRootRenderLanes
	      );
	      break;
	    case 5:
	      resetHooksOnUnwind(next);
	    default:
	      unwindInterruptedWork(current, next),
	        (next = workInProgress =
	          resetWorkInProgress(next, entangledRenderLanes)),
	        (next = beginWork(current, next, entangledRenderLanes));
	  }
	  unitOfWork.memoizedProps = unitOfWork.pendingProps;
	  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
	}
	function throwAndUnwindWorkLoop(
	  root,
	  unitOfWork,
	  thrownValue,
	  suspendedReason
	) {
	  lastContextDependency = currentlyRenderingFiber$1 = null;
	  resetHooksOnUnwind(unitOfWork);
	  thenableState = null;
	  thenableIndexCounter = 0;
	  var returnFiber = unitOfWork.return;
	  try {
	    if (
	      throwException(
	        root,
	        returnFiber,
	        unitOfWork,
	        thrownValue,
	        workInProgressRootRenderLanes
	      )
	    ) {
	      workInProgressRootExitStatus = 1;
	      logUncaughtError(
	        root,
	        createCapturedValueAtFiber(thrownValue, root.current)
	      );
	      workInProgress = null;
	      return;
	    }
	  } catch (error) {
	    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
	    workInProgressRootExitStatus = 1;
	    logUncaughtError(
	      root,
	      createCapturedValueAtFiber(thrownValue, root.current)
	    );
	    workInProgress = null;
	    return;
	  }
	  if (unitOfWork.flags & 32768) {
	    if (isHydrating || 1 === suspendedReason) root = !0;
	    else if (
	      workInProgressRootIsPrerendering ||
	      0 !== (workInProgressRootRenderLanes & 536870912)
	    )
	      root = !1;
	    else if (
	      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
	      2 === suspendedReason ||
	        9 === suspendedReason ||
	        3 === suspendedReason ||
	        6 === suspendedReason)
	    )
	      (suspendedReason = suspenseHandlerStackCursor.current),
	        null !== suspendedReason &&
	          13 === suspendedReason.tag &&
	          (suspendedReason.flags |= 16384);
	    unwindUnitOfWork(unitOfWork, root);
	  } else completeUnitOfWork(unitOfWork);
	}
	function completeUnitOfWork(unitOfWork) {
	  var completedWork = unitOfWork;
	  do {
	    if (0 !== (completedWork.flags & 32768)) {
	      unwindUnitOfWork(
	        completedWork,
	        workInProgressRootDidSkipSuspendedSiblings
	      );
	      return;
	    }
	    unitOfWork = completedWork.return;
	    var next = completeWork(
	      completedWork.alternate,
	      completedWork,
	      entangledRenderLanes
	    );
	    if (null !== next) {
	      workInProgress = next;
	      return;
	    }
	    completedWork = completedWork.sibling;
	    if (null !== completedWork) {
	      workInProgress = completedWork;
	      return;
	    }
	    workInProgress = completedWork = unitOfWork;
	  } while (null !== completedWork);
	  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
	}
	function unwindUnitOfWork(unitOfWork, skipSiblings) {
	  do {
	    var next = unwindWork(unitOfWork.alternate, unitOfWork);
	    if (null !== next) {
	      next.flags &= 32767;
	      workInProgress = next;
	      return;
	    }
	    next = unitOfWork.return;
	    null !== next &&
	      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
	    if (
	      !skipSiblings &&
	      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
	    ) {
	      workInProgress = unitOfWork;
	      return;
	    }
	    workInProgress = unitOfWork = next;
	  } while (null !== unitOfWork);
	  workInProgressRootExitStatus = 6;
	  workInProgress = null;
	}
	function commitRoot(
	  root,
	  finishedWork,
	  lanes,
	  recoverableErrors,
	  transitions,
	  didIncludeRenderPhaseUpdate,
	  spawnedLane,
	  updatedLanes,
	  suspendedRetryLanes
	) {
	  root.cancelPendingCommit = null;
	  do flushPendingEffects();
	  while (0 !== pendingEffectsStatus);
	  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage$1(327));
	  if (null !== finishedWork) {
	    if (finishedWork === root.current) throw Error(formatProdErrorMessage$1(177));
	    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
	    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
	    markRootFinished(
	      root,
	      lanes,
	      didIncludeRenderPhaseUpdate,
	      spawnedLane,
	      updatedLanes,
	      suspendedRetryLanes
	    );
	    root === workInProgressRoot &&
	      ((workInProgress = workInProgressRoot = null),
	      (workInProgressRootRenderLanes = 0));
	    pendingFinishedWork = finishedWork;
	    pendingEffectsRoot = root;
	    pendingEffectsLanes = lanes;
	    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
	    pendingPassiveTransitions = transitions;
	    pendingRecoverableErrors = recoverableErrors;
	    0 !== (finishedWork.subtreeFlags & 10256) ||
	    0 !== (finishedWork.flags & 10256)
	      ? ((root.callbackNode = null),
	        (root.callbackPriority = 0),
	        scheduleCallback$1(NormalPriority$1, function () {
	          flushPassiveEffects();
	          return null;
	        }))
	      : ((root.callbackNode = null), (root.callbackPriority = 0));
	    recoverableErrors = 0 !== (finishedWork.flags & 13878);
	    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
	      recoverableErrors = ReactSharedInternals.T;
	      ReactSharedInternals.T = null;
	      transitions = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      spawnedLane = executionContext;
	      executionContext |= 4;
	      try {
	        commitBeforeMutationEffects(root, finishedWork);
	      } finally {
	        (executionContext = spawnedLane),
	          (ReactDOMSharedInternals.p = transitions),
	          (ReactSharedInternals.T = recoverableErrors);
	      }
	    }
	    pendingEffectsStatus = 1;
	    flushMutationEffects();
	    flushLayoutEffects();
	    flushSpawnedWork();
	  }
	}
	function flushMutationEffects() {
	  if (1 === pendingEffectsStatus) {
	    pendingEffectsStatus = 0;
	    var root = pendingEffectsRoot,
	      finishedWork = pendingFinishedWork,
	      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
	    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
	      rootMutationHasEffect = ReactSharedInternals.T;
	      ReactSharedInternals.T = null;
	      var previousPriority = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      var prevExecutionContext = executionContext;
	      executionContext |= 4;
	      try {
	        commitMutationEffectsOnFiber(finishedWork, root);
	        var priorSelectionInformation = selectionInformation,
	          curFocusedElem = getActiveElementDeep(root.containerInfo),
	          priorFocusedElem = priorSelectionInformation.focusedElem,
	          priorSelectionRange = priorSelectionInformation.selectionRange;
	        if (
	          curFocusedElem !== priorFocusedElem &&
	          priorFocusedElem &&
	          priorFocusedElem.ownerDocument &&
	          containsNode(
	            priorFocusedElem.ownerDocument.documentElement,
	            priorFocusedElem
	          )
	        ) {
	          if (
	            null !== priorSelectionRange &&
	            hasSelectionCapabilities(priorFocusedElem)
	          ) {
	            var start = priorSelectionRange.start,
	              end = priorSelectionRange.end;
	            void 0 === end && (end = start);
	            if ("selectionStart" in priorFocusedElem)
	              (priorFocusedElem.selectionStart = start),
	                (priorFocusedElem.selectionEnd = Math.min(
	                  end,
	                  priorFocusedElem.value.length
	                ));
	            else {
	              var doc = priorFocusedElem.ownerDocument || document,
	                win = (doc && doc.defaultView) || window;
	              if (win.getSelection) {
	                var selection = win.getSelection(),
	                  length = priorFocusedElem.textContent.length,
	                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
	                  end$jscomp$0 =
	                    void 0 === priorSelectionRange.end
	                      ? start$jscomp$0
	                      : Math.min(priorSelectionRange.end, length);
	                !selection.extend &&
	                  start$jscomp$0 > end$jscomp$0 &&
	                  ((curFocusedElem = end$jscomp$0),
	                  (end$jscomp$0 = start$jscomp$0),
	                  (start$jscomp$0 = curFocusedElem));
	                var startMarker = getNodeForCharacterOffset(
	                    priorFocusedElem,
	                    start$jscomp$0
	                  ),
	                  endMarker = getNodeForCharacterOffset(
	                    priorFocusedElem,
	                    end$jscomp$0
	                  );
	                if (
	                  startMarker &&
	                  endMarker &&
	                  (1 !== selection.rangeCount ||
	                    selection.anchorNode !== startMarker.node ||
	                    selection.anchorOffset !== startMarker.offset ||
	                    selection.focusNode !== endMarker.node ||
	                    selection.focusOffset !== endMarker.offset)
	                ) {
	                  var range = doc.createRange();
	                  range.setStart(startMarker.node, startMarker.offset);
	                  selection.removeAllRanges();
	                  start$jscomp$0 > end$jscomp$0
	                    ? (selection.addRange(range),
	                      selection.extend(endMarker.node, endMarker.offset))
	                    : (range.setEnd(endMarker.node, endMarker.offset),
	                      selection.addRange(range));
	                }
	              }
	            }
	          }
	          doc = [];
	          for (
	            selection = priorFocusedElem;
	            (selection = selection.parentNode);

	          )
	            1 === selection.nodeType &&
	              doc.push({
	                element: selection,
	                left: selection.scrollLeft,
	                top: selection.scrollTop
	              });
	          "function" === typeof priorFocusedElem.focus &&
	            priorFocusedElem.focus();
	          for (
	            priorFocusedElem = 0;
	            priorFocusedElem < doc.length;
	            priorFocusedElem++
	          ) {
	            var info = doc[priorFocusedElem];
	            info.element.scrollLeft = info.left;
	            info.element.scrollTop = info.top;
	          }
	        }
	        _enabled = !!eventsEnabled;
	        selectionInformation = eventsEnabled = null;
	      } finally {
	        (executionContext = prevExecutionContext),
	          (ReactDOMSharedInternals.p = previousPriority),
	          (ReactSharedInternals.T = rootMutationHasEffect);
	      }
	    }
	    root.current = finishedWork;
	    pendingEffectsStatus = 2;
	  }
	}
	function flushLayoutEffects() {
	  if (2 === pendingEffectsStatus) {
	    pendingEffectsStatus = 0;
	    var root = pendingEffectsRoot,
	      finishedWork = pendingFinishedWork,
	      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
	    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
	      rootHasLayoutEffect = ReactSharedInternals.T;
	      ReactSharedInternals.T = null;
	      var previousPriority = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      var prevExecutionContext = executionContext;
	      executionContext |= 4;
	      try {
	        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
	      } finally {
	        (executionContext = prevExecutionContext),
	          (ReactDOMSharedInternals.p = previousPriority),
	          (ReactSharedInternals.T = rootHasLayoutEffect);
	      }
	    }
	    pendingEffectsStatus = 3;
	  }
	}
	function flushSpawnedWork() {
	  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
	    pendingEffectsStatus = 0;
	    requestPaint();
	    var root = pendingEffectsRoot,
	      finishedWork = pendingFinishedWork,
	      lanes = pendingEffectsLanes,
	      recoverableErrors = pendingRecoverableErrors;
	    0 !== (finishedWork.subtreeFlags & 10256) ||
	    0 !== (finishedWork.flags & 10256)
	      ? (pendingEffectsStatus = 5)
	      : ((pendingEffectsStatus = 0),
	        (pendingFinishedWork = pendingEffectsRoot = null),
	        releaseRootPooledCache(root, root.pendingLanes));
	    var remainingLanes = root.pendingLanes;
	    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
	    lanesToEventPriority(lanes);
	    finishedWork = finishedWork.stateNode;
	    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
	      try {
	        injectedHook.onCommitFiberRoot(
	          rendererID,
	          finishedWork,
	          void 0,
	          128 === (finishedWork.current.flags & 128)
	        );
	      } catch (err) {}
	    if (null !== recoverableErrors) {
	      finishedWork = ReactSharedInternals.T;
	      remainingLanes = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      ReactSharedInternals.T = null;
	      try {
	        for (
	          var onRecoverableError = root.onRecoverableError, i = 0;
	          i < recoverableErrors.length;
	          i++
	        ) {
	          var recoverableError = recoverableErrors[i];
	          onRecoverableError(recoverableError.value, {
	            componentStack: recoverableError.stack
	          });
	        }
	      } finally {
	        (ReactSharedInternals.T = finishedWork),
	          (ReactDOMSharedInternals.p = remainingLanes);
	      }
	    }
	    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
	    ensureRootIsScheduled(root);
	    remainingLanes = root.pendingLanes;
	    0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42)
	      ? root === rootWithNestedUpdates
	        ? nestedUpdateCount++
	        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
	      : (nestedUpdateCount = 0);
	    flushSyncWorkAcrossRoots_impl(0);
	  }
	}
	function releaseRootPooledCache(root, remainingLanes) {
	  0 === (root.pooledCacheLanes &= remainingLanes) &&
	    ((remainingLanes = root.pooledCache),
	    null != remainingLanes &&
	      ((root.pooledCache = null), releaseCache(remainingLanes)));
	}
	function flushPendingEffects(wasDelayedCommit) {
	  flushMutationEffects();
	  flushLayoutEffects();
	  flushSpawnedWork();
	  return flushPassiveEffects();
	}
	function flushPassiveEffects() {
	  if (5 !== pendingEffectsStatus) return !1;
	  var root = pendingEffectsRoot,
	    remainingLanes = pendingEffectsRemainingLanes;
	  pendingEffectsRemainingLanes = 0;
	  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
	    prevTransition = ReactSharedInternals.T,
	    previousPriority = ReactDOMSharedInternals.p;
	  try {
	    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
	    ReactSharedInternals.T = null;
	    renderPriority = pendingPassiveTransitions;
	    pendingPassiveTransitions = null;
	    var root$jscomp$0 = pendingEffectsRoot,
	      lanes = pendingEffectsLanes;
	    pendingEffectsStatus = 0;
	    pendingFinishedWork = pendingEffectsRoot = null;
	    pendingEffectsLanes = 0;
	    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage$1(331));
	    var prevExecutionContext = executionContext;
	    executionContext |= 4;
	    commitPassiveUnmountOnFiber(root$jscomp$0.current);
	    commitPassiveMountOnFiber(
	      root$jscomp$0,
	      root$jscomp$0.current,
	      lanes,
	      renderPriority
	    );
	    executionContext = prevExecutionContext;
	    flushSyncWorkAcrossRoots_impl(0);
	    if (
	      injectedHook &&
	      "function" === typeof injectedHook.onPostCommitFiberRoot
	    )
	      try {
	        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
	      } catch (err) {}
	    return !0;
	  } finally {
	    (ReactDOMSharedInternals.p = previousPriority),
	      (ReactSharedInternals.T = prevTransition),
	      releaseRootPooledCache(root, remainingLanes);
	  }
	}
	function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
	  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
	  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
	  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
	  null !== rootFiber &&
	    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
	}
	function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
	  if (3 === sourceFiber.tag)
	    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
	  else
	    for (; null !== nearestMountedAncestor; ) {
	      if (3 === nearestMountedAncestor.tag) {
	        captureCommitPhaseErrorOnRoot(
	          nearestMountedAncestor,
	          sourceFiber,
	          error
	        );
	        break;
	      } else if (1 === nearestMountedAncestor.tag) {
	        var instance = nearestMountedAncestor.stateNode;
	        if (
	          "function" ===
	            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
	          ("function" === typeof instance.componentDidCatch &&
	            (null === legacyErrorBoundariesThatAlreadyFailed ||
	              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
	        ) {
	          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
	          error = createClassErrorUpdate(2);
	          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
	          null !== instance &&
	            (initializeClassErrorUpdate(
	              error,
	              instance,
	              nearestMountedAncestor,
	              sourceFiber
	            ),
	            markRootUpdated$1(instance, 2),
	            ensureRootIsScheduled(instance));
	          break;
	        }
	      }
	      nearestMountedAncestor = nearestMountedAncestor.return;
	    }
	}
	function attachPingListener(root, wakeable, lanes) {
	  var pingCache = root.pingCache;
	  if (null === pingCache) {
	    pingCache = root.pingCache = new PossiblyWeakMap();
	    var threadIDs = new Set();
	    pingCache.set(wakeable, threadIDs);
	  } else
	    (threadIDs = pingCache.get(wakeable)),
	      void 0 === threadIDs &&
	        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
	  threadIDs.has(lanes) ||
	    ((workInProgressRootDidAttachPingListener = !0),
	    threadIDs.add(lanes),
	    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
	    wakeable.then(root, root));
	}
	function pingSuspendedRoot(root, wakeable, pingedLanes) {
	  var pingCache = root.pingCache;
	  null !== pingCache && pingCache.delete(wakeable);
	  root.pingedLanes |= root.suspendedLanes & pingedLanes;
	  root.warmLanes &= ~pingedLanes;
	  workInProgressRoot === root &&
	    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
	    (4 === workInProgressRootExitStatus ||
	    (3 === workInProgressRootExitStatus &&
	      (workInProgressRootRenderLanes & 62914560) ===
	        workInProgressRootRenderLanes &&
	      300 > now() - globalMostRecentFallbackTime)
	      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
	      : (workInProgressRootPingedLanes |= pingedLanes),
	    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
	      (workInProgressSuspendedRetryLanes = 0));
	  ensureRootIsScheduled(root);
	}
	function retryTimedOutBoundary(boundaryFiber, retryLane) {
	  0 === retryLane && (retryLane = claimNextRetryLane());
	  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
	  null !== boundaryFiber &&
	    (markRootUpdated$1(boundaryFiber, retryLane),
	    ensureRootIsScheduled(boundaryFiber));
	}
	function retryDehydratedSuspenseBoundary(boundaryFiber) {
	  var suspenseState = boundaryFiber.memoizedState,
	    retryLane = 0;
	  null !== suspenseState && (retryLane = suspenseState.retryLane);
	  retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function resolveRetryWakeable(boundaryFiber, wakeable) {
	  var retryLane = 0;
	  switch (boundaryFiber.tag) {
	    case 13:
	      var retryCache = boundaryFiber.stateNode;
	      var suspenseState = boundaryFiber.memoizedState;
	      null !== suspenseState && (retryLane = suspenseState.retryLane);
	      break;
	    case 19:
	      retryCache = boundaryFiber.stateNode;
	      break;
	    case 22:
	      retryCache = boundaryFiber.stateNode._retryCache;
	      break;
	    default:
	      throw Error(formatProdErrorMessage$1(314));
	  }
	  null !== retryCache && retryCache.delete(wakeable);
	  retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function scheduleCallback$1(priorityLevel, callback) {
	  return scheduleCallback$3(priorityLevel, callback);
	}
	var firstScheduledRoot = null,
	  lastScheduledRoot = null,
	  didScheduleMicrotask = !1,
	  mightHavePendingSyncWork = !1,
	  isFlushingWork = !1,
	  currentEventTransitionLane = 0;
	function ensureRootIsScheduled(root) {
	  root !== lastScheduledRoot &&
	    null === root.next &&
	    (null === lastScheduledRoot
	      ? (firstScheduledRoot = lastScheduledRoot = root)
	      : (lastScheduledRoot = lastScheduledRoot.next = root));
	  mightHavePendingSyncWork = !0;
	  didScheduleMicrotask ||
	    ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
	}
	function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
	  if (!isFlushingWork && mightHavePendingSyncWork) {
	    isFlushingWork = !0;
	    do {
	      var didPerformSomeWork = !1;
	      for (var root$174 = firstScheduledRoot; null !== root$174; ) {
	        if (0 !== syncTransitionLanes) {
	            var pendingLanes = root$174.pendingLanes;
	            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
	            else {
	              var suspendedLanes = root$174.suspendedLanes,
	                pingedLanes = root$174.pingedLanes;
	              JSCompiler_inline_result =
	                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
	              JSCompiler_inline_result &=
	                pendingLanes & ~(suspendedLanes & ~pingedLanes);
	              JSCompiler_inline_result =
	                JSCompiler_inline_result & 201326741
	                  ? (JSCompiler_inline_result & 201326741) | 1
	                  : JSCompiler_inline_result
	                    ? JSCompiler_inline_result | 2
	                    : 0;
	            }
	            0 !== JSCompiler_inline_result &&
	              ((didPerformSomeWork = !0),
	              performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
	          } else
	            (JSCompiler_inline_result = workInProgressRootRenderLanes),
	              (JSCompiler_inline_result = getNextLanes(
	                root$174,
	                root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
	                null !== root$174.cancelPendingCommit ||
	                  -1 !== root$174.timeoutHandle
	              )),
	              0 === (JSCompiler_inline_result & 3) ||
	                checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) ||
	                ((didPerformSomeWork = !0),
	                performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
	        root$174 = root$174.next;
	      }
	    } while (didPerformSomeWork);
	    isFlushingWork = !1;
	  }
	}
	function processRootScheduleInImmediateTask() {
	  processRootScheduleInMicrotask();
	}
	function processRootScheduleInMicrotask() {
	  mightHavePendingSyncWork = didScheduleMicrotask = !1;
	  var syncTransitionLanes = 0;
	  0 !== currentEventTransitionLane &&
	    (shouldAttemptEagerTransition() &&
	      (syncTransitionLanes = currentEventTransitionLane),
	    (currentEventTransitionLane = 0));
	  for (
	    var currentTime = now(), prev = null, root = firstScheduledRoot;
	    null !== root;

	  ) {
	    var next = root.next,
	      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
	    if (0 === nextLanes)
	      (root.next = null),
	        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
	        null === next && (lastScheduledRoot = prev);
	    else if (
	      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
	    )
	      mightHavePendingSyncWork = !0;
	    root = next;
	  }
	  flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
	}
	function scheduleTaskForRootDuringMicrotask(root, currentTime) {
	  for (
	    var suspendedLanes = root.suspendedLanes,
	      pingedLanes = root.pingedLanes,
	      expirationTimes = root.expirationTimes,
	      lanes = root.pendingLanes & -62914561;
	    0 < lanes;

	  ) {
	    var index$3 = 31 - clz32(lanes),
	      lane = 1 << index$3,
	      expirationTime = expirationTimes[index$3];
	    if (-1 === expirationTime) {
	      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
	        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
	    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
	    lanes &= ~lane;
	  }
	  currentTime = workInProgressRoot;
	  suspendedLanes = workInProgressRootRenderLanes;
	  suspendedLanes = getNextLanes(
	    root,
	    root === currentTime ? suspendedLanes : 0,
	    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
	  );
	  pingedLanes = root.callbackNode;
	  if (
	    0 === suspendedLanes ||
	    (root === currentTime &&
	      (2 === workInProgressSuspendedReason ||
	        9 === workInProgressSuspendedReason)) ||
	    null !== root.cancelPendingCommit
	  )
	    return (
	      null !== pingedLanes &&
	        null !== pingedLanes &&
	        cancelCallback$1(pingedLanes),
	      (root.callbackNode = null),
	      (root.callbackPriority = 0)
	    );
	  if (
	    0 === (suspendedLanes & 3) ||
	    checkIfRootIsPrerendering(root, suspendedLanes)
	  ) {
	    currentTime = suspendedLanes & -suspendedLanes;
	    if (currentTime === root.callbackPriority) return currentTime;
	    null !== pingedLanes && cancelCallback$1(pingedLanes);
	    switch (lanesToEventPriority(suspendedLanes)) {
	      case 2:
	      case 8:
	        suspendedLanes = UserBlockingPriority;
	        break;
	      case 32:
	        suspendedLanes = NormalPriority$1;
	        break;
	      case 268435456:
	        suspendedLanes = IdlePriority;
	        break;
	      default:
	        suspendedLanes = NormalPriority$1;
	    }
	    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
	    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
	    root.callbackPriority = currentTime;
	    root.callbackNode = suspendedLanes;
	    return currentTime;
	  }
	  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
	  root.callbackPriority = 2;
	  root.callbackNode = null;
	  return 2;
	}
	function performWorkOnRootViaSchedulerTask(root, didTimeout) {
	  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
	    return (root.callbackNode = null), (root.callbackPriority = 0), null;
	  var originalCallbackNode = root.callbackNode;
	  if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
	    return null;
	  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
	  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
	    root,
	    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
	    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
	  );
	  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
	  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
	  scheduleTaskForRootDuringMicrotask(root, now());
	  return null != root.callbackNode && root.callbackNode === originalCallbackNode
	    ? performWorkOnRootViaSchedulerTask.bind(null, root)
	    : null;
	}
	function performSyncWorkOnRoot(root, lanes) {
	  if (flushPendingEffects()) return null;
	  performWorkOnRoot(root, lanes, !0);
	}
	function scheduleImmediateRootScheduleTask() {
	  scheduleMicrotask(function () {
	    0 !== (executionContext & 6)
	      ? scheduleCallback$3(
	          ImmediatePriority,
	          processRootScheduleInImmediateTask
	        )
	      : processRootScheduleInMicrotask();
	  });
	}
	function requestTransitionLane() {
	  0 === currentEventTransitionLane &&
	    (currentEventTransitionLane = claimNextTransitionLane());
	  return currentEventTransitionLane;
	}
	function coerceFormActionProp(actionProp) {
	  return null == actionProp ||
	    "symbol" === typeof actionProp ||
	    "boolean" === typeof actionProp
	    ? null
	    : "function" === typeof actionProp
	      ? actionProp
	      : sanitizeURL("" + actionProp);
	}
	function createFormDataWithSubmitter(form, submitter) {
	  var temp = submitter.ownerDocument.createElement("input");
	  temp.name = submitter.name;
	  temp.value = submitter.value;
	  form.id && temp.setAttribute("form", form.id);
	  submitter.parentNode.insertBefore(temp, submitter);
	  form = new FormData(form);
	  temp.parentNode.removeChild(temp);
	  return form;
	}
	function extractEvents$1(
	  dispatchQueue,
	  domEventName,
	  maybeTargetInst,
	  nativeEvent,
	  nativeEventTarget
	) {
	  if (
	    "submit" === domEventName &&
	    maybeTargetInst &&
	    maybeTargetInst.stateNode === nativeEventTarget
	  ) {
	    var action = coerceFormActionProp(
	        (nativeEventTarget[internalPropsKey] || null).action
	      ),
	      submitter = nativeEvent.submitter;
	    submitter &&
	      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
	        ? coerceFormActionProp(domEventName.formAction)
	        : submitter.getAttribute("formAction")),
	      null !== domEventName && ((action = domEventName), (submitter = null)));
	    var event = new SyntheticEvent(
	      "action",
	      "action",
	      null,
	      nativeEvent,
	      nativeEventTarget
	    );
	    dispatchQueue.push({
	      event: event,
	      listeners: [
	        {
	          instance: null,
	          listener: function () {
	            if (nativeEvent.defaultPrevented) {
	              if (0 !== currentEventTransitionLane) {
	                var formData = submitter
	                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
	                  : new FormData(nativeEventTarget);
	                startHostTransition(
	                  maybeTargetInst,
	                  {
	                    pending: !0,
	                    data: formData,
	                    method: nativeEventTarget.method,
	                    action: action
	                  },
	                  null,
	                  formData
	                );
	              }
	            } else
	              "function" === typeof action &&
	                (event.preventDefault(),
	                (formData = submitter
	                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
	                  : new FormData(nativeEventTarget)),
	                startHostTransition(
	                  maybeTargetInst,
	                  {
	                    pending: !0,
	                    data: formData,
	                    method: nativeEventTarget.method,
	                    action: action
	                  },
	                  action,
	                  formData
	                ));
	          },
	          currentTarget: nativeEventTarget
	        }
	      ]
	    });
	  }
	}
	for (
	  var i$jscomp$inline_1528 = 0;
	  i$jscomp$inline_1528 < simpleEventPluginEvents.length;
	  i$jscomp$inline_1528++
	) {
	  var eventName$jscomp$inline_1529 =
	      simpleEventPluginEvents[i$jscomp$inline_1528],
	    domEventName$jscomp$inline_1530 =
	      eventName$jscomp$inline_1529.toLowerCase(),
	    capitalizedEvent$jscomp$inline_1531 =
	      eventName$jscomp$inline_1529[0].toUpperCase() +
	      eventName$jscomp$inline_1529.slice(1);
	  registerSimpleEvent(
	    domEventName$jscomp$inline_1530,
	    "on" + capitalizedEvent$jscomp$inline_1531
	  );
	}
	registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
	registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
	registerSimpleEvent(ANIMATION_START, "onAnimationStart");
	registerSimpleEvent("dblclick", "onDoubleClick");
	registerSimpleEvent("focusin", "onFocus");
	registerSimpleEvent("focusout", "onBlur");
	registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
	registerSimpleEvent(TRANSITION_START, "onTransitionStart");
	registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
	registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
	registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
	registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
	registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
	registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
	registerTwoPhaseEvent(
	  "onChange",
	  "change click focusin focusout input keydown keyup selectionchange".split(" ")
	);
	registerTwoPhaseEvent(
	  "onSelect",
	  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
	    " "
	  )
	);
	registerTwoPhaseEvent("onBeforeInput", [
	  "compositionend",
	  "keypress",
	  "textInput",
	  "paste"
	]);
	registerTwoPhaseEvent(
	  "onCompositionEnd",
	  "compositionend focusout keydown keypress keyup mousedown".split(" ")
	);
	registerTwoPhaseEvent(
	  "onCompositionStart",
	  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
	);
	registerTwoPhaseEvent(
	  "onCompositionUpdate",
	  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
	);
	var mediaEventTypes =
	    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
	      " "
	    ),
	  nonDelegatedEvents = new Set(
	    "beforetoggle cancel close invalid load scroll scrollend toggle"
	      .split(" ")
	      .concat(mediaEventTypes)
	  );
	function processDispatchQueue(dispatchQueue, eventSystemFlags) {
	  eventSystemFlags = 0 !== (eventSystemFlags & 4);
	  for (var i = 0; i < dispatchQueue.length; i++) {
	    var _dispatchQueue$i = dispatchQueue[i],
	      event = _dispatchQueue$i.event;
	    _dispatchQueue$i = _dispatchQueue$i.listeners;
	    a: {
	      var previousInstance = void 0;
	      if (eventSystemFlags)
	        for (
	          var i$jscomp$0 = _dispatchQueue$i.length - 1;
	          0 <= i$jscomp$0;
	          i$jscomp$0--
	        ) {
	          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
	            instance = _dispatchListeners$i.instance,
	            currentTarget = _dispatchListeners$i.currentTarget;
	          _dispatchListeners$i = _dispatchListeners$i.listener;
	          if (instance !== previousInstance && event.isPropagationStopped())
	            break a;
	          previousInstance = _dispatchListeners$i;
	          event.currentTarget = currentTarget;
	          try {
	            previousInstance(event);
	          } catch (error) {
	            reportGlobalError(error);
	          }
	          event.currentTarget = null;
	          previousInstance = instance;
	        }
	      else
	        for (
	          i$jscomp$0 = 0;
	          i$jscomp$0 < _dispatchQueue$i.length;
	          i$jscomp$0++
	        ) {
	          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
	          instance = _dispatchListeners$i.instance;
	          currentTarget = _dispatchListeners$i.currentTarget;
	          _dispatchListeners$i = _dispatchListeners$i.listener;
	          if (instance !== previousInstance && event.isPropagationStopped())
	            break a;
	          previousInstance = _dispatchListeners$i;
	          event.currentTarget = currentTarget;
	          try {
	            previousInstance(event);
	          } catch (error) {
	            reportGlobalError(error);
	          }
	          event.currentTarget = null;
	          previousInstance = instance;
	        }
	    }
	  }
	}
	function listenToNonDelegatedEvent(domEventName, targetElement) {
	  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
	  void 0 === JSCompiler_inline_result &&
	    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
	      new Set());
	  var listenerSetKey = domEventName + "__bubble";
	  JSCompiler_inline_result.has(listenerSetKey) ||
	    (addTrappedEventListener(targetElement, domEventName, 2, !1),
	    JSCompiler_inline_result.add(listenerSetKey));
	}
	function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
	  var eventSystemFlags = 0;
	  isCapturePhaseListener && (eventSystemFlags |= 4);
	  addTrappedEventListener(
	    target,
	    domEventName,
	    eventSystemFlags,
	    isCapturePhaseListener
	  );
	}
	var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
	function listenToAllSupportedEvents(rootContainerElement) {
	  if (!rootContainerElement[listeningMarker]) {
	    rootContainerElement[listeningMarker] = !0;
	    allNativeEvents.forEach(function (domEventName) {
	      "selectionchange" !== domEventName &&
	        (nonDelegatedEvents.has(domEventName) ||
	          listenToNativeEvent(domEventName, !1, rootContainerElement),
	        listenToNativeEvent(domEventName, !0, rootContainerElement));
	    });
	    var ownerDocument =
	      9 === rootContainerElement.nodeType
	        ? rootContainerElement
	        : rootContainerElement.ownerDocument;
	    null === ownerDocument ||
	      ownerDocument[listeningMarker] ||
	      ((ownerDocument[listeningMarker] = !0),
	      listenToNativeEvent("selectionchange", !1, ownerDocument));
	  }
	}
	function addTrappedEventListener(
	  targetContainer,
	  domEventName,
	  eventSystemFlags,
	  isCapturePhaseListener
	) {
	  switch (getEventPriority(domEventName)) {
	    case 2:
	      var listenerWrapper = dispatchDiscreteEvent;
	      break;
	    case 8:
	      listenerWrapper = dispatchContinuousEvent;
	      break;
	    default:
	      listenerWrapper = dispatchEvent;
	  }
	  eventSystemFlags = listenerWrapper.bind(
	    null,
	    domEventName,
	    eventSystemFlags,
	    targetContainer
	  );
	  listenerWrapper = void 0;
	  !passiveBrowserEventsSupported ||
	    ("touchstart" !== domEventName &&
	      "touchmove" !== domEventName &&
	      "wheel" !== domEventName) ||
	    (listenerWrapper = !0);
	  isCapturePhaseListener
	    ? void 0 !== listenerWrapper
	      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
	          capture: !0,
	          passive: listenerWrapper
	        })
	      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
	    : void 0 !== listenerWrapper
	      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
	          passive: listenerWrapper
	        })
	      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
	}
	function dispatchEventForPluginEventSystem(
	  domEventName,
	  eventSystemFlags,
	  nativeEvent,
	  targetInst$jscomp$0,
	  targetContainer
	) {
	  var ancestorInst = targetInst$jscomp$0;
	  if (
	    0 === (eventSystemFlags & 1) &&
	    0 === (eventSystemFlags & 2) &&
	    null !== targetInst$jscomp$0
	  )
	    a: for (;;) {
	      if (null === targetInst$jscomp$0) return;
	      var nodeTag = targetInst$jscomp$0.tag;
	      if (3 === nodeTag || 4 === nodeTag) {
	        var container = targetInst$jscomp$0.stateNode.containerInfo;
	        if (container === targetContainer) break;
	        if (4 === nodeTag)
	          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
	            var grandTag = nodeTag.tag;
	            if (
	              (3 === grandTag || 4 === grandTag) &&
	              nodeTag.stateNode.containerInfo === targetContainer
	            )
	              return;
	            nodeTag = nodeTag.return;
	          }
	        for (; null !== container; ) {
	          nodeTag = getClosestInstanceFromNode(container);
	          if (null === nodeTag) return;
	          grandTag = nodeTag.tag;
	          if (
	            5 === grandTag ||
	            6 === grandTag ||
	            26 === grandTag ||
	            27 === grandTag
	          ) {
	            targetInst$jscomp$0 = ancestorInst = nodeTag;
	            continue a;
	          }
	          container = container.parentNode;
	        }
	      }
	      targetInst$jscomp$0 = targetInst$jscomp$0.return;
	    }
	  batchedUpdates$1(function () {
	    var targetInst = ancestorInst,
	      nativeEventTarget = getEventTarget(nativeEvent),
	      dispatchQueue = [];
	    a: {
	      var reactName = topLevelEventsToReactNames.get(domEventName);
	      if (void 0 !== reactName) {
	        var SyntheticEventCtor = SyntheticEvent,
	          reactEventType = domEventName;
	        switch (domEventName) {
	          case "keypress":
	            if (0 === getEventCharCode(nativeEvent)) break a;
	          case "keydown":
	          case "keyup":
	            SyntheticEventCtor = SyntheticKeyboardEvent;
	            break;
	          case "focusin":
	            reactEventType = "focus";
	            SyntheticEventCtor = SyntheticFocusEvent;
	            break;
	          case "focusout":
	            reactEventType = "blur";
	            SyntheticEventCtor = SyntheticFocusEvent;
	            break;
	          case "beforeblur":
	          case "afterblur":
	            SyntheticEventCtor = SyntheticFocusEvent;
	            break;
	          case "click":
	            if (2 === nativeEvent.button) break a;
	          case "auxclick":
	          case "dblclick":
	          case "mousedown":
	          case "mousemove":
	          case "mouseup":
	          case "mouseout":
	          case "mouseover":
	          case "contextmenu":
	            SyntheticEventCtor = SyntheticMouseEvent;
	            break;
	          case "drag":
	          case "dragend":
	          case "dragenter":
	          case "dragexit":
	          case "dragleave":
	          case "dragover":
	          case "dragstart":
	          case "drop":
	            SyntheticEventCtor = SyntheticDragEvent;
	            break;
	          case "touchcancel":
	          case "touchend":
	          case "touchmove":
	          case "touchstart":
	            SyntheticEventCtor = SyntheticTouchEvent;
	            break;
	          case ANIMATION_END:
	          case ANIMATION_ITERATION:
	          case ANIMATION_START:
	            SyntheticEventCtor = SyntheticAnimationEvent;
	            break;
	          case TRANSITION_END:
	            SyntheticEventCtor = SyntheticTransitionEvent;
	            break;
	          case "scroll":
	          case "scrollend":
	            SyntheticEventCtor = SyntheticUIEvent;
	            break;
	          case "wheel":
	            SyntheticEventCtor = SyntheticWheelEvent;
	            break;
	          case "copy":
	          case "cut":
	          case "paste":
	            SyntheticEventCtor = SyntheticClipboardEvent;
	            break;
	          case "gotpointercapture":
	          case "lostpointercapture":
	          case "pointercancel":
	          case "pointerdown":
	          case "pointermove":
	          case "pointerout":
	          case "pointerover":
	          case "pointerup":
	            SyntheticEventCtor = SyntheticPointerEvent;
	            break;
	          case "toggle":
	          case "beforetoggle":
	            SyntheticEventCtor = SyntheticToggleEvent;
	        }
	        var inCapturePhase = 0 !== (eventSystemFlags & 4),
	          accumulateTargetOnly =
	            !inCapturePhase &&
	            ("scroll" === domEventName || "scrollend" === domEventName),
	          reactEventName = inCapturePhase
	            ? null !== reactName
	              ? reactName + "Capture"
	              : null
	            : reactName;
	        inCapturePhase = [];
	        for (
	          var instance = targetInst, lastHostComponent;
	          null !== instance;

	        ) {
	          var _instance = instance;
	          lastHostComponent = _instance.stateNode;
	          _instance = _instance.tag;
	          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
	            null === lastHostComponent ||
	            null === reactEventName ||
	            ((_instance = getListener(instance, reactEventName)),
	            null != _instance &&
	              inCapturePhase.push(
	                createDispatchListener(instance, _instance, lastHostComponent)
	              ));
	          if (accumulateTargetOnly) break;
	          instance = instance.return;
	        }
	        0 < inCapturePhase.length &&
	          ((reactName = new SyntheticEventCtor(
	            reactName,
	            reactEventType,
	            null,
	            nativeEvent,
	            nativeEventTarget
	          )),
	          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
	      }
	    }
	    if (0 === (eventSystemFlags & 7)) {
	      a: {
	        reactName =
	          "mouseover" === domEventName || "pointerover" === domEventName;
	        SyntheticEventCtor =
	          "mouseout" === domEventName || "pointerout" === domEventName;
	        if (
	          reactName &&
	          nativeEvent !== currentReplayingEvent &&
	          (reactEventType =
	            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
	          (getClosestInstanceFromNode(reactEventType) ||
	            reactEventType[internalContainerInstanceKey])
	        )
	          break a;
	        if (SyntheticEventCtor || reactName) {
	          reactName =
	            nativeEventTarget.window === nativeEventTarget
	              ? nativeEventTarget
	              : (reactName = nativeEventTarget.ownerDocument)
	                ? reactName.defaultView || reactName.parentWindow
	                : window;
	          if (SyntheticEventCtor) {
	            if (
	              ((reactEventType =
	                nativeEvent.relatedTarget || nativeEvent.toElement),
	              (SyntheticEventCtor = targetInst),
	              (reactEventType = reactEventType
	                ? getClosestInstanceFromNode(reactEventType)
	                : null),
	              null !== reactEventType &&
	                ((accumulateTargetOnly =
	                  getNearestMountedFiber(reactEventType)),
	                (inCapturePhase = reactEventType.tag),
	                reactEventType !== accumulateTargetOnly ||
	                  (5 !== inCapturePhase &&
	                    27 !== inCapturePhase &&
	                    6 !== inCapturePhase)))
	            )
	              reactEventType = null;
	          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
	          if (SyntheticEventCtor !== reactEventType) {
	            inCapturePhase = SyntheticMouseEvent;
	            _instance = "onMouseLeave";
	            reactEventName = "onMouseEnter";
	            instance = "mouse";
	            if ("pointerout" === domEventName || "pointerover" === domEventName)
	              (inCapturePhase = SyntheticPointerEvent),
	                (_instance = "onPointerLeave"),
	                (reactEventName = "onPointerEnter"),
	                (instance = "pointer");
	            accumulateTargetOnly =
	              null == SyntheticEventCtor
	                ? reactName
	                : getNodeFromInstance(SyntheticEventCtor);
	            lastHostComponent =
	              null == reactEventType
	                ? reactName
	                : getNodeFromInstance(reactEventType);
	            reactName = new inCapturePhase(
	              _instance,
	              instance + "leave",
	              SyntheticEventCtor,
	              nativeEvent,
	              nativeEventTarget
	            );
	            reactName.target = accumulateTargetOnly;
	            reactName.relatedTarget = lastHostComponent;
	            _instance = null;
	            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
	              ((inCapturePhase = new inCapturePhase(
	                reactEventName,
	                instance + "enter",
	                reactEventType,
	                nativeEvent,
	                nativeEventTarget
	              )),
	              (inCapturePhase.target = lastHostComponent),
	              (inCapturePhase.relatedTarget = accumulateTargetOnly),
	              (_instance = inCapturePhase));
	            accumulateTargetOnly = _instance;
	            if (SyntheticEventCtor && reactEventType)
	              b: {
	                inCapturePhase = SyntheticEventCtor;
	                reactEventName = reactEventType;
	                instance = 0;
	                for (
	                  lastHostComponent = inCapturePhase;
	                  lastHostComponent;
	                  lastHostComponent = getParent(lastHostComponent)
	                )
	                  instance++;
	                lastHostComponent = 0;
	                for (
	                  _instance = reactEventName;
	                  _instance;
	                  _instance = getParent(_instance)
	                )
	                  lastHostComponent++;
	                for (; 0 < instance - lastHostComponent; )
	                  (inCapturePhase = getParent(inCapturePhase)), instance--;
	                for (; 0 < lastHostComponent - instance; )
	                  (reactEventName = getParent(reactEventName)),
	                    lastHostComponent--;
	                for (; instance--; ) {
	                  if (
	                    inCapturePhase === reactEventName ||
	                    (null !== reactEventName &&
	                      inCapturePhase === reactEventName.alternate)
	                  )
	                    break b;
	                  inCapturePhase = getParent(inCapturePhase);
	                  reactEventName = getParent(reactEventName);
	                }
	                inCapturePhase = null;
	              }
	            else inCapturePhase = null;
	            null !== SyntheticEventCtor &&
	              accumulateEnterLeaveListenersForEvent(
	                dispatchQueue,
	                reactName,
	                SyntheticEventCtor,
	                inCapturePhase,
	                !1
	              );
	            null !== reactEventType &&
	              null !== accumulateTargetOnly &&
	              accumulateEnterLeaveListenersForEvent(
	                dispatchQueue,
	                accumulateTargetOnly,
	                reactEventType,
	                inCapturePhase,
	                !0
	              );
	          }
	        }
	      }
	      a: {
	        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
	        SyntheticEventCtor =
	          reactName.nodeName && reactName.nodeName.toLowerCase();
	        if (
	          "select" === SyntheticEventCtor ||
	          ("input" === SyntheticEventCtor && "file" === reactName.type)
	        )
	          var getTargetInstFunc = getTargetInstForChangeEvent;
	        else if (isTextInputElement(reactName))
	          if (isInputEventSupported)
	            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	          else {
	            getTargetInstFunc = getTargetInstForInputEventPolyfill;
	            var handleEventFunc = handleEventsForInputEventPolyfill;
	          }
	        else
	          (SyntheticEventCtor = reactName.nodeName),
	            !SyntheticEventCtor ||
	            "input" !== SyntheticEventCtor.toLowerCase() ||
	            ("checkbox" !== reactName.type && "radio" !== reactName.type)
	              ? targetInst &&
	                isCustomElement(targetInst.elementType) &&
	                (getTargetInstFunc = getTargetInstForChangeEvent)
	              : (getTargetInstFunc = getTargetInstForClickEvent);
	        if (
	          getTargetInstFunc &&
	          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
	        ) {
	          createAndAccumulateChangeEvent(
	            dispatchQueue,
	            getTargetInstFunc,
	            nativeEvent,
	            nativeEventTarget
	          );
	          break a;
	        }
	        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
	        "focusout" === domEventName &&
	          targetInst &&
	          "number" === reactName.type &&
	          null != targetInst.memoizedProps.value &&
	          setDefaultValue(reactName, "number", reactName.value);
	      }
	      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
	      switch (domEventName) {
	        case "focusin":
	          if (
	            isTextInputElement(handleEventFunc) ||
	            "true" === handleEventFunc.contentEditable
	          )
	            (activeElement = handleEventFunc),
	              (activeElementInst = targetInst),
	              (lastSelection = null);
	          break;
	        case "focusout":
	          lastSelection = activeElementInst = activeElement = null;
	          break;
	        case "mousedown":
	          mouseDown = !0;
	          break;
	        case "contextmenu":
	        case "mouseup":
	        case "dragend":
	          mouseDown = !1;
	          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
	          break;
	        case "selectionchange":
	          if (skipSelectionChangeEvent) break;
	        case "keydown":
	        case "keyup":
	          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
	      }
	      var fallbackData;
	      if (canUseCompositionEvent)
	        b: {
	          switch (domEventName) {
	            case "compositionstart":
	              var eventType = "onCompositionStart";
	              break b;
	            case "compositionend":
	              eventType = "onCompositionEnd";
	              break b;
	            case "compositionupdate":
	              eventType = "onCompositionUpdate";
	              break b;
	          }
	          eventType = void 0;
	        }
	      else
	        isComposing
	          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
	            (eventType = "onCompositionEnd")
	          : "keydown" === domEventName &&
	            229 === nativeEvent.keyCode &&
	            (eventType = "onCompositionStart");
	      eventType &&
	        (useFallbackCompositionData &&
	          "ko" !== nativeEvent.locale &&
	          (isComposing || "onCompositionStart" !== eventType
	            ? "onCompositionEnd" === eventType &&
	              isComposing &&
	              (fallbackData = getData())
	            : ((root$2 = nativeEventTarget),
	              (startText = "value" in root$2 ? root$2.value : root$2.textContent),
	              (isComposing = !0))),
	        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
	        0 < handleEventFunc.length &&
	          ((eventType = new SyntheticCompositionEvent(
	            eventType,
	            domEventName,
	            null,
	            nativeEvent,
	            nativeEventTarget
	          )),
	          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
	          fallbackData
	            ? (eventType.data = fallbackData)
	            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
	              null !== fallbackData && (eventType.data = fallbackData))));
	      if (
	        (fallbackData = canUseTextInputEvent
	          ? getNativeBeforeInputChars(domEventName, nativeEvent)
	          : getFallbackBeforeInputChars(domEventName, nativeEvent))
	      )
	        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
	          0 < eventType.length &&
	            ((handleEventFunc = new SyntheticCompositionEvent(
	              "onBeforeInput",
	              "beforeinput",
	              null,
	              nativeEvent,
	              nativeEventTarget
	            )),
	            dispatchQueue.push({
	              event: handleEventFunc,
	              listeners: eventType
	            }),
	            (handleEventFunc.data = fallbackData));
	      extractEvents$1(
	        dispatchQueue,
	        domEventName,
	        targetInst,
	        nativeEvent,
	        nativeEventTarget
	      );
	    }
	    processDispatchQueue(dispatchQueue, eventSystemFlags);
	  });
	}
	function createDispatchListener(instance, listener, currentTarget) {
	  return {
	    instance: instance,
	    listener: listener,
	    currentTarget: currentTarget
	  };
	}
	function accumulateTwoPhaseListeners(targetFiber, reactName) {
	  for (
	    var captureName = reactName + "Capture", listeners = [];
	    null !== targetFiber;

	  ) {
	    var _instance2 = targetFiber,
	      stateNode = _instance2.stateNode;
	    _instance2 = _instance2.tag;
	    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
	      null === stateNode ||
	      ((_instance2 = getListener(targetFiber, captureName)),
	      null != _instance2 &&
	        listeners.unshift(
	          createDispatchListener(targetFiber, _instance2, stateNode)
	        ),
	      (_instance2 = getListener(targetFiber, reactName)),
	      null != _instance2 &&
	        listeners.push(
	          createDispatchListener(targetFiber, _instance2, stateNode)
	        ));
	    if (3 === targetFiber.tag) return listeners;
	    targetFiber = targetFiber.return;
	  }
	  return [];
	}
	function getParent(inst) {
	  if (null === inst) return null;
	  do inst = inst.return;
	  while (inst && 5 !== inst.tag && 27 !== inst.tag);
	  return inst ? inst : null;
	}
	function accumulateEnterLeaveListenersForEvent(
	  dispatchQueue,
	  event,
	  target,
	  common,
	  inCapturePhase
	) {
	  for (
	    var registrationName = event._reactName, listeners = [];
	    null !== target && target !== common;

	  ) {
	    var _instance3 = target,
	      alternate = _instance3.alternate,
	      stateNode = _instance3.stateNode;
	    _instance3 = _instance3.tag;
	    if (null !== alternate && alternate === common) break;
	    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
	      null === stateNode ||
	      ((alternate = stateNode),
	      inCapturePhase
	        ? ((stateNode = getListener(target, registrationName)),
	          null != stateNode &&
	            listeners.unshift(
	              createDispatchListener(target, stateNode, alternate)
	            ))
	        : inCapturePhase ||
	          ((stateNode = getListener(target, registrationName)),
	          null != stateNode &&
	            listeners.push(
	              createDispatchListener(target, stateNode, alternate)
	            )));
	    target = target.return;
	  }
	  0 !== listeners.length &&
	    dispatchQueue.push({ event: event, listeners: listeners });
	}
	var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
	  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
	function normalizeMarkupForTextOrAttribute(markup) {
	  return ("string" === typeof markup ? markup : "" + markup)
	    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
	    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
	}
	function checkForUnmatchedText(serverText, clientText) {
	  clientText = normalizeMarkupForTextOrAttribute(clientText);
	  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
	}
	function noop$1() {}
	function setProp(domElement, tag, key, value, props, prevValue) {
	  switch (key) {
	    case "children":
	      "string" === typeof value
	        ? "body" === tag ||
	          ("textarea" === tag && "" === value) ||
	          setTextContent(domElement, value)
	        : ("number" === typeof value || "bigint" === typeof value) &&
	          "body" !== tag &&
	          setTextContent(domElement, "" + value);
	      break;
	    case "className":
	      setValueForKnownAttribute(domElement, "class", value);
	      break;
	    case "tabIndex":
	      setValueForKnownAttribute(domElement, "tabindex", value);
	      break;
	    case "dir":
	    case "role":
	    case "viewBox":
	    case "width":
	    case "height":
	      setValueForKnownAttribute(domElement, key, value);
	      break;
	    case "style":
	      setValueForStyles(domElement, value, prevValue);
	      break;
	    case "data":
	      if ("object" !== tag) {
	        setValueForKnownAttribute(domElement, "data", value);
	        break;
	      }
	    case "src":
	    case "href":
	      if ("" === value && ("a" !== tag || "href" !== key)) {
	        domElement.removeAttribute(key);
	        break;
	      }
	      if (
	        null == value ||
	        "function" === typeof value ||
	        "symbol" === typeof value ||
	        "boolean" === typeof value
	      ) {
	        domElement.removeAttribute(key);
	        break;
	      }
	      value = sanitizeURL("" + value);
	      domElement.setAttribute(key, value);
	      break;
	    case "action":
	    case "formAction":
	      if ("function" === typeof value) {
	        domElement.setAttribute(
	          key,
	          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
	        );
	        break;
	      } else
	        "function" === typeof prevValue &&
	          ("formAction" === key
	            ? ("input" !== tag &&
	                setProp(domElement, tag, "name", props.name, props, null),
	              setProp(
	                domElement,
	                tag,
	                "formEncType",
	                props.formEncType,
	                props,
	                null
	              ),
	              setProp(
	                domElement,
	                tag,
	                "formMethod",
	                props.formMethod,
	                props,
	                null
	              ),
	              setProp(
	                domElement,
	                tag,
	                "formTarget",
	                props.formTarget,
	                props,
	                null
	              ))
	            : (setProp(domElement, tag, "encType", props.encType, props, null),
	              setProp(domElement, tag, "method", props.method, props, null),
	              setProp(domElement, tag, "target", props.target, props, null)));
	      if (
	        null == value ||
	        "symbol" === typeof value ||
	        "boolean" === typeof value
	      ) {
	        domElement.removeAttribute(key);
	        break;
	      }
	      value = sanitizeURL("" + value);
	      domElement.setAttribute(key, value);
	      break;
	    case "onClick":
	      null != value && (domElement.onclick = noop$1);
	      break;
	    case "onScroll":
	      null != value && listenToNonDelegatedEvent("scroll", domElement);
	      break;
	    case "onScrollEnd":
	      null != value && listenToNonDelegatedEvent("scrollend", domElement);
	      break;
	    case "dangerouslySetInnerHTML":
	      if (null != value) {
	        if ("object" !== typeof value || !("__html" in value))
	          throw Error(formatProdErrorMessage$1(61));
	        key = value.__html;
	        if (null != key) {
	          if (null != props.children) throw Error(formatProdErrorMessage$1(60));
	          domElement.innerHTML = key;
	        }
	      }
	      break;
	    case "multiple":
	      domElement.multiple =
	        value && "function" !== typeof value && "symbol" !== typeof value;
	      break;
	    case "muted":
	      domElement.muted =
	        value && "function" !== typeof value && "symbol" !== typeof value;
	      break;
	    case "suppressContentEditableWarning":
	    case "suppressHydrationWarning":
	    case "defaultValue":
	    case "defaultChecked":
	    case "innerHTML":
	    case "ref":
	      break;
	    case "autoFocus":
	      break;
	    case "xlinkHref":
	      if (
	        null == value ||
	        "function" === typeof value ||
	        "boolean" === typeof value ||
	        "symbol" === typeof value
	      ) {
	        domElement.removeAttribute("xlink:href");
	        break;
	      }
	      key = sanitizeURL("" + value);
	      domElement.setAttributeNS(
	        "http://www.w3.org/1999/xlink",
	        "xlink:href",
	        key
	      );
	      break;
	    case "contentEditable":
	    case "spellCheck":
	    case "draggable":
	    case "value":
	    case "autoReverse":
	    case "externalResourcesRequired":
	    case "focusable":
	    case "preserveAlpha":
	      null != value && "function" !== typeof value && "symbol" !== typeof value
	        ? domElement.setAttribute(key, "" + value)
	        : domElement.removeAttribute(key);
	      break;
	    case "inert":
	    case "allowFullScreen":
	    case "async":
	    case "autoPlay":
	    case "controls":
	    case "default":
	    case "defer":
	    case "disabled":
	    case "disablePictureInPicture":
	    case "disableRemotePlayback":
	    case "formNoValidate":
	    case "hidden":
	    case "loop":
	    case "noModule":
	    case "noValidate":
	    case "open":
	    case "playsInline":
	    case "readOnly":
	    case "required":
	    case "reversed":
	    case "scoped":
	    case "seamless":
	    case "itemScope":
	      value && "function" !== typeof value && "symbol" !== typeof value
	        ? domElement.setAttribute(key, "")
	        : domElement.removeAttribute(key);
	      break;
	    case "capture":
	    case "download":
	      !0 === value
	        ? domElement.setAttribute(key, "")
	        : !1 !== value &&
	            null != value &&
	            "function" !== typeof value &&
	            "symbol" !== typeof value
	          ? domElement.setAttribute(key, value)
	          : domElement.removeAttribute(key);
	      break;
	    case "cols":
	    case "rows":
	    case "size":
	    case "span":
	      null != value &&
	      "function" !== typeof value &&
	      "symbol" !== typeof value &&
	      !isNaN(value) &&
	      1 <= value
	        ? domElement.setAttribute(key, value)
	        : domElement.removeAttribute(key);
	      break;
	    case "rowSpan":
	    case "start":
	      null == value ||
	      "function" === typeof value ||
	      "symbol" === typeof value ||
	      isNaN(value)
	        ? domElement.removeAttribute(key)
	        : domElement.setAttribute(key, value);
	      break;
	    case "popover":
	      listenToNonDelegatedEvent("beforetoggle", domElement);
	      listenToNonDelegatedEvent("toggle", domElement);
	      setValueForAttribute(domElement, "popover", value);
	      break;
	    case "xlinkActuate":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:actuate",
	        value
	      );
	      break;
	    case "xlinkArcrole":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:arcrole",
	        value
	      );
	      break;
	    case "xlinkRole":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:role",
	        value
	      );
	      break;
	    case "xlinkShow":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:show",
	        value
	      );
	      break;
	    case "xlinkTitle":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:title",
	        value
	      );
	      break;
	    case "xlinkType":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:type",
	        value
	      );
	      break;
	    case "xmlBase":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/XML/1998/namespace",
	        "xml:base",
	        value
	      );
	      break;
	    case "xmlLang":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/XML/1998/namespace",
	        "xml:lang",
	        value
	      );
	      break;
	    case "xmlSpace":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/XML/1998/namespace",
	        "xml:space",
	        value
	      );
	      break;
	    case "is":
	      setValueForAttribute(domElement, "is", value);
	      break;
	    case "innerText":
	    case "textContent":
	      break;
	    default:
	      if (
	        !(2 < key.length) ||
	        ("o" !== key[0] && "O" !== key[0]) ||
	        ("n" !== key[1] && "N" !== key[1])
	      )
	        (key = aliases.get(key) || key),
	          setValueForAttribute(domElement, key, value);
	  }
	}
	function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
	  switch (key) {
	    case "style":
	      setValueForStyles(domElement, value, prevValue);
	      break;
	    case "dangerouslySetInnerHTML":
	      if (null != value) {
	        if ("object" !== typeof value || !("__html" in value))
	          throw Error(formatProdErrorMessage$1(61));
	        key = value.__html;
	        if (null != key) {
	          if (null != props.children) throw Error(formatProdErrorMessage$1(60));
	          domElement.innerHTML = key;
	        }
	      }
	      break;
	    case "children":
	      "string" === typeof value
	        ? setTextContent(domElement, value)
	        : ("number" === typeof value || "bigint" === typeof value) &&
	          setTextContent(domElement, "" + value);
	      break;
	    case "onScroll":
	      null != value && listenToNonDelegatedEvent("scroll", domElement);
	      break;
	    case "onScrollEnd":
	      null != value && listenToNonDelegatedEvent("scrollend", domElement);
	      break;
	    case "onClick":
	      null != value && (domElement.onclick = noop$1);
	      break;
	    case "suppressContentEditableWarning":
	    case "suppressHydrationWarning":
	    case "innerHTML":
	    case "ref":
	      break;
	    case "innerText":
	    case "textContent":
	      break;
	    default:
	      if (!registrationNameDependencies.hasOwnProperty(key))
	        a: {
	          if (
	            "o" === key[0] &&
	            "n" === key[1] &&
	            ((props = key.endsWith("Capture")),
	            (tag = key.slice(2, props ? key.length - 7 : void 0)),
	            (prevValue = domElement[internalPropsKey] || null),
	            (prevValue = null != prevValue ? prevValue[key] : null),
	            "function" === typeof prevValue &&
	              domElement.removeEventListener(tag, prevValue, props),
	            "function" === typeof value)
	          ) {
	            "function" !== typeof prevValue &&
	              null !== prevValue &&
	              (key in domElement
	                ? (domElement[key] = null)
	                : domElement.hasAttribute(key) &&
	                  domElement.removeAttribute(key));
	            domElement.addEventListener(tag, value, props);
	            break a;
	          }
	          key in domElement
	            ? (domElement[key] = value)
	            : !0 === value
	              ? domElement.setAttribute(key, "")
	              : setValueForAttribute(domElement, key, value);
	        }
	  }
	}
	function setInitialProperties(domElement, tag, props) {
	  switch (tag) {
	    case "div":
	    case "span":
	    case "svg":
	    case "path":
	    case "a":
	    case "g":
	    case "p":
	    case "li":
	      break;
	    case "img":
	      listenToNonDelegatedEvent("error", domElement);
	      listenToNonDelegatedEvent("load", domElement);
	      var hasSrc = !1,
	        hasSrcSet = !1,
	        propKey;
	      for (propKey in props)
	        if (props.hasOwnProperty(propKey)) {
	          var propValue = props[propKey];
	          if (null != propValue)
	            switch (propKey) {
	              case "src":
	                hasSrc = !0;
	                break;
	              case "srcSet":
	                hasSrcSet = !0;
	                break;
	              case "children":
	              case "dangerouslySetInnerHTML":
	                throw Error(formatProdErrorMessage$1(137, tag));
	              default:
	                setProp(domElement, tag, propKey, propValue, props, null);
	            }
	        }
	      hasSrcSet &&
	        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
	      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
	      return;
	    case "input":
	      listenToNonDelegatedEvent("invalid", domElement);
	      var defaultValue = (propKey = propValue = hasSrcSet = null),
	        checked = null,
	        defaultChecked = null;
	      for (hasSrc in props)
	        if (props.hasOwnProperty(hasSrc)) {
	          var propValue$188 = props[hasSrc];
	          if (null != propValue$188)
	            switch (hasSrc) {
	              case "name":
	                hasSrcSet = propValue$188;
	                break;
	              case "type":
	                propValue = propValue$188;
	                break;
	              case "checked":
	                checked = propValue$188;
	                break;
	              case "defaultChecked":
	                defaultChecked = propValue$188;
	                break;
	              case "value":
	                propKey = propValue$188;
	                break;
	              case "defaultValue":
	                defaultValue = propValue$188;
	                break;
	              case "children":
	              case "dangerouslySetInnerHTML":
	                if (null != propValue$188)
	                  throw Error(formatProdErrorMessage$1(137, tag));
	                break;
	              default:
	                setProp(domElement, tag, hasSrc, propValue$188, props, null);
	            }
	        }
	      initInput(
	        domElement,
	        propKey,
	        defaultValue,
	        checked,
	        defaultChecked,
	        propValue,
	        hasSrcSet,
	        !1
	      );
	      track(domElement);
	      return;
	    case "select":
	      listenToNonDelegatedEvent("invalid", domElement);
	      hasSrc = propValue = propKey = null;
	      for (hasSrcSet in props)
	        if (
	          props.hasOwnProperty(hasSrcSet) &&
	          ((defaultValue = props[hasSrcSet]), null != defaultValue)
	        )
	          switch (hasSrcSet) {
	            case "value":
	              propKey = defaultValue;
	              break;
	            case "defaultValue":
	              propValue = defaultValue;
	              break;
	            case "multiple":
	              hasSrc = defaultValue;
	            default:
	              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
	          }
	      tag = propKey;
	      props = propValue;
	      domElement.multiple = !!hasSrc;
	      null != tag
	        ? updateOptions(domElement, !!hasSrc, tag, !1)
	        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
	      return;
	    case "textarea":
	      listenToNonDelegatedEvent("invalid", domElement);
	      propKey = hasSrcSet = hasSrc = null;
	      for (propValue in props)
	        if (
	          props.hasOwnProperty(propValue) &&
	          ((defaultValue = props[propValue]), null != defaultValue)
	        )
	          switch (propValue) {
	            case "value":
	              hasSrc = defaultValue;
	              break;
	            case "defaultValue":
	              hasSrcSet = defaultValue;
	              break;
	            case "children":
	              propKey = defaultValue;
	              break;
	            case "dangerouslySetInnerHTML":
	              if (null != defaultValue) throw Error(formatProdErrorMessage$1(91));
	              break;
	            default:
	              setProp(domElement, tag, propValue, defaultValue, props, null);
	          }
	      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
	      track(domElement);
	      return;
	    case "option":
	      for (checked in props)
	        if (
	          props.hasOwnProperty(checked) &&
	          ((hasSrc = props[checked]), null != hasSrc)
	        )
	          switch (checked) {
	            case "selected":
	              domElement.selected =
	                hasSrc &&
	                "function" !== typeof hasSrc &&
	                "symbol" !== typeof hasSrc;
	              break;
	            default:
	              setProp(domElement, tag, checked, hasSrc, props, null);
	          }
	      return;
	    case "dialog":
	      listenToNonDelegatedEvent("beforetoggle", domElement);
	      listenToNonDelegatedEvent("toggle", domElement);
	      listenToNonDelegatedEvent("cancel", domElement);
	      listenToNonDelegatedEvent("close", domElement);
	      break;
	    case "iframe":
	    case "object":
	      listenToNonDelegatedEvent("load", domElement);
	      break;
	    case "video":
	    case "audio":
	      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
	        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
	      break;
	    case "image":
	      listenToNonDelegatedEvent("error", domElement);
	      listenToNonDelegatedEvent("load", domElement);
	      break;
	    case "details":
	      listenToNonDelegatedEvent("toggle", domElement);
	      break;
	    case "embed":
	    case "source":
	    case "link":
	      listenToNonDelegatedEvent("error", domElement),
	        listenToNonDelegatedEvent("load", domElement);
	    case "area":
	    case "base":
	    case "br":
	    case "col":
	    case "hr":
	    case "keygen":
	    case "meta":
	    case "param":
	    case "track":
	    case "wbr":
	    case "menuitem":
	      for (defaultChecked in props)
	        if (
	          props.hasOwnProperty(defaultChecked) &&
	          ((hasSrc = props[defaultChecked]), null != hasSrc)
	        )
	          switch (defaultChecked) {
	            case "children":
	            case "dangerouslySetInnerHTML":
	              throw Error(formatProdErrorMessage$1(137, tag));
	            default:
	              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
	          }
	      return;
	    default:
	      if (isCustomElement(tag)) {
	        for (propValue$188 in props)
	          props.hasOwnProperty(propValue$188) &&
	            ((hasSrc = props[propValue$188]),
	            void 0 !== hasSrc &&
	              setPropOnCustomElement(
	                domElement,
	                tag,
	                propValue$188,
	                hasSrc,
	                props,
	                void 0
	              ));
	        return;
	      }
	  }
	  for (defaultValue in props)
	    props.hasOwnProperty(defaultValue) &&
	      ((hasSrc = props[defaultValue]),
	      null != hasSrc &&
	        setProp(domElement, tag, defaultValue, hasSrc, props, null));
	}
	function updateProperties(domElement, tag, lastProps, nextProps) {
	  switch (tag) {
	    case "div":
	    case "span":
	    case "svg":
	    case "path":
	    case "a":
	    case "g":
	    case "p":
	    case "li":
	      break;
	    case "input":
	      var name = null,
	        type = null,
	        value = null,
	        defaultValue = null,
	        lastDefaultValue = null,
	        checked = null,
	        defaultChecked = null;
	      for (propKey in lastProps) {
	        var lastProp = lastProps[propKey];
	        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
	          switch (propKey) {
	            case "checked":
	              break;
	            case "value":
	              break;
	            case "defaultValue":
	              lastDefaultValue = lastProp;
	            default:
	              nextProps.hasOwnProperty(propKey) ||
	                setProp(domElement, tag, propKey, null, nextProps, lastProp);
	          }
	      }
	      for (var propKey$205 in nextProps) {
	        var propKey = nextProps[propKey$205];
	        lastProp = lastProps[propKey$205];
	        if (
	          nextProps.hasOwnProperty(propKey$205) &&
	          (null != propKey || null != lastProp)
	        )
	          switch (propKey$205) {
	            case "type":
	              type = propKey;
	              break;
	            case "name":
	              name = propKey;
	              break;
	            case "checked":
	              checked = propKey;
	              break;
	            case "defaultChecked":
	              defaultChecked = propKey;
	              break;
	            case "value":
	              value = propKey;
	              break;
	            case "defaultValue":
	              defaultValue = propKey;
	              break;
	            case "children":
	            case "dangerouslySetInnerHTML":
	              if (null != propKey)
	                throw Error(formatProdErrorMessage$1(137, tag));
	              break;
	            default:
	              propKey !== lastProp &&
	                setProp(
	                  domElement,
	                  tag,
	                  propKey$205,
	                  propKey,
	                  nextProps,
	                  lastProp
	                );
	          }
	      }
	      updateInput(
	        domElement,
	        value,
	        defaultValue,
	        lastDefaultValue,
	        checked,
	        defaultChecked,
	        type,
	        name
	      );
	      return;
	    case "select":
	      propKey = value = defaultValue = propKey$205 = null;
	      for (type in lastProps)
	        if (
	          ((lastDefaultValue = lastProps[type]),
	          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
	        )
	          switch (type) {
	            case "value":
	              break;
	            case "multiple":
	              propKey = lastDefaultValue;
	            default:
	              nextProps.hasOwnProperty(type) ||
	                setProp(
	                  domElement,
	                  tag,
	                  type,
	                  null,
	                  nextProps,
	                  lastDefaultValue
	                );
	          }
	      for (name in nextProps)
	        if (
	          ((type = nextProps[name]),
	          (lastDefaultValue = lastProps[name]),
	          nextProps.hasOwnProperty(name) &&
	            (null != type || null != lastDefaultValue))
	        )
	          switch (name) {
	            case "value":
	              propKey$205 = type;
	              break;
	            case "defaultValue":
	              defaultValue = type;
	              break;
	            case "multiple":
	              value = type;
	            default:
	              type !== lastDefaultValue &&
	                setProp(
	                  domElement,
	                  tag,
	                  name,
	                  type,
	                  nextProps,
	                  lastDefaultValue
	                );
	          }
	      tag = defaultValue;
	      lastProps = value;
	      nextProps = propKey;
	      null != propKey$205
	        ? updateOptions(domElement, !!lastProps, propKey$205, !1)
	        : !!nextProps !== !!lastProps &&
	          (null != tag
	            ? updateOptions(domElement, !!lastProps, tag, !0)
	            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
	      return;
	    case "textarea":
	      propKey = propKey$205 = null;
	      for (defaultValue in lastProps)
	        if (
	          ((name = lastProps[defaultValue]),
	          lastProps.hasOwnProperty(defaultValue) &&
	            null != name &&
	            !nextProps.hasOwnProperty(defaultValue))
	        )
	          switch (defaultValue) {
	            case "value":
	              break;
	            case "children":
	              break;
	            default:
	              setProp(domElement, tag, defaultValue, null, nextProps, name);
	          }
	      for (value in nextProps)
	        if (
	          ((name = nextProps[value]),
	          (type = lastProps[value]),
	          nextProps.hasOwnProperty(value) && (null != name || null != type))
	        )
	          switch (value) {
	            case "value":
	              propKey$205 = name;
	              break;
	            case "defaultValue":
	              propKey = name;
	              break;
	            case "children":
	              break;
	            case "dangerouslySetInnerHTML":
	              if (null != name) throw Error(formatProdErrorMessage$1(91));
	              break;
	            default:
	              name !== type &&
	                setProp(domElement, tag, value, name, nextProps, type);
	          }
	      updateTextarea(domElement, propKey$205, propKey);
	      return;
	    case "option":
	      for (var propKey$221 in lastProps)
	        if (
	          ((propKey$205 = lastProps[propKey$221]),
	          lastProps.hasOwnProperty(propKey$221) &&
	            null != propKey$205 &&
	            !nextProps.hasOwnProperty(propKey$221))
	        )
	          switch (propKey$221) {
	            case "selected":
	              domElement.selected = !1;
	              break;
	            default:
	              setProp(
	                domElement,
	                tag,
	                propKey$221,
	                null,
	                nextProps,
	                propKey$205
	              );
	          }
	      for (lastDefaultValue in nextProps)
	        if (
	          ((propKey$205 = nextProps[lastDefaultValue]),
	          (propKey = lastProps[lastDefaultValue]),
	          nextProps.hasOwnProperty(lastDefaultValue) &&
	            propKey$205 !== propKey &&
	            (null != propKey$205 || null != propKey))
	        )
	          switch (lastDefaultValue) {
	            case "selected":
	              domElement.selected =
	                propKey$205 &&
	                "function" !== typeof propKey$205 &&
	                "symbol" !== typeof propKey$205;
	              break;
	            default:
	              setProp(
	                domElement,
	                tag,
	                lastDefaultValue,
	                propKey$205,
	                nextProps,
	                propKey
	              );
	          }
	      return;
	    case "img":
	    case "link":
	    case "area":
	    case "base":
	    case "br":
	    case "col":
	    case "embed":
	    case "hr":
	    case "keygen":
	    case "meta":
	    case "param":
	    case "source":
	    case "track":
	    case "wbr":
	    case "menuitem":
	      for (var propKey$226 in lastProps)
	        (propKey$205 = lastProps[propKey$226]),
	          lastProps.hasOwnProperty(propKey$226) &&
	            null != propKey$205 &&
	            !nextProps.hasOwnProperty(propKey$226) &&
	            setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
	      for (checked in nextProps)
	        if (
	          ((propKey$205 = nextProps[checked]),
	          (propKey = lastProps[checked]),
	          nextProps.hasOwnProperty(checked) &&
	            propKey$205 !== propKey &&
	            (null != propKey$205 || null != propKey))
	        )
	          switch (checked) {
	            case "children":
	            case "dangerouslySetInnerHTML":
	              if (null != propKey$205)
	                throw Error(formatProdErrorMessage$1(137, tag));
	              break;
	            default:
	              setProp(
	                domElement,
	                tag,
	                checked,
	                propKey$205,
	                nextProps,
	                propKey
	              );
	          }
	      return;
	    default:
	      if (isCustomElement(tag)) {
	        for (var propKey$231 in lastProps)
	          (propKey$205 = lastProps[propKey$231]),
	            lastProps.hasOwnProperty(propKey$231) &&
	              void 0 !== propKey$205 &&
	              !nextProps.hasOwnProperty(propKey$231) &&
	              setPropOnCustomElement(
	                domElement,
	                tag,
	                propKey$231,
	                void 0,
	                nextProps,
	                propKey$205
	              );
	        for (defaultChecked in nextProps)
	          (propKey$205 = nextProps[defaultChecked]),
	            (propKey = lastProps[defaultChecked]),
	            !nextProps.hasOwnProperty(defaultChecked) ||
	              propKey$205 === propKey ||
	              (void 0 === propKey$205 && void 0 === propKey) ||
	              setPropOnCustomElement(
	                domElement,
	                tag,
	                defaultChecked,
	                propKey$205,
	                nextProps,
	                propKey
	              );
	        return;
	      }
	  }
	  for (var propKey$236 in lastProps)
	    (propKey$205 = lastProps[propKey$236]),
	      lastProps.hasOwnProperty(propKey$236) &&
	        null != propKey$205 &&
	        !nextProps.hasOwnProperty(propKey$236) &&
	        setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
	  for (lastProp in nextProps)
	    (propKey$205 = nextProps[lastProp]),
	      (propKey = lastProps[lastProp]),
	      !nextProps.hasOwnProperty(lastProp) ||
	        propKey$205 === propKey ||
	        (null == propKey$205 && null == propKey) ||
	        setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
	}
	var eventsEnabled = null,
	  selectionInformation = null;
	function getOwnerDocumentFromRootContainer(rootContainerElement) {
	  return 9 === rootContainerElement.nodeType
	    ? rootContainerElement
	    : rootContainerElement.ownerDocument;
	}
	function getOwnHostContext(namespaceURI) {
	  switch (namespaceURI) {
	    case "http://www.w3.org/2000/svg":
	      return 1;
	    case "http://www.w3.org/1998/Math/MathML":
	      return 2;
	    default:
	      return 0;
	  }
	}
	function getChildHostContextProd(parentNamespace, type) {
	  if (0 === parentNamespace)
	    switch (type) {
	      case "svg":
	        return 1;
	      case "math":
	        return 2;
	      default:
	        return 0;
	    }
	  return 1 === parentNamespace && "foreignObject" === type
	    ? 0
	    : parentNamespace;
	}
	function shouldSetTextContent(type, props) {
	  return (
	    "textarea" === type ||
	    "noscript" === type ||
	    "string" === typeof props.children ||
	    "number" === typeof props.children ||
	    "bigint" === typeof props.children ||
	    ("object" === typeof props.dangerouslySetInnerHTML &&
	      null !== props.dangerouslySetInnerHTML &&
	      null != props.dangerouslySetInnerHTML.__html)
	  );
	}
	var currentPopstateTransitionEvent = null;
	function shouldAttemptEagerTransition() {
	  var event = window.event;
	  if (event && "popstate" === event.type) {
	    if (event === currentPopstateTransitionEvent) return !1;
	    currentPopstateTransitionEvent = event;
	    return !0;
	  }
	  currentPopstateTransitionEvent = null;
	  return !1;
	}
	var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
	  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
	  localPromise = "function" === typeof Promise ? Promise : void 0,
	  scheduleMicrotask =
	    "function" === typeof queueMicrotask
	      ? queueMicrotask
	      : "undefined" !== typeof localPromise
	        ? function (callback) {
	            return localPromise
	              .resolve(null)
	              .then(callback)
	              .catch(handleErrorInNextTick);
	          }
	        : scheduleTimeout;
	function handleErrorInNextTick(error) {
	  setTimeout(function () {
	    throw error;
	  });
	}
	function isSingletonScope(type) {
	  return "head" === type;
	}
	function clearSuspenseBoundary(parentInstance, suspenseInstance) {
	  var node = suspenseInstance,
	    possiblePreambleContribution = 0,
	    depth = 0;
	  do {
	    var nextNode = node.nextSibling;
	    parentInstance.removeChild(node);
	    if (nextNode && 8 === nextNode.nodeType)
	      if (((node = nextNode.data), "/$" === node)) {
	        if (
	          0 < possiblePreambleContribution &&
	          8 > possiblePreambleContribution
	        ) {
	          node = possiblePreambleContribution;
	          var ownerDocument = parentInstance.ownerDocument;
	          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
	          node & 2 && releaseSingletonInstance(ownerDocument.body);
	          if (node & 4)
	            for (
	              node = ownerDocument.head,
	                releaseSingletonInstance(node),
	                ownerDocument = node.firstChild;
	              ownerDocument;

	            ) {
	              var nextNode$jscomp$0 = ownerDocument.nextSibling,
	                nodeName = ownerDocument.nodeName;
	              ownerDocument[internalHoistableMarker] ||
	                "SCRIPT" === nodeName ||
	                "STYLE" === nodeName ||
	                ("LINK" === nodeName &&
	                  "stylesheet" === ownerDocument.rel.toLowerCase()) ||
	                node.removeChild(ownerDocument);
	              ownerDocument = nextNode$jscomp$0;
	            }
	        }
	        if (0 === depth) {
	          parentInstance.removeChild(nextNode);
	          retryIfBlockedOn(suspenseInstance);
	          return;
	        }
	        depth--;
	      } else
	        "$" === node || "$?" === node || "$!" === node
	          ? depth++
	          : (possiblePreambleContribution = node.charCodeAt(0) - 48);
	    else possiblePreambleContribution = 0;
	    node = nextNode;
	  } while (node);
	  retryIfBlockedOn(suspenseInstance);
	}
	function clearContainerSparingly(container) {
	  var nextNode = container.firstChild;
	  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
	  for (; nextNode; ) {
	    var node = nextNode;
	    nextNode = nextNode.nextSibling;
	    switch (node.nodeName) {
	      case "HTML":
	      case "HEAD":
	      case "BODY":
	        clearContainerSparingly(node);
	        detachDeletedInstance(node);
	        continue;
	      case "SCRIPT":
	      case "STYLE":
	        continue;
	      case "LINK":
	        if ("stylesheet" === node.rel.toLowerCase()) continue;
	    }
	    container.removeChild(node);
	  }
	}
	function canHydrateInstance(instance, type, props, inRootOrSingleton) {
	  for (; 1 === instance.nodeType; ) {
	    var anyProps = props;
	    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
	      if (
	        !inRootOrSingleton &&
	        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
	      )
	        break;
	    } else if (!inRootOrSingleton)
	      if ("input" === type && "hidden" === instance.type) {
	        var name = null == anyProps.name ? null : "" + anyProps.name;
	        if (
	          "hidden" === anyProps.type &&
	          instance.getAttribute("name") === name
	        )
	          return instance;
	      } else return instance;
	    else if (!instance[internalHoistableMarker])
	      switch (type) {
	        case "meta":
	          if (!instance.hasAttribute("itemprop")) break;
	          return instance;
	        case "link":
	          name = instance.getAttribute("rel");
	          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
	            break;
	          else if (
	            name !== anyProps.rel ||
	            instance.getAttribute("href") !==
	              (null == anyProps.href || "" === anyProps.href
	                ? null
	                : anyProps.href) ||
	            instance.getAttribute("crossorigin") !==
	              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
	            instance.getAttribute("title") !==
	              (null == anyProps.title ? null : anyProps.title)
	          )
	            break;
	          return instance;
	        case "style":
	          if (instance.hasAttribute("data-precedence")) break;
	          return instance;
	        case "script":
	          name = instance.getAttribute("src");
	          if (
	            (name !== (null == anyProps.src ? null : anyProps.src) ||
	              instance.getAttribute("type") !==
	                (null == anyProps.type ? null : anyProps.type) ||
	              instance.getAttribute("crossorigin") !==
	                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
	            name &&
	            instance.hasAttribute("async") &&
	            !instance.hasAttribute("itemprop")
	          )
	            break;
	          return instance;
	        default:
	          return instance;
	      }
	    instance = getNextHydratable(instance.nextSibling);
	    if (null === instance) break;
	  }
	  return null;
	}
	function canHydrateTextInstance(instance, text, inRootOrSingleton) {
	  if ("" === text) return null;
	  for (; 3 !== instance.nodeType; ) {
	    if (
	      (1 !== instance.nodeType ||
	        "INPUT" !== instance.nodeName ||
	        "hidden" !== instance.type) &&
	      !inRootOrSingleton
	    )
	      return null;
	    instance = getNextHydratable(instance.nextSibling);
	    if (null === instance) return null;
	  }
	  return instance;
	}
	function isSuspenseInstanceFallback(instance) {
	  return (
	    "$!" === instance.data ||
	    ("$?" === instance.data && "complete" === instance.ownerDocument.readyState)
	  );
	}
	function registerSuspenseInstanceRetry(instance, callback) {
	  var ownerDocument = instance.ownerDocument;
	  if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
	    callback();
	  else {
	    var listener = function () {
	      callback();
	      ownerDocument.removeEventListener("DOMContentLoaded", listener);
	    };
	    ownerDocument.addEventListener("DOMContentLoaded", listener);
	    instance._reactRetry = listener;
	  }
	}
	function getNextHydratable(node) {
	  for (; null != node; node = node.nextSibling) {
	    var nodeType = node.nodeType;
	    if (1 === nodeType || 3 === nodeType) break;
	    if (8 === nodeType) {
	      nodeType = node.data;
	      if (
	        "$" === nodeType ||
	        "$!" === nodeType ||
	        "$?" === nodeType ||
	        "F!" === nodeType ||
	        "F" === nodeType
	      )
	        break;
	      if ("/$" === nodeType) return null;
	    }
	  }
	  return node;
	}
	var previousHydratableOnEnteringScopedSingleton = null;
	function getParentSuspenseInstance(targetInstance) {
	  targetInstance = targetInstance.previousSibling;
	  for (var depth = 0; targetInstance; ) {
	    if (8 === targetInstance.nodeType) {
	      var data = targetInstance.data;
	      if ("$" === data || "$!" === data || "$?" === data) {
	        if (0 === depth) return targetInstance;
	        depth--;
	      } else "/$" === data && depth++;
	    }
	    targetInstance = targetInstance.previousSibling;
	  }
	  return null;
	}
	function resolveSingletonInstance(type, props, rootContainerInstance) {
	  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
	  switch (type) {
	    case "html":
	      type = props.documentElement;
	      if (!type) throw Error(formatProdErrorMessage$1(452));
	      return type;
	    case "head":
	      type = props.head;
	      if (!type) throw Error(formatProdErrorMessage$1(453));
	      return type;
	    case "body":
	      type = props.body;
	      if (!type) throw Error(formatProdErrorMessage$1(454));
	      return type;
	    default:
	      throw Error(formatProdErrorMessage$1(451));
	  }
	}
	function releaseSingletonInstance(instance) {
	  for (var attributes = instance.attributes; attributes.length; )
	    instance.removeAttributeNode(attributes[0]);
	  detachDeletedInstance(instance);
	}
	var preloadPropsMap = new Map(),
	  preconnectsSet = new Set();
	function getHoistableRoot(container) {
	  return "function" === typeof container.getRootNode
	    ? container.getRootNode()
	    : 9 === container.nodeType
	      ? container
	      : container.ownerDocument;
	}
	var previousDispatcher = ReactDOMSharedInternals.d;
	ReactDOMSharedInternals.d = {
	  f: flushSyncWork,
	  r: requestFormReset,
	  D: prefetchDNS,
	  C: preconnect,
	  L: preload,
	  m: preloadModule,
	  X: preinitScript,
	  S: preinitStyle,
	  M: preinitModuleScript
	};
	function flushSyncWork() {
	  var previousWasRendering = previousDispatcher.f(),
	    wasRendering = flushSyncWork$1();
	  return previousWasRendering || wasRendering;
	}
	function requestFormReset(form) {
	  var formInst = getInstanceFromNode(form);
	  null !== formInst && 5 === formInst.tag && "form" === formInst.type
	    ? requestFormReset$1(formInst)
	    : previousDispatcher.r(form);
	}
	var globalDocument = "undefined" === typeof document ? null : document;
	function preconnectAs(rel, href, crossOrigin) {
	  var ownerDocument = globalDocument;
	  if (ownerDocument && "string" === typeof href && href) {
	    var limitedEscapedHref =
	      escapeSelectorAttributeValueInsideDoubleQuotes(href);
	    limitedEscapedHref =
	      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
	    "string" === typeof crossOrigin &&
	      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
	    preconnectsSet.has(limitedEscapedHref) ||
	      (preconnectsSet.add(limitedEscapedHref),
	      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
	      null === ownerDocument.querySelector(limitedEscapedHref) &&
	        ((href = ownerDocument.createElement("link")),
	        setInitialProperties(href, "link", rel),
	        markNodeAsHoistable(href),
	        ownerDocument.head.appendChild(href)));
	  }
	}
	function prefetchDNS(href) {
	  previousDispatcher.D(href);
	  preconnectAs("dns-prefetch", href, null);
	}
	function preconnect(href, crossOrigin) {
	  previousDispatcher.C(href, crossOrigin);
	  preconnectAs("preconnect", href, crossOrigin);
	}
	function preload(href, as, options) {
	  previousDispatcher.L(href, as, options);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && href && as) {
	    var preloadSelector =
	      'link[rel="preload"][as="' +
	      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
	      '"]';
	    "image" === as
	      ? options && options.imageSrcSet
	        ? ((preloadSelector +=
	            '[imagesrcset="' +
	            escapeSelectorAttributeValueInsideDoubleQuotes(
	              options.imageSrcSet
	            ) +
	            '"]'),
	          "string" === typeof options.imageSizes &&
	            (preloadSelector +=
	              '[imagesizes="' +
	              escapeSelectorAttributeValueInsideDoubleQuotes(
	                options.imageSizes
	              ) +
	              '"]'))
	        : (preloadSelector +=
	            '[href="' +
	            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
	            '"]')
	      : (preloadSelector +=
	          '[href="' +
	          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
	          '"]');
	    var key = preloadSelector;
	    switch (as) {
	      case "style":
	        key = getStyleKey(href);
	        break;
	      case "script":
	        key = getScriptKey(href);
	    }
	    preloadPropsMap.has(key) ||
	      ((href = assign(
	        {
	          rel: "preload",
	          href:
	            "image" === as && options && options.imageSrcSet ? void 0 : href,
	          as: as
	        },
	        options
	      )),
	      preloadPropsMap.set(key, href),
	      null !== ownerDocument.querySelector(preloadSelector) ||
	        ("style" === as &&
	          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
	        ("script" === as &&
	          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
	        ((as = ownerDocument.createElement("link")),
	        setInitialProperties(as, "link", href),
	        markNodeAsHoistable(as),
	        ownerDocument.head.appendChild(as)));
	  }
	}
	function preloadModule(href, options) {
	  previousDispatcher.m(href, options);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && href) {
	    var as = options && "string" === typeof options.as ? options.as : "script",
	      preloadSelector =
	        'link[rel="modulepreload"][as="' +
	        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
	        '"][href="' +
	        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
	        '"]',
	      key = preloadSelector;
	    switch (as) {
	      case "audioworklet":
	      case "paintworklet":
	      case "serviceworker":
	      case "sharedworker":
	      case "worker":
	      case "script":
	        key = getScriptKey(href);
	    }
	    if (
	      !preloadPropsMap.has(key) &&
	      ((href = assign({ rel: "modulepreload", href: href }, options)),
	      preloadPropsMap.set(key, href),
	      null === ownerDocument.querySelector(preloadSelector))
	    ) {
	      switch (as) {
	        case "audioworklet":
	        case "paintworklet":
	        case "serviceworker":
	        case "sharedworker":
	        case "worker":
	        case "script":
	          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
	            return;
	      }
	      as = ownerDocument.createElement("link");
	      setInitialProperties(as, "link", href);
	      markNodeAsHoistable(as);
	      ownerDocument.head.appendChild(as);
	    }
	  }
	}
	function preinitStyle(href, precedence, options) {
	  previousDispatcher.S(href, precedence, options);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && href) {
	    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
	      key = getStyleKey(href);
	    precedence = precedence || "default";
	    var resource = styles.get(key);
	    if (!resource) {
	      var state = { loading: 0, preload: null };
	      if (
	        (resource = ownerDocument.querySelector(
	          getStylesheetSelectorFromKey(key)
	        ))
	      )
	        state.loading = 5;
	      else {
	        href = assign(
	          { rel: "stylesheet", href: href, "data-precedence": precedence },
	          options
	        );
	        (options = preloadPropsMap.get(key)) &&
	          adoptPreloadPropsForStylesheet(href, options);
	        var link = (resource = ownerDocument.createElement("link"));
	        markNodeAsHoistable(link);
	        setInitialProperties(link, "link", href);
	        link._p = new Promise(function (resolve, reject) {
	          link.onload = resolve;
	          link.onerror = reject;
	        });
	        link.addEventListener("load", function () {
	          state.loading |= 1;
	        });
	        link.addEventListener("error", function () {
	          state.loading |= 2;
	        });
	        state.loading |= 4;
	        insertStylesheet(resource, precedence, ownerDocument);
	      }
	      resource = {
	        type: "stylesheet",
	        instance: resource,
	        count: 1,
	        state: state
	      };
	      styles.set(key, resource);
	    }
	  }
	}
	function preinitScript(src, options) {
	  previousDispatcher.X(src, options);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && src) {
	    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
	      key = getScriptKey(src),
	      resource = scripts.get(key);
	    resource ||
	      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
	      resource ||
	        ((src = assign({ src: src, async: !0 }, options)),
	        (options = preloadPropsMap.get(key)) &&
	          adoptPreloadPropsForScript(src, options),
	        (resource = ownerDocument.createElement("script")),
	        markNodeAsHoistable(resource),
	        setInitialProperties(resource, "link", src),
	        ownerDocument.head.appendChild(resource)),
	      (resource = {
	        type: "script",
	        instance: resource,
	        count: 1,
	        state: null
	      }),
	      scripts.set(key, resource));
	  }
	}
	function preinitModuleScript(src, options) {
	  previousDispatcher.M(src, options);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && src) {
	    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
	      key = getScriptKey(src),
	      resource = scripts.get(key);
	    resource ||
	      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
	      resource ||
	        ((src = assign({ src: src, async: !0, type: "module" }, options)),
	        (options = preloadPropsMap.get(key)) &&
	          adoptPreloadPropsForScript(src, options),
	        (resource = ownerDocument.createElement("script")),
	        markNodeAsHoistable(resource),
	        setInitialProperties(resource, "link", src),
	        ownerDocument.head.appendChild(resource)),
	      (resource = {
	        type: "script",
	        instance: resource,
	        count: 1,
	        state: null
	      }),
	      scripts.set(key, resource));
	  }
	}
	function getResource(type, currentProps, pendingProps, currentResource) {
	  var JSCompiler_inline_result = (JSCompiler_inline_result =
	    rootInstanceStackCursor.current)
	    ? getHoistableRoot(JSCompiler_inline_result)
	    : null;
	  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage$1(446));
	  switch (type) {
	    case "meta":
	    case "title":
	      return null;
	    case "style":
	      return "string" === typeof pendingProps.precedence &&
	        "string" === typeof pendingProps.href
	        ? ((currentProps = getStyleKey(pendingProps.href)),
	          (pendingProps = getResourcesFromRoot(
	            JSCompiler_inline_result
	          ).hoistableStyles),
	          (currentResource = pendingProps.get(currentProps)),
	          currentResource ||
	            ((currentResource = {
	              type: "style",
	              instance: null,
	              count: 0,
	              state: null
	            }),
	            pendingProps.set(currentProps, currentResource)),
	          currentResource)
	        : { type: "void", instance: null, count: 0, state: null };
	    case "link":
	      if (
	        "stylesheet" === pendingProps.rel &&
	        "string" === typeof pendingProps.href &&
	        "string" === typeof pendingProps.precedence
	      ) {
	        type = getStyleKey(pendingProps.href);
	        var styles$244 = getResourcesFromRoot(
	            JSCompiler_inline_result
	          ).hoistableStyles,
	          resource$245 = styles$244.get(type);
	        resource$245 ||
	          ((JSCompiler_inline_result =
	            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
	          (resource$245 = {
	            type: "stylesheet",
	            instance: null,
	            count: 0,
	            state: { loading: 0, preload: null }
	          }),
	          styles$244.set(type, resource$245),
	          (styles$244 = JSCompiler_inline_result.querySelector(
	            getStylesheetSelectorFromKey(type)
	          )) &&
	            !styles$244._p &&
	            ((resource$245.instance = styles$244),
	            (resource$245.state.loading = 5)),
	          preloadPropsMap.has(type) ||
	            ((pendingProps = {
	              rel: "preload",
	              as: "style",
	              href: pendingProps.href,
	              crossOrigin: pendingProps.crossOrigin,
	              integrity: pendingProps.integrity,
	              media: pendingProps.media,
	              hrefLang: pendingProps.hrefLang,
	              referrerPolicy: pendingProps.referrerPolicy
	            }),
	            preloadPropsMap.set(type, pendingProps),
	            styles$244 ||
	              preloadStylesheet(
	                JSCompiler_inline_result,
	                type,
	                pendingProps,
	                resource$245.state
	              )));
	        if (currentProps && null === currentResource)
	          throw Error(formatProdErrorMessage$1(528, ""));
	        return resource$245;
	      }
	      if (currentProps && null !== currentResource)
	        throw Error(formatProdErrorMessage$1(529, ""));
	      return null;
	    case "script":
	      return (
	        (currentProps = pendingProps.async),
	        (pendingProps = pendingProps.src),
	        "string" === typeof pendingProps &&
	        currentProps &&
	        "function" !== typeof currentProps &&
	        "symbol" !== typeof currentProps
	          ? ((currentProps = getScriptKey(pendingProps)),
	            (pendingProps = getResourcesFromRoot(
	              JSCompiler_inline_result
	            ).hoistableScripts),
	            (currentResource = pendingProps.get(currentProps)),
	            currentResource ||
	              ((currentResource = {
	                type: "script",
	                instance: null,
	                count: 0,
	                state: null
	              }),
	              pendingProps.set(currentProps, currentResource)),
	            currentResource)
	          : { type: "void", instance: null, count: 0, state: null }
	      );
	    default:
	      throw Error(formatProdErrorMessage$1(444, type));
	  }
	}
	function getStyleKey(href) {
	  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
	}
	function getStylesheetSelectorFromKey(key) {
	  return 'link[rel="stylesheet"][' + key + "]";
	}
	function stylesheetPropsFromRawProps(rawProps) {
	  return assign({}, rawProps, {
	    "data-precedence": rawProps.precedence,
	    precedence: null
	  });
	}
	function preloadStylesheet(ownerDocument, key, preloadProps, state) {
	  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
	    ? (state.loading = 1)
	    : ((key = ownerDocument.createElement("link")),
	      (state.preload = key),
	      key.addEventListener("load", function () {
	        return (state.loading |= 1);
	      }),
	      key.addEventListener("error", function () {
	        return (state.loading |= 2);
	      }),
	      setInitialProperties(key, "link", preloadProps),
	      markNodeAsHoistable(key),
	      ownerDocument.head.appendChild(key));
	}
	function getScriptKey(src) {
	  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
	}
	function getScriptSelectorFromKey(key) {
	  return "script[async]" + key;
	}
	function acquireResource(hoistableRoot, resource, props) {
	  resource.count++;
	  if (null === resource.instance)
	    switch (resource.type) {
	      case "style":
	        var instance = hoistableRoot.querySelector(
	          'style[data-href~="' +
	            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
	            '"]'
	        );
	        if (instance)
	          return (
	            (resource.instance = instance),
	            markNodeAsHoistable(instance),
	            instance
	          );
	        var styleProps = assign({}, props, {
	          "data-href": props.href,
	          "data-precedence": props.precedence,
	          href: null,
	          precedence: null
	        });
	        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
	          "style"
	        );
	        markNodeAsHoistable(instance);
	        setInitialProperties(instance, "style", styleProps);
	        insertStylesheet(instance, props.precedence, hoistableRoot);
	        return (resource.instance = instance);
	      case "stylesheet":
	        styleProps = getStyleKey(props.href);
	        var instance$250 = hoistableRoot.querySelector(
	          getStylesheetSelectorFromKey(styleProps)
	        );
	        if (instance$250)
	          return (
	            (resource.state.loading |= 4),
	            (resource.instance = instance$250),
	            markNodeAsHoistable(instance$250),
	            instance$250
	          );
	        instance = stylesheetPropsFromRawProps(props);
	        (styleProps = preloadPropsMap.get(styleProps)) &&
	          adoptPreloadPropsForStylesheet(instance, styleProps);
	        instance$250 = (
	          hoistableRoot.ownerDocument || hoistableRoot
	        ).createElement("link");
	        markNodeAsHoistable(instance$250);
	        var linkInstance = instance$250;
	        linkInstance._p = new Promise(function (resolve, reject) {
	          linkInstance.onload = resolve;
	          linkInstance.onerror = reject;
	        });
	        setInitialProperties(instance$250, "link", instance);
	        resource.state.loading |= 4;
	        insertStylesheet(instance$250, props.precedence, hoistableRoot);
	        return (resource.instance = instance$250);
	      case "script":
	        instance$250 = getScriptKey(props.src);
	        if (
	          (styleProps = hoistableRoot.querySelector(
	            getScriptSelectorFromKey(instance$250)
	          ))
	        )
	          return (
	            (resource.instance = styleProps),
	            markNodeAsHoistable(styleProps),
	            styleProps
	          );
	        instance = props;
	        if ((styleProps = preloadPropsMap.get(instance$250)))
	          (instance = assign({}, props)),
	            adoptPreloadPropsForScript(instance, styleProps);
	        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	        styleProps = hoistableRoot.createElement("script");
	        markNodeAsHoistable(styleProps);
	        setInitialProperties(styleProps, "link", instance);
	        hoistableRoot.head.appendChild(styleProps);
	        return (resource.instance = styleProps);
	      case "void":
	        return null;
	      default:
	        throw Error(formatProdErrorMessage$1(443, resource.type));
	    }
	  else
	    "stylesheet" === resource.type &&
	      0 === (resource.state.loading & 4) &&
	      ((instance = resource.instance),
	      (resource.state.loading |= 4),
	      insertStylesheet(instance, props.precedence, hoistableRoot));
	  return resource.instance;
	}
	function insertStylesheet(instance, precedence, root) {
	  for (
	    var nodes = root.querySelectorAll(
	        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
	      ),
	      last = nodes.length ? nodes[nodes.length - 1] : null,
	      prior = last,
	      i = 0;
	    i < nodes.length;
	    i++
	  ) {
	    var node = nodes[i];
	    if (node.dataset.precedence === precedence) prior = node;
	    else if (prior !== last) break;
	  }
	  prior
	    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
	    : ((precedence = 9 === root.nodeType ? root.head : root),
	      precedence.insertBefore(instance, precedence.firstChild));
	}
	function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
	  null == stylesheetProps.crossOrigin &&
	    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
	  null == stylesheetProps.referrerPolicy &&
	    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
	  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
	}
	function adoptPreloadPropsForScript(scriptProps, preloadProps) {
	  null == scriptProps.crossOrigin &&
	    (scriptProps.crossOrigin = preloadProps.crossOrigin);
	  null == scriptProps.referrerPolicy &&
	    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
	  null == scriptProps.integrity &&
	    (scriptProps.integrity = preloadProps.integrity);
	}
	var tagCaches = null;
	function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
	  if (null === tagCaches) {
	    var cache = new Map();
	    var caches = (tagCaches = new Map());
	    caches.set(ownerDocument, cache);
	  } else
	    (caches = tagCaches),
	      (cache = caches.get(ownerDocument)),
	      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
	  if (cache.has(type)) return cache;
	  cache.set(type, null);
	  ownerDocument = ownerDocument.getElementsByTagName(type);
	  for (caches = 0; caches < ownerDocument.length; caches++) {
	    var node = ownerDocument[caches];
	    if (
	      !(
	        node[internalHoistableMarker] ||
	        node[internalInstanceKey] ||
	        ("link" === type && "stylesheet" === node.getAttribute("rel"))
	      ) &&
	      "http://www.w3.org/2000/svg" !== node.namespaceURI
	    ) {
	      var nodeKey = node.getAttribute(keyAttribute) || "";
	      nodeKey = type + nodeKey;
	      var existing = cache.get(nodeKey);
	      existing ? existing.push(node) : cache.set(nodeKey, [node]);
	    }
	  }
	  return cache;
	}
	function mountHoistable(hoistableRoot, type, instance) {
	  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	  hoistableRoot.head.insertBefore(
	    instance,
	    "title" === type ? hoistableRoot.querySelector("head > title") : null
	  );
	}
	function isHostHoistableType(type, props, hostContext) {
	  if (1 === hostContext || null != props.itemProp) return !1;
	  switch (type) {
	    case "meta":
	    case "title":
	      return !0;
	    case "style":
	      if (
	        "string" !== typeof props.precedence ||
	        "string" !== typeof props.href ||
	        "" === props.href
	      )
	        break;
	      return !0;
	    case "link":
	      if (
	        "string" !== typeof props.rel ||
	        "string" !== typeof props.href ||
	        "" === props.href ||
	        props.onLoad ||
	        props.onError
	      )
	        break;
	      switch (props.rel) {
	        case "stylesheet":
	          return (
	            (type = props.disabled),
	            "string" === typeof props.precedence && null == type
	          );
	        default:
	          return !0;
	      }
	    case "script":
	      if (
	        props.async &&
	        "function" !== typeof props.async &&
	        "symbol" !== typeof props.async &&
	        !props.onLoad &&
	        !props.onError &&
	        props.src &&
	        "string" === typeof props.src
	      )
	        return !0;
	  }
	  return !1;
	}
	function preloadResource(resource) {
	  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
	    ? !1
	    : !0;
	}
	var suspendedState = null;
	function noop$4() {}
	function suspendResource(hoistableRoot, resource, props) {
	  if (null === suspendedState) throw Error(formatProdErrorMessage$1(475));
	  var state = suspendedState;
	  if (
	    "stylesheet" === resource.type &&
	    ("string" !== typeof props.media ||
	      !1 !== matchMedia(props.media).matches) &&
	    0 === (resource.state.loading & 4)
	  ) {
	    if (null === resource.instance) {
	      var key = getStyleKey(props.href),
	        instance = hoistableRoot.querySelector(
	          getStylesheetSelectorFromKey(key)
	        );
	      if (instance) {
	        hoistableRoot = instance._p;
	        null !== hoistableRoot &&
	          "object" === typeof hoistableRoot &&
	          "function" === typeof hoistableRoot.then &&
	          (state.count++,
	          (state = onUnsuspend.bind(state)),
	          hoistableRoot.then(state, state));
	        resource.state.loading |= 4;
	        resource.instance = instance;
	        markNodeAsHoistable(instance);
	        return;
	      }
	      instance = hoistableRoot.ownerDocument || hoistableRoot;
	      props = stylesheetPropsFromRawProps(props);
	      (key = preloadPropsMap.get(key)) &&
	        adoptPreloadPropsForStylesheet(props, key);
	      instance = instance.createElement("link");
	      markNodeAsHoistable(instance);
	      var linkInstance = instance;
	      linkInstance._p = new Promise(function (resolve, reject) {
	        linkInstance.onload = resolve;
	        linkInstance.onerror = reject;
	      });
	      setInitialProperties(instance, "link", props);
	      resource.instance = instance;
	    }
	    null === state.stylesheets && (state.stylesheets = new Map());
	    state.stylesheets.set(resource, hoistableRoot);
	    (hoistableRoot = resource.state.preload) &&
	      0 === (resource.state.loading & 3) &&
	      (state.count++,
	      (resource = onUnsuspend.bind(state)),
	      hoistableRoot.addEventListener("load", resource),
	      hoistableRoot.addEventListener("error", resource));
	  }
	}
	function waitForCommitToBeReady() {
	  if (null === suspendedState) throw Error(formatProdErrorMessage$1(475));
	  var state = suspendedState;
	  state.stylesheets &&
	    0 === state.count &&
	    insertSuspendedStylesheets(state, state.stylesheets);
	  return 0 < state.count
	    ? function (commit) {
	        var stylesheetTimer = setTimeout(function () {
	          state.stylesheets &&
	            insertSuspendedStylesheets(state, state.stylesheets);
	          if (state.unsuspend) {
	            var unsuspend = state.unsuspend;
	            state.unsuspend = null;
	            unsuspend();
	          }
	        }, 6e4);
	        state.unsuspend = commit;
	        return function () {
	          state.unsuspend = null;
	          clearTimeout(stylesheetTimer);
	        };
	      }
	    : null;
	}
	function onUnsuspend() {
	  this.count--;
	  if (0 === this.count)
	    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
	    else if (this.unsuspend) {
	      var unsuspend = this.unsuspend;
	      this.unsuspend = null;
	      unsuspend();
	    }
	}
	var precedencesByRoot = null;
	function insertSuspendedStylesheets(state, resources) {
	  state.stylesheets = null;
	  null !== state.unsuspend &&
	    (state.count++,
	    (precedencesByRoot = new Map()),
	    resources.forEach(insertStylesheetIntoRoot, state),
	    (precedencesByRoot = null),
	    onUnsuspend.call(state));
	}
	function insertStylesheetIntoRoot(root, resource) {
	  if (!(resource.state.loading & 4)) {
	    var precedences = precedencesByRoot.get(root);
	    if (precedences) var last = precedences.get(null);
	    else {
	      precedences = new Map();
	      precedencesByRoot.set(root, precedences);
	      for (
	        var nodes = root.querySelectorAll(
	            "link[data-precedence],style[data-precedence]"
	          ),
	          i = 0;
	        i < nodes.length;
	        i++
	      ) {
	        var node = nodes[i];
	        if (
	          "LINK" === node.nodeName ||
	          "not all" !== node.getAttribute("media")
	        )
	          precedences.set(node.dataset.precedence, node), (last = node);
	      }
	      last && precedences.set(null, last);
	    }
	    nodes = resource.instance;
	    node = nodes.getAttribute("data-precedence");
	    i = precedences.get(node) || last;
	    i === last && precedences.set(null, nodes);
	    precedences.set(node, nodes);
	    this.count++;
	    last = onUnsuspend.bind(this);
	    nodes.addEventListener("load", last);
	    nodes.addEventListener("error", last);
	    i
	      ? i.parentNode.insertBefore(nodes, i.nextSibling)
	      : ((root = 9 === root.nodeType ? root.head : root),
	        root.insertBefore(nodes, root.firstChild));
	    resource.state.loading |= 4;
	  }
	}
	var HostTransitionContext = {
	  $$typeof: REACT_CONTEXT_TYPE,
	  Provider: null,
	  Consumer: null,
	  _currentValue: sharedNotPendingObject,
	  _currentValue2: sharedNotPendingObject,
	  _threadCount: 0
	};
	function FiberRootNode(
	  containerInfo,
	  tag,
	  hydrate,
	  identifierPrefix,
	  onUncaughtError,
	  onCaughtError,
	  onRecoverableError,
	  formState
	) {
	  this.tag = 1;
	  this.containerInfo = containerInfo;
	  this.pingCache = this.current = this.pendingChildren = null;
	  this.timeoutHandle = -1;
	  this.callbackNode =
	    this.next =
	    this.pendingContext =
	    this.context =
	    this.cancelPendingCommit =
	      null;
	  this.callbackPriority = 0;
	  this.expirationTimes = createLaneMap(-1);
	  this.entangledLanes =
	    this.shellSuspendCounter =
	    this.errorRecoveryDisabledLanes =
	    this.expiredLanes =
	    this.warmLanes =
	    this.pingedLanes =
	    this.suspendedLanes =
	    this.pendingLanes =
	      0;
	  this.entanglements = createLaneMap(0);
	  this.hiddenUpdates = createLaneMap(null);
	  this.identifierPrefix = identifierPrefix;
	  this.onUncaughtError = onUncaughtError;
	  this.onCaughtError = onCaughtError;
	  this.onRecoverableError = onRecoverableError;
	  this.pooledCache = null;
	  this.pooledCacheLanes = 0;
	  this.formState = formState;
	  this.incompleteTransitions = new Map();
	}
	function createFiberRoot(
	  containerInfo,
	  tag,
	  hydrate,
	  initialChildren,
	  hydrationCallbacks,
	  isStrictMode,
	  identifierPrefix,
	  onUncaughtError,
	  onCaughtError,
	  onRecoverableError,
	  transitionCallbacks,
	  formState
	) {
	  containerInfo = new FiberRootNode(
	    containerInfo,
	    tag,
	    hydrate,
	    identifierPrefix,
	    onUncaughtError,
	    onCaughtError,
	    onRecoverableError,
	    formState
	  );
	  tag = 1;
	  !0 === isStrictMode && (tag |= 24);
	  isStrictMode = createFiberImplClass(3, null, null, tag);
	  containerInfo.current = isStrictMode;
	  isStrictMode.stateNode = containerInfo;
	  tag = createCache();
	  tag.refCount++;
	  containerInfo.pooledCache = tag;
	  tag.refCount++;
	  isStrictMode.memoizedState = {
	    element: initialChildren,
	    isDehydrated: hydrate,
	    cache: tag
	  };
	  initializeUpdateQueue(isStrictMode);
	  return containerInfo;
	}
	function getContextForSubtree(parentComponent) {
	  if (!parentComponent) return emptyContextObject;
	  parentComponent = emptyContextObject;
	  return parentComponent;
	}
	function updateContainerImpl(
	  rootFiber,
	  lane,
	  element,
	  container,
	  parentComponent,
	  callback
	) {
	  parentComponent = getContextForSubtree(parentComponent);
	  null === container.context
	    ? (container.context = parentComponent)
	    : (container.pendingContext = parentComponent);
	  container = createUpdate(lane);
	  container.payload = { element: element };
	  callback = void 0 === callback ? null : callback;
	  null !== callback && (container.callback = callback);
	  element = enqueueUpdate(rootFiber, container, lane);
	  null !== element &&
	    (scheduleUpdateOnFiber(element, rootFiber, lane),
	    entangleTransitions(element, rootFiber, lane));
	}
	function markRetryLaneImpl(fiber, retryLane) {
	  fiber = fiber.memoizedState;
	  if (null !== fiber && null !== fiber.dehydrated) {
	    var a = fiber.retryLane;
	    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
	  }
	}
	function markRetryLaneIfNotHydrated(fiber, retryLane) {
	  markRetryLaneImpl(fiber, retryLane);
	  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
	}
	function attemptContinuousHydration(fiber) {
	  if (13 === fiber.tag) {
	    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
	    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
	    markRetryLaneIfNotHydrated(fiber, 67108864);
	  }
	}
	var _enabled = !0;
	function dispatchDiscreteEvent(
	  domEventName,
	  eventSystemFlags,
	  container,
	  nativeEvent
	) {
	  var prevTransition = ReactSharedInternals.T;
	  ReactSharedInternals.T = null;
	  var previousPriority = ReactDOMSharedInternals.p;
	  try {
	    (ReactDOMSharedInternals.p = 2),
	      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
	  } finally {
	    (ReactDOMSharedInternals.p = previousPriority),
	      (ReactSharedInternals.T = prevTransition);
	  }
	}
	function dispatchContinuousEvent(
	  domEventName,
	  eventSystemFlags,
	  container,
	  nativeEvent
	) {
	  var prevTransition = ReactSharedInternals.T;
	  ReactSharedInternals.T = null;
	  var previousPriority = ReactDOMSharedInternals.p;
	  try {
	    (ReactDOMSharedInternals.p = 8),
	      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
	  } finally {
	    (ReactDOMSharedInternals.p = previousPriority),
	      (ReactSharedInternals.T = prevTransition);
	  }
	}
	function dispatchEvent(
	  domEventName,
	  eventSystemFlags,
	  targetContainer,
	  nativeEvent
	) {
	  if (_enabled) {
	    var blockedOn = findInstanceBlockingEvent(nativeEvent);
	    if (null === blockedOn)
	      dispatchEventForPluginEventSystem(
	        domEventName,
	        eventSystemFlags,
	        nativeEvent,
	        return_targetInst,
	        targetContainer
	      ),
	        clearIfContinuousEvent(domEventName, nativeEvent);
	    else if (
	      queueIfContinuousEvent(
	        blockedOn,
	        domEventName,
	        eventSystemFlags,
	        targetContainer,
	        nativeEvent
	      )
	    )
	      nativeEvent.stopPropagation();
	    else if (
	      (clearIfContinuousEvent(domEventName, nativeEvent),
	      eventSystemFlags & 4 &&
	        -1 < discreteReplayableEvents.indexOf(domEventName))
	    ) {
	      for (; null !== blockedOn; ) {
	        var fiber = getInstanceFromNode(blockedOn);
	        if (null !== fiber)
	          switch (fiber.tag) {
	            case 3:
	              fiber = fiber.stateNode;
	              if (fiber.current.memoizedState.isDehydrated) {
	                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
	                if (0 !== lanes) {
	                  var root = fiber;
	                  root.pendingLanes |= 2;
	                  for (root.entangledLanes |= 2; lanes; ) {
	                    var lane = 1 << (31 - clz32(lanes));
	                    root.entanglements[1] |= lane;
	                    lanes &= ~lane;
	                  }
	                  ensureRootIsScheduled(fiber);
	                  0 === (executionContext & 6) &&
	                    ((workInProgressRootRenderTargetTime = now() + 500),
	                    flushSyncWorkAcrossRoots_impl(0));
	                }
	              }
	              break;
	            case 13:
	              (root = enqueueConcurrentRenderForLane(fiber, 2)),
	                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
	                flushSyncWork$1(),
	                markRetryLaneIfNotHydrated(fiber, 2);
	          }
	        fiber = findInstanceBlockingEvent(nativeEvent);
	        null === fiber &&
	          dispatchEventForPluginEventSystem(
	            domEventName,
	            eventSystemFlags,
	            nativeEvent,
	            return_targetInst,
	            targetContainer
	          );
	        if (fiber === blockedOn) break;
	        blockedOn = fiber;
	      }
	      null !== blockedOn && nativeEvent.stopPropagation();
	    } else
	      dispatchEventForPluginEventSystem(
	        domEventName,
	        eventSystemFlags,
	        nativeEvent,
	        null,
	        targetContainer
	      );
	  }
	}
	function findInstanceBlockingEvent(nativeEvent) {
	  nativeEvent = getEventTarget(nativeEvent);
	  return findInstanceBlockingTarget(nativeEvent);
	}
	var return_targetInst = null;
	function findInstanceBlockingTarget(targetNode) {
	  return_targetInst = null;
	  targetNode = getClosestInstanceFromNode(targetNode);
	  if (null !== targetNode) {
	    var nearestMounted = getNearestMountedFiber(targetNode);
	    if (null === nearestMounted) targetNode = null;
	    else {
	      var tag = nearestMounted.tag;
	      if (13 === tag) {
	        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
	        if (null !== targetNode) return targetNode;
	        targetNode = null;
	      } else if (3 === tag) {
	        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
	          return 3 === nearestMounted.tag
	            ? nearestMounted.stateNode.containerInfo
	            : null;
	        targetNode = null;
	      } else nearestMounted !== targetNode && (targetNode = null);
	    }
	  }
	  return_targetInst = targetNode;
	  return null;
	}
	function getEventPriority(domEventName) {
	  switch (domEventName) {
	    case "beforetoggle":
	    case "cancel":
	    case "click":
	    case "close":
	    case "contextmenu":
	    case "copy":
	    case "cut":
	    case "auxclick":
	    case "dblclick":
	    case "dragend":
	    case "dragstart":
	    case "drop":
	    case "focusin":
	    case "focusout":
	    case "input":
	    case "invalid":
	    case "keydown":
	    case "keypress":
	    case "keyup":
	    case "mousedown":
	    case "mouseup":
	    case "paste":
	    case "pause":
	    case "play":
	    case "pointercancel":
	    case "pointerdown":
	    case "pointerup":
	    case "ratechange":
	    case "reset":
	    case "resize":
	    case "seeked":
	    case "submit":
	    case "toggle":
	    case "touchcancel":
	    case "touchend":
	    case "touchstart":
	    case "volumechange":
	    case "change":
	    case "selectionchange":
	    case "textInput":
	    case "compositionstart":
	    case "compositionend":
	    case "compositionupdate":
	    case "beforeblur":
	    case "afterblur":
	    case "beforeinput":
	    case "blur":
	    case "fullscreenchange":
	    case "focus":
	    case "hashchange":
	    case "popstate":
	    case "select":
	    case "selectstart":
	      return 2;
	    case "drag":
	    case "dragenter":
	    case "dragexit":
	    case "dragleave":
	    case "dragover":
	    case "mousemove":
	    case "mouseout":
	    case "mouseover":
	    case "pointermove":
	    case "pointerout":
	    case "pointerover":
	    case "scroll":
	    case "touchmove":
	    case "wheel":
	    case "mouseenter":
	    case "mouseleave":
	    case "pointerenter":
	    case "pointerleave":
	      return 8;
	    case "message":
	      switch (getCurrentPriorityLevel()) {
	        case ImmediatePriority:
	          return 2;
	        case UserBlockingPriority:
	          return 8;
	        case NormalPriority$1:
	        case LowPriority:
	          return 32;
	        case IdlePriority:
	          return 268435456;
	        default:
	          return 32;
	      }
	    default:
	      return 32;
	  }
	}
	var hasScheduledReplayAttempt = !1,
	  queuedFocus = null,
	  queuedDrag = null,
	  queuedMouse = null,
	  queuedPointers = new Map(),
	  queuedPointerCaptures = new Map(),
	  queuedExplicitHydrationTargets = [],
	  discreteReplayableEvents =
	    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
	      " "
	    );
	function clearIfContinuousEvent(domEventName, nativeEvent) {
	  switch (domEventName) {
	    case "focusin":
	    case "focusout":
	      queuedFocus = null;
	      break;
	    case "dragenter":
	    case "dragleave":
	      queuedDrag = null;
	      break;
	    case "mouseover":
	    case "mouseout":
	      queuedMouse = null;
	      break;
	    case "pointerover":
	    case "pointerout":
	      queuedPointers.delete(nativeEvent.pointerId);
	      break;
	    case "gotpointercapture":
	    case "lostpointercapture":
	      queuedPointerCaptures.delete(nativeEvent.pointerId);
	  }
	}
	function accumulateOrCreateContinuousQueuedReplayableEvent(
	  existingQueuedEvent,
	  blockedOn,
	  domEventName,
	  eventSystemFlags,
	  targetContainer,
	  nativeEvent
	) {
	  if (
	    null === existingQueuedEvent ||
	    existingQueuedEvent.nativeEvent !== nativeEvent
	  )
	    return (
	      (existingQueuedEvent = {
	        blockedOn: blockedOn,
	        domEventName: domEventName,
	        eventSystemFlags: eventSystemFlags,
	        nativeEvent: nativeEvent,
	        targetContainers: [targetContainer]
	      }),
	      null !== blockedOn &&
	        ((blockedOn = getInstanceFromNode(blockedOn)),
	        null !== blockedOn && attemptContinuousHydration(blockedOn)),
	      existingQueuedEvent
	    );
	  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
	  blockedOn = existingQueuedEvent.targetContainers;
	  null !== targetContainer &&
	    -1 === blockedOn.indexOf(targetContainer) &&
	    blockedOn.push(targetContainer);
	  return existingQueuedEvent;
	}
	function queueIfContinuousEvent(
	  blockedOn,
	  domEventName,
	  eventSystemFlags,
	  targetContainer,
	  nativeEvent
	) {
	  switch (domEventName) {
	    case "focusin":
	      return (
	        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedFocus,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        )),
	        !0
	      );
	    case "dragenter":
	      return (
	        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedDrag,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        )),
	        !0
	      );
	    case "mouseover":
	      return (
	        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedMouse,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        )),
	        !0
	      );
	    case "pointerover":
	      var pointerId = nativeEvent.pointerId;
	      queuedPointers.set(
	        pointerId,
	        accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedPointers.get(pointerId) || null,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        )
	      );
	      return !0;
	    case "gotpointercapture":
	      return (
	        (pointerId = nativeEvent.pointerId),
	        queuedPointerCaptures.set(
	          pointerId,
	          accumulateOrCreateContinuousQueuedReplayableEvent(
	            queuedPointerCaptures.get(pointerId) || null,
	            blockedOn,
	            domEventName,
	            eventSystemFlags,
	            targetContainer,
	            nativeEvent
	          )
	        ),
	        !0
	      );
	  }
	  return !1;
	}
	function attemptExplicitHydrationTarget(queuedTarget) {
	  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
	  if (null !== targetInst) {
	    var nearestMounted = getNearestMountedFiber(targetInst);
	    if (null !== nearestMounted)
	      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
	        if (
	          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
	          null !== targetInst)
	        ) {
	          queuedTarget.blockedOn = targetInst;
	          runWithPriority(queuedTarget.priority, function () {
	            if (13 === nearestMounted.tag) {
	              var lane = requestUpdateLane();
	              lane = getBumpedLaneForHydrationByLane(lane);
	              var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
	              null !== root &&
	                scheduleUpdateOnFiber(root, nearestMounted, lane);
	              markRetryLaneIfNotHydrated(nearestMounted, lane);
	            }
	          });
	          return;
	        }
	      } else if (
	        3 === targetInst &&
	        nearestMounted.stateNode.current.memoizedState.isDehydrated
	      ) {
	        queuedTarget.blockedOn =
	          3 === nearestMounted.tag
	            ? nearestMounted.stateNode.containerInfo
	            : null;
	        return;
	      }
	  }
	  queuedTarget.blockedOn = null;
	}
	function attemptReplayContinuousQueuedEvent(queuedEvent) {
	  if (null !== queuedEvent.blockedOn) return !1;
	  for (
	    var targetContainers = queuedEvent.targetContainers;
	    0 < targetContainers.length;

	  ) {
	    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
	    if (null === nextBlockedOn) {
	      nextBlockedOn = queuedEvent.nativeEvent;
	      var nativeEventClone = new nextBlockedOn.constructor(
	        nextBlockedOn.type,
	        nextBlockedOn
	      );
	      currentReplayingEvent = nativeEventClone;
	      nextBlockedOn.target.dispatchEvent(nativeEventClone);
	      currentReplayingEvent = null;
	    } else
	      return (
	        (targetContainers = getInstanceFromNode(nextBlockedOn)),
	        null !== targetContainers &&
	          attemptContinuousHydration(targetContainers),
	        (queuedEvent.blockedOn = nextBlockedOn),
	        !1
	      );
	    targetContainers.shift();
	  }
	  return !0;
	}
	function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
	  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
	}
	function replayUnblockedEvents() {
	  hasScheduledReplayAttempt = !1;
	  null !== queuedFocus &&
	    attemptReplayContinuousQueuedEvent(queuedFocus) &&
	    (queuedFocus = null);
	  null !== queuedDrag &&
	    attemptReplayContinuousQueuedEvent(queuedDrag) &&
	    (queuedDrag = null);
	  null !== queuedMouse &&
	    attemptReplayContinuousQueuedEvent(queuedMouse) &&
	    (queuedMouse = null);
	  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
	  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
	}
	function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
	  queuedEvent.blockedOn === unblocked &&
	    ((queuedEvent.blockedOn = null),
	    hasScheduledReplayAttempt ||
	      ((hasScheduledReplayAttempt = !0),
	      Scheduler.unstable_scheduleCallback(
	        Scheduler.unstable_NormalPriority,
	        replayUnblockedEvents
	      )));
	}
	var lastScheduledReplayQueue = null;
	function scheduleReplayQueueIfNeeded(formReplayingQueue) {
	  lastScheduledReplayQueue !== formReplayingQueue &&
	    ((lastScheduledReplayQueue = formReplayingQueue),
	    Scheduler.unstable_scheduleCallback(
	      Scheduler.unstable_NormalPriority,
	      function () {
	        lastScheduledReplayQueue === formReplayingQueue &&
	          (lastScheduledReplayQueue = null);
	        for (var i = 0; i < formReplayingQueue.length; i += 3) {
	          var form = formReplayingQueue[i],
	            submitterOrAction = formReplayingQueue[i + 1],
	            formData = formReplayingQueue[i + 2];
	          if ("function" !== typeof submitterOrAction)
	            if (null === findInstanceBlockingTarget(submitterOrAction || form))
	              continue;
	            else break;
	          var formInst = getInstanceFromNode(form);
	          null !== formInst &&
	            (formReplayingQueue.splice(i, 3),
	            (i -= 3),
	            startHostTransition(
	              formInst,
	              {
	                pending: !0,
	                data: formData,
	                method: form.method,
	                action: submitterOrAction
	              },
	              submitterOrAction,
	              formData
	            ));
	        }
	      }
	    ));
	}
	function retryIfBlockedOn(unblocked) {
	  function unblock(queuedEvent) {
	    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
	  }
	  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
	  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
	  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
	  queuedPointers.forEach(unblock);
	  queuedPointerCaptures.forEach(unblock);
	  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
	    var queuedTarget = queuedExplicitHydrationTargets[i];
	    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
	  }
	  for (
	    ;
	    0 < queuedExplicitHydrationTargets.length &&
	    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

	  )
	    attemptExplicitHydrationTarget(i),
	      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
	  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
	  if (null != i)
	    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
	      var form = i[queuedTarget],
	        submitterOrAction = i[queuedTarget + 1],
	        formProps = form[internalPropsKey] || null;
	      if ("function" === typeof submitterOrAction)
	        formProps || scheduleReplayQueueIfNeeded(i);
	      else if (formProps) {
	        var action = null;
	        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
	          if (
	            ((form = submitterOrAction),
	            (formProps = submitterOrAction[internalPropsKey] || null))
	          )
	            action = formProps.formAction;
	          else {
	            if (null !== findInstanceBlockingTarget(form)) continue;
	          }
	        else action = formProps.action;
	        "function" === typeof action
	          ? (i[queuedTarget + 1] = action)
	          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
	        scheduleReplayQueueIfNeeded(i);
	      }
	    }
	}
	function ReactDOMRoot(internalRoot) {
	  this._internalRoot = internalRoot;
	}
	ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
	  function (children) {
	    var root = this._internalRoot;
	    if (null === root) throw Error(formatProdErrorMessage$1(409));
	    var current = root.current,
	      lane = requestUpdateLane();
	    updateContainerImpl(current, lane, children, root, null, null);
	  };
	ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
	  function () {
	    var root = this._internalRoot;
	    if (null !== root) {
	      this._internalRoot = null;
	      var container = root.containerInfo;
	      updateContainerImpl(root.current, 2, null, root, null, null);
	      flushSyncWork$1();
	      container[internalContainerInstanceKey] = null;
	    }
	  };
	function ReactDOMHydrationRoot(internalRoot) {
	  this._internalRoot = internalRoot;
	}
	ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
	  if (target) {
	    var updatePriority = resolveUpdatePriority();
	    target = { blockedOn: null, target: target, priority: updatePriority };
	    for (
	      var i = 0;
	      i < queuedExplicitHydrationTargets.length &&
	      0 !== updatePriority &&
	      updatePriority < queuedExplicitHydrationTargets[i].priority;
	      i++
	    );
	    queuedExplicitHydrationTargets.splice(i, 0, target);
	    0 === i && attemptExplicitHydrationTarget(target);
	  }
	};
	var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
	if (
	  "19.1.0" !==
	  isomorphicReactPackageVersion$jscomp$inline_1785
	)
	  throw Error(
	    formatProdErrorMessage$1(
	      527,
	      isomorphicReactPackageVersion$jscomp$inline_1785,
	      "19.1.0"
	    )
	  );
	ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
	  var fiber = componentOrElement._reactInternals;
	  if (void 0 === fiber) {
	    if ("function" === typeof componentOrElement.render)
	      throw Error(formatProdErrorMessage$1(188));
	    componentOrElement = Object.keys(componentOrElement).join(",");
	    throw Error(formatProdErrorMessage$1(268, componentOrElement));
	  }
	  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
	  componentOrElement =
	    null !== componentOrElement
	      ? findCurrentHostFiberImpl(componentOrElement)
	      : null;
	  componentOrElement =
	    null === componentOrElement ? null : componentOrElement.stateNode;
	  return componentOrElement;
	};
	var internals$jscomp$inline_2256 = {
	  bundleType: 0,
	  version: "19.1.0",
	  rendererPackageName: "react-dom",
	  currentDispatcherRef: ReactSharedInternals,
	  reconcilerVersion: "19.1.0"
	};
	if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
	  var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
	  if (
	    !hook$jscomp$inline_2257.isDisabled &&
	    hook$jscomp$inline_2257.supportsFiber
	  )
	    try {
	      (rendererID = hook$jscomp$inline_2257.inject(
	        internals$jscomp$inline_2256
	      )),
	        (injectedHook = hook$jscomp$inline_2257);
	    } catch (err) {}
	}
	reactDomClient_production.createRoot = function (container, options) {
	  if (!isValidContainer(container)) throw Error(formatProdErrorMessage$1(299));
	  var isStrictMode = !1,
	    identifierPrefix = "",
	    onUncaughtError = defaultOnUncaughtError,
	    onCaughtError = defaultOnCaughtError,
	    onRecoverableError = defaultOnRecoverableError,
	    transitionCallbacks = null;
	  null !== options &&
	    void 0 !== options &&
	    (!0 === options.unstable_strictMode && (isStrictMode = !0),
	    void 0 !== options.identifierPrefix &&
	      (identifierPrefix = options.identifierPrefix),
	    void 0 !== options.onUncaughtError &&
	      (onUncaughtError = options.onUncaughtError),
	    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
	    void 0 !== options.onRecoverableError &&
	      (onRecoverableError = options.onRecoverableError),
	    void 0 !== options.unstable_transitionCallbacks &&
	      (transitionCallbacks = options.unstable_transitionCallbacks));
	  options = createFiberRoot(
	    container,
	    1,
	    !1,
	    null,
	    null,
	    isStrictMode,
	    identifierPrefix,
	    onUncaughtError,
	    onCaughtError,
	    onRecoverableError,
	    transitionCallbacks,
	    null
	  );
	  container[internalContainerInstanceKey] = options.current;
	  listenToAllSupportedEvents(container);
	  return new ReactDOMRoot(options);
	};
	reactDomClient_production.hydrateRoot = function (container, initialChildren, options) {
	  if (!isValidContainer(container)) throw Error(formatProdErrorMessage$1(299));
	  var isStrictMode = !1,
	    identifierPrefix = "",
	    onUncaughtError = defaultOnUncaughtError,
	    onCaughtError = defaultOnCaughtError,
	    onRecoverableError = defaultOnRecoverableError,
	    transitionCallbacks = null,
	    formState = null;
	  null !== options &&
	    void 0 !== options &&
	    (!0 === options.unstable_strictMode && (isStrictMode = !0),
	    void 0 !== options.identifierPrefix &&
	      (identifierPrefix = options.identifierPrefix),
	    void 0 !== options.onUncaughtError &&
	      (onUncaughtError = options.onUncaughtError),
	    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
	    void 0 !== options.onRecoverableError &&
	      (onRecoverableError = options.onRecoverableError),
	    void 0 !== options.unstable_transitionCallbacks &&
	      (transitionCallbacks = options.unstable_transitionCallbacks),
	    void 0 !== options.formState && (formState = options.formState));
	  initialChildren = createFiberRoot(
	    container,
	    1,
	    !0,
	    initialChildren,
	    null != options ? options : null,
	    isStrictMode,
	    identifierPrefix,
	    onUncaughtError,
	    onCaughtError,
	    onRecoverableError,
	    transitionCallbacks,
	    formState
	  );
	  initialChildren.context = getContextForSubtree(null);
	  options = initialChildren.current;
	  isStrictMode = requestUpdateLane();
	  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
	  identifierPrefix = createUpdate(isStrictMode);
	  identifierPrefix.callback = null;
	  enqueueUpdate(options, identifierPrefix, isStrictMode);
	  options = isStrictMode;
	  initialChildren.current.lanes = options;
	  markRootUpdated$1(initialChildren, options);
	  ensureRootIsScheduled(initialChildren);
	  container[internalContainerInstanceKey] = initialChildren.current;
	  listenToAllSupportedEvents(container);
	  return new ReactDOMHydrationRoot(initialChildren);
	};
	reactDomClient_production.version = "19.1.0";

	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}

	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  client.exports = reactDomClient_production;
	}

	var clientExports = client.exports;
	var ReactDOM = /*@__PURE__*/getDefaultExportFromCjs(clientExports);

	var shim = {exports: {}};

	var useSyncExternalStoreShim_production_min = {};

	/**
	 * @license React
	 * use-sync-external-store-shim.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var e$2=reactExports;function h$3(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k$2="function"===typeof Object.is?Object.is:h$3,l$2=e$2.useState,m$2=e$2.useEffect,n$3=e$2.useLayoutEffect,p$3=e$2.useDebugValue;function q$3(a,b){var d=b(),f=l$2({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n$3(function(){c.value=d;c.getSnapshot=b;r$2(c)&&g({inst:c});},[a,d,b]);m$2(function(){r$2(c)&&g({inst:c});return a(function(){r$2(c)&&g({inst:c});})},[a]);p$3(d);return d}
	function r$2(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k$2(a,d)}catch(f){return !0}}function t$3(a,b){return b()}var u$2="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t$3:q$3;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e$2.useSyncExternalStore?e$2.useSyncExternalStore:u$2;

	{
	  shim.exports = useSyncExternalStoreShim_production_min;
	}

	var shimExports = shim.exports;

	var withSelector = {exports: {}};

	var withSelector_production_min = {};

	/**
	 * @license React
	 * use-sync-external-store-shim/with-selector.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var h$2=reactExports,n$2=shimExports;function p$2(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q$2="function"===typeof Object.is?Object.is:p$2,r$1=n$2.useSyncExternalStore,t$2=h$2.useRef,u$1=h$2.useEffect,v$3=h$2.useMemo,w$1=h$2.useDebugValue;
	withSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t$2(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v$3(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q$2(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r$1(a,c[0],c[1]);
	u$1(function(){f.hasValue=!0;f.value=d;},[d]);w$1(d);return d};

	{
	  withSelector.exports = withSelector_production_min;
	}

	var withSelectorExports = withSelector.exports;

	// Default to a dummy "batch" implementation that just runs the callback
	function defaultNoopBatch(callback) {
	  callback();
	}

	let batch = defaultNoopBatch; // Allow injecting another batching function later

	const setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings

	const getBatch = () => batch;

	const ContextKey = Symbol.for(`react-redux-context`);
	const gT = typeof globalThis !== "undefined" ? globalThis :
	/* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
	{};

	function getContext() {
	  var _gT$ContextKey;

	  if (!reactExports.createContext) return {};
	  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = new Map();
	  let realContext = contextMap.get(reactExports.createContext);

	  if (!realContext) {
	    realContext = reactExports.createContext(null);

	    contextMap.set(reactExports.createContext, realContext);
	  }

	  return realContext;
	}

	const ReactReduxContext = /*#__PURE__*/getContext();

	/**
	 * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level
	 * hook that you should usually not need to call directly.
	 *
	 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
	 * @returns {Function} A `useReduxContext` hook bound to the specified context.
	 */
	function createReduxContextHook(context = ReactReduxContext) {
	  return function useReduxContext() {
	    const contextValue = reactExports.useContext(context);

	    return contextValue;
	  };
	}
	/**
	 * A hook to access the value of the `ReactReduxContext`. This is a low-level
	 * hook that you should usually not need to call directly.
	 *
	 * @returns {any} the value of the `ReactReduxContext`
	 *
	 * @example
	 *
	 * import React from 'react'
	 * import { useReduxContext } from 'react-redux'
	 *
	 * export const CounterComponent = () => {
	 *   const { store } = useReduxContext()
	 *   return <div>{store.getState()}</div>
	 * }
	 */

	const useReduxContext = /*#__PURE__*/createReduxContextHook();

	const notInitialized = () => {
	  throw new Error('uSES not initialized!');
	};

	let useSyncExternalStoreWithSelector = notInitialized;
	const initializeUseSelector = fn => {
	  useSyncExternalStoreWithSelector = fn;
	};

	const refEquality = (a, b) => a === b;
	/**
	 * Hook factory, which creates a `useSelector` hook bound to a given context.
	 *
	 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
	 * @returns {Function} A `useSelector` hook bound to the specified context.
	 */


	function createSelectorHook(context = ReactReduxContext) {
	  const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
	  return function useSelector(selector, equalityFnOrOptions = {}) {
	    const {
	      equalityFn = refEquality,
	      stabilityCheck = undefined,
	      noopCheck = undefined
	    } = typeof equalityFnOrOptions === 'function' ? {
	      equalityFn: equalityFnOrOptions
	    } : equalityFnOrOptions;

	    const {
	      store,
	      subscription,
	      getServerState,
	      stabilityCheck: globalStabilityCheck,
	      noopCheck: globalNoopCheck
	    } = useReduxContext$1();
	    reactExports.useRef(true);
	    const wrappedSelector = reactExports.useCallback({
	      [selector.name](state) {
	        const selected = selector(state);

	        return selected;
	      }

	    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
	    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
	    reactExports.useDebugValue(selectedState);
	    return selectedState;
	  };
	}
	/**
	 * A hook to access the redux store's state. This hook takes a selector function
	 * as an argument. The selector is called with the store state.
	 *
	 * This hook takes an optional equality comparison function as the second parameter
	 * that allows you to customize the way the selected state is compared to determine
	 * whether the component needs to be re-rendered.
	 *
	 * @param {Function} selector the selector function
	 * @param {Function=} equalityFn the function that will be used to determine equality
	 *
	 * @returns {any} the selected state
	 *
	 * @example
	 *
	 * import React from 'react'
	 * import { useSelector } from 'react-redux'
	 *
	 * export const CounterComponent = () => {
	 *   const counter = useSelector(state => state.counter)
	 *   return <div>{counter}</div>
	 * }
	 */

	const useSelector = /*#__PURE__*/createSelectorHook();

	var reactIs_production_min$1 = {};

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var b$1="function"===typeof Symbol&&Symbol.for,c$1=b$1?Symbol.for("react.element"):60103,d$1=b$1?Symbol.for("react.portal"):60106,e$1=b$1?Symbol.for("react.fragment"):60107,f$1=b$1?Symbol.for("react.strict_mode"):60108,g$1=b$1?Symbol.for("react.profiler"):60114,h$1=b$1?Symbol.for("react.provider"):60109,k$1=b$1?Symbol.for("react.context"):60110,l$1=b$1?Symbol.for("react.async_mode"):60111,m$1=b$1?Symbol.for("react.concurrent_mode"):60111,n$1=b$1?Symbol.for("react.forward_ref"):60112,p$1=b$1?Symbol.for("react.suspense"):60113,q$1=b$1?
	Symbol.for("react.suspense_list"):60120,r=b$1?Symbol.for("react.memo"):60115,t$1=b$1?Symbol.for("react.lazy"):60116,v$2=b$1?Symbol.for("react.block"):60121,w=b$1?Symbol.for("react.fundamental"):60117,x=b$1?Symbol.for("react.responder"):60118,y=b$1?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c$1:switch(a=a.type,a){case l$1:case m$1:case e$1:case g$1:case f$1:case p$1:return a;default:switch(a=a&&a.$$typeof,a){case k$1:case n$1:case t$1:case r:case h$1:return a;default:return u}}case d$1:return u}}}function A(a){return z(a)===m$1}reactIs_production_min$1.AsyncMode=l$1;reactIs_production_min$1.ConcurrentMode=m$1;reactIs_production_min$1.ContextConsumer=k$1;reactIs_production_min$1.ContextProvider=h$1;reactIs_production_min$1.Element=c$1;reactIs_production_min$1.ForwardRef=n$1;reactIs_production_min$1.Fragment=e$1;reactIs_production_min$1.Lazy=t$1;reactIs_production_min$1.Memo=r;reactIs_production_min$1.Portal=d$1;
	reactIs_production_min$1.Profiler=g$1;reactIs_production_min$1.StrictMode=f$1;reactIs_production_min$1.Suspense=p$1;reactIs_production_min$1.isAsyncMode=function(a){return A(a)||z(a)===l$1};reactIs_production_min$1.isConcurrentMode=A;reactIs_production_min$1.isContextConsumer=function(a){return z(a)===k$1};reactIs_production_min$1.isContextProvider=function(a){return z(a)===h$1};reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c$1};reactIs_production_min$1.isForwardRef=function(a){return z(a)===n$1};reactIs_production_min$1.isFragment=function(a){return z(a)===e$1};reactIs_production_min$1.isLazy=function(a){return z(a)===t$1};
	reactIs_production_min$1.isMemo=function(a){return z(a)===r};reactIs_production_min$1.isPortal=function(a){return z(a)===d$1};reactIs_production_min$1.isProfiler=function(a){return z(a)===g$1};reactIs_production_min$1.isStrictMode=function(a){return z(a)===f$1};reactIs_production_min$1.isSuspense=function(a){return z(a)===p$1};
	reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e$1||a===m$1||a===g$1||a===f$1||a===p$1||a===q$1||"object"===typeof a&&null!==a&&(a.$$typeof===t$1||a.$$typeof===r||a.$$typeof===h$1||a.$$typeof===k$1||a.$$typeof===n$1||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v$2)};reactIs_production_min$1.typeOf=z;

	var reactIs_production_min = {};

	/**
	 * @license React
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
	function v$1(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;
	reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return !1};reactIs_production_min.isConcurrentMode=function(){return !1};reactIs_production_min.isContextConsumer=function(a){return v$1(a)===h};reactIs_production_min.isContextProvider=function(a){return v$1(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return v$1(a)===l};reactIs_production_min.isFragment=function(a){return v$1(a)===d};reactIs_production_min.isLazy=function(a){return v$1(a)===q};reactIs_production_min.isMemo=function(a){return v$1(a)===p};
	reactIs_production_min.isPortal=function(a){return v$1(a)===c};reactIs_production_min.isProfiler=function(a){return v$1(a)===f};reactIs_production_min.isStrictMode=function(a){return v$1(a)===e};reactIs_production_min.isSuspense=function(a){return v$1(a)===m};reactIs_production_min.isSuspenseList=function(a){return v$1(a)===n};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};reactIs_production_min.typeOf=v$1;

	// well as nesting subscriptions of descendant components, so that we can ensure the
	// ancestor components re-render before descendants

	function createListenerCollection() {
	  const batch = getBatch();
	  let first = null;
	  let last = null;
	  return {
	    clear() {
	      first = null;
	      last = null;
	    },

	    notify() {
	      batch(() => {
	        let listener = first;

	        while (listener) {
	          listener.callback();
	          listener = listener.next;
	        }
	      });
	    },

	    get() {
	      let listeners = [];
	      let listener = first;

	      while (listener) {
	        listeners.push(listener);
	        listener = listener.next;
	      }

	      return listeners;
	    },

	    subscribe(callback) {
	      let isSubscribed = true;
	      let listener = last = {
	        callback,
	        next: null,
	        prev: last
	      };

	      if (listener.prev) {
	        listener.prev.next = listener;
	      } else {
	        first = listener;
	      }

	      return function unsubscribe() {
	        if (!isSubscribed || first === null) return;
	        isSubscribed = false;

	        if (listener.next) {
	          listener.next.prev = listener.prev;
	        } else {
	          last = listener.prev;
	        }

	        if (listener.prev) {
	          listener.prev.next = listener.next;
	        } else {
	          first = listener.next;
	        }
	      };
	    }

	  };
	}

	const nullListeners = {
	  notify() {},

	  get: () => []
	};
	function createSubscription(store, parentSub) {
	  let unsubscribe;
	  let listeners = nullListeners; // Reasons to keep the subscription active

	  let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)

	  let selfSubscribed = false;

	  function addNestedSub(listener) {
	    trySubscribe();
	    const cleanupListener = listeners.subscribe(listener); // cleanup nested sub

	    let removed = false;
	    return () => {
	      if (!removed) {
	        removed = true;
	        cleanupListener();
	        tryUnsubscribe();
	      }
	    };
	  }

	  function notifyNestedSubs() {
	    listeners.notify();
	  }

	  function handleChangeWrapper() {
	    if (subscription.onStateChange) {
	      subscription.onStateChange();
	    }
	  }

	  function isSubscribed() {
	    return selfSubscribed;
	  }

	  function trySubscribe() {
	    subscriptionsAmount++;

	    if (!unsubscribe) {
	      unsubscribe = store.subscribe(handleChangeWrapper);
	      listeners = createListenerCollection();
	    }
	  }

	  function tryUnsubscribe() {
	    subscriptionsAmount--;

	    if (unsubscribe && subscriptionsAmount === 0) {
	      unsubscribe();
	      unsubscribe = undefined;
	      listeners.clear();
	      listeners = nullListeners;
	    }
	  }

	  function trySubscribeSelf() {
	    if (!selfSubscribed) {
	      selfSubscribed = true;
	      trySubscribe();
	    }
	  }

	  function tryUnsubscribeSelf() {
	    if (selfSubscribed) {
	      selfSubscribed = false;
	      tryUnsubscribe();
	    }
	  }

	  const subscription = {
	    addNestedSub,
	    notifyNestedSubs,
	    handleChangeWrapper,
	    isSubscribed,
	    trySubscribe: trySubscribeSelf,
	    tryUnsubscribe: tryUnsubscribeSelf,
	    getListeners: () => listeners
	  };
	  return subscription;
	}

	// To get around it, we can conditionally useEffect on the server (no-op) and
	// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
	// subscription callback always has the selector from the latest render commit
	// available, otherwise a store update may happen between render and the effect,
	// which may cause missed updates; we also must ensure the store subscription
	// is created synchronously, otherwise a store update may occur before the
	// subscription is created and an inconsistent state may be observed
	// Matches logic in React's `shared/ExecutionEnvironment` file

	const canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
	const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;

	function Provider({
	  store,
	  context,
	  children,
	  serverState,
	  stabilityCheck = 'once',
	  noopCheck = 'once'
	}) {
	  const contextValue = reactExports.useMemo(() => {
	    const subscription = createSubscription(store);
	    return {
	      store,
	      subscription,
	      getServerState: serverState ? () => serverState : undefined,
	      stabilityCheck,
	      noopCheck
	    };
	  }, [store, serverState, stabilityCheck, noopCheck]);
	  const previousState = reactExports.useMemo(() => store.getState(), [store]);
	  useIsomorphicLayoutEffect(() => {
	    const {
	      subscription
	    } = contextValue;
	    subscription.onStateChange = subscription.notifyNestedSubs;
	    subscription.trySubscribe();

	    if (previousState !== store.getState()) {
	      subscription.notifyNestedSubs();
	    }

	    return () => {
	      subscription.tryUnsubscribe();
	      subscription.onStateChange = undefined;
	    };
	  }, [contextValue, previousState]);
	  const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype

	  return /*#__PURE__*/reactExports.createElement(Context.Provider, {
	    value: contextValue
	  }, children);
	}

	/**
	 * Hook factory, which creates a `useStore` hook bound to a given context.
	 *
	 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
	 * @returns {Function} A `useStore` hook bound to the specified context.
	 */

	function createStoreHook(context = ReactReduxContext) {
	  const useReduxContext$1 = // @ts-ignore
	  context === ReactReduxContext ? useReduxContext : // @ts-ignore
	  createReduxContextHook(context);
	  return function useStore() {
	    const {
	      store
	    } = useReduxContext$1(); // @ts-ignore

	    return store;
	  };
	}
	/**
	 * A hook to access the redux store.
	 *
	 * @returns {any} the redux store
	 *
	 * @example
	 *
	 * import React from 'react'
	 * import { useStore } from 'react-redux'
	 *
	 * export const ExampleComponent = () => {
	 *   const store = useStore()
	 *   return <div>{store.getState()}</div>
	 * }
	 */

	const useStore = /*#__PURE__*/createStoreHook();

	/**
	 * Hook factory, which creates a `useDispatch` hook bound to a given context.
	 *
	 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
	 * @returns {Function} A `useDispatch` hook bound to the specified context.
	 */

	function createDispatchHook(context = ReactReduxContext) {
	  const useStore$1 = // @ts-ignore
	  context === ReactReduxContext ? useStore : createStoreHook(context);
	  return function useDispatch() {
	    const store = useStore$1(); // @ts-ignore

	    return store.dispatch;
	  };
	}
	/**
	 * A hook to access the redux `dispatch` function.
	 *
	 * @returns {any|function} redux store's `dispatch` function
	 *
	 * @example
	 *
	 * import React, { useCallback } from 'react'
	 * import { useDispatch } from 'react-redux'
	 *
	 * export const CounterComponent = ({ value }) => {
	 *   const dispatch = useDispatch()
	 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
	 *   return (
	 *     <div>
	 *       <span>{value}</span>
	 *       <button onClick={increaseCounter}>Increase counter</button>
	 *     </div>
	 *   )
	 * }
	 */

	const useDispatch = /*#__PURE__*/createDispatchHook();

	// The primary entry point assumes we're working with standard ReactDOM/RN, but
	// older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).
	// Because of that, the useSyncExternalStore compat shim is needed.
	initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
	// with standard React renderers (ReactDOM, React Native)

	setBatch(reactDomExports.unstable_batchedUpdates);

	// src/utils/formatProdErrorMessage.ts
	function formatProdErrorMessage(code) {
	  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
	}

	// src/utils/symbol-observable.ts
	var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
	var symbol_observable_default = $$observable;

	// src/utils/actionTypes.ts
	var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
	var ActionTypes = {
	  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
	  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
	  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
	};
	var actionTypes_default = ActionTypes;

	// src/utils/isPlainObject.ts
	function isPlainObject(obj) {
	  if (typeof obj !== "object" || obj === null)
	    return false;
	  let proto = obj;
	  while (Object.getPrototypeOf(proto) !== null) {
	    proto = Object.getPrototypeOf(proto);
	  }
	  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
	}

	// src/createStore.ts
	function createStore(reducer, preloadedState, enhancer) {
	  if (typeof reducer !== "function") {
	    throw new Error(formatProdErrorMessage(2) );
	  }
	  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
	    throw new Error(formatProdErrorMessage(0) );
	  }
	  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
	    enhancer = preloadedState;
	    preloadedState = void 0;
	  }
	  if (typeof enhancer !== "undefined") {
	    if (typeof enhancer !== "function") {
	      throw new Error(formatProdErrorMessage(1) );
	    }
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	  let currentReducer = reducer;
	  let currentState = preloadedState;
	  let currentListeners = /* @__PURE__ */ new Map();
	  let nextListeners = currentListeners;
	  let listenerIdCounter = 0;
	  let isDispatching = false;
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = /* @__PURE__ */ new Map();
	      currentListeners.forEach((listener, key) => {
	        nextListeners.set(key, listener);
	      });
	    }
	  }
	  function getState() {
	    if (isDispatching) {
	      throw new Error(formatProdErrorMessage(3) );
	    }
	    return currentState;
	  }
	  function subscribe(listener) {
	    if (typeof listener !== "function") {
	      throw new Error(formatProdErrorMessage(4) );
	    }
	    if (isDispatching) {
	      throw new Error(formatProdErrorMessage(5) );
	    }
	    let isSubscribed = true;
	    ensureCanMutateNextListeners();
	    const listenerId = listenerIdCounter++;
	    nextListeners.set(listenerId, listener);
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	      if (isDispatching) {
	        throw new Error(formatProdErrorMessage(6) );
	      }
	      isSubscribed = false;
	      ensureCanMutateNextListeners();
	      nextListeners.delete(listenerId);
	      currentListeners = null;
	    };
	  }
	  function dispatch(action) {
	    if (!isPlainObject(action)) {
	      throw new Error(formatProdErrorMessage(7) );
	    }
	    if (typeof action.type === "undefined") {
	      throw new Error(formatProdErrorMessage(8) );
	    }
	    if (typeof action.type !== "string") {
	      throw new Error(formatProdErrorMessage(17) );
	    }
	    if (isDispatching) {
	      throw new Error(formatProdErrorMessage(9) );
	    }
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	    const listeners = currentListeners = nextListeners;
	    listeners.forEach((listener) => {
	      listener();
	    });
	    return action;
	  }
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== "function") {
	      throw new Error(formatProdErrorMessage(10) );
	    }
	    currentReducer = nextReducer;
	    dispatch({
	      type: actionTypes_default.REPLACE
	    });
	  }
	  function observable() {
	    const outerSubscribe = subscribe;
	    return {
	      /**
	       * The minimal observable subscription method.
	       * @param observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe(observer) {
	        if (typeof observer !== "object" || observer === null) {
	          throw new Error(formatProdErrorMessage(11) );
	        }
	        function observeState() {
	          const observerAsObserver = observer;
	          if (observerAsObserver.next) {
	            observerAsObserver.next(getState());
	          }
	        }
	        observeState();
	        const unsubscribe = outerSubscribe(observeState);
	        return {
	          unsubscribe
	        };
	      },
	      [symbol_observable_default]() {
	        return this;
	      }
	    };
	  }
	  dispatch({
	    type: actionTypes_default.INIT
	  });
	  const store = {
	    dispatch,
	    subscribe,
	    getState,
	    replaceReducer,
	    [symbol_observable_default]: observable
	  };
	  return store;
	}
	function legacy_createStore(reducer, preloadedState, enhancer) {
	  return createStore(reducer, preloadedState, enhancer);
	}
	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach((key) => {
	    const reducer = reducers[key];
	    const initialState = reducer(void 0, {
	      type: actionTypes_default.INIT
	    });
	    if (typeof initialState === "undefined") {
	      throw new Error(formatProdErrorMessage(12) );
	    }
	    if (typeof reducer(void 0, {
	      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
	    }) === "undefined") {
	      throw new Error(formatProdErrorMessage(13) );
	    }
	  });
	}
	function combineReducers(reducers) {
	  const reducerKeys = Object.keys(reducers);
	  const finalReducers = {};
	  for (let i = 0; i < reducerKeys.length; i++) {
	    const key = reducerKeys[i];
	    if (typeof reducers[key] === "function") {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  const finalReducerKeys = Object.keys(finalReducers);
	  let shapeAssertionError;
	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }
	  return function combination(state = {}, action) {
	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }
	    let hasChanged = false;
	    const nextState = {};
	    for (let i = 0; i < finalReducerKeys.length; i++) {
	      const key = finalReducerKeys[i];
	      const reducer = finalReducers[key];
	      const previousStateForKey = state[key];
	      const nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === "undefined") {
	        throw new Error(formatProdErrorMessage(14) );
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
	    return hasChanged ? nextState : state;
	  };
	}

	// src/compose.ts
	function compose$1(...funcs) {
	  if (funcs.length === 0) {
	    return (arg) => arg;
	  }
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	  return funcs.reduce((a, b) => (...args) => a(b(...args)));
	}

	// src/applyMiddleware.ts
	function applyMiddleware(...middlewares) {
	  return (createStore2) => (reducer, preloadedState) => {
	    const store = createStore2(reducer, preloadedState);
	    let dispatch = () => {
	      throw new Error(formatProdErrorMessage(15) );
	    };
	    const middlewareAPI = {
	      getState: store.getState,
	      dispatch: (action, ...args) => dispatch(action, ...args)
	    };
	    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
	    dispatch = compose$1(...chain)(store.dispatch);
	    return {
	      ...store,
	      dispatch
	    };
	  };
	}

	/** A function that accepts a potential "extra argument" value to be injected later,
	 * and returns an instance of the thunk middleware that uses that value
	 */
	function createThunkMiddleware(extraArgument) {
	  // Standard Redux middleware definition pattern:
	  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
	  var middleware = function middleware(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // The thunk middleware looks for any functions that were passed to `store.dispatch`.
	        // If this "action" is really a function, call it and return the result.
	        if (typeof action === 'function') {
	          // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
	          return action(dispatch, getState, extraArgument);
	        } // Otherwise, pass the action down the middleware chain as usual


	        return next(action);
	      };
	    };
	  };

	  return middleware;
	}

	var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
	// with whatever "extra arg" they want to inject into their thunks

	thunk.withExtraArgument = createThunkMiddleware;

	function extensionComposeStub() {
	  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	  if (funcs.length === 0) return undefined;
	  if (typeof funcs[0] === 'object') return compose$1;
	  return compose$1(...funcs);
	}
	const composeWithDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : extensionComposeStub;

	var images = {
		EQ_PREAMP_LINE: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAABCAYAAADpXEERAAAAE0lEQVQoU2Pcdfruf4ZRMKRDAAD1lwNjTqcaUQAAAABJRU5ErkJggg==",
		EQ_GRAPH_LINE_COLORS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAATCAYAAABRC2cZAAAAR0lEQVQYV2O4rCT9n+F9kOJ/hvfViv8ZHkzSQCE2afxneH/HEJm49Nr0PwOYWPLIAkp0PjL4z1B41uQ/Q9QGnf8MWrPEIAQANWYwvnlToNIAAAAASUVORK5CYII="
	};
	var colors = [
		"rgb(0,0,0)",
		"rgb(24,33,41)",
		"rgb(239,49,16)",
		"rgb(206,41,16)",
		"rgb(214,90,0)",
		"rgb(214,102,0)",
		"rgb(214,115,0)",
		"rgb(198,123,8)",
		"rgb(222,165,24)",
		"rgb(214,181,33)",
		"rgb(189,222,41)",
		"rgb(148,222,33)",
		"rgb(41,206,16)",
		"rgb(50,190,16)",
		"rgb(57,181,16)",
		"rgb(49,156,8)",
		"rgb(41,148,0)",
		"rgb(24,132,8)",
		"rgb(255,255,255)",
		"rgb(214,214,222)",
		"rgb(181,189,189)",
		"rgb(160,170,175)",
		"rgb(148,156,165)",
		"rgb(150,150,150)"
	];
	var playlistStyle = {
		normal: "#00FF00",
		current: "#FFFFFF",
		normalbg: "#000000",
		selectedbg: "#0000FF",
		font: "Arial"
	};
	var baseSkin = {
		images: images,
		colors: colors,
		playlistStyle: playlistStyle
	};

	const BANDS = [
	    60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000,
	];
	const WINDOWS = {
	    MAIN: "main",
	    PLAYLIST: "playlist",
	    EQUALIZER: "equalizer",
	    MILKDROP: "milkdrop",
	};
	const LOAD_STYLE = {
	    BUFFER: "BUFFER",
	    PLAY: "PLAY",
	    NONE: "NONE",
	};
	// TODO: Make this an enum?
	const MEDIA_TAG_REQUEST_STATUS = {
	    INITIALIZED: "INITIALIZED",
	    FAILED: "FAILED",
	    COMPLETE: "COMPLETE",
	    NOT_REQUESTED: "NOT_REQUESTED",
	};
	const UTF8_ELLIPSIS = "\u2026";
	const CHARACTER_WIDTH = 5;
	const WINDOW_RESIZE_SEGMENT_WIDTH = 25;
	const WINDOW_RESIZE_SEGMENT_HEIGHT = 29;
	const WINDOW_WIDTH = 275;
	const TRACK_HEIGHT = 13;
	const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
	const DEFAULT_SKIN = baseSkin;
	const VISUALIZERS = {
	    OSCILLOSCOPE: "OSCILLOSCOPE",
	    BAR: "BAR",
	    NONE: "NONE",
	    MILKDROP: "MILKDROP",
	};
	const VISUALIZER_ORDER = [
	    VISUALIZERS.BAR,
	    VISUALIZERS.OSCILLOSCOPE, // Order is correct
	    VISUALIZERS.NONE,
	];
	const TIME_MODE = {
	    ELAPSED: "ELAPSED",
	    REMAINING: "REMAINING",
	};
	const MEDIA_STATUS = {
	    PLAYING: "PLAYING",
	    STOPPED: "STOPPED",
	    PAUSED: "PAUSED",
	};
	const PLAYER_MEDIA_STATUS = {
	    PLAYING: "PLAYING",
	    STOPPED: "STOPPED",
	    PAUSED: "PAUSED",
	    ENDED: "ENDED",
	    CLOSED: "CLOSED",
	};

	function imgFromUrl(url) {
	    return new Promise((resolve, reject) => {
	        const img = new Image();
	        img.onload = () => {
	            resolve(img);
	        };
	        img.onerror = reject;
	        img.src = url;
	    });
	}
	const getTimeObj = (time) => {
	    if (time == null) {
	        // If we clean up `<MiniTime />` we don't need to do this any more.
	        return {
	            minutesFirstDigit: " ",
	            minutesSecondDigit: " ",
	            secondsFirstDigit: " ",
	            secondsSecondDigit: " ",
	        };
	    }
	    const minutes = Math.floor(time / 60);
	    const seconds = time % 60;
	    const digits = time == null
	        ? [" ", " ", " ", " "]
	        : [
	            String(Math.floor(minutes / 10)),
	            String(Math.floor(minutes % 10)),
	            String(Math.floor(seconds / 10)),
	            String(Math.floor(seconds % 10)),
	        ];
	    const [minutesFirstDigit, minutesSecondDigit, secondsFirstDigit, secondsSecondDigit,] = digits;
	    return {
	        minutesFirstDigit,
	        minutesSecondDigit,
	        secondsFirstDigit,
	        secondsSecondDigit,
	    };
	};
	const getTimeStr = (time, truncate = true) => {
	    if (time == null) {
	        return "";
	    }
	    const { minutesFirstDigit, minutesSecondDigit, secondsFirstDigit, secondsSecondDigit, } = getTimeObj(time);
	    return [
	        truncate && minutesFirstDigit === "0" ? "" : minutesFirstDigit,
	        minutesSecondDigit,
	        ":",
	        secondsFirstDigit,
	        secondsSecondDigit,
	    ].join("");
	};
	const parseViscolors = (text) => {
	    const entries = text.split("\n");
	    const regex = /^\s*(\d+)\s*,?\s*(\d+)\s*,?\s*(\d+)/;
	    const colors = [...DEFAULT_SKIN.colors];
	    entries
	        .map((line) => regex.exec(line))
	        .filter(Boolean)
	        .map((matches) => matches.slice(1, 4).join(","))
	        .map((rgb, i) => {
	        colors[i] = `rgb(${rgb})`;
	    });
	    return colors;
	};
	const SECTION_REGEX = /^\s*\[(.+?)\]\s*$/;
	const PROPERTY_REGEX = /^\s*([^;][^=]*)\s*=\s*(.*)\s*$/;
	const parseIni = (text) => {
	    let section, match;
	    return text.split(/[\r\n]+/g).reduce((data, line) => {
	        if ((match = line.match(PROPERTY_REGEX)) && section != null) {
	            const key = match[1].trim().toLowerCase();
	            const value = match[2]
	                // Ignore anything after a second `=`
	                // TODO: What if this is inside quotes or escaped?
	                .replace(/\=.*$/g, "")
	                .trim()
	                // Strip quotes
	                // TODO: What about escaped quotes?
	                // TODO: What about unbalanced quotes?
	                .replace(/(^")|("$)|(^')|('$)/g, "");
	            data[section][key] = value;
	        }
	        else if ((match = line.match(SECTION_REGEX))) {
	            section = match[1].trim().toLowerCase();
	            data[section] = {};
	        }
	        return data;
	    }, {});
	};
	const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
	function base64FromDataArray$1(dataArray) {
	    return window.btoa(Array.from(dataArray)
	        .map((byte) => String.fromCharCode(byte))
	        .join(""));
	}
	const base64FromArrayBuffer = (arrayBuffer) => {
	    return base64FromDataArray$1(new Uint8Array(arrayBuffer));
	};
	// https://stackoverflow.com/a/15832662/1263117
	function downloadURI(uri, name) {
	    const link = document.createElement("a");
	    link.download = name;
	    link.href = uri;
	    window.document.body.appendChild(link);
	    link.click();
	    window.document.body.removeChild(link);
	}
	const toPercent = (min, max, value) => (value - min) / (max - min);
	const percentToRange = (percent, min, max) => min + Math.round(percent * (max - min));
	const percentToIndex = (percent, length) => percentToRange(percent, 0, length - 1);
	const rebound = (oldMin, oldMax, newMin, newMax) => (oldValue) => percentToRange(toPercent(oldMin, oldMax, oldValue), newMin, newMax);
	// Convert an .eqf value to a 0-100
	const normalizeEqBand = rebound(1, 64, 0, 100);
	// Convert a 0-100 to an .eqf value
	const denormalizeEqBand = rebound(0, 100, 1, 64);
	// Merge a `source` object to a `target` recursively
	// TODO: The typing here is a bit of a disaster.
	function merge(target, source) {
	    const s = source;
	    const t = target;
	    // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties
	    for (const key of Object.keys(s)) {
	        if (s[key] instanceof Object)
	            Object.assign(s[key], merge(t[key], s[key]));
	    }
	    // Join `target` and modified `source`
	    Object.assign(target || {}, source);
	    return target;
	}
	// Maps a value in a range (defined my min/max) to a value in an array (options).
	function segment(min, max, value, newValues) {
	    const ratio = toPercent(min, max, value);
	    /*
	    | 0 | 1 | 2 |
	    0   1   2   3
	    */
	    return newValues[percentToIndex(ratio, newValues.length)];
	}
	// https://bost.ocks.org/mike/shuffle/
	// Shuffle an array in O(n)
	function shuffle(array) {
	    const sorted = [...array];
	    let m = sorted.length;
	    // While there remain elements to shuffle…
	    while (m) {
	        // Pick a remaining element…
	        const i = Math.floor(Math.random() * m--);
	        // And swap it with the current element.
	        const val = sorted[m];
	        sorted[m] = sorted[i];
	        sorted[i] = val;
	    }
	    return sorted;
	}
	function sort(array, iteratee) {
	    return [...array].sort((a, b) => {
	        const aKey = iteratee(a);
	        const bKey = iteratee(b);
	        if (aKey < bKey) {
	            return -1;
	        }
	        else if (aKey > bKey) {
	            return 1;
	        }
	        return 0;
	    });
	}
	function moveSelected(arr, isSelected, offset) {
	    const newArr = new Array(arr.length);
	    let next = 0;
	    for (let i = 0; i < newArr.length; i++) {
	        const from = i - offset;
	        // Is a value supposed to move here?
	        if (from >= 0 && from < arr.length && isSelected(from)) {
	            newArr[i] = arr[from];
	        }
	        else {
	            while (next < arr.length && isSelected(next)) {
	                next++;
	            }
	            newArr[i] = arr[next];
	            next++;
	        }
	    }
	    return newArr;
	}
	function replaceAtIndex(arr, index, newValue) {
	    return [...arr.slice(0, index), newValue, ...arr.slice(index + 1)];
	}
	let counter = 0;
	function uniqueId$1() {
	    return counter++;
	}
	function objectForEach(obj, cb) {
	    Object.keys(obj).forEach((key) => cb(obj[key], key));
	}
	function objectMap(obj, cb) {
	    const modified = {};
	    Object.keys(obj).forEach((key) => (modified[key] = cb(obj[key], key)));
	    return modified;
	}
	function objectFilter(obj, predicate) {
	    // TODO: Could return the original reference if no values change
	    return Object.keys(obj).reduce((newObj, key) => {
	        if (predicate(obj[key], key)) {
	            newObj[key] = obj[key];
	        }
	        return newObj;
	    }, {});
	}
	const calculateBoundingBox = (windows) => {
	    if (windows.length === 0) {
	        return null;
	    }
	    const windowSizes = windows.map((w) => ({
	        left: w.x,
	        top: w.y,
	        bottom: w.y + w.height,
	        right: w.x + w.width,
	    }));
	    return windowSizes.reduce((b, w) => ({
	        left: Math.min(b.left, w.left),
	        top: Math.min(b.top, w.top),
	        bottom: Math.max(b.bottom, w.bottom),
	        right: Math.max(b.right, w.right),
	    }));
	};
	function findLastIndex(arr, cb) {
	    for (let i = arr.length - 1; i >= 0; i--) {
	        if (cb(arr[i])) {
	            return i;
	        }
	    }
	    return -1;
	}
	function getWindowSize$1() {
	    // Apparently this is crazy across browsers.
	    return {
	        width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
	        height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight),
	    };
	}
	function getScreenSize() {
	    return {
	        width: window.screen.width,
	        height: window.screen.height,
	    };
	}
	function getPos(e) {
	    switch (e.type) {
	        case "touchstart":
	        case "touchmove": {
	            const touch = e.targetTouches[0] ?? e.touches[0];
	            if (touch == null) {
	                // Investigating https://github.com/captbaritone/webamp/issues/1105
	                throw new Error("Unexpected touch event with zero touch targets.");
	            }
	            return touch;
	        }
	        case "mousedown":
	        case "mousemove": {
	            return e;
	        }
	        default:
	            throw new Error(`Unexpected event type: ${e.type}`);
	    }
	}
	function getX(e) {
	    return getPos(e).clientX;
	}
	function getY(e) {
	    return getPos(e).clientY;
	}
	function weakMapMemoize(func) {
	    const cache = new WeakMap();
	    return (value) => {
	        if (!cache.has(value)) {
	            cache.set(value, func(value));
	        }
	        return cache.get(value);
	    };
	}

	const defaultPlaylistState$1 = {
	    trackOrder: [],
	    currentTrack: null,
	    lastSelectedIndex: null,
	    selectedTracks: [],
	};
	const playlist = (state = defaultPlaylistState$1, action) => {
	    switch (action.type) {
	        case "CLICKED_TRACK":
	            return {
	                ...state,
	                selectedTracks: [state.trackOrder[action.index]],
	                lastSelectedIndex: action.index,
	            };
	        case "CTRL_CLICKED_TRACK": {
	            const id = state.trackOrder[action.index];
	            const index = state.selectedTracks.indexOf(id);
	            const newSelectedTracks = [...state.selectedTracks];
	            if (index === -1) {
	                newSelectedTracks.push(id);
	            }
	            else {
	                newSelectedTracks.splice(index, 1);
	            }
	            return {
	                ...state,
	                selectedTracks: newSelectedTracks,
	                // Using this as the lastClickedIndex is kinda funny, since you
	                // may have just _un_selected the track. However, this is what
	                // Winamp 2 does, so we'll copy it.
	                lastSelectedIndex: action.index,
	            };
	        }
	        case "SHIFT_CLICKED_TRACK":
	            if (state.lastSelectedIndex == null) {
	                return state;
	            }
	            const clickedIndex = action.index;
	            const start = Math.min(clickedIndex, state.lastSelectedIndex);
	            const end = Math.max(clickedIndex, state.lastSelectedIndex);
	            const selectedTracks = state.trackOrder.slice(start, end + 1);
	            return {
	                ...state,
	                selectedTracks,
	            };
	        case "SELECT_ALL":
	            return {
	                ...state,
	                selectedTracks: [...state.trackOrder],
	            };
	        case "SELECT_ZERO":
	            return {
	                ...state,
	                selectedTracks: [],
	            };
	        case "INVERT_SELECTION":
	            return {
	                ...state,
	                selectedTracks: state.trackOrder.filter((id) => !state.selectedTracks.includes(id)),
	            };
	        case "REMOVE_ALL_TRACKS":
	            // TODO: Consider disposing of ObjectUrls
	            return {
	                ...state,
	                trackOrder: [],
	                currentTrack: null,
	                selectedTracks: [],
	                lastSelectedIndex: null,
	            };
	        case "REMOVE_TRACKS":
	            // TODO: Consider disposing of ObjectUrls
	            const actionIds = new Set(action.ids.map(Number));
	            const { currentTrack } = state;
	            return {
	                ...state,
	                trackOrder: state.trackOrder.filter((trackId) => !actionIds.has(trackId)),
	                currentTrack: actionIds.has(Number(currentTrack)) ? null : currentTrack,
	                selectedTracks: Array.from(state.selectedTracks).filter((id) => actionIds.has(id)),
	                // TODO: This could probably be made to work, but we clear it just to be safe.
	                lastSelectedIndex: null,
	            };
	        case "REVERSE_LIST":
	            return {
	                ...state,
	                trackOrder: [...state.trackOrder].reverse(),
	                // TODO: This could probably be made to work, but we clear it just to be safe.
	                lastSelectedIndex: null,
	            };
	        case "RANDOMIZE_LIST":
	            return {
	                ...state,
	                trackOrder: shuffle(state.trackOrder),
	            };
	        case "SET_TRACK_ORDER":
	            const { trackOrder } = action;
	            return { ...state, trackOrder };
	        case "ADD_TRACK_FROM_URL":
	            const atIndex = action.atIndex == null
	                ? state.trackOrder.length
	                : action.atIndex;
	            return {
	                ...state,
	                trackOrder: [
	                    ...state.trackOrder.slice(0, atIndex),
	                    Number(action.id),
	                    ...state.trackOrder.slice(atIndex),
	                ],
	                // TODO: This could probably be made to work, but we clear it just to be safe.
	                lastSelectedIndex: null,
	            };
	        case "PLAY_TRACK":
	        case "BUFFER_TRACK":
	            return {
	                ...state,
	                currentTrack: action.id,
	            };
	        case "DRAG_SELECTED":
	            return {
	                ...state,
	                trackOrder: moveSelected(state.trackOrder, (i) => state.selectedTracks.includes(state.trackOrder[i]), action.offset),
	                // TODO: This could probably be made to work, but we clear it just to be safe.
	                lastSelectedIndex: null,
	            };
	        default:
	            return state;
	    }
	};

	const defaultWindowsState = {
	    focused: WINDOWS.MAIN,
	    positionsAreRelative: true,
	    genWindows: {
	        // TODO: Remove static capabilities and derive them from ids/generic
	        [WINDOWS.MAIN]: {
	            title: "Main Window",
	            size: [0, 0],
	            open: true,
	            shade: false,
	            canResize: false,
	            canShade: true,
	            canDouble: true,
	            hotkey: "Alt+W",
	            position: { x: 0, y: 0 },
	        },
	        [WINDOWS.EQUALIZER]: {
	            title: "Equalizer",
	            size: [0, 0],
	            open: true,
	            shade: false,
	            canResize: false,
	            canShade: true,
	            canDouble: true,
	            hotkey: "Alt+G",
	            position: { x: 0, y: 0 },
	        },
	        [WINDOWS.PLAYLIST]: {
	            title: "Playlist Editor",
	            size: [0, 0],
	            open: true,
	            shade: false,
	            canResize: true,
	            canShade: true,
	            canDouble: false,
	            hotkey: "Alt+E",
	            position: { x: 0, y: 0 },
	        },
	        [WINDOWS.MILKDROP]: {
	            title: "Milkdrop",
	            size: [0, 0],
	            open: false,
	            shade: false,
	            canResize: true,
	            canShade: false,
	            canDouble: false,
	            position: { x: 0, y: 0 },
	        },
	    },
	    browserWindowSize: { width: 0, height: 0 },
	    windowOrder: [
	        WINDOWS.PLAYLIST,
	        WINDOWS.EQUALIZER,
	        WINDOWS.MILKDROP,
	        WINDOWS.MAIN,
	    ],
	    milkdropEnabled: false,
	};
	const windows = (state = defaultWindowsState, action) => {
	    switch (action.type) {
	        case "ENABLE_MILKDROP":
	            return {
	                ...state,
	                milkdropEnabled: true,
	                genWindows: {
	                    ...state.genWindows,
	                    [WINDOWS.MILKDROP]: {
	                        ...state.genWindows[WINDOWS.MILKDROP],
	                        open: action.open,
	                    },
	                },
	            };
	        case "SET_FOCUSED_WINDOW":
	            let windowOrder = state.windowOrder;
	            if (action.window != null) {
	                windowOrder = [
	                    ...state.windowOrder.filter((windowId) => windowId !== action.window),
	                    action.window,
	                ];
	            }
	            return { ...state, focused: action.window, windowOrder };
	        case "TOGGLE_WINDOW_SHADE_MODE":
	            const { canShade } = state.genWindows[action.windowId];
	            if (!canShade) {
	                throw new Error(`Tried to shade/unshade a window that cannot be shaded: ${action.windowId}`);
	            }
	            return {
	                ...state,
	                genWindows: {
	                    ...state.genWindows,
	                    [action.windowId]: {
	                        ...state.genWindows[action.windowId],
	                        shade: !state.genWindows[action.windowId].shade,
	                    },
	                },
	            };
	        case "TOGGLE_WINDOW":
	            const windowState = state.genWindows[action.windowId];
	            return {
	                ...state,
	                genWindows: {
	                    ...state.genWindows,
	                    [action.windowId]: {
	                        ...windowState,
	                        open: !windowState.open,
	                    },
	                },
	            };
	        case "CLOSE_WINDOW":
	            return {
	                ...state,
	                genWindows: {
	                    ...state.genWindows,
	                    [action.windowId]: {
	                        ...state.genWindows[action.windowId],
	                        open: false,
	                    },
	                },
	            };
	        case "WINDOW_SIZE_CHANGED":
	            const { canResize } = state.genWindows[action.windowId];
	            if (!canResize) {
	                throw new Error(`Tried to resize a window that cannot be resized: ${action.windowId}`);
	            }
	            return {
	                ...state,
	                genWindows: {
	                    ...state.genWindows,
	                    [action.windowId]: {
	                        ...state.genWindows[action.windowId],
	                        size: action.size,
	                    },
	                },
	            };
	        case "UPDATE_WINDOW_POSITIONS":
	            return {
	                ...state,
	                positionsAreRelative: action.absolute === true
	                    ? false
	                    : state.positionsAreRelative,
	                genWindows: objectMap(state.genWindows, (w, windowId) => {
	                    const newPosition = action.positions[windowId];
	                    if (newPosition == null) {
	                        return w;
	                    }
	                    return { ...w, position: newPosition };
	                }),
	            };
	        case "RESET_WINDOW_SIZES":
	            return {
	                ...state,
	                genWindows: objectMap(state.genWindows, (w) => ({
	                    ...w,
	                    // Not sure why TypeScript can't figure this out for itself.
	                    size: [0, 0],
	                })),
	            };
	        case "LOAD_SERIALIZED_STATE": {
	            const { genWindows, focused, positionsAreRelative } = action
	                .serializedState.windows;
	            return {
	                ...state,
	                positionsAreRelative,
	                genWindows: objectMap(state.genWindows, (w, windowId) => {
	                    const serializedW = genWindows[windowId];
	                    if (serializedW == null) {
	                        return w;
	                    }
	                    // Pull out `hidden` since it's been removed from our state.
	                    const { hidden, ...rest } = serializedW;
	                    return { ...w, ...rest };
	                }),
	                focused,
	            };
	        }
	        case "BROWSER_WINDOW_SIZE_CHANGED":
	            return {
	                ...state,
	                browserWindowSize: {
	                    height: action.height,
	                    width: action.width,
	                },
	            };
	        default:
	            return state;
	    }
	};
	function getSerializedState$3(state) {
	    return {
	        positionsAreRelative: state.positionsAreRelative,
	        genWindows: objectMap(state.genWindows, (w) => {
	            return {
	                size: w.size,
	                open: w.open,
	                hidden: false, // Not used any more
	                shade: w.shade || false,
	                position: w.position,
	            };
	        }),
	        focused: state.focused,
	    };
	}

	const defaultState$1 = {
	    timeMode: TIME_MODE.ELAPSED,
	    timeElapsed: 0,
	    // The winamp ini file declares the default volume as "200".
	    // The UI seems to show a default volume near 78, which would
	    // math with the default value being 200 out of 255.
	    volume: Math.round((200 / 255) * 100),
	    balance: 0,
	    shuffle: false,
	    repeat: false,
	    // TODO: Enforce possible values
	    status: PLAYER_MEDIA_STATUS.STOPPED,
	};
	const media = (state = defaultState$1, action) => {
	    switch (action.type) {
	        // TODO: Make these constants
	        case "PLAY":
	        case "IS_PLAYING":
	            return { ...state, status: PLAYER_MEDIA_STATUS.PLAYING };
	        case "PAUSE":
	            return { ...state, status: PLAYER_MEDIA_STATUS.PAUSED };
	        case "STOP":
	            return { ...state, status: PLAYER_MEDIA_STATUS.STOPPED };
	        case "IS_STOPPED":
	            return { ...state, status: PLAYER_MEDIA_STATUS.ENDED };
	        case "OPEN_WINAMP":
	            return { ...state, status: PLAYER_MEDIA_STATUS.STOPPED };
	        case "CLOSE_WINAMP":
	            return { ...state, status: PLAYER_MEDIA_STATUS.CLOSED };
	        case "TOGGLE_TIME_MODE":
	            const newMode = state.timeMode === TIME_MODE.REMAINING
	                ? TIME_MODE.ELAPSED
	                : TIME_MODE.REMAINING;
	            return { ...state, timeMode: newMode };
	        case "UPDATE_TIME_ELAPSED":
	            return { ...state, timeElapsed: action.elapsed };
	        case "SET_MEDIA":
	            return {
	                ...state,
	            };
	        case "SET_VOLUME":
	            return { ...state, volume: action.volume };
	        case "SET_BALANCE":
	            return { ...state, balance: action.balance };
	        case "TOGGLE_REPEAT":
	            return { ...state, repeat: !state.repeat };
	        case "TOGGLE_SHUFFLE":
	            return { ...state, shuffle: !state.shuffle };
	        case "LOAD_SERIALIZED_STATE":
	            return { ...state, ...action.serializedState.media };
	        default:
	            return state;
	    }
	};
	function getSerializedState$2(state) {
	    const { volume, balance, shuffle, repeat } = state;
	    return { volume, balance, shuffle, repeat };
	}

	var createSelector_1;
	var defaultMemoize_1 = defaultMemoize;
	function defaultEqualityCheck(a, b) {
	  return a === b;
	}

	function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
	  if (prev === null || next === null || prev.length !== next.length) {
	    return false;
	  }

	  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
	  var length = prev.length;
	  for (var i = 0; i < length; i++) {
	    if (!equalityCheck(prev[i], next[i])) {
	      return false;
	    }
	  }

	  return true;
	}

	function defaultMemoize(func) {
	  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

	  var lastArgs = null;
	  var lastResult = null;
	  // we reference arguments instead of spreading them for performance reasons
	  return function () {
	    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
	      // apply arguments instead of spreading for performance.
	      lastResult = func.apply(null, arguments);
	    }

	    lastArgs = arguments;
	    return lastResult;
	  };
	}

	function getDependencies(funcs) {
	  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

	  if (!dependencies.every(function (dep) {
	    return typeof dep === 'function';
	  })) {
	    var dependencyTypes = dependencies.map(function (dep) {
	      return typeof dep;
	    }).join(', ');
	    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
	  }

	  return dependencies;
	}

	function createSelectorCreator(memoize) {
	  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    memoizeOptions[_key - 1] = arguments[_key];
	  }

	  return function () {
	    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      funcs[_key2] = arguments[_key2];
	    }

	    var recomputations = 0;
	    var resultFunc = funcs.pop();
	    var dependencies = getDependencies(funcs);

	    var memoizedResultFunc = memoize.apply(undefined, [function () {
	      recomputations++;
	      // apply arguments instead of spreading for performance.
	      return resultFunc.apply(null, arguments);
	    }].concat(memoizeOptions));

	    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
	    var selector = defaultMemoize(function () {
	      var params = [];
	      var length = dependencies.length;

	      for (var i = 0; i < length; i++) {
	        // apply arguments instead of spreading and mutate a local list of params for performance.
	        params.push(dependencies[i].apply(null, arguments));
	      }

	      // apply arguments instead of spreading for performance.
	      return memoizedResultFunc.apply(null, params);
	    });

	    selector.resultFunc = resultFunc;
	    selector.recomputations = function () {
	      return recomputations;
	    };
	    selector.resetRecomputations = function () {
	      return recomputations = 0;
	    };
	    return selector;
	  };
	}

	createSelector_1 = createSelectorCreator(defaultMemoize);

	const defaultSkinGenExColors = {
	    itemBackground: "rgb(0,0,0)",
	    itemForeground: "rgb(0,255,0)",
	    windowBackground: "rgb(56,55,87)",
	    buttonText: "rgb(57,57,66)",
	    windowText: "rgb(255,255,255)",
	    divider: "rgb(117,116,139)",
	    playlistSelection: "rgb(0,0,198)",
	    listHeaderBackground: "rgb(72,72,120)",
	    listHeaderText: "rgb(255,255,255)",
	    listHeaderFrameTopAndLeft: "rgb(108,108,180)",
	    listHeaderFrameBottomAndRight: "rgb(36,36,60)",
	    listHeaderFramePressed: "rgb(18,18,30)",
	    listHeaderDeadArea: "rgb(36,36,60)",
	    scrollbarOne: "rgb(36,36,60)",
	    scrollbarTwo: "rgb(36,36,60)",
	    pressedScrollbarOne: "rgb(121,130,150)",
	    pressedScrollbarTwo: "rgb(78,88,110)",
	    scrollbarDeadArea: "rgb(36,36,60)",
	    listTextHighlighted: "rgb(0,198,255)",
	    listTextHighlightedBackground: "rgb(0,198,255)",
	    listTextSelected: "rgb(0,198,255)",
	    listTextSelectedBackground: "rgb(0,198,255)",
	};
	const defaultDisplayState = {
	    doubled: false,
	    marqueeStep: 0,
	    disableMarquee: false,
	    loading: true,
	    llama: false,
	    closed: false,
	    working: false,
	    skinImages: DEFAULT_SKIN.images,
	    skinColors: DEFAULT_SKIN.colors,
	    skinCursors: null,
	    skinPlaylistStyle: null,
	    skinRegion: {},
	    visualizerStyle: 0, // Index into VISUALIZER_ORDER
	    dummyVizData: null,
	    playlistScrollPosition: 0,
	    skinGenLetterWidths: null, // TODO: Get the default value for this?
	    skinGenExColors: defaultSkinGenExColors,
	    additionalVisualizers: [],
	    zIndex: 0,
	};
	const display = (state = defaultDisplayState, action) => {
	    switch (action.type) {
	        case "LOAD_DEFAULT_SKIN": {
	            const { skinImages, skinColors, skinCursors, skinPlaylistStyle, skinRegion, skinGenLetterWidths, skinGenExColors, } = defaultDisplayState;
	            return {
	                ...state,
	                skinImages,
	                skinColors,
	                skinCursors,
	                skinPlaylistStyle,
	                skinRegion,
	                skinGenLetterWidths,
	                skinGenExColors,
	            };
	        }
	        case "TOGGLE_DOUBLESIZE_MODE":
	            return { ...state, doubled: !state.doubled };
	        case "TOGGLE_LLAMA_MODE":
	            return { ...state, llama: !state.llama };
	        case "STEP_MARQUEE":
	            return state.disableMarquee
	                ? state
	                : { ...state, marqueeStep: state.marqueeStep + 1 };
	        case "DISABLE_MARQUEE":
	            return { ...state, disableMarquee: true };
	        case "STOP_WORKING":
	            return { ...state, working: false };
	        case "START_WORKING":
	            return { ...state, working: true };
	        case "CLOSE_WINAMP":
	            return { ...state, closed: true };
	        case "OPEN_WINAMP":
	            return { ...state, closed: false };
	        case "LOADING":
	            return { ...state, loading: true };
	        case "LOADED":
	            return { ...state, loading: false };
	        case "SET_SKIN_DATA":
	            const { data } = action;
	            return {
	                ...state,
	                loading: false,
	                skinImages: data.skinImages,
	                skinColors: data.skinColors,
	                skinPlaylistStyle: data.skinPlaylistStyle,
	                skinCursors: data.skinCursors,
	                skinRegion: data.skinRegion,
	                skinGenLetterWidths: data.skinGenLetterWidths,
	                skinGenExColors: data.skinGenExColors || defaultSkinGenExColors,
	            };
	        case "TOGGLE_VISUALIZER_STYLE":
	            return {
	                ...state,
	                visualizerStyle: (state.visualizerStyle + 1) % VISUALIZER_ORDER.length,
	            };
	        case "SET_PLAYLIST_SCROLL_POSITION":
	            return { ...state, playlistScrollPosition: action.position };
	        case "SET_Z_INDEX":
	            return { ...state, zIndex: action.zIndex };
	        case "SET_DUMMY_VIZ_DATA":
	            return { ...state, dummyVizData: action.data };
	        case "LOAD_SERIALIZED_STATE": {
	            const { skinCursors, ...rest } = action.serializedState.display;
	            const upgrade = (url) => ({ type: "cur", url });
	            const newSkinCursors = skinCursors == null ? null : objectMap(skinCursors, upgrade);
	            return { ...state, skinCursors: newSkinCursors, ...rest };
	        }
	        default:
	            return state;
	    }
	};
	const getSerializedState$1 = (state) => {
	    // My kingdom for a type-safe `_.pick`.
	    const { visualizerStyle, doubled, llama, marqueeStep, skinImages, skinCursors, skinRegion, skinGenLetterWidths, skinColors, skinPlaylistStyle, } = state;
	    let newCursors = null;
	    if (skinCursors != null) {
	        // @ts-ignore Typescript does not like that we can have `undefined` as
	        // values here. Since this is going to get serialized to JSON (which will
	        // drop undefined) it's fine.
	        // This code is geting removed soon anyway.
	        newCursors = objectMap(skinCursors, (cursor) => {
	            return cursor.type === "cur" ? cursor.url : undefined;
	        });
	    }
	    return {
	        visualizerStyle,
	        doubled,
	        llama,
	        marqueeStep,
	        skinImages,
	        skinCursors: newCursors,
	        skinRegion,
	        skinGenLetterWidths,
	        skinColors,
	        skinPlaylistStyle,
	    };
	};
	const getVisualizerStyle$1 = createSelector_1((state) => state.visualizerStyle, (visualizationStyle) => {
	    return VISUALIZER_ORDER[visualizationStyle];
	});

	const defaultUserInput = {
	    focus: null,
	    bandFocused: null,
	    scrubPosition: 0,
	    userMessage: null,
	};
	const userInput = (state = defaultUserInput, action) => {
	    switch (action.type) {
	        case "SET_FOCUS":
	            return { ...state, focus: action.input, bandFocused: null };
	        case "SET_BAND_FOCUS":
	            return {
	                ...state,
	                focus: action.input,
	                bandFocused: action.bandFocused,
	            };
	        case "UNSET_FOCUS":
	            return { ...state, focus: null, bandFocused: null };
	        case "SET_SCRUB_POSITION":
	            return { ...state, scrubPosition: action.position };
	        case "SET_USER_MESSAGE":
	            return { ...state, userMessage: action.message };
	        case "UNSET_USER_MESSAGE":
	            return { ...state, userMessage: null };
	        default:
	            return state;
	    }
	};

	const defaultState = {
	    on: true,
	    auto: false,
	    sliders: {
	        preamp: 50,
	        60: 50,
	        170: 50,
	        310: 50,
	        600: 50,
	        1000: 50,
	        3000: 50,
	        6000: 50,
	        12000: 50,
	        14000: 50,
	        16000: 50,
	    },
	};
	const equalizer = (state = defaultState, action) => {
	    switch (action.type) {
	        case "SET_BAND_VALUE":
	            const newSliders = {
	                ...state.sliders,
	                [action.band]: action.value,
	            };
	            return { ...state, sliders: newSliders };
	        case "SET_EQ_ON":
	            return { ...state, on: true };
	        case "SET_EQ_OFF":
	            return { ...state, on: false };
	        case "SET_EQ_AUTO":
	            return { ...state, auto: action.value };
	        case "LOAD_SERIALIZED_STATE":
	            return action.serializedState.equalizer || state;
	        default:
	            return state;
	    }
	};
	function getSerializedState(state) {
	    return state;
	}

	const network = (state = { connected: true }, action) => {
	    switch (action.type) {
	        case "NETWORK_CONNECTED":
	            return { ...state, connected: true };
	        case "NETWORK_DISCONNECTED":
	            return { ...state, connected: false };
	        default:
	            return state;
	    }
	};

	const defaultSettingsState = {
	    availableSkins: [],
	};
	const settings = (state = defaultSettingsState, action) => {
	    switch (action.type) {
	        case "SET_AVAILABLE_SKINS":
	            return { ...state, availableSkins: action.skins };
	        default:
	            return state;
	    }
	};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	var browser$3 = invariant;

	var invariant$1 = /*@__PURE__*/getDefaultExportFromCjs(browser$3);

	async function genMediaTags(file, musicMetadata) {
	    invariant$1(file != null, "Attempted to get the tags of media file without passing a file");
	    const options = {
	        duration: true,
	        skipPostHeaders: true, // avoid unnecessary data to be read
	    };
	    if (typeof file === "string") {
	        if ("parseWebStream" in musicMetadata &&
	            typeof musicMetadata.parseWebStream === "function") {
	            const response = await fetch(file);
	            if (!response.ok) {
	                throw new Error(`Failed to fetch URL: ${file}, status: ${response.status}`);
	            }
	            // https://github.com/Borewit/music-metadata/issues/2455
	            // There's currently an issue where some URLs will fail to parse id3 tags
	            // when using parseWebStream. This approach can work around it. However,
	            // My current assumption is that this is an issue mostly specific to that
	            // individual file and not a wide spread issue, but if we find it happens
	            // more broadly we can deopt to using parseBlob as below.
	            // const blob = await response.blob();
	            // return musicMetadata.parseBlob(blob, options);
	            const webStream = response.body;
	            if (webStream == null) {
	                throw new Error("Response body is null, cannot parse metadata.");
	            }
	            return musicMetadata.parseWebStream(webStream, undefined, options);
	        }
	        if ("fetchFromUrl" in musicMetadata &&
	            typeof musicMetadata.fetchFromUrl === "function") {
	            return musicMetadata.fetchFromUrl(file, options);
	        }
	        throw new Error("No suitable method available to parse URL");
	    }
	    // Assume Blob
	    return musicMetadata.parseBlob(file, options);
	}
	function genMediaDuration(url) {
	    invariant$1(typeof url === "string", "Attempted to get the duration of media file without passing a url");
	    return new Promise((resolve, reject) => {
	        // TODO: Does this actually stop downloading the file once it's
	        // got the duration?
	        const audio = document.createElement("audio");
	        audio.crossOrigin = "anonymous";
	        const durationChange = () => {
	            resolve(audio.duration);
	            audio.removeEventListener("durationchange", durationChange);
	            audio.removeEventListener("error", errorHandler);
	            audio.src = "";
	            // TODO: Not sure if this really gets cleaned up.
	        };
	        const errorHandler = (e) => {
	            audio.removeEventListener("durationchange", durationChange);
	            audio.removeEventListener("error", errorHandler);
	            reject(e);
	        };
	        audio.addEventListener("durationchange", durationChange);
	        audio.addEventListener("error", errorHandler);
	        audio.src = url;
	    });
	}
	async function genArrayBufferFromFileReference(fileReference) {
	    invariant$1(fileReference != null, "Attempt to get an ArrayBuffer without assigning a fileReference");
	    return new Promise((resolve, reject) => {
	        const reader = new FileReader();
	        reader.onload = () => {
	            resolve(reader.result);
	        };
	        reader.onerror = reject;
	        reader.readAsArrayBuffer(fileReference);
	    });
	}
	async function genStringFromFileReference(fileReference) {
	    return new Promise((resolve, reject) => {
	        const reader = new FileReader();
	        reader.onload = () => {
	            resolve(reader.result);
	        };
	        reader.onerror = reject;
	        reader.readAsText(fileReference);
	    });
	}
	async function promptForFileReferences({ accept, directory = false } = {
	    accept: null,
	    directory: false,
	}) {
	    return new Promise((resolve) => {
	        // Does this represent a memory leak somehow?
	        // Can this fail? Do we ever reject?
	        const fileInput = document.createElement("input");
	        if (accept)
	            fileInput.setAttribute("accept", accept);
	        fileInput.type = "file";
	        fileInput.multiple = true;
	        // @ts-ignore Non-standard
	        fileInput.webkitdirectory = directory;
	        // @ts-ignore Non-standard
	        fileInput.directory = directory;
	        // @ts-ignore Non-standard
	        fileInput.mozdirectory = directory;
	        // Not entirely sure why this is needed, since the input
	        // was just created, but somehow this helps prevent change
	        // events from getting swallowed.
	        // https://stackoverflow.com/a/12102992/1263117
	        // @ts-ignore Technically you can't set this to null, it has to be a string.
	        // But I don't feel like retesting it, so I'll leave it as null
	        fileInput.value = null;
	        fileInput.addEventListener("change", (e) => {
	            const files = e.target.files;
	            resolve(files);
	        });
	        fileInput.click();
	    });
	}
	function urlIsBlobUrl(url) {
	    return /^blob:/.test(url);
	}
	function curUrlFromByteArray$1(arr) {
	    const base64 = base64FromDataArray$1(arr);
	    return `data:image/x-win-bitmap;base64,${base64}`;
	}
	// This is not perfect, but... meh: https://stackoverflow.com/a/36756650/1263117
	function filenameFromUrl(url) {
	    if (urlIsBlobUrl(url)) {
	        return null;
	    }
	    const lastSegment = url.split("/").pop();
	    if (lastSegment == null) {
	        return null;
	    }
	    return lastSegment.split("#")[0].split("?")[0];
	}

	const trackName = weakMapMemoize((track) => {
	    const { artist, title, defaultName, url } = track;
	    if (artist && title) {
	        return `${artist} - ${title}`;
	    }
	    else if (title) {
	        return title;
	    }
	    else if (defaultName) {
	        return defaultName;
	    }
	    else if (url) {
	        const filename = filenameFromUrl(url);
	        if (filename) {
	            return filename;
	        }
	    }
	    return "???";
	});

	const defaultPlaylistState = {};
	const tracks = (state = defaultPlaylistState, action) => {
	    switch (action.type) {
	        case "ADD_TRACK_FROM_URL":
	            return {
	                ...state,
	                [action.id]: {
	                    id: action.id,
	                    defaultName: action.defaultName || null,
	                    duration: action.duration ?? null,
	                    url: action.url,
	                    mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.INITIALIZED,
	                },
	            };
	        case "SET_MEDIA": {
	            const newTrack = {
	                ...state[action.id],
	                duration: action.length,
	            };
	            return {
	                ...state,
	                [action.id]: newTrack,
	            };
	        }
	        case "MEDIA_TAG_REQUEST_INITIALIZED":
	            return {
	                ...state,
	                [action.id]: {
	                    ...state[action.id],
	                    mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.INITIALIZED,
	                },
	            };
	        case "MEDIA_TAG_REQUEST_FAILED":
	            return {
	                ...state,
	                [action.id]: {
	                    ...state[action.id],
	                    mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.FAILED,
	                },
	            };
	        case "SET_MEDIA_DURATION": {
	            return {
	                ...state,
	                [action.id]: {
	                    ...state[action.id],
	                    duration: action.duration,
	                },
	            };
	        }
	        case "SET_MEDIA_TAGS":
	            const track = state[action.id];
	            const { sampleRate, bitrate, numberOfChannels, title, artist, album, albumArtUrl, } = action;
	            const { kbps, khz, channels } = track;
	            return {
	                ...state,
	                [action.id]: {
	                    ...track,
	                    mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.COMPLETE,
	                    title,
	                    artist,
	                    album,
	                    albumArtUrl,
	                    kbps: bitrate != null ? String(Math.round(bitrate / 1000)) : kbps,
	                    khz: sampleRate != null ? String(Math.round(sampleRate / 1000)) : khz,
	                    channels: numberOfChannels != null ? numberOfChannels : channels,
	                },
	            };
	        default:
	            return state;
	    }
	};
	const getTrackDisplayName$1 = (state, id = null) => {
	    if (id == null) {
	        return null;
	    }
	    const track = state[id];
	    if (track == null) {
	        return null;
	    }
	    return trackName(track);
	};

	var TransitionType;
	(function (TransitionType) {
	    TransitionType[TransitionType["IMMEDIATE"] = 0] = "IMMEDIATE";
	    TransitionType[TransitionType["DEFAULT"] = 1] = "DEFAULT";
	    TransitionType[TransitionType["USER_PRESET"] = 2] = "USER_PRESET";
	})(TransitionType || (TransitionType = {}));

	const defaultMilkdropState = {
	    display: "WINDOW",
	    overlay: false,
	    presetHistory: [],
	    presets: [],
	    currentPresetIndex: null,
	    butterchurn: null,
	    transitionType: TransitionType.DEFAULT,
	    randomize: true,
	    cycling: true,
	    message: null,
	};
	const milkdrop = (state = defaultMilkdropState, action) => {
	    switch (action.type) {
	        case "SET_MILKDROP_DESKTOP":
	            return {
	                ...state,
	                display: action.enabled ? "DESKTOP" : "WINDOW",
	            };
	        case "SET_MILKDROP_FULLSCREEN":
	            return {
	                ...state,
	                display: action.enabled ? "FULLSCREEN" : "WINDOW",
	            };
	        case "GOT_BUTTERCHURN":
	            return { ...state, butterchurn: action.butterchurn };
	        case "GOT_BUTTERCHURN_PRESETS":
	            return {
	                ...state,
	                presets: state.presets.concat(action.presets),
	            };
	        case "PRESET_REQUESTED":
	            if (action.addToHistory) {
	                return {
	                    ...state,
	                    presetHistory: [...state.presetHistory, action.index],
	                };
	            }
	            return {
	                ...state,
	                presetHistory: state.presetHistory.slice(0, -1),
	            };
	        case "RESOLVE_PRESET_AT_INDEX":
	            const preset = state.presets[action.index];
	            return {
	                ...state,
	                presets: replaceAtIndex(state.presets, action.index, {
	                    type: "RESOLVED",
	                    name: preset.name,
	                    preset: action.json,
	                }),
	            };
	        case "SELECT_PRESET_AT_INDEX":
	            return {
	                ...state,
	                currentPresetIndex: action.index,
	                transitionType: action.transitionType,
	            };
	        case "TOGGLE_PRESET_OVERLAY":
	            return { ...state, overlay: !state.overlay };
	        case "TOGGLE_RANDOMIZE_PRESETS":
	            return { ...state, randomize: !state.randomize };
	        case "TOGGLE_PRESET_CYCLING":
	            return { ...state, cycling: !state.cycling };
	        case "SCHEDULE_MILKDROP_MESSAGE":
	            return {
	                ...state,
	                message: {
	                    text: action.message,
	                    time: Date.now(),
	                },
	            };
	        default:
	            return state;
	    }
	};

	const reducer = combineReducers({
	    userInput,
	    windows,
	    display,
	    settings,
	    equalizer,
	    playlist,
	    media,
	    network,
	    tracks,
	    milkdrop,
	});

	const getAsDataURI = (text) => `data:text/html;base64,${window.btoa(text)}`;
	// Replaces deprecated "noshade" attribute
	const noshadeStyle = {
	    height: "2px",
	    borderWidth: 0,
	    color: "gray",
	    backgroundColor: "gray",
	};
	const Font = (props) => {
	    // @ts-ignore
	    return jsxRuntimeExports.jsx("font", { ...props });
	};
	const Hr$1 = (props) => {
	    // @ts-ignore
	    return jsxRuntimeExports.jsx("hr", { ...props });
	};
	const Div = (props) => {
	    // @ts-ignore
	    return jsxRuntimeExports.jsx("div", { ...props });
	};
	const Table = (props) => {
	    // @ts-ignore
	    return jsxRuntimeExports.jsx("table", { ...props });
	};
	// TODO: Move <html> tag out to the string creation step in order
	// to avoid the warning.
	const Playlist = (props) => (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(Div, { align: "center", children: [jsxRuntimeExports.jsx(Div, { className: "para2", align: "center", children: jsxRuntimeExports.jsx("p", { children: "WINAMP" }) }), jsxRuntimeExports.jsx(Div, { className: "para1", align: "center", children: jsxRuntimeExports.jsx("p", { children: "playlist" }) })] }), jsxRuntimeExports.jsx(Hr$1, { align: "left", width: "90%", size: "1", color: "#FFBF00", style: noshadeStyle }), jsxRuntimeExports.jsx(Div, { align: "right", children: jsxRuntimeExports.jsx(Table, { border: "0", cellSpacing: "0", cellPadding: "0", width: "98%", children: jsxRuntimeExports.jsx("tbody", { children: jsxRuntimeExports.jsx("tr", { children: jsxRuntimeExports.jsxs("td", { children: [jsxRuntimeExports.jsx("small", { children: jsxRuntimeExports.jsxs("small", { children: [jsxRuntimeExports.jsx(Font, { face: "Arial", color: "#FFBF00", children: props.numberOfTracks }), jsxRuntimeExports.jsx(Font, { color: "#409FFF", face: "Arial", children: " track in playlist, average track length: " }), jsxRuntimeExports.jsx(Font, { face: "Arial", color: "#FFBF00", children: props.averageTrackLength })] }) }), jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsx("small", { children: jsxRuntimeExports.jsxs("small", { children: [jsxRuntimeExports.jsx(Font, { color: "#409FFF", face: "Arial", children: "Playlist length: " }), jsxRuntimeExports.jsx(Font, { face: "Arial", color: "#FFBF00", children: props.playlistLengthMinutes }), jsxRuntimeExports.jsx(Font, { color: "#409FFF", face: "Arial", children: " minutes " }), jsxRuntimeExports.jsx(Font, { face: "Arial", color: "#FFBF00", children: props.playlistLengthSeconds }), jsxRuntimeExports.jsx(Font, { color: "#409FFF", face: "Arial", children: " second " }), jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsxs(Font, { color: "#409FFF", face: "Arial", children: ["Right-click ", jsxRuntimeExports.jsx("a", { href: "./", children: "here" }), " to save this HTML file."] })] }) })] }) }) }) }) }), jsxRuntimeExports.jsxs("blockquote", { children: [jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx(Font, { color: "#FFBF00", face: "Arial", children: jsxRuntimeExports.jsx("big", { children: "Playlist files:" }) }) }), jsxRuntimeExports.jsx("ul", { children: jsxRuntimeExports.jsx(Font, { face: "Arial", color: "#FFFFFF", children: jsxRuntimeExports.jsx("small", { children: props.tracks.map((track) => (jsxRuntimeExports.jsxs("span", { children: [track, jsxRuntimeExports.jsx("br", {})] }, track))) }) }) })] }), jsxRuntimeExports.jsx(Hr$1, { align: "left", width: "90%", size: "1", color: "#FFBF00", style: noshadeStyle })] }));
	const createPlaylistHTML = (props) => {
	    const node = document.createElement("div");
	    const root = clientExports.createRoot(node);
	    reactDomExports.flushSync(() => {
	        root.render(jsxRuntimeExports.jsx(Playlist, { ...props }));
	    });
	    return `
  <html>
      <head>
      <link rel="stylesheet" href="null" />
      <style type="text/css">
        body { background: #000040; }
        .para1 { margin-top: -42px; margin-left: 145px; margin-right: 10px; font-family: "font2, Arial"; font-size: 30px; line-height: 35px; text-align: left; color: #E1E1E1; }
        .para2 { margin-top: 15px; margin-left: 15px; margin-right: 50px; font-family: "font1, Arial Black"; font-size: 50px; line-height: 40px; text-align: left; color: #004080; }
      </style>
      <title>Winamp Generated PlayList</title>
    </head>
     <body bgcolor="#000080" topmargin="0" leftmargin="0" text="#FFFFFF">
    ${node.innerHTML}
    </body
  </html>`;
	};
	const createPlaylistURL = (props) => getAsDataURI(createPlaylistHTML(props));

	const getBalanceText = (balance) => {
	    if (balance === 0) {
	        return "Balance: Center";
	    }
	    const direction = balance > 0 ? "Right" : "Left";
	    return `Balance: ${Math.abs(balance)}% ${direction}`;
	};
	const getVolumeText = (volume) => `Volume: ${volume}%`;
	const getPositionText = (duration, seekToPercent) => {
	    const newElapsedStr = getTimeStr((duration * seekToPercent) / 100, false);
	    const durationStr = getTimeStr(duration, false);
	    return `Seek to: ${newElapsedStr}/${durationStr} (${seekToPercent}%)`;
	};
	const getDoubleSizeModeText = (enabled) => `${enabled ? "Disable" : "Enable"} doublesize mode`;
	const formatHz = (hz) => hz < 1000 ? `${hz}HZ` : `${hz / 1000}KHZ`;
	// Format a number as a string, ensuring it has a + or - sign
	const ensureSign = (num) => num > 0 ? `+${num}` : num.toString();
	// Round to 1 and exactly 1 decimal point
	const roundToTenths = (num) => (Math.round(num * 10) / 10).toFixed(1);
	const getEqText = (band, level) => {
	    const db = roundToTenths(((level - 50) / 50) * 12);
	    const label = band === "preamp" ? "Preamp" : formatHz(band);
	    return `EQ: ${label} ${ensureSign(Number(db))} DB`;
	};

	function getPositionDiff(graph, sizeDiff) {
	    const newGraph = {};
	    const positionDiff = {};
	    for (const key of Object.keys(graph)) {
	        newGraph[key] = { above: [], left: [] };
	        positionDiff[key] = { x: 0, y: 0 };
	    }
	    // Construct an inverted graph
	    for (const [key, neighbors] of Object.entries(graph)) {
	        const { below, right } = neighbors;
	        if (right != null) {
	            newGraph[right].left.push(key);
	        }
	        if (below != null) {
	            newGraph[below].above.push(key);
	        }
	    }
	    function walkRight(key) {
	        const node = newGraph[key];
	        const nodeSizeDiff = sizeDiff[key];
	        node.left.forEach((left) => {
	            positionDiff[left].x += nodeSizeDiff.width + positionDiff[key].x;
	            walkRight(left);
	        });
	    }
	    function walkDown(key) {
	        const node = newGraph[key];
	        const nodeSizeDiff = sizeDiff[key];
	        node.above.forEach((above) => {
	            positionDiff[above].y += nodeSizeDiff.height + positionDiff[key].y;
	            walkDown(above);
	        });
	    }
	    // Find disconnected nodes, and walk
	    for (const [key, neighbors] of Object.entries(graph)) {
	        if (neighbors.below == null) {
	            walkDown(key);
	        }
	        if (neighbors.right == null) {
	            walkRight(key);
	        }
	    }
	    return positionDiff;
	}
	function generateGraph(windows) {
	    const bottoms = {};
	    const rights = {};
	    for (const w of windows) {
	        const bottom = w.y + w.height;
	        if (bottoms[bottom]) {
	            bottoms[bottom].push(w);
	        }
	        else {
	            bottoms[bottom] = [w];
	        }
	        const right = w.x + w.width;
	        if (rights[right]) {
	            rights[right].push(w);
	        }
	        else {
	            rights[right] = [w];
	        }
	    }
	    const graph = {};
	    for (const w of windows) {
	        const edges = {};
	        const top = w.y;
	        const left = w.x;
	        const tops = bottoms[top];
	        const lefts = rights[left];
	        if (tops) {
	            for (const below of tops) {
	                const isToTheLeft = below.x + below.width < w.x;
	                const isToTheRight = below.x > w.x + w.width;
	                const overlapsInX = !(isToTheLeft || isToTheRight);
	                if (overlapsInX) {
	                    edges.below = below.key;
	                    break;
	                }
	            }
	        }
	        if (lefts) {
	            for (const right of lefts) {
	                const isAbove = right.y + right.height < w.y;
	                const isBelow = right.y > w.y + w.height;
	                const overlapsInY = !(isAbove || isBelow);
	                if (overlapsInY) {
	                    edges.right = right.key;
	                    break;
	                }
	            }
	        }
	        graph[w.key] = edges;
	    }
	    return graph;
	}

	const getSliders = (state) => state.equalizer.sliders;
	const getEqfData = createSelector_1(getSliders, (sliders) => {
	    const preset = {
	        name: "Entry1",
	        preamp: denormalizeEqBand(sliders.preamp),
	        hz60: denormalizeEqBand(sliders[60]),
	        hz170: denormalizeEqBand(sliders[170]),
	        hz310: denormalizeEqBand(sliders[310]),
	        hz600: denormalizeEqBand(sliders[600]),
	        hz1000: denormalizeEqBand(sliders[1000]),
	        hz3000: denormalizeEqBand(sliders[3000]),
	        hz6000: denormalizeEqBand(sliders[6000]),
	        hz12000: denormalizeEqBand(sliders[12000]),
	        hz14000: denormalizeEqBand(sliders[14000]),
	        hz16000: denormalizeEqBand(sliders[16000]),
	    };
	    const eqfData = {
	        presets: [preset],
	        type: "Winamp EQ library file v1.1",
	    };
	    return eqfData;
	});
	const getTracks = (state) => state.tracks;
	const getTrackUrl = (state) => {
	    return (id) => {
	        return state.tracks[id]?.url;
	    };
	};
	const getTrackOrder = (state) => state.playlist.trackOrder;
	const getTrackCount = createSelector_1(getTrackOrder, (trackOrder) => trackOrder.length);
	const getOrderedTracks = createSelector_1(getTracks, getTrackOrder, (tracks, trackOrder) => trackOrder.filter((id) => tracks[id]));
	const getPlaylistTracks = createSelector_1(getTracks, getTrackOrder, (tracks, trackOrder) => trackOrder.map((id) => tracks[id]).filter(Boolean));
	const getUserTracks = createSelector_1(getTracks, getTrackOrder, (tracks, trackOrder) => trackOrder.map((id) => {
	    const track = tracks[id];
	    return {
	        url: track.url,
	        metaData: {
	            artist: track.artist || "",
	            title: track.title || "",
	            album: track.album,
	            albumArtUrl: track.albumArtUrl || "",
	        },
	    };
	}));
	const getOrderedTrackObjects = createSelector_1(getTracks, getOrderedTracks, (tracks, trackOrder) => trackOrder.map((id) => tracks[id]));
	const getSelectedTrackIds = (state) => {
	    return state.playlist.selectedTracks;
	};
	const getSelectedTrackIdsSet = createSelector_1(getSelectedTrackIds, (selectedTrackArray) => {
	    return new Set(selectedTrackArray);
	});
	const getSelectedTrackObjects = createSelector_1(getOrderedTrackObjects, getSelectedTrackIdsSet, (tracks, selectedIds) => tracks.filter((track) => selectedIds.has(track.id)));
	// If a duration is `null`, it counts as zero, which seems fine enough.
	const runningTimeFromTracks = (tracks) => tracks.reduce((time, track) => time + Number(track.duration), 0);
	const getTotalRunningTime = createSelector_1(getOrderedTrackObjects, runningTimeFromTracks);
	const getSelectedRunningTime = createSelector_1(getSelectedTrackObjects, runningTimeFromTracks);
	// Note: We should append "+" to these values if some of the tracks are of unknown time.
	const getRunningTimeMessage = createSelector_1(getTotalRunningTime, getSelectedRunningTime, (totalRunningTime, selectedRunningTime) => `${getTimeStr(selectedRunningTime)}/${getTimeStr(totalRunningTime)}`);
	// TODO: use selectors to get memoization
	const getCurrentTrackIndex = (state) => {
	    const { playlist } = state;
	    if (playlist.currentTrack == null) {
	        return -1;
	    }
	    return playlist.trackOrder.indexOf(playlist.currentTrack);
	};
	const getCurrentTrackNumber = createSelector_1(getCurrentTrackIndex, (currentTrackIndex) => currentTrackIndex + 1);
	const getCurrentTrackId = (state) => state.playlist.currentTrack;
	// TODO: Sigh... Technically, we should detect if we are looping only repeat if we are.
	// I think this would require pre-computing the "random" order of a playlist.
	const getRandomTrackId = (state) => {
	    const { playlist: { trackOrder, currentTrack }, } = state;
	    if (trackOrder.length === 0) {
	        return null;
	    }
	    let nextId;
	    do {
	        nextId = trackOrder[Math.floor(trackOrder.length * Math.random())];
	    } while (nextId === currentTrack && trackOrder.length > 1);
	    return nextId;
	};
	const getNextTrackId = (state, n = 1) => {
	    const { playlist: { trackOrder }, media: { repeat, shuffle }, } = state;
	    if (shuffle) {
	        return getRandomTrackId(state);
	    }
	    const trackCount = getTrackCount(state);
	    if (trackCount === 0) {
	        return null;
	    }
	    const currentIndex = getCurrentTrackIndex(state);
	    let nextIndex = currentIndex + n;
	    if (repeat) {
	        nextIndex = nextIndex % trackCount;
	        if (nextIndex < 0) {
	            // Handle wrapping around backwards
	            nextIndex += trackCount;
	        }
	        return trackOrder[nextIndex];
	    }
	    if (currentIndex === trackCount - 1 && n > 0) {
	        return null;
	    }
	    else if (currentIndex === 0 && n < 0) {
	        return null;
	    }
	    nextIndex = clamp(nextIndex, 0, trackCount - 1);
	    return trackOrder[nextIndex];
	};
	const getGenWindows = (state) => {
	    return state.windows.genWindows;
	};
	const getWindowOpen = createSelector_1(getGenWindows, (genWindows) => {
	    return (windowId) => genWindows[windowId].open;
	});
	const getWindowHidden = createSelector_1(getMilkdropWindowEnabled, (milkdropWindowEnabled) => {
	    return (windowId) => {
	        return windowId === WINDOWS.MILKDROP && !milkdropWindowEnabled;
	    };
	});
	const getWindowShade = createSelector_1(getGenWindows, (genWindows) => {
	    return (windowId) => genWindows[windowId].shade;
	});
	const getWindowSize = createSelector_1(getGenWindows, (genWindows) => {
	    return (windowId) => genWindows[windowId].size;
	});
	const getWindowPositions = createSelector_1(getGenWindows, (windows) => objectMap(windows, (w) => w.position));
	const BASE_WINDOW_HEIGHT = 58;
	const getNumberOfVisibleTracks = createSelector_1(getWindowSize, (getWindowSize_) => {
	    const playlistSize = getWindowSize_("playlist");
	    return Math.floor((BASE_WINDOW_HEIGHT + WINDOW_RESIZE_SEGMENT_HEIGHT * playlistSize[1]) /
	        TRACK_HEIGHT);
	});
	const getOverflowTrackCount = createSelector_1(getTrackCount, getNumberOfVisibleTracks, (trackCount, numberOfVisibleTracks) => Math.max(0, trackCount - numberOfVisibleTracks));
	const _getPlaylistScrollPosition = (state) => state.display.playlistScrollPosition;
	const getPlaylistScrollPosition = createSelector_1(getOverflowTrackCount, _getPlaylistScrollPosition, (overflowTrackCount, playlistScrollPosition) => {
	    if (overflowTrackCount === 0) {
	        return 0;
	    }
	    return Math.round((Math.round((overflowTrackCount * playlistScrollPosition) / 100) /
	        overflowTrackCount) *
	        100);
	});
	const getScrollOffset = createSelector_1(_getPlaylistScrollPosition, getTrackCount, getNumberOfVisibleTracks, (playlistScrollPosition, trackCount, numberOfVisibleTracks) => {
	    const overflow = Math.max(0, trackCount - numberOfVisibleTracks);
	    return percentToIndex(playlistScrollPosition / 100, overflow + 1);
	});
	const getVisibleTrackIds = createSelector_1(getScrollOffset, getTrackOrder, getNumberOfVisibleTracks, (offset, trackOrder, numberOfVisibleTracks) => trackOrder.slice(offset, offset + numberOfVisibleTracks));
	function getAllTracksAreVisible(state) {
	    return getVisibleTrackIds(state).length === state.playlist.trackOrder.length;
	}
	const getTrackIsVisibleFunction = createSelector_1(getVisibleTrackIds, (visibleTrackIds) => {
	    return (id) => visibleTrackIds.includes(id);
	});
	createSelector_1(getVisibleTrackIds, getTracks, (visibleTrackIds, tracks) => visibleTrackIds.map((id) => tracks[id]));
	const getDuration = (state) => {
	    const { playlist, tracks } = state;
	    if (playlist.currentTrack == null) {
	        return null;
	    }
	    const currentTrack = tracks[playlist.currentTrack];
	    return currentTrack && currentTrack.duration;
	};
	const getTrackDisplayName = createSelector_1(getTracks, (tracks) => {
	    return defaultMemoize_1((trackId) => getTrackDisplayName$1(tracks, trackId));
	});
	const getCurrentTrackDisplayName = createSelector_1(getCurrentTrackId, getTrackDisplayName, (id, getName) => {
	    return getName(id);
	});
	const getPlayerMediaStatus = (state) => {
	    return state.media.status;
	};
	const getMediaStatus = createSelector_1(getPlayerMediaStatus, (status) => {
	    switch (status) {
	        case "PLAYING":
	        case "PAUSED":
	            return status;
	        case "STOPPED":
	        case "ENDED":
	        case "CLOSED":
	            return "STOPPED";
	        default:
	            const s = status;
	            throw new Error(`Unknown media status: ${s}`);
	    }
	});
	const getMediaIsPlaying = (state) => state.media.status === MEDIA_STATUS.PLAYING;
	const getCurrentTrack = createSelector_1(getCurrentTrackId, getTracks, (trackId, tracks) => {
	    return trackId == null ? null : tracks[trackId];
	});
	const getCurrentlyPlayingTrackIdIfLoaded = createSelector_1(getMediaIsPlaying, getCurrentTrack, (mediaIsPlaying, currentTrack) => {
	    if (!mediaIsPlaying ||
	        !currentTrack ||
	        currentTrack.mediaTagsRequestStatus ===
	            MEDIA_TAG_REQUEST_STATUS.INITIALIZED) {
	        return null;
	    }
	    return currentTrack.id;
	});
	const getCurrentTrackInfo = createSelector_1(getCurrentTrack, (track) => {
	    if (track == null) {
	        return null;
	    }
	    return {
	        url: track.url,
	        metaData: {
	            title: track.title || null,
	            artist: track.artist || null,
	            album: track.album || null,
	            albumArtUrl: track.albumArtUrl || null,
	        },
	    };
	});
	const getMinimalMediaText = createSelector_1(getCurrentTrackNumber, getCurrentTrackDisplayName, (trackNumber, name) => (name == null ? null : `${trackNumber}. ${name}`));
	const getMediaText = createSelector_1(getMinimalMediaText, getDuration, (minimalMediaText, duration) => minimalMediaText == null
	    ? null
	    : `${minimalMediaText} (${getTimeStr(duration)})`);
	const getNumberOfTracks = (state) => getTrackOrder(state).length;
	const getPlaylistDuration = createSelector_1(getTracks, (tracks) => Object.values(tracks).reduce((total, track) => total + (track.duration || 0), 0));
	const getPlaylistURL = createSelector_1(getNumberOfTracks, getPlaylistDuration, getTrackOrder, getTracks, getTrackDisplayName, (numberOfTracks, playlistDuration, trackOrder, tracks, getDisplayName) => createPlaylistURL({
	    numberOfTracks,
	    averageTrackLength: getTimeStr(playlistDuration / numberOfTracks),
	    // TODO: Handle hours
	    playlistLengthMinutes: Math.floor(playlistDuration / 60),
	    playlistLengthSeconds: Math.floor(playlistDuration % 60),
	    tracks: trackOrder.map((id, i) => `${i + 1}. ${getDisplayName(id)} (${getTimeStr(tracks[id].duration)})`),
	}));
	const WINDOW_HEIGHT = 116;
	const SHADE_WINDOW_HEIGHT = 14;
	function getWPixelSize(w, doubled) {
	    const [width, height] = w.size;
	    const doubledMultiplier = doubled && w.canDouble ? 2 : 1;
	    const pix = {
	        height: WINDOW_HEIGHT + height * WINDOW_RESIZE_SEGMENT_HEIGHT,
	        width: WINDOW_WIDTH + width * WINDOW_RESIZE_SEGMENT_WIDTH,
	    };
	    return {
	        height: (w.shade ? SHADE_WINDOW_HEIGHT : pix.height) * doubledMultiplier,
	        width: pix.width * doubledMultiplier,
	    };
	}
	function getFocusedWindow(state) {
	    return state.windows.focused;
	}
	function getPositionsAreRelative(state) {
	    return state.windows.positionsAreRelative;
	}
	function getDoubled(state) {
	    return state.display.doubled;
	}
	function getLlamaMode(state) {
	    return state.display.llama;
	}
	function getZIndex(state) {
	    return state.display.zIndex;
	}
	// TODO: This is poorly memoized. It invalidates when a window moves.
	const getWindowSizes = createSelector_1(getGenWindows, getDoubled, (windows, doubled) => {
	    return objectMap(windows, (w) => getWPixelSize(w, doubled));
	});
	const getWindowPixelSize = createSelector_1(getWindowSizes, (sizes) => {
	    return (windowId) => sizes[windowId];
	});
	const getWindowOrder = (state) => state.windows.windowOrder;
	const getNormalizedWindowOrder = createSelector_1(getWindowOrder, getGenWindows, (windowOrder, genWindows) => {
	    return [
	        WINDOWS.MAIN,
	        ...windowOrder.filter((windowId) => windowId !== WINDOWS.MAIN && genWindows[windowId] != null),
	    ];
	});
	// TODO: Now that both size and position are stored on genWindows this seems a bit silly.
	const getWindowsInfo = createSelector_1(getWindowSizes, getWindowPositions, getNormalizedWindowOrder, (sizes, positions, windowOrder) => {
	    return windowOrder.map((key) => ({
	        key,
	        ...sizes[key],
	        ...positions[key],
	    }));
	});
	const getWindowGraph = createSelector_1(getWindowsInfo, generateGraph);
	const defaultPlaylistStyle = {
	    normal: "#00FF00",
	    current: "#FFFFFF",
	    normalbg: "#000000",
	    selectedbg: "#0000C6",
	    font: "Arial",
	};
	function getSkinColors(state) {
	    return state.display.skinColors;
	}
	const getSkinPlaylistStyle = (state) => {
	    return state.display.skinPlaylistStyle || defaultPlaylistStyle;
	};
	const getVisualizerStyle = (state) => {
	    const milkdrop = state.windows.genWindows[WINDOWS.MILKDROP];
	    if (milkdrop != null && milkdrop.open) {
	        return VISUALIZERS.MILKDROP;
	    }
	    return getVisualizerStyle$1(state.display);
	};
	const getVolume = (state) => state.media.volume;
	const getBalance = (state) => state.media.balance;
	const getShuffle = (state) => state.media.shuffle;
	const getRepeat = (state) => state.media.repeat;
	const getChannels = createSelector_1(getCurrentTrack, (track) => {
	    return track != null ? track.channels || null : null;
	});
	const getTimeElapsed = (state) => {
	    return state.media.timeElapsed;
	};
	function getSerlializedState(state) {
	    return {
	        version: 1,
	        media: getSerializedState$2(state.media),
	        equalizer: getSerializedState(state.equalizer),
	        display: getSerializedState$1(state.display),
	        windows: getSerializedState$3(state.windows),
	    };
	}
	function getEqualizerEnabled(state) {
	    return state.equalizer.on;
	}
	function getBrowserWindowSize(state) {
	    return state.windows.browserWindowSize;
	}
	const getOpenWindows = createSelector_1(getGenWindows, (genWindows) => objectFilter(genWindows, (w) => w.open));
	const getStackedLayoutPositions = createSelector_1(getOpenWindows, getDoubled, (openWindows, doubled) => {
	    let offset = 0;
	    return objectMap(openWindows, (w) => {
	        const position = { x: 0, y: offset };
	        offset += getWPixelSize(w, doubled).height;
	        return position;
	    });
	});
	const getUserInputFocus = (state) => {
	    return state.userInput.focus;
	};
	const getUserInputScrubPosition = (state) => {
	    return state.userInput.scrubPosition;
	};
	// TODO: Make this a reselect selector
	const getMarqueeText = (state) => {
	    const defaultText = "Winamp 2.91";
	    if (state.userInput.userMessage != null) {
	        return state.userInput.userMessage;
	    }
	    switch (getUserInputFocus(state)) {
	        case "balance":
	            return getBalanceText(state.media.balance);
	        case "volume":
	            return getVolumeText(state.media.volume);
	        case "position":
	            const duration = getDuration(state);
	            if (duration == null) {
	                // This probably can't ever happen.
	                return defaultText;
	            }
	            return getPositionText(duration, getUserInputScrubPosition(state));
	        case "double":
	            return getDoubleSizeModeText(state.display.doubled);
	        case "eq":
	            const band = state.userInput.bandFocused;
	            if (band == null) {
	                // This probably can't ever happen.
	                return defaultText;
	            }
	            return getEqText(band, state.equalizer.sliders[band]);
	    }
	    if (state.playlist.currentTrack != null) {
	        const mediaText = getMediaText(state);
	        if (mediaText == null) {
	            // This probably can't ever happen.
	            return defaultText;
	        }
	        return mediaText;
	    }
	    return defaultText;
	};
	const getKbps = createSelector_1(getCurrentTrack, (track) => {
	    return track != null ? track.kbps || null : null;
	});
	const getKhz = createSelector_1(getCurrentTrack, (track) => {
	    return track != null ? track.khz || null : null;
	});
	function getMilkdropMessage(state) {
	    return state.milkdrop.message;
	}
	// Has Butterchurn been injected?
	function getMilkdropEnabled(state) {
	    return state.windows.milkdropEnabled;
	}
	function getMilkdropWindowEnabled(state) {
	    return state.milkdrop.display === "WINDOW";
	}
	function getMilkdropDesktopEnabled(state) {
	    return state.milkdrop.display === "DESKTOP";
	}
	function getMilkdropFullscreenEnabled(state) {
	    return state.milkdrop.display === "FULLSCREEN";
	}
	function getButterchurn(state) {
	    return state.milkdrop.butterchurn;
	}
	function getPresetTransitionType(state) {
	    return state.milkdrop.transitionType;
	}
	function getCurrentPresetIndex(state) {
	    return state.milkdrop.currentPresetIndex;
	}
	function getCurrentPreset(state) {
	    const index = getCurrentPresetIndex(state);
	    if (index == null) {
	        return null;
	    }
	    const preset = state.milkdrop.presets[index];
	    if (preset == null || preset.type === "UNRESOLVED") {
	        return null;
	    }
	    return preset.preset;
	}
	function getPresetNames(state) {
	    return state.milkdrop.presets.map((preset) => preset.name);
	}
	function getPresetOverlayOpen(state) {
	    return state.milkdrop.overlay;
	}
	function getPresetsAreCycling(state) {
	    return state.milkdrop.cycling;
	}
	function getRandomizePresets(state) {
	    return state.milkdrop.randomize;
	}
	function getClosed(state) {
	    return state.display.closed;
	}
	function getSkinImages(state) {
	    return state.display.skinImages;
	}
	function getSkinCursors(state) {
	    return state.display.skinCursors;
	}
	function getSkinRegion(state) {
	    return state.display.skinRegion;
	}
	function getSkinLetterWidths(state) {
	    return state.display.skinGenLetterWidths;
	}
	function getPreampLineUrl(state) {
	    return state.display.skinImages.EQ_PREAMP_LINE;
	}
	function getLineColorsUrl(state) {
	    return state.display.skinImages.EQ_GRAPH_LINE_COLORS;
	}
	const getPreampLineImage = createSelector_1(getPreampLineUrl, async (url) => {
	    if (url == null) {
	        return null;
	    }
	    return imgFromUrl(url);
	});
	const getLineColorsImage = createSelector_1(getLineColorsUrl, async (url) => {
	    if (url == null) {
	        return null;
	    }
	    return imgFromUrl(url);
	});
	function getMarqueeStep(state) {
	    return state.display.marqueeStep;
	}
	function getNetworkConnected(state) {
	    return state.network.connected;
	}
	function getTimeMode(state) {
	    return state.media.timeMode;
	}
	function getLoading(state) {
	    return state.display.loading;
	}
	function getWorking(state) {
	    return state.display.working;
	}
	function getAvaliableSkins(state) {
	    return state.settings.availableSkins;
	}

	const SNAP_DISTANCE = 15;
	const top = (box) => box.y;
	const bottom = (box) => box.y + box.height;
	const left = (box) => box.x;
	const right = (box) => box.x + box.width;
	const near = (a, b) => Math.abs(a - b) < SNAP_DISTANCE;
	// http://stackoverflow.com/a/3269471/1263117
	const overlapX = (a, b) => left(a) <= right(b) + SNAP_DISTANCE && left(b) <= right(a) + SNAP_DISTANCE;
	const overlapY = (a, b) => top(a) <= bottom(b) + SNAP_DISTANCE && top(b) <= bottom(a) + SNAP_DISTANCE;
	// Give a new position for `boxA` that snaps it to `boxB` if neede.
	const snap = (boxA, boxB) => {
	    let x, y;
	    // TODO: Refactor/simplify this code
	    if (overlapY(boxA, boxB)) {
	        if (near(left(boxA), right(boxB))) {
	            x = right(boxB);
	        }
	        else if (near(right(boxA), left(boxB))) {
	            x = left(boxB) - boxA.width;
	        }
	        else if (near(left(boxA), left(boxB))) {
	            x = left(boxB);
	        }
	        else if (near(right(boxA), right(boxB))) {
	            x = right(boxB) - boxA.width;
	        }
	    }
	    if (overlapX(boxA, boxB)) {
	        if (near(top(boxA), bottom(boxB))) {
	            y = bottom(boxB);
	        }
	        else if (near(bottom(boxA), top(boxB))) {
	            y = top(boxB) - boxA.height;
	        }
	        else if (near(top(boxA), top(boxB))) {
	            y = top(boxB);
	        }
	        else if (near(bottom(boxA), bottom(boxB))) {
	            y = bottom(boxB) - boxA.height;
	        }
	    }
	    return { x, y };
	};
	const snapDiff = (a, b) => {
	    const newPos = snap(a, b);
	    return {
	        x: newPos.x === undefined ? 0 : newPos.x - a.x,
	        y: newPos.y === undefined ? 0 : newPos.y - a.y,
	    };
	};
	// TODO: Use the first x and y combo
	const snapDiffManyToMany = (as, bs) => {
	    let x = 0;
	    let y = 0;
	    for (const a of as) {
	        for (const b of bs) {
	            const diff = snapDiff(a, b);
	            x = x || diff.x;
	            y = y || diff.y;
	            if (x !== undefined && x > 0 && y !== undefined && y > 0) {
	                break;
	            }
	        }
	    }
	    return { x, y };
	};
	const snapWithin = (boxA, boundingBox) => {
	    let x, y;
	    if (boxA.x - SNAP_DISTANCE < 0) {
	        x = 0;
	    }
	    else if (boxA.x + boxA.width + SNAP_DISTANCE > boundingBox.width) {
	        x = boundingBox.width - boxA.width;
	    }
	    if (boxA.y - SNAP_DISTANCE < 0) {
	        y = 0;
	    }
	    else if (boxA.y + boxA.height + SNAP_DISTANCE > boundingBox.height) {
	        y = boundingBox.height - boxA.height;
	    }
	    return { x, y };
	};
	const snapWithinDiff = (a, b) => {
	    const newPos = snapWithin(a, b);
	    return {
	        x: newPos.x === undefined ? 0 : newPos.x - a.x,
	        y: newPos.y === undefined ? 0 : newPos.y - a.y,
	    };
	};
	const boundingBox = (nodes) => {
	    const boxes = nodes.slice();
	    const firstNode = boxes.pop();
	    if (firstNode == null) {
	        throw new Error("boundingBox must be called with at least one node");
	    }
	    const bounding = {
	        top: top(firstNode),
	        right: right(firstNode),
	        bottom: bottom(firstNode),
	        left: left(firstNode),
	    };
	    boxes.forEach((node) => {
	        bounding.top = Math.min(bounding.top, top(node));
	        bounding.right = Math.max(bounding.right, right(node));
	        bounding.bottom = Math.max(bounding.bottom, bottom(node));
	        bounding.left = Math.min(bounding.left, left(node));
	    });
	    return {
	        x: bounding.left,
	        y: bounding.top,
	        width: bounding.right - bounding.left,
	        height: bounding.bottom - bounding.top,
	    };
	};
	function traceConnection(areConnected) {
	    return (candidates, node) => {
	        const connected = new Set();
	        const checkNode = (n) => {
	            for (const candidate of candidates) {
	                if (!connected.has(candidate) && areConnected(candidate, n)) {
	                    connected.add(candidate);
	                    checkNode(candidate);
	                }
	            }
	        };
	        checkNode(node);
	        return connected;
	    };
	}
	const applyDiff = (a, b) => ({
	    x: a.x + b.x,
	    y: a.y + b.y,
	});
	// TODO: This should not
	const applyMultipleDiffs = (initial, ...diffs) => {
	    const metaDiff = diffs.reduce((m, diff) => ({
	        // Use the smallest non-zero diff for each axis.
	        // TODO: Min should be the absolute value
	        x: m.x === 0 || diff.x === 0 ? m.x + diff.x : Math.min(m.x, diff.x),
	        y: m.y === 0 || diff.y === 0 ? m.y + diff.y : Math.min(m.y, diff.y),
	    }));
	    return applyDiff(initial, metaDiff);
	};

	// Dispatch an action and, if needed rearrange the windows to preserve
	// the existing edge relationship.
	//
	// Works by checking the edges before the action is dispatched. Then,
	// after dispatching, calculating what position change would be required
	// to restore those relationships.
	function withWindowGraphIntegrity(action) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const graph = getWindowGraph(state);
	        const originalSizes = getWindowSizes(state);
	        dispatch(action);
	        const newSizes = getWindowSizes(getState());
	        const sizeDiff = {};
	        for (const window of Object.keys(newSizes)) {
	            const original = originalSizes[window];
	            const current = newSizes[window];
	            sizeDiff[window] = {
	                height: current.height - original.height,
	                width: current.width - original.width,
	            };
	        }
	        const positionDiff = getPositionDiff(graph, sizeDiff);
	        const windowPositions = getWindowPositions(state);
	        const newPositions = objectMap(windowPositions, (position, key) => applyDiff(position, positionDiff[key]));
	        dispatch(updateWindowPositions(newPositions));
	    };
	}
	function toggleDoubleSizeMode() {
	    return withWindowGraphIntegrity({ type: "TOGGLE_DOUBLESIZE_MODE" });
	}
	function toggleEqualizerShadeMode() {
	    return withWindowGraphIntegrity({
	        type: "TOGGLE_WINDOW_SHADE_MODE",
	        windowId: "equalizer",
	    });
	}
	function toggleMainWindowShadeMode() {
	    return withWindowGraphIntegrity({
	        type: "TOGGLE_WINDOW_SHADE_MODE",
	        windowId: "main",
	    });
	}
	function togglePlaylistShadeMode() {
	    return withWindowGraphIntegrity({
	        type: "TOGGLE_WINDOW_SHADE_MODE",
	        windowId: "playlist",
	    });
	}
	function closeWindow(windowId) {
	    return { type: "CLOSE_WINDOW", windowId };
	}
	function setFocusedWindow(window) {
	    return { type: "SET_FOCUSED_WINDOW", window };
	}
	function setWindowSize(windowId, size) {
	    return { type: "WINDOW_SIZE_CHANGED", windowId, size };
	}
	function toggleWindow(windowId) {
	    return { type: "TOGGLE_WINDOW", windowId };
	}
	function updateWindowPositions(positions, absolute) {
	    return { type: "UPDATE_WINDOW_POSITIONS", positions, absolute };
	}
	function centerWindowsInContainer(container) {
	    return (dispatch, getState) => {
	        if (!getPositionsAreRelative(getState())) {
	            return;
	        }
	        const { left, top } = container.getBoundingClientRect();
	        const { scrollWidth: width, scrollHeight: height } = container;
	        dispatch(centerWindows({ left, top, width, height }));
	    };
	}
	function centerWindowsInView() {
	    const height = window.innerHeight;
	    const width = window.innerWidth;
	    return centerWindows({ left: 0, top: 0, width, height });
	}
	function centerWindows({ left, top, width, height }) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const windowsInfo = getWindowsInfo(state);
	        const getOpen = getWindowOpen(state);
	        const offsetLeft = left + window.scrollX;
	        const offsetTop = top + window.scrollY;
	        // A layout has been supplied. We will compute the bounding box and
	        // center the given layout.
	        const bounding = calculateBoundingBox(windowsInfo.filter((w) => getOpen(w.key)));
	        if (bounding == null) {
	            // There are no windows to center
	            return;
	        }
	        const boxHeight = bounding.bottom - bounding.top;
	        const boxWidth = bounding.right - bounding.left;
	        const move = {
	            x: Math.ceil(offsetLeft - bounding.left + (width - boxWidth) / 2),
	            y: Math.ceil(offsetTop - bounding.top + (height - boxHeight) / 2),
	        };
	        const newPositions = windowsInfo.reduce((pos, w) => ({
	            ...pos,
	            [w.key]: { x: move.x + w.x, y: move.y + w.y },
	        }), {});
	        dispatch(updateWindowPositions(newPositions, true));
	    };
	}
	function browserWindowSizeChanged(size) {
	    return (dispatch) => {
	        dispatch({ type: "BROWSER_WINDOW_SIZE_CHANGED", ...size });
	        dispatch(ensureWindowsAreOnScreen());
	    };
	}
	function resetWindowSizes() {
	    return { type: "RESET_WINDOW_SIZES" };
	}
	function stackWindows() {
	    return (dispatch, getState) => {
	        dispatch(updateWindowPositions(getStackedLayoutPositions(getState())));
	    };
	}
	function setWindowLayout(layout) {
	    return (dispatch) => {
	        if (layout == null) {
	            dispatch(stackWindows());
	            return;
	        }
	        for (const id of ["playlist", "milkdrop"]) {
	            const w = layout[id];
	            if (w != null && w.size != null) {
	                const { extraHeight: plusHeight, extraWidth: plusWidth } = w.size;
	                dispatch(setWindowSize(id, [plusWidth, plusHeight]));
	            }
	        }
	        for (const id of ["main", "playlist", "equalizer", "milkdrop"]) {
	            const w = layout[id];
	            if (w == null || w.closed) {
	                dispatch(closeWindow(id));
	            }
	        }
	        for (const id of ["main", "playlist", "equalizer"]) {
	            if (layout[id]?.shadeMode) {
	                dispatch({
	                    type: "TOGGLE_WINDOW_SHADE_MODE",
	                    windowId: id,
	                });
	            }
	        }
	        dispatch(updateWindowPositions(objectMap(layout, (w) => {
	            // For some reason TypeScript cli thinks this
	            // is nullable, but in VSCode it does not...
	            if (w == null)
	                throw new Error("w is null");
	            return {
	                x: w.position.left,
	                y: w.position.top,
	            };
	        }), false));
	    };
	}
	function ensureWindowsAreOnScreen() {
	    return (dispatch, getState) => {
	        const state = getState();
	        const windowsInfo = getWindowsInfo(state);
	        const getOpen = getWindowOpen(state);
	        const { height, width } = getWindowSize$1();
	        const bounding = calculateBoundingBox(windowsInfo.filter((w) => getOpen(w.key)));
	        if (bounding == null) {
	            // There are no windows visible, so there's no work to do.
	            return;
	        }
	        const positions = getWindowPositions(state);
	        // Are we good?
	        if (bounding.left >= 0 &&
	            bounding.top >= 0 &&
	            bounding.right <= width &&
	            bounding.bottom <= height) {
	            // My work here is done.
	            return;
	        }
	        const boundingHeight = bounding.bottom - bounding.top;
	        const boundingWidth = bounding.right - bounding.left;
	        // Could we simply shift all the windows by a constant offset?
	        if (boundingWidth <= width && boundingHeight <= height) {
	            let moveY = 0;
	            let moveX = 0;
	            if (bounding.top <= 0) {
	                moveY = bounding.top;
	            }
	            else if (bounding.bottom > height) {
	                moveY = bounding.bottom - height;
	            }
	            if (bounding.left <= 0) {
	                moveX = bounding.left;
	            }
	            else if (bounding.right > width) {
	                moveX = bounding.right - width;
	            }
	            const newPositions = objectMap(positions, (position) => ({
	                x: position.x - moveX,
	                y: position.y - moveY,
	            }));
	            dispatch(updateWindowPositions(newPositions));
	            return;
	        }
	        // TODO: Try moving the individual groups to try to fit them in
	        // I give up. Just reset everything.
	        dispatch(resetWindowSizes());
	        dispatch(stackWindows());
	        dispatch(centerWindowsInView());
	    };
	}

	const PRESET_VALUES = [
	    "hz60",
	    "hz170",
	    "hz310",
	    "hz600",
	    "hz1000",
	    "hz3000",
	    "hz6000",
	    "hz12000",
	    "hz14000",
	    "hz16000",
	    "preamp",
	];
	const HEADER = "Winamp EQ library file v1.1";

	function parser(arrayBuffer) {
	    const data = {
	        type: "",
	        presets: [],
	    };
	    let i = 0;
	    const arr = new Int8Array(arrayBuffer);
	    // Parse header
	    data.type = String.fromCharCode.apply(null, Array.from(arr.slice(i, HEADER.length)));
	    if (data.type !== HEADER) {
	        throw new Error("Invalid .eqf file.");
	    }
	    i += HEADER.length;
	    // Skip "<ctrl-z>!--"
	    i += 4;
	    // Get the presets
	    while (i < arr.length) {
	        const preset = {};
	        // Get the name
	        const nameStart = i;
	        const nameEnd = nameStart + 257; // Str is fixed length
	        // Str is null terminated
	        while (arr[i] !== 0 && i <= nameEnd) {
	            i++;
	        }
	        preset.name = String.fromCharCode.apply(null, Array.from(arr.slice(nameStart, i)));
	        i = nameEnd; // Skip over any unused bytes
	        // Get the levels
	        PRESET_VALUES.forEach((valueName) => {
	            preset[valueName] = 64 - arr[i++]; // Adjust for inverse values
	        });
	        data.presets.push(preset);
	    }
	    return data;
	}

	const PRESET_LENGTH = 257;
	function creator(data) {
	    const buffer = [];
	    // Add header
	    for (let i = 0; i < HEADER.length; i++) {
	        buffer.push(HEADER.charCodeAt(i));
	    }
	    // Add control character and ending
	    buffer.push(26); // <ctrl-z>
	    const ending = "!--";
	    for (let i = 0; i < ending.length; i++) {
	        buffer.push(ending.charCodeAt(i));
	    }
	    if (!data.presets) {
	        throw new Error("Eqf data is missing presets");
	    }
	    data.presets.forEach((preset) => {
	        // Add preset name
	        let k = 0;
	        for (; k < preset.name.length; k++) {
	            buffer.push(preset.name.charCodeAt(k));
	        }
	        // Pad name to fixed length
	        for (; k < PRESET_LENGTH; k++) {
	            buffer.push(0);
	        }
	        // Add preset values
	        PRESET_VALUES.forEach((valueName) => {
	            buffer.push(64 - preset[valueName]); // Adjust for inverse values
	        });
	    });
	    return new Uint8Array(buffer).buffer;
	}

	/* TODO: There are too many " " and "_" characters */
	const FONT_LOOKUP = {
	    a: [0, 0],
	    b: [0, 1],
	    c: [0, 2],
	    d: [0, 3],
	    e: [0, 4],
	    f: [0, 5],
	    g: [0, 6],
	    h: [0, 7],
	    i: [0, 8],
	    j: [0, 9],
	    k: [0, 10],
	    l: [0, 11],
	    m: [0, 12],
	    n: [0, 13],
	    o: [0, 14],
	    p: [0, 15],
	    q: [0, 16],
	    r: [0, 17],
	    s: [0, 18],
	    t: [0, 19],
	    u: [0, 20],
	    v: [0, 21],
	    w: [0, 22],
	    x: [0, 23],
	    y: [0, 24],
	    z: [0, 25],
	    '"': [0, 26],
	    "@": [0, 27],
	    " ": [0, 30],
	    "0": [1, 0],
	    "1": [1, 1],
	    "2": [1, 2],
	    "3": [1, 3],
	    "4": [1, 4],
	    "5": [1, 5],
	    "6": [1, 6],
	    "7": [1, 7],
	    "8": [1, 8],
	    "9": [1, 9],
	    [UTF8_ELLIPSIS]: [1, 10],
	    ".": [1, 11],
	    ":": [1, 12],
	    "(": [1, 13],
	    ")": [1, 14],
	    "-": [1, 15],
	    "'": [1, 16],
	    "!": [1, 17],
	    _: [1, 18],
	    "+": [1, 19],
	    "\\": [1, 20],
	    "/": [1, 21],
	    "[": [1, 22],
	    "]": [1, 23],
	    "^": [1, 24],
	    "&": [1, 25],
	    "%": [1, 26],
	    ",": [1, 27],
	    "=": [1, 28],
	    $: [1, 29],
	    "#": [1, 30],
	    Å: [2, 0],
	    Ö: [2, 1],
	    Ä: [2, 2],
	    "?": [2, 3],
	    "*": [2, 4],
	    "<": [1, 22],
	    ">": [1, 23],
	    "{": [1, 22],
	    "}": [1, 23],
	};
	const imageConstFromChar = (char) => `CHARACTER_${char.charCodeAt(0)}`;
	const CHAR_X = 5;
	const CHAR_Y = 6;
	const characterSprites = [];
	for (const key in FONT_LOOKUP) {
	    if (FONT_LOOKUP.hasOwnProperty(key)) {
	        const position = FONT_LOOKUP[key];
	        characterSprites.push({
	            name: imageConstFromChar(key),
	            y: position[0] * CHAR_Y,
	            x: position[1] * CHAR_X,
	            width: CHAR_X,
	            height: CHAR_Y,
	        });
	    }
	}
	const sprites = {
	    BALANCE: [
	        { name: "MAIN_BALANCE_BACKGROUND", x: 9, y: 0, width: 38, height: 420 },
	        { name: "MAIN_BALANCE_THUMB", x: 15, y: 422, width: 14, height: 11 },
	        { name: "MAIN_BALANCE_THUMB_ACTIVE", x: 0, y: 422, width: 14, height: 11 },
	    ],
	    CBUTTONS: [
	        { name: "MAIN_PREVIOUS_BUTTON", x: 0, y: 0, width: 23, height: 18 },
	        {
	            name: "MAIN_PREVIOUS_BUTTON_ACTIVE",
	            x: 0,
	            y: 18,
	            width: 23,
	            height: 18,
	        },
	        { name: "MAIN_PLAY_BUTTON", x: 23, y: 0, width: 23, height: 18 },
	        { name: "MAIN_PLAY_BUTTON_ACTIVE", x: 23, y: 18, width: 23, height: 18 },
	        { name: "MAIN_PAUSE_BUTTON", x: 46, y: 0, width: 23, height: 18 },
	        { name: "MAIN_PAUSE_BUTTON_ACTIVE", x: 46, y: 18, width: 23, height: 18 },
	        { name: "MAIN_STOP_BUTTON", x: 69, y: 0, width: 23, height: 18 },
	        { name: "MAIN_STOP_BUTTON_ACTIVE", x: 69, y: 18, width: 23, height: 18 },
	        { name: "MAIN_NEXT_BUTTON", x: 92, y: 0, width: 23, height: 18 },
	        { name: "MAIN_NEXT_BUTTON_ACTIVE", x: 92, y: 18, width: 22, height: 18 },
	        { name: "MAIN_EJECT_BUTTON", x: 114, y: 0, width: 22, height: 16 },
	        { name: "MAIN_EJECT_BUTTON_ACTIVE", x: 114, y: 16, width: 22, height: 16 },
	    ],
	    MAIN: [
	        { name: "MAIN_WINDOW_BACKGROUND", x: 0, y: 0, width: 275, height: 116 },
	    ],
	    MONOSTER: [
	        { name: "MAIN_STEREO", x: 0, y: 12, width: 29, height: 12 },
	        { name: "MAIN_STEREO_SELECTED", x: 0, y: 0, width: 29, height: 12 },
	        { name: "MAIN_MONO", x: 29, y: 12, width: 27, height: 12 },
	        { name: "MAIN_MONO_SELECTED", x: 29, y: 0, width: 27, height: 12 },
	    ],
	    NUMBERS: [
	        { name: "NO_MINUS_SIGN", x: 9, y: 6, width: 5, height: 1 },
	        { name: "MINUS_SIGN", x: 20, y: 6, width: 5, height: 1 },
	        { name: "DIGIT_0", x: 0, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_1", x: 9, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_2", x: 18, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_3", x: 27, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_4", x: 36, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_5", x: 45, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_6", x: 54, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_7", x: 63, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_8", x: 72, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_9", x: 81, y: 0, width: 9, height: 13 },
	    ],
	    NUMS_EX: [
	        { name: "NO_MINUS_SIGN_EX", x: 90, y: 0, width: 9, height: 13 },
	        { name: "MINUS_SIGN_EX", x: 99, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_0_EX", x: 0, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_1_EX", x: 9, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_2_EX", x: 18, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_3_EX", x: 27, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_4_EX", x: 36, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_5_EX", x: 45, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_6_EX", x: 54, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_7_EX", x: 63, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_8_EX", x: 72, y: 0, width: 9, height: 13 },
	        { name: "DIGIT_9_EX", x: 81, y: 0, width: 9, height: 13 },
	    ],
	    PLAYPAUS: [
	        { name: "MAIN_PLAYING_INDICATOR", x: 0, y: 0, width: 9, height: 9 },
	        { name: "MAIN_PAUSED_INDICATOR", x: 9, y: 0, width: 9, height: 9 },
	        { name: "MAIN_STOPPED_INDICATOR", x: 18, y: 0, width: 9, height: 9 },
	        { name: "MAIN_NOT_WORKING_INDICATOR", x: 36, y: 0, width: 9, height: 9 },
	        { name: "MAIN_WORKING_INDICATOR", x: 39, y: 0, width: 9, height: 9 },
	    ],
	    PLEDIT: [
	        { name: "PLAYLIST_TOP_TILE", x: 127, y: 21, width: 25, height: 20 },
	        { name: "PLAYLIST_TOP_LEFT_CORNER", x: 0, y: 21, width: 25, height: 20 },
	        { name: "PLAYLIST_TITLE_BAR", x: 26, y: 21, width: 100, height: 20 },
	        {
	            name: "PLAYLIST_TOP_RIGHT_CORNER",
	            x: 153,
	            y: 21,
	            width: 25,
	            height: 20,
	        },
	        {
	            name: "PLAYLIST_TOP_TILE_SELECTED",
	            x: 127,
	            y: 0,
	            width: 25,
	            height: 20,
	        },
	        { name: "PLAYLIST_TOP_LEFT_SELECTED", x: 0, y: 0, width: 25, height: 20 },
	        {
	            name: "PLAYLIST_TITLE_BAR_SELECTED",
	            x: 26,
	            y: 0,
	            width: 100,
	            height: 20,
	        },
	        {
	            name: "PLAYLIST_TOP_RIGHT_CORNER_SELECTED",
	            x: 153,
	            y: 0,
	            width: 25,
	            height: 20,
	        },
	        { name: "PLAYLIST_LEFT_TILE", x: 0, y: 42, width: 12, height: 29 },
	        { name: "PLAYLIST_RIGHT_TILE", x: 31, y: 42, width: 20, height: 29 },
	        { name: "PLAYLIST_BOTTOM_TILE", x: 179, y: 0, width: 25, height: 38 },
	        {
	            name: "PLAYLIST_BOTTOM_LEFT_CORNER",
	            x: 0,
	            y: 72,
	            width: 125,
	            height: 38,
	        },
	        {
	            name: "PLAYLIST_BOTTOM_RIGHT_CORNER",
	            x: 126,
	            y: 72,
	            width: 150,
	            height: 38,
	        },
	        {
	            name: "PLAYLIST_VISUALIZER_BACKGROUND",
	            x: 205,
	            y: 0,
	            width: 75,
	            height: 38,
	        },
	        { name: "PLAYLIST_SHADE_BACKGROUND", x: 72, y: 57, width: 25, height: 14 },
	        {
	            name: "PLAYLIST_SHADE_BACKGROUND_LEFT",
	            x: 72,
	            y: 42,
	            width: 25,
	            height: 14,
	        },
	        {
	            name: "PLAYLIST_SHADE_BACKGROUND_RIGHT",
	            x: 99,
	            y: 57,
	            width: 50,
	            height: 14,
	        },
	        {
	            name: "PLAYLIST_SHADE_BACKGROUND_RIGHT_SELECTED",
	            x: 99,
	            y: 42,
	            width: 50,
	            height: 14,
	        },
	        {
	            name: "PLAYLIST_SCROLL_HANDLE_SELECTED",
	            x: 61,
	            y: 53,
	            width: 8,
	            height: 18,
	        },
	        { name: "PLAYLIST_SCROLL_HANDLE", x: 52, y: 53, width: 8, height: 18 },
	        { name: "PLAYLIST_ADD_URL", x: 0, y: 111, width: 22, height: 18 },
	        { name: "PLAYLIST_ADD_URL_SELECTED", x: 23, y: 111, width: 22, height: 18 },
	        { name: "PLAYLIST_ADD_DIR", x: 0, y: 130, width: 22, height: 18 },
	        { name: "PLAYLIST_ADD_DIR_SELECTED", x: 23, y: 130, width: 22, height: 18 },
	        { name: "PLAYLIST_ADD_FILE", x: 0, y: 149, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_ADD_FILE_SELECTED",
	            x: 23,
	            y: 149,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_REMOVE_ALL", x: 54, y: 111, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_REMOVE_ALL_SELECTED",
	            x: 77,
	            y: 111,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_CROP", x: 54, y: 130, width: 22, height: 18 },
	        { name: "PLAYLIST_CROP_SELECTED", x: 77, y: 130, width: 22, height: 18 },
	        { name: "PLAYLIST_REMOVE_SELECTED", x: 54, y: 149, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_REMOVE_SELECTED_SELECTED",
	            x: 77,
	            y: 149,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_REMOVE_MISC", x: 54, y: 168, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_REMOVE_MISC_SELECTED",
	            x: 77,
	            y: 168,
	            width: 22,
	            height: 18,
	        },
	        {
	            name: "PLAYLIST_INVERT_SELECTION",
	            x: 104,
	            y: 111,
	            width: 22,
	            height: 18,
	        },
	        {
	            name: "PLAYLIST_INVERT_SELECTION_SELECTED",
	            x: 127,
	            y: 111,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_SELECT_ZERO", x: 104, y: 130, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_SELECT_ZERO_SELECTED",
	            x: 127,
	            y: 130,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_SELECT_ALL", x: 104, y: 149, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_SELECT_ALL_SELECTED",
	            x: 127,
	            y: 149,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_SORT_LIST", x: 154, y: 111, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_SORT_LIST_SELECTED",
	            x: 177,
	            y: 111,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_FILE_INFO", x: 154, y: 130, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_FILE_INFO_SELECTED",
	            x: 177,
	            y: 130,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_MISC_OPTIONS", x: 154, y: 149, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_MISC_OPTIONS_SELECTED",
	            x: 177,
	            y: 149,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_NEW_LIST", x: 204, y: 111, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_NEW_LIST_SELECTED",
	            x: 227,
	            y: 111,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_SAVE_LIST", x: 204, y: 130, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_SAVE_LIST_SELECTED",
	            x: 227,
	            y: 130,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_LOAD_LIST", x: 204, y: 149, width: 22, height: 18 },
	        {
	            name: "PLAYLIST_LOAD_LIST_SELECTED",
	            x: 227,
	            y: 149,
	            width: 22,
	            height: 18,
	        },
	        { name: "PLAYLIST_ADD_MENU_BAR", x: 48, y: 111, width: 3, height: 54 },
	        { name: "PLAYLIST_REMOVE_MENU_BAR", x: 100, y: 111, width: 3, height: 72 },
	        { name: "PLAYLIST_SELECT_MENU_BAR", x: 150, y: 111, width: 3, height: 54 },
	        { name: "PLAYLIST_MISC_MENU_BAR", x: 200, y: 111, width: 3, height: 54 },
	        { name: "PLAYLIST_LIST_BAR", x: 250, y: 111, width: 3, height: 54 },
	        { name: "PLAYLIST_CLOSE_SELECTED", x: 52, y: 42, width: 9, height: 9 },
	        { name: "PLAYLIST_COLLAPSE_SELECTED", x: 62, y: 42, width: 9, height: 9 },
	        { name: "PLAYLIST_EXPAND_SELECTED", x: 150, y: 42, width: 9, height: 9 },
	    ],
	    EQ_EX: [
	        {
	            name: "EQ_SHADE_BACKGROUND_SELECTED",
	            x: 0,
	            y: 0,
	            width: 275,
	            height: 14,
	        },
	        { name: "EQ_SHADE_BACKGROUND", x: 0, y: 15, width: 275, height: 14 },
	        { name: "EQ_SHADE_VOLUME_SLIDER_LEFT", x: 1, y: 30, width: 3, height: 7 },
	        { name: "EQ_SHADE_VOLUME_SLIDER_CENTER", x: 4, y: 30, width: 3, height: 7 },
	        { name: "EQ_SHADE_VOLUME_SLIDER_RIGHT", x: 7, y: 30, width: 3, height: 7 },
	        { name: "EQ_SHADE_BALANCE_SLIDER_LEFT", x: 11, y: 30, width: 3, height: 7 },
	        {
	            name: "EQ_SHADE_BALANCE_SLIDER_CENTER",
	            x: 14,
	            y: 30,
	            width: 3,
	            height: 7,
	        },
	        {
	            name: "EQ_SHADE_BALANCE_SLIDER_RIGHT",
	            x: 17,
	            y: 30,
	            width: 3,
	            height: 7,
	        },
	        { name: "EQ_MAXIMIZE_BUTTON_ACTIVE", x: 1, y: 38, width: 9, height: 9 },
	        { name: "EQ_MINIMIZE_BUTTON_ACTIVE", x: 1, y: 47, width: 9, height: 9 },
	        { name: "EQ_SHADE_CLOSE_BUTTON", x: 11, y: 38, width: 9, height: 9 },
	        { name: "EQ_SHADE_CLOSE_BUTTON_ACTIVE", x: 11, y: 47, width: 9, height: 9 },
	    ],
	    EQMAIN: [
	        { name: "EQ_WINDOW_BACKGROUND", x: 0, y: 0, width: 275, height: 116 },
	        { name: "EQ_TITLE_BAR", x: 0, y: 149, width: 275, height: 14 },
	        { name: "EQ_TITLE_BAR_SELECTED", x: 0, y: 134, width: 275, height: 14 },
	        { name: "EQ_SLIDER_BACKGROUND", x: 13, y: 164, width: 209, height: 129 },
	        { name: "EQ_SLIDER_THUMB", x: 0, y: 164, width: 11, height: 11 },
	        { name: "EQ_SLIDER_THUMB_SELECTED", x: 0, y: 176, width: 11, height: 11 },
	        { name: "EQ_CLOSE_BUTTON", x: 0, y: 116, width: 9, height: 9 },
	        { name: "EQ_CLOSE_BUTTON_ACTIVE", x: 0, y: 125, width: 9, height: 9 },
	        // This is technically not a sprite, it's just part of the background.
	        // However, we extract it to use it as a fallback for
	        // `EQ_MAXIMIZE_BUTTON_ACTIVE`. Without this, skins that don't implement
	        // `eq_ex.bmp` would show the default skin's `EQ_MAXIMIZE_BUTTON_ACTIVE`
	        // instead of showing no sprite aka, just showing through to this portion of
	        // the title bar image.
	        {
	            name: "EQ_MAXIMIZE_BUTTON_ACTIVE_FALLBACK",
	            x: 254,
	            y: 152,
	            width: 9,
	            height: 9,
	        },
	        { name: "EQ_ON_BUTTON", x: 10, y: 119, width: 26, height: 12 },
	        { name: "EQ_ON_BUTTON_DEPRESSED", x: 128, y: 119, width: 26, height: 12 },
	        { name: "EQ_ON_BUTTON_SELECTED", x: 69, y: 119, width: 26, height: 12 },
	        {
	            name: "EQ_ON_BUTTON_SELECTED_DEPRESSED",
	            x: 187,
	            y: 119,
	            width: 26,
	            height: 12,
	        },
	        { name: "EQ_AUTO_BUTTON", x: 36, y: 119, width: 32, height: 12 },
	        {
	            name: "EQ_AUTO_BUTTON_DEPRESSED",
	            x: 154,
	            y: 119,
	            width: 32,
	            height: 12,
	        },
	        { name: "EQ_AUTO_BUTTON_SELECTED", x: 95, y: 119, width: 32, height: 12 },
	        {
	            name: "EQ_AUTO_BUTTON_SELECTED_DEPRESSED",
	            x: 213,
	            y: 119,
	            width: 32,
	            height: 12,
	        },
	        { name: "EQ_GRAPH_BACKGROUND", x: 0, y: 294, width: 113, height: 19 },
	        { name: "EQ_GRAPH_LINE_COLORS", x: 115, y: 294, width: 1, height: 19 },
	        { name: "EQ_PRESETS_BUTTON", x: 224, y: 164, width: 44, height: 12 },
	        {
	            name: "EQ_PRESETS_BUTTON_SELECTED",
	            x: 224,
	            y: 176,
	            width: 44,
	            height: 12,
	        },
	        { name: "EQ_PREAMP_LINE", x: 0, y: 314, width: 113, height: 1 },
	    ],
	    POSBAR: [
	        {
	            name: "MAIN_POSITION_SLIDER_BACKGROUND",
	            x: 0,
	            y: 0,
	            width: 248,
	            height: 10,
	        },
	        {
	            name: "MAIN_POSITION_SLIDER_THUMB",
	            x: 248,
	            y: 0,
	            width: 29,
	            height: 10,
	        },
	        {
	            name: "MAIN_POSITION_SLIDER_THUMB_SELECTED",
	            x: 278,
	            y: 0,
	            width: 29,
	            height: 10,
	        },
	    ],
	    SHUFREP: [
	        { name: "MAIN_SHUFFLE_BUTTON", x: 28, y: 0, width: 47, height: 15 },
	        {
	            name: "MAIN_SHUFFLE_BUTTON_DEPRESSED",
	            x: 28,
	            y: 15,
	            width: 47,
	            height: 15,
	        },
	        {
	            name: "MAIN_SHUFFLE_BUTTON_SELECTED",
	            x: 28,
	            y: 30,
	            width: 47,
	            height: 15,
	        },
	        {
	            name: "MAIN_SHUFFLE_BUTTON_SELECTED_DEPRESSED",
	            x: 28,
	            y: 45,
	            width: 47,
	            height: 15,
	        },
	        { name: "MAIN_REPEAT_BUTTON", x: 0, y: 0, width: 28, height: 15 },
	        {
	            name: "MAIN_REPEAT_BUTTON_DEPRESSED",
	            x: 0,
	            y: 15,
	            width: 28,
	            height: 15,
	        },
	        {
	            name: "MAIN_REPEAT_BUTTON_SELECTED",
	            x: 0,
	            y: 30,
	            width: 28,
	            height: 15,
	        },
	        {
	            name: "MAIN_REPEAT_BUTTON_SELECTED_DEPRESSED",
	            x: 0,
	            y: 45,
	            width: 28,
	            height: 15,
	        },
	        { name: "MAIN_EQ_BUTTON", x: 0, y: 61, width: 23, height: 12 },
	        { name: "MAIN_EQ_BUTTON_SELECTED", x: 0, y: 73, width: 23, height: 12 },
	        { name: "MAIN_EQ_BUTTON_DEPRESSED", x: 46, y: 61, width: 23, height: 12 },
	        {
	            name: "MAIN_EQ_BUTTON_DEPRESSED_SELECTED",
	            x: 46,
	            y: 73,
	            width: 23,
	            height: 12,
	        },
	        { name: "MAIN_PLAYLIST_BUTTON", x: 23, y: 61, width: 23, height: 12 },
	        {
	            name: "MAIN_PLAYLIST_BUTTON_SELECTED",
	            x: 23,
	            y: 73,
	            width: 23,
	            height: 12,
	        },
	        {
	            name: "MAIN_PLAYLIST_BUTTON_DEPRESSED",
	            x: 69,
	            y: 61,
	            width: 23,
	            height: 12,
	        },
	        {
	            name: "MAIN_PLAYLIST_BUTTON_DEPRESSED_SELECTED",
	            x: 69,
	            y: 73,
	            width: 23,
	            height: 12,
	        },
	    ],
	    TEXT: characterSprites,
	    TITLEBAR: [
	        { name: "MAIN_TITLE_BAR", x: 27, y: 15, width: 275, height: 14 },
	        { name: "MAIN_TITLE_BAR_SELECTED", x: 27, y: 0, width: 275, height: 14 },
	        {
	            name: "MAIN_EASTER_EGG_TITLE_BAR",
	            x: 27,
	            y: 72,
	            width: 275,
	            height: 14,
	        },
	        {
	            name: "MAIN_EASTER_EGG_TITLE_BAR_SELECTED",
	            x: 27,
	            y: 57,
	            width: 275,
	            height: 14,
	        },
	        { name: "MAIN_OPTIONS_BUTTON", x: 0, y: 0, width: 9, height: 9 },
	        {
	            name: "MAIN_OPTIONS_BUTTON_DEPRESSED",
	            x: 0,
	            y: 9,
	            width: 9,
	            height: 9,
	        },
	        { name: "MAIN_MINIMIZE_BUTTON", x: 9, y: 0, width: 9, height: 9 },
	        {
	            name: "MAIN_MINIMIZE_BUTTON_DEPRESSED",
	            x: 9,
	            y: 9,
	            width: 9,
	            height: 9,
	        },
	        { name: "MAIN_SHADE_BUTTON", x: 0, y: 18, width: 9, height: 9 },
	        { name: "MAIN_SHADE_BUTTON_DEPRESSED", x: 9, y: 18, width: 9, height: 9 },
	        { name: "MAIN_CLOSE_BUTTON", x: 18, y: 0, width: 9, height: 9 },
	        { name: "MAIN_CLOSE_BUTTON_DEPRESSED", x: 18, y: 9, width: 9, height: 9 },
	        {
	            name: "MAIN_CLUTTER_BAR_BACKGROUND",
	            x: 304,
	            y: 0,
	            width: 8,
	            height: 43,
	        },
	        {
	            name: "MAIN_CLUTTER_BAR_BACKGROUND_DISABLED",
	            x: 312,
	            y: 0,
	            width: 8,
	            height: 43,
	        },
	        {
	            name: "MAIN_CLUTTER_BAR_BUTTON_O_SELECTED",
	            x: 304,
	            y: 47,
	            width: 8,
	            height: 8,
	        },
	        {
	            name: "MAIN_CLUTTER_BAR_BUTTON_A_SELECTED",
	            x: 312,
	            y: 55,
	            width: 8,
	            height: 7,
	        },
	        {
	            name: "MAIN_CLUTTER_BAR_BUTTON_I_SELECTED",
	            x: 320,
	            y: 62,
	            width: 8,
	            height: 7,
	        },
	        {
	            name: "MAIN_CLUTTER_BAR_BUTTON_D_SELECTED",
	            x: 328,
	            y: 69,
	            width: 8,
	            height: 8,
	        },
	        {
	            name: "MAIN_CLUTTER_BAR_BUTTON_V_SELECTED",
	            x: 336,
	            y: 77,
	            width: 8,
	            height: 7,
	        },
	        { name: "MAIN_SHADE_BACKGROUND", x: 27, y: 42, width: 275, height: 14 },
	        {
	            name: "MAIN_SHADE_BACKGROUND_SELECTED",
	            x: 27,
	            y: 29,
	            width: 275,
	            height: 14,
	        },
	        { name: "MAIN_SHADE_BUTTON_SELECTED", x: 0, y: 27, width: 9, height: 9 },
	        {
	            name: "MAIN_SHADE_BUTTON_SELECTED_DEPRESSED",
	            x: 9,
	            y: 27,
	            width: 9,
	            height: 9,
	        },
	        {
	            name: "MAIN_SHADE_POSITION_BACKGROUND",
	            x: 0,
	            y: 36,
	            width: 17,
	            height: 7,
	        },
	        { name: "MAIN_SHADE_POSITION_THUMB", x: 20, y: 36, width: 3, height: 7 },
	        {
	            name: "MAIN_SHADE_POSITION_THUMB_LEFT",
	            x: 17,
	            y: 36,
	            width: 3,
	            height: 7,
	        },
	        {
	            name: "MAIN_SHADE_POSITION_THUMB_RIGHT",
	            x: 23,
	            y: 36,
	            width: 3,
	            height: 7,
	        },
	    ],
	    VOLUME: [
	        { name: "MAIN_VOLUME_BACKGROUND", x: 0, y: 0, width: 68, height: 420 },
	        { name: "MAIN_VOLUME_THUMB", x: 15, y: 422, width: 14, height: 11 },
	        {
	            name: "MAIN_VOLUME_THUMB_SELECTED",
	            x: 0,
	            y: 422,
	            width: 14,
	            height: 11,
	        },
	    ],
	    GEN: [
	        { name: "GEN_TOP_LEFT_SELECTED", x: 0, y: 0, width: 25, height: 20 },
	        { name: "GEN_TOP_LEFT_END_SELECTED", x: 26, y: 0, width: 25, height: 20 },
	        {
	            name: "GEN_TOP_CENTER_FILL_SELECTED",
	            x: 52,
	            y: 0,
	            width: 25,
	            height: 20,
	        },
	        { name: "GEN_TOP_RIGHT_END_SELECTED", x: 78, y: 0, width: 25, height: 20 },
	        {
	            name: "GEN_TOP_LEFT_RIGHT_FILL_SELECTED",
	            x: 104,
	            y: 0,
	            width: 25,
	            height: 20,
	        },
	        { name: "GEN_TOP_RIGHT_SELECTED", x: 130, y: 0, width: 25, height: 20 },
	        { name: "GEN_TOP_LEFT", x: 0, y: 21, width: 25, height: 20 },
	        { name: "GEN_TOP_LEFT_END", x: 26, y: 21, width: 25, height: 20 },
	        { name: "GEN_TOP_CENTER_FILL", x: 52, y: 21, width: 25, height: 20 },
	        { name: "GEN_TOP_RIGHT_END", x: 78, y: 21, width: 25, height: 20 },
	        { name: "GEN_TOP_LEFT_RIGHT_FILL", x: 104, y: 21, width: 25, height: 20 },
	        { name: "GEN_TOP_RIGHT", x: 130, y: 21, width: 25, height: 20 },
	        { name: "GEN_BOTTOM_LEFT", x: 0, y: 42, width: 125, height: 14 },
	        { name: "GEN_BOTTOM_RIGHT", x: 0, y: 57, width: 125, height: 14 },
	        { name: "GEN_BOTTOM_FILL", x: 127, y: 72, width: 25, height: 14 },
	        { name: "GEN_MIDDLE_LEFT", x: 127, y: 42, width: 11, height: 29 },
	        { name: "GEN_MIDDLE_LEFT_BOTTOM", x: 158, y: 42, width: 11, height: 24 },
	        { name: "GEN_MIDDLE_RIGHT", x: 139, y: 42, width: 8, height: 29 },
	        { name: "GEN_MIDDLE_RIGHT_BOTTOM", x: 170, y: 42, width: 8, height: 24 },
	        { name: "GEN_CLOSE_SELECTED", x: 148, y: 42, width: 9, height: 9 },
	    ],
	    /*
	  
	    We don't currently support the Media Library, so there are disabled
	    GENEX: [
	      {
	        name: "GENEX_BUTTON_BACKGROUND_LEFT_UNPRESSED",
	        x: 0,
	        y: 0,
	        height: 15,
	        width: 4,
	      },
	      {
	        name: "GENEX_BUTTON_BACKGROUND_CENTER_UNPRESSED",
	        x: 4,
	        y: 0,
	        height: 15,
	        width: 39,
	      },
	      {
	        name: "GENEX_BUTTON_BACKGROUND_RIGHT_UNPRESSED",
	        x: 43,
	        y: 0,
	        height: 15,
	        width: 4,
	      },
	      {
	        name: "GENEX_BUTTON_BACKGROUND_PRESSED",
	        x: 0,
	        y: 1,
	        height: 15,
	        width: 47,
	      },
	      { name: "GENEX_SCROLL_UP_UNPRESSED", x: 0, y: 31, height: 14, width: 14 },
	      {
	        name: "GENEX_SCROLL_DOWN_UNPRESSED",
	        x: 14,
	        y: 31,
	        height: 14,
	        width: 14,
	      },
	      { name: "GENEX_SCROLL_UP_PRESSED", x: 28, y: 31, height: 14, width: 14 },
	      { name: "GENEX_SCROLL_DOWN_PRESSED", x: 42, y: 31, height: 14, width: 14 },
	      { name: "GENEX_SCROLL_LEFT_UNPRESSED", x: 0, y: 45, height: 14, width: 14 },
	      {
	        name: "GENEX_SCROLL_RIGHT_UNPRESSED",
	        x: 14,
	        y: 45,
	        height: 14,
	        width: 14,
	      },
	      { name: "GENEX_SCROLL_LEFT_PRESSED", x: 28, y: 45, height: 14, width: 14 },
	      { name: "GENEX_SCROLL_RIGHT_PRESSED", x: 42, y: 45, height: 14, width: 14 },
	      {
	        name: "GENEX_VERTICAL_SCROLL_HANDLE_UNPRESSED",
	        x: 56,
	        y: 31,
	        height: 28,
	        width: 14,
	      },
	      {
	        name: "GENEX_VERTICAL_SCROLL_HANDLE_PRESSED",
	        x: 70,
	        y: 31,
	        height: 28,
	        width: 14,
	      },
	      {
	        name: "GENEX_HORIZONTAL_SCROLL_HANDLE_UNPRESSED",
	        x: 84,
	        y: 31,
	        height: 14,
	        width: 28,
	      },
	      {
	        name: "GENEX_HORIZONTAL_SCROLL_HANDLE_PRESSED",
	        x: 84,
	        y: 45,
	        height: 14,
	        width: 28,
	      },
	    ],
	    */
	};

	function pointPairs(arr) {
	    const pairedValues = [];
	    for (let i = 0; i < arr.length; i += 2) {
	        pairedValues.push(`${arr[i]},${arr[i + 1]}`);
	    }
	    return pairedValues;
	}
	function regionParser(regionStr) {
	    const iniData = parseIni(regionStr);
	    const data = {};
	    Object.keys(iniData).forEach((section) => {
	        const { numpoints, pointlist } = iniData[section];
	        if (!numpoints || !pointlist) {
	            return;
	        }
	        const pointCounts = numpoints.split(/\s*,\s*/).filter((val) => val !== "");
	        const points = pointPairs(
	        // points can be separated by spaces, or by commas
	        pointlist.split(/\s*[, ]\s*/).filter((val) => val !== ""));
	        let pointIndex = 0;
	        const polygons = pointCounts.map((numStr) => {
	            const num = Number(numStr);
	            if (num < 3) {
	                // What use is a polygon with less than three sides?
	                pointIndex += num;
	                return null;
	            }
	            const polygon = points.slice(pointIndex, pointIndex + num).join(" ");
	            if (!polygon.length) {
	                // It's possible that the skin author specified more polygons than provided points.
	                return null;
	            }
	            pointIndex += num;
	            return polygon;
	        });
	        const validPolygons = polygons.filter((polygon) => polygon != null);
	        if (validPolygons.length) {
	            data[section] = validPolygons;
	        }
	    });
	    return data;
	}

	const getFileExtension = (fileName) => {
	    const matches = /\.([a-z]{3,4})$/i.exec(fileName);
	    return matches ? matches[1].toLowerCase() : null;
	};
	function getFilenameRegex(base, ext) {
	    // Note: The four slashes: \\\\ ultimately represent a single escaped slash in
	    // the regex ("\\"), however each itself needs to be escaped so that
	    // JavaScript does not interperate it as an escape character in the string
	    // literal. Wonderful.
	    return new RegExp(`^(.*[/\\\\])?${base}.(${ext})$`, "i");
	}
	async function getFileFromZip(zip, fileName, ext, mode) {
	    const files = zip.file(getFilenameRegex(fileName, ext));
	    if (!files.length) {
	        return null;
	    }
	    // Windows file system is case insensitve, but zip files are not.
	    // This means that it's possible for a zip to contain both `main.bmp` _and_
	    // `main.BMP` but in Winamp only one will be materialized onto disk when
	    // decompressing. I suspect that in this case later files in the archive
	    // overwrite earlier ones. To mimic that behavior we use the last matching
	    // file.
	    //
	    // This works because `JSZip.file` filters the files by iterating the
	    // underlying `files` object under the hood:
	    // https://github.com/Stuk/jszip/blob/25d401e104926fef8528d670ecfe53f14e77a297/lib/object.js#L182
	    // Since JavaScript objects are iterable in the order that the keys were
	    // added this _should_ mean that by taking the last file here we will get
	    // the last file that JSZip extracted.
	    const lastFile = files[files.length - 1];
	    try {
	        const contents = await lastFile.async(mode);
	        return { contents, name: lastFile.name };
	    }
	    catch (e) {
	        console.warn(`Failed to extract "${fileName}.${ext}" from the skin archive.`);
	        return null;
	    }
	}
	function fallbackGetImgFromBlob(blob) {
	    return imgFromUrl(URL.createObjectURL(blob));
	}
	async function getImgFromBlob(blob) {
	    try {
	        // Use this faster native browser API if available.
	        // NOTE: In some browsers `window.createImageBitmap` may not exist so this will throw.
	        return await window.createImageBitmap(blob);
	    }
	    catch (e) {
	        try {
	            return await fallbackGetImgFromBlob(blob);
	        }
	        catch (ee) {
	            // Like Winamp we will silently fail on images that don't parse.
	            return null;
	        }
	    }
	}
	function getSpriteUrisFromImg(img, sprites) {
	    const canvas = document.createElement("canvas");
	    const context = canvas.getContext("2d", { willReadFrequently: true });
	    if (context == null) {
	        throw new Error("Failed to get canvas context");
	    }
	    const images = {};
	    sprites.forEach((sprite) => {
	        canvas.height = sprite.height;
	        canvas.width = sprite.width;
	        context.drawImage(img, -sprite.x, -sprite.y);
	        const image = canvas.toDataURL();
	        images[sprite.name] = image;
	    });
	    return images;
	}
	async function getImgFromFilename(zip, fileName) {
	    // Winamp only supports .bmp images, but WACUP set a precidence of supporting
	    // .png as well to reduce size. Since we care about size as well, we follow
	    // suit. Our default skin uses .png to save 14kb.
	    const file = await getFileFromZip(zip, fileName, "(png|bmp)", "blob");
	    if (!file) {
	        return null;
	    }
	    const mimeType = `image/${getFileExtension(file.name) || "*"}`;
	    // The spec for createImageBitmap() says the browser should try to sniff the
	    // mime type, but it looks like Firefox does not. So we specify it here
	    // explicitly.
	    const typedBlob = new Blob([file.contents], { type: mimeType });
	    return getImgFromBlob(typedBlob);
	}
	async function getSpriteUrisFromFilename(zip, fileName) {
	    const img = await getImgFromFilename(zip, fileName);
	    if (img == null) {
	        return {};
	    }
	    return getSpriteUrisFromImg(img, sprites[fileName]);
	}
	// https://docs.microsoft.com/en-us/windows/win32/xaudio2/resource-interchange-file-format--riff-
	const RIFF_MAGIC = "RIFF".split("").map((c) => c.charCodeAt(0));
	function arrayStartsWith(arr, matcher) {
	    return matcher.every((item, i) => arr[i] === item);
	}
	async function getCursorFromFilename(zip, fileName) {
	    const file = await getFileFromZip(zip, fileName, "CUR", "uint8array");
	    if (file == null) {
	        return null;
	    }
	    const contents = file.contents;
	    if (arrayStartsWith(contents, RIFF_MAGIC)) {
	        return { type: "ani", aniData: contents };
	    }
	    return { type: "cur", url: curUrlFromByteArray$1(contents) };
	}
	async function getPlaylistStyle(zip) {
	    const files = zip.file(getFilenameRegex("PLEDIT", "txt"));
	    const file = files[0];
	    if (file == null) {
	        return DEFAULT_SKIN.playlistStyle;
	    }
	    const ini = await file.async("text");
	    if (ini == null) {
	        return DEFAULT_SKIN.playlistStyle;
	    }
	    const data = ini && parseIni(ini).text;
	    if (!data) {
	        // Corrupt or missing PLEDIT.txt file.
	        return DEFAULT_SKIN.playlistStyle;
	    }
	    // Winamp seems to permit colors that contain too many characters.
	    // For compatibility with existing skins, we normalize them here.
	    ["normal", "current", "normalbg", "selectedbg", "mbFG", "mbBG"].forEach((colorKey) => {
	        let color = data[colorKey];
	        if (!color) {
	            return;
	        }
	        if (color[0] !== "#") {
	            color = `#${color}`;
	        }
	        data[colorKey] = color.slice(0, 7);
	    });
	    return { ...DEFAULT_SKIN.playlistStyle, ...data };
	}
	async function getGenExColors(zip) {
	    const img = await getImgFromFilename(zip, "GENEX");
	    if (img == null) {
	        return null;
	    }
	    const canvas = document.createElement("canvas");
	    const context = canvas.getContext("2d", { willReadFrequently: true });
	    if (context == null) {
	        return null;
	    }
	    canvas.width = img.width;
	    canvas.height = img.height;
	    context.drawImage(img, 0, 0);
	    const getColorAt = (x) => `rgb(${context
        .getImageData(x, 0, 1, 1)
        // Discard the alpha channel
        .data.slice(0, 3)
        .join(",")})`;
	    // Ideally we would just have a map from key to the x value and map over
	    // that with getColorAt, but I don't know a great way to make that type
	    // safe. So, we'll just do this for now, where we explicitly call getColorAt
	    // for each key.
	    return {
	        // (1) x=48: item background (background to edits, listviews, etc.)
	        itemBackground: getColorAt(48),
	        // (2) x=50: item foreground (text colour of edits, listviews, etc.)
	        itemForeground: getColorAt(50),
	        // (3) x=52: window background (used to set the bg color for the dialog)
	        windowBackground: getColorAt(52),
	        // (4) x=54: button text colour
	        buttonText: getColorAt(54),
	        // (5) x=56: window text colour
	        windowText: getColorAt(56),
	        // (6) x=58: colour of dividers and sunken borders
	        divider: getColorAt(58),
	        // (7) x=60: selection colour for entries inside playlists (nothing else yet)
	        playlistSelection: getColorAt(60),
	        // (8) x=62: listview header background colour
	        listHeaderBackground: getColorAt(62),
	        // (9) x=64: listview header text colour
	        listHeaderText: getColorAt(64),
	        // (10) x=66: listview header frame top and left colour
	        listHeaderFrameTopAndLeft: getColorAt(66),
	        // (11) x=68: listview header frame bottom and right colour
	        listHeaderFrameBottomAndRight: getColorAt(68),
	        // (12) x=70: listview header frame colour, when pressed
	        listHeaderFramePressed: getColorAt(70),
	        // (13) x=72: listview header dead area colour
	        listHeaderDeadArea: getColorAt(72),
	        // (14) x=74: scrollbar colour #1
	        scrollbarOne: getColorAt(74),
	        // (15) x=76: scrollbar colour #2
	        scrollbarTwo: getColorAt(76),
	        // (16) x=78: pressed scrollbar colour #1
	        pressedScrollbarOne: getColorAt(78),
	        // (17) x=80: pressed scrollbar colour #2
	        pressedScrollbarTwo: getColorAt(80),
	        // (18) x=82: scrollbar dead area colour
	        scrollbarDeadArea: getColorAt(82),
	        // (19) x=84 List view text colour highlighted
	        listTextHighlighted: getColorAt(84),
	        // (20) x=86 List view background colour highlighted
	        listTextHighlightedBackground: getColorAt(86),
	        // (21) x=88 List view text colour selected
	        listTextSelected: getColorAt(88),
	        // (22) x=90 List view background colour selected
	        listTextSelectedBackground: getColorAt(90),
	    };
	}

	const shallowMerge = objs => objs.reduce((prev, img) => Object.assign(prev, img), {});
	const CURSORS = ["CLOSE", "EQCLOSE", "EQNORMAL", "EQSLID", "EQTITLE", "MAINMENU", "MMENU", "MIN", "NORMAL", "PCLOSE", "PNORMAL", "POSBAR", "PSIZE", "PTBAR", "PVSCROLL", "PWINBUT", "PWSNORM", "PWSSIZE", "SONGNAME", "TITLEBAR", "VOLBAL", "WINBUT", "WSNORMAL", "WSPOSBAR"
	/*
	 * > There are usually 4 more cursors in the skins: volbar.cur, wsclose.cur,
	 * > wswinbut.cur, wsmin.cur, but they are never used, at least in the last
	 * > versions of winamp, so there's no need of including them. The cursors
	 * > shown when the mouse is over the app-buttons are the same in normal and
	 * > winshade mode, except for the main menu button. You can make animated
	 * > cursors, but you have to name them with the extension .cur (animated
	 * > cursors are usually .ani files).
	 *
	 * -- Skinners Atlas
	 *
	 * "VOLBAR",
	 * "WSCLOSE",
	 * "WSWINBUT",
	 * "WSMIN",
	 *
	 */];
	async function genVizColors(zip) {
	  const viscolor = await getFileFromZip(zip, "VISCOLOR", "txt", "text");
	  return viscolor ? parseViscolors(viscolor.contents) : DEFAULT_SKIN.colors;
	}
	async function genImages(zip) {
	  const imageObjs = await Promise.all(Object.keys(sprites).map(fileName => getSpriteUrisFromFilename(zip, fileName)));
	  // Merge all the objects into a single object. Tests assert that sprite keys are unique.
	  return shallowMerge(imageObjs);
	}
	async function genCursors(zip) {
	  const cursorObjs = await Promise.all(CURSORS.map(async cursorName => ({
	    [cursorName]: await getCursorFromFilename(zip, cursorName)
	  })));
	  return shallowMerge(cursorObjs);
	}
	async function genRegion(zip) {
	  const region = await getFileFromZip(zip, "REGION", "txt", "text");
	  return region ? regionParser(region.contents) : {};
	}
	async function genGenTextSprites(zip) {
	  const img = await getImgFromFilename(zip, "GEN");
	  if (img == null) {
	    return null;
	  }
	  const canvas = document.createElement("canvas");
	  const context = canvas.getContext("2d", {
	    willReadFrequently: true
	  });
	  canvas.width = img.width;
	  canvas.height = img.height;
	  context.drawImage(img, 0, 0);
	  const getLetters = (y, prefix) => {
	    const getColorAt = x => context.getImageData(x, y, 1, 1).data.join(",");
	    let x = 1;
	    const backgroundColor = getColorAt(0);
	    const height = 7;
	    return LETTERS.map(letter => {
	      let nextBackground = x;
	      while (getColorAt(nextBackground) !== backgroundColor && nextBackground < canvas.width) {
	        nextBackground++;
	      }
	      const width = nextBackground - x;
	      const name = `${prefix}_${letter}`;
	      const sprite = {
	        x,
	        y,
	        height,
	        width,
	        name
	      };
	      x = nextBackground + 1;
	      return sprite;
	    });
	  };
	  const letterWidths = {};
	  const sprites = [...getLetters(88, "GEN_TEXT_SELECTED"), ...getLetters(96, "GEN_TEXT")];
	  sprites.forEach(sprite => {
	    letterWidths[sprite.name] = sprite.width;
	  });
	  return [letterWidths, getSpriteUrisFromImg(img, sprites)];
	}

	// A promise that, given an array buffer returns a skin style object
	async function skinParser(zipFileBuffer, JSZip) {
	  const zip = await JSZip.loadAsync(zipFileBuffer);
	  const [colors, playlistStyle, images, cursors, region, genTextSprites, genExColors] = await Promise.all([genVizColors(zip), getPlaylistStyle(zip), genImages(zip), genCursors(zip), genRegion(zip), genGenTextSprites(zip), getGenExColors(zip)]);
	  const [genLetterWidths, genTextImages] = genTextSprites || [null, {}];
	  return {
	    colors,
	    playlistStyle,
	    images: {
	      ...images,
	      ...genTextImages
	    },
	    genLetterWidths,
	    cursors,
	    region,
	    genExColors
	  };
	}

	var tinyqueue = {exports: {}};

	tinyqueue.exports = TinyQueue;
	tinyqueue.exports.default = TinyQueue;

	function TinyQueue(data, compare) {
	    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

	    this.data = data || [];
	    this.length = this.data.length;
	    this.compare = compare || defaultCompare;

	    if (this.length > 0) {
	        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
	    }
	}

	function defaultCompare(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	TinyQueue.prototype = {

	    push: function (item) {
	        this.data.push(item);
	        this.length++;
	        this._up(this.length - 1);
	    },

	    pop: function () {
	        if (this.length === 0) return undefined;

	        var top = this.data[0];
	        this.length--;

	        if (this.length > 0) {
	            this.data[0] = this.data[this.length];
	            this._down(0);
	        }
	        this.data.pop();

	        return top;
	    },

	    peek: function () {
	        return this.data[0];
	    },

	    _up: function (pos) {
	        var data = this.data;
	        var compare = this.compare;
	        var item = data[pos];

	        while (pos > 0) {
	            var parent = (pos - 1) >> 1;
	            var current = data[parent];
	            if (compare(item, current) >= 0) break;
	            data[pos] = current;
	            pos = parent;
	        }

	        data[pos] = item;
	    },

	    _down: function (pos) {
	        var data = this.data;
	        var compare = this.compare;
	        var halfLength = this.length >> 1;
	        var item = data[pos];

	        while (pos < halfLength) {
	            var left = (pos << 1) + 1;
	            var right = left + 1;
	            var best = data[left];

	            if (right < this.length && compare(data[right], best) < 0) {
	                left = right;
	                best = data[right];
	            }
	            if (compare(best, item) >= 0) break;

	            data[pos] = best;
	            pos = left;
	        }

	        data[pos] = item;
	    }
	};

	var tinyqueueExports = tinyqueue.exports;
	var TinyQueue$1 = /*@__PURE__*/getDefaultExportFromCjs(tinyqueueExports);

	// Push promises onto a queue with a priority.
	// Run a given number of jobs in parallel
	// Useful for prioritizing network requests
	class LoadQueue {
	  constructor({
	    threads
	  }) {
	    // TODO: Consider not running items with zero priority
	    // Priority is a function so that items can change their priority between
	    // when their priority is evaluated.
	    // For example, we might add a track to the playlist and then scroll to/away
	    // from it before it gets processed.
	    this._queue = new TinyQueue$1([], (a, b) => a.priority() - b.priority());
	    this._availableThreads = threads;
	  }
	  push(task, priority) {
	    const t = {
	      task,
	      priority
	    };
	    this._queue.push(t);
	    // Wait until the next event loop to pick a task to run. This way, we can
	    // enqueue multiple items in an event loop, and be sure they will be run in
	    // priority order.
	    setTimeout(() => {
	      this._run();
	    }, 0);
	    return () => {
	      // TODO: Could return a boolean representing if the task has already been
	      // kicked off.
	      this._queue = this._queue.filter(t1 => t1 !== t);
	    };
	  }
	  _run() {
	    while (this._availableThreads > 0) {
	      if (this._queue.length === 0) {
	        return;
	      }
	      this._availableThreads--;
	      const t = this._queue.pop();
	      const promise = t.task();
	      invariant$1(typeof promise.then === "function", `LoadQueue only supports loading Promises. Got ${promise}`);
	      promise.then(() => {
	        this._availableThreads++;
	        this._run();
	      });
	    }
	  }
	}

	function cropPlaylist() {
	    return (dispatch, getState) => {
	        const state = getState();
	        if (getSelectedTrackObjects(state).length === 0) {
	            return;
	        }
	        const selectedTrackIds = getSelectedTrackIds(state);
	        const { playlist: { trackOrder }, } = state;
	        dispatch({
	            type: "REMOVE_TRACKS",
	            // @ts-ignore The keys are numbers, but TypeScript does not trust us.
	            // https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208
	            ids: trackOrder.filter((id) => !selectedTrackIds.has(id)),
	        });
	    };
	}
	function removeSelectedTracks() {
	    return (dispatch, getState) => {
	        dispatch({
	            type: "REMOVE_TRACKS",
	            // @ts-ignore The keys are numbers, but TypeScript does not trust us.
	            // https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208
	            ids: Array.from(getSelectedTrackIds(getState())),
	        });
	    };
	}
	function removeAllTracks() {
	    return (dispatch) => {
	        // It's a bit funky that we need to do both of these.
	        dispatch({ type: "STOP" });
	        dispatch({ type: "REMOVE_ALL_TRACKS" });
	    };
	}
	function reverseList() {
	    return { type: "REVERSE_LIST" };
	}
	function randomizeList() {
	    return { type: "RANDOMIZE_LIST" };
	}
	function sortListByTitle() {
	    return (dispatch, getState) => {
	        const state = getState();
	        const tracks = getTracks(state);
	        const trackOrder = sort(getTrackOrder(state), (i) => `${tracks[i].title}`.toLowerCase());
	        return dispatch({ type: "SET_TRACK_ORDER", trackOrder });
	    };
	}
	function setPlaylistScrollPosition(position) {
	    return { type: "SET_PLAYLIST_SCROLL_POSITION", position };
	}
	function scrollNTracks(n) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const overflow = getOverflowTrackCount(state);
	        const currentOffset = getScrollOffset(state);
	        const position = overflow ? clamp((currentOffset + n) / overflow, 0, 1) : 0;
	        return dispatch({
	            type: "SET_PLAYLIST_SCROLL_POSITION",
	            position: position * 100,
	        });
	    };
	}
	function scrollPlaylistByDelta(e) {
	    e.preventDefault();
	    return (dispatch, getState) => {
	        const state = getState();
	        if (getOverflowTrackCount(state)) {
	            e.stopPropagation();
	        }
	        const totalPixelHeight = state.playlist.trackOrder.length * TRACK_HEIGHT;
	        const percentDelta = (e.deltaY / totalPixelHeight) * 100;
	        dispatch({
	            type: "SET_PLAYLIST_SCROLL_POSITION",
	            position: clamp(state.display.playlistScrollPosition + percentDelta, 0, 100),
	        });
	    };
	}
	function scrollUpFourTracks() {
	    return scrollNTracks(-4);
	}
	function scrollDownFourTracks() {
	    return scrollNTracks(4);
	}
	function dragSelected(offset) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const tracks = getTracks(state);
	        const trackOrder = getTrackOrder(state);
	        const selectedIds = getSelectedTrackIdsSet(state);
	        const firstSelected = trackOrder.findIndex((trackId) => tracks[trackId] && selectedIds.has(trackId));
	        if (firstSelected === -1) {
	            return;
	        }
	        const lastSelected = findLastIndex(trackOrder, (trackId) => tracks[trackId] && selectedIds.has(trackId));
	        if (lastSelected === -1) {
	            throw new Error("We found a first selected, but not a last selected.");
	        }
	        // Ensure we don't try to drag off either end.
	        const min = -firstSelected;
	        const max = trackOrder.length - 1 - lastSelected;
	        const normalizedOffset = clamp(offset, min, max);
	        if (normalizedOffset !== 0) {
	            dispatch({ type: "DRAG_SELECTED", offset: normalizedOffset });
	        }
	    };
	}
	function invertSelection() {
	    return { type: "INVERT_SELECTION" };
	}
	function selectZero() {
	    return { type: "SELECT_ZERO" };
	}
	function selectAll() {
	    return { type: "SELECT_ALL" };
	}

	const BAND_SNAP_DISTANCE = 5;
	const BAND_MID_POINT_VALUE = 50;
	function _snapBandValue(value) {
	    if (value < BAND_MID_POINT_VALUE + BAND_SNAP_DISTANCE &&
	        value > BAND_MID_POINT_VALUE - BAND_SNAP_DISTANCE) {
	        return BAND_MID_POINT_VALUE;
	    }
	    return value;
	}
	function setEqBand(band, value) {
	    return { type: "SET_BAND_VALUE", band, value: _snapBandValue(value) };
	}
	function _setEqTo(value) {
	    return (dispatch) => {
	        Object.values(BANDS).forEach((band) => {
	            dispatch({
	                type: "SET_BAND_VALUE",
	                value,
	                band: band,
	            });
	        });
	    };
	}
	function setEqToMax() {
	    return _setEqTo(100);
	}
	function setEqToMid() {
	    return _setEqTo(50);
	}
	function setEqToMin() {
	    return _setEqTo(0);
	}
	function setPreamp(value) {
	    return {
	        type: "SET_BAND_VALUE",
	        band: "preamp",
	        value: _snapBandValue(value),
	    };
	}
	function toggleEq() {
	    return (dispatch, getState) => {
	        if (getState().equalizer.on) {
	            dispatch({ type: "SET_EQ_OFF" });
	        }
	        else {
	            dispatch({ type: "SET_EQ_ON" });
	        }
	    };
	}
	function toggleEqAuto() {
	    return (dispatch) => {
	        // We don't actually support this feature yet so don't let the user ever turn it on.
	        // dispatch({ type: SET_EQ_AUTO, value: !getState().equalizer.auto });
	        dispatch({ type: "SET_EQ_AUTO", value: false });
	    };
	}

	// Lower is better
	const DURATION_VISIBLE_PRIORITY = 5;
	const META_DATA_VISIBLE_PRIORITY = 10;
	const DURATION_PRIORITY = 15;
	const META_DATA_PRIORITY = 20;
	const loadQueue = new LoadQueue({ threads: 4 });
	function addTracksFromReferences(fileReferences, loadStyle, atIndex) {
	    const tracks = Array.from(fileReferences).map((file) => ({
	        blob: file,
	        defaultName: file.name,
	    }));
	    return loadMediaFiles(tracks, loadStyle, atIndex);
	}
	const SKIN_FILENAME_MATCHER = new RegExp("(wsz|zip)$", "i");
	const EQF_FILENAME_MATCHER = new RegExp("eqf$", "i");
	function loadFilesFromReferences(fileReferences, loadStyle = LOAD_STYLE.PLAY, atIndex = undefined) {
	    return (dispatch) => {
	        if (fileReferences.length < 1) {
	            return;
	        }
	        else if (fileReferences.length === 1) {
	            const fileReference = fileReferences[0];
	            if (SKIN_FILENAME_MATCHER.test(fileReference.name)) {
	                dispatch(setSkinFromBlob(fileReference));
	                return;
	            }
	            else if (EQF_FILENAME_MATCHER.test(fileReference.name)) {
	                dispatch(setEqFromFileReference(fileReference));
	                return;
	            }
	        }
	        dispatch(addTracksFromReferences(fileReferences, loadStyle, atIndex));
	    };
	}
	function setSkinFromBlob(blob) {
	    return async (dispatch, getState, { requireJSZip }) => {
	        if (!requireJSZip) {
	            alert("Webamp has not been configured to support custom skins.");
	            return;
	        }
	        dispatch({ type: "LOADING" });
	        let JSZip;
	        try {
	            JSZip = await requireJSZip();
	        }
	        catch (e) {
	            console.error(e);
	            dispatch({ type: "LOADED" });
	            alert("Failed to load the skin parser.");
	            return;
	        }
	        try {
	            const skinData = await skinParser(blob, JSZip);
	            dispatch({
	                type: "SET_SKIN_DATA",
	                data: {
	                    skinImages: skinData.images,
	                    skinColors: skinData.colors,
	                    skinPlaylistStyle: skinData.playlistStyle,
	                    skinCursors: skinData.cursors,
	                    skinRegion: skinData.region,
	                    skinGenLetterWidths: skinData.genLetterWidths,
	                    skinGenExColors: skinData.genExColors,
	                },
	            });
	        }
	        catch (e) {
	            console.error(e);
	            dispatch({ type: "LOADED" });
	            alert(`Failed to parse skin`);
	        }
	    };
	}
	function setSkinFromUrl(url) {
	    return async (dispatch) => {
	        dispatch({ type: "LOADING" });
	        try {
	            const response = await fetch(url);
	            if (!response.ok) {
	                throw new Error(response.statusText);
	            }
	            dispatch(setSkinFromBlob(response.blob()));
	        }
	        catch (e) {
	            console.error(e);
	            dispatch({ type: "LOADED" });
	            alert(`Failed to download skin from ${url}`);
	        }
	    };
	}
	// This function is private, since Winamp consumers can provide means for
	// opening files via other methods. Only use the file type specific
	// versions below, since they can defer to the user-defined behavior.
	function _openFileDialog(accept, expectedType) {
	    return async (dispatch) => {
	        const fileReferences = await promptForFileReferences({ accept });
	        dispatch({
	            type: "OPENED_FILES",
	            expectedType,
	            count: fileReferences.length,
	            firstFileName: fileReferences[0]?.name,
	        });
	        dispatch(loadFilesFromReferences(fileReferences));
	    };
	}
	function openEqfFileDialog() {
	    return _openFileDialog(".eqf", "EQ");
	}
	function openMediaFileDialog() {
	    return _openFileDialog(null, "MEDIA");
	}
	function openSkinFileDialog() {
	    return _openFileDialog(".zip, .wsz", "SKIN");
	}
	function fetchMediaDuration(url, id) {
	    return (dispatch, getState) => {
	        loadQueue.push(async () => {
	            try {
	                const duration = await genMediaDuration(url);
	                dispatch({ type: "SET_MEDIA_DURATION", duration, id });
	            }
	            catch (e) {
	                // TODO: Should we update the state to indicate that we don't know the length?
	            }
	        }, () => {
	            const trackIsVisible = getTrackIsVisibleFunction(getState());
	            return trackIsVisible(id)
	                ? DURATION_VISIBLE_PRIORITY
	                : DURATION_PRIORITY;
	        });
	    };
	}
	function loadMedia(e, loadStyle = LOAD_STYLE.NONE, atIndex = 0) {
	    const { files } = e.dataTransfer;
	    return async (dispatch, getState, { handleTrackDropEvent }) => {
	        if (handleTrackDropEvent) {
	            const tracks = await handleTrackDropEvent(e);
	            if (tracks != null) {
	                dispatch(loadMediaFiles(tracks, loadStyle, atIndex));
	                return;
	            }
	        }
	        dispatch(loadFilesFromReferences(files, loadStyle, atIndex));
	    };
	}
	function loadMediaFiles(tracks, loadStyle = LOAD_STYLE.NONE, atIndex = 0) {
	    return (dispatch) => {
	        if (loadStyle === LOAD_STYLE.PLAY) {
	            // I'm the worst. It just so happens that in every case that we autoPlay,
	            // we should also clear all tracks.
	            dispatch(removeAllTracks());
	        }
	        tracks.forEach((track, i) => {
	            const priority = i === 0 ? loadStyle : LOAD_STYLE.NONE;
	            dispatch(loadMediaFile(track, priority, atIndex + i));
	        });
	    };
	}
	function loadMediaFile(track, priority = LOAD_STYLE.NONE, atIndex = 0) {
	    return (dispatch) => {
	        const id = uniqueId$1();
	        const { defaultName, metaData, duration } = track;
	        let canonicalUrl;
	        if ("url" in track) {
	            canonicalUrl = track.url.toString();
	        }
	        else if ("blob" in track) {
	            canonicalUrl = URL.createObjectURL(track.blob);
	        }
	        else {
	            throw new Error("Expected track to have either a blob or a url");
	        }
	        dispatch({
	            type: "ADD_TRACK_FROM_URL",
	            url: canonicalUrl,
	            duration: track.duration,
	            defaultName,
	            id,
	            atIndex,
	        });
	        switch (priority) {
	            case LOAD_STYLE.BUFFER:
	                dispatch({ type: "BUFFER_TRACK", id });
	                break;
	            case LOAD_STYLE.PLAY:
	                dispatch({ type: "PLAY_TRACK", id });
	                break;
	            case LOAD_STYLE.NONE:
	            default:
	                // If we're not going to load this right away,
	                // we should set duration on our own
	                if (duration != null) {
	                    dispatch({ type: "SET_MEDIA_DURATION", duration, id });
	                }
	                else {
	                    dispatch(fetchMediaDuration(canonicalUrl, id));
	                }
	        }
	        if (metaData != null) {
	            const { artist, title, album } = metaData;
	            dispatch({
	                type: "SET_MEDIA_TAGS",
	                artist,
	                title,
	                album,
	                // For now, we lie about these next three things.
	                // TODO: Ideally we would leave these as null and force a media data
	                // fetch when the user starts playing.
	                sampleRate: 44000,
	                bitrate: 192000,
	                numberOfChannels: 2,
	                id,
	            });
	        }
	        else if ("blob" in track) {
	            // Blobs can be loaded quickly
	            dispatch(fetchMediaTags(track.blob, id));
	        }
	        else {
	            dispatch(queueFetchingMediaTags(id));
	        }
	    };
	}
	function queueFetchingMediaTags(id) {
	    return (dispatch, getState) => {
	        const track = getTracks(getState())[id];
	        loadQueue.push(() => dispatch(fetchMediaTags(track.url, id)), () => {
	            const trackIsVisible = getTrackIsVisibleFunction(getState());
	            return trackIsVisible(id)
	                ? META_DATA_VISIBLE_PRIORITY
	                : META_DATA_PRIORITY;
	        });
	    };
	}
	function fetchMediaTags(file, id) {
	    return async (dispatch, getState, { requireMusicMetadata }) => {
	        dispatch({ type: "MEDIA_TAG_REQUEST_INITIALIZED", id });
	        try {
	            const metadata = await genMediaTags(file, await requireMusicMetadata());
	            // There's more data here, but we don't have a use for it yet:
	            const { artist, title, album, picture } = metadata.common;
	            const { numberOfChannels, bitrate, sampleRate } = metadata.format;
	            let albumArtUrl = null;
	            if (picture && picture.length >= 1) {
	                const byteArray = new Uint8Array(picture[0].data);
	                const blob = new Blob([byteArray], { type: picture[0].format });
	                albumArtUrl = URL.createObjectURL(blob);
	            }
	            dispatch({
	                type: "SET_MEDIA_TAGS",
	                artist: artist ? artist : "",
	                title: title ? title : "",
	                album,
	                albumArtUrl,
	                numberOfChannels,
	                bitrate,
	                sampleRate,
	                id,
	            });
	        }
	        catch (e) {
	            dispatch({ type: "MEDIA_TAG_REQUEST_FAILED", id });
	        }
	    };
	}
	function setEqFromFileReference(fileReference) {
	    return async (dispatch) => {
	        const arrayBuffer = await genArrayBufferFromFileReference(fileReference);
	        const eqf = parser(arrayBuffer);
	        const preset = eqf.presets[0];
	        dispatch(setEqFromObject(preset));
	    };
	}
	function setEqFromObject(preset) {
	    return (dispatch) => {
	        dispatch(setPreamp(normalizeEqBand(preset.preamp)));
	        BANDS.forEach((band) => {
	            // @ts-ignore band and EqfPreset align
	            dispatch(setEqBand(band, normalizeEqBand(preset[`hz${band}`])));
	        });
	    };
	}
	function downloadPreset() {
	    return (dispatch, getState) => {
	        const state = getState();
	        const data = getEqfData(state);
	        const arrayBuffer = creator(data);
	        const base64 = base64FromArrayBuffer(arrayBuffer);
	        const dataURI = `data:application/zip;base64,${base64}`;
	        downloadURI(dataURI, "entry.eqf");
	    };
	}
	function downloadHtmlPlaylist() {
	    return (dispatch, getState) => {
	        const uri = getPlaylistURL(getState());
	        downloadURI(uri, "Winamp Playlist.html");
	    };
	}
	let el = document.createElement("input");
	el.type = "file";
	// @ts-ingore
	const DIR_SUPPORT = 
	// @ts-ignore
	typeof el.webkitdirectory !== "undefined" ||
	    // @ts-ignore
	    typeof el.mozdirectory !== "undefined" ||
	    // @ts-ignore
	    typeof el.directory !== "undefined";
	// Release our reference
	el = null;
	function addFilesAtIndex(nextIndex) {
	    return async (dispatch) => {
	        const fileReferences = await promptForFileReferences();
	        dispatch(addTracksFromReferences(fileReferences, LOAD_STYLE.NONE, nextIndex));
	    };
	}
	function addDirAtIndex(nextIndex) {
	    return async (dispatch) => {
	        if (!DIR_SUPPORT) {
	            alert("Not supported in your browser");
	            return;
	        }
	        const fileReferences = await promptForFileReferences({ directory: true });
	        dispatch(addTracksFromReferences(fileReferences, LOAD_STYLE.NONE, nextIndex));
	    };
	}
	function addFilesFromUrl(atIndex = 0) {
	    return async (dispatch, getState, { handleAddUrlEvent }) => {
	        if (handleAddUrlEvent) {
	            const tracks = await handleAddUrlEvent();
	            if (tracks != null) {
	                dispatch(loadMediaFiles(tracks, LOAD_STYLE.NONE, atIndex));
	                return;
	            }
	        }
	        else {
	            alert("Not supported in Webamp");
	        }
	    };
	}
	function addFilesFromList() {
	    return async (dispatch, getState, { handleLoadListEvent }) => {
	        if (handleLoadListEvent) {
	            const tracks = await handleLoadListEvent();
	            if (tracks != null) {
	                dispatch(removeAllTracks());
	                dispatch(loadMediaFiles(tracks, LOAD_STYLE.NONE, 0));
	                return;
	            }
	        }
	        else {
	            alert("Not supported in Webamp");
	        }
	    };
	}
	function saveFilesToList() {
	    return (dispatch, getState, { handleSaveListEvent }) => {
	        if (handleSaveListEvent) {
	            handleSaveListEvent(getUserTracks(getState()));
	        }
	        else {
	            alert("Not supported in Webamp");
	        }
	    };
	}
	function droppedFiles(e, windowId) {
	    return (dispatch) => dispatch({
	        type: "DROPPED_FILES",
	        count: e.dataTransfer.files.length,
	        firstFileName: e.dataTransfer.files[0]?.name,
	        windowId,
	    });
	}

	function playTrack(id) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const isStopped = getMediaStatus(state) === MEDIA_STATUS.STOPPED;
	        if (isStopped) {
	            dispatch({ type: "BUFFER_TRACK", id });
	        }
	        else {
	            dispatch({ type: "PLAY_TRACK", id });
	        }
	    };
	}
	function playTrackNow(id) {
	    return { type: "PLAY_TRACK", id };
	}
	function play() {
	    return (dispatch, getState) => {
	        const state = getState();
	        if (state.media.status === MEDIA_STATUS.STOPPED &&
	            state.playlist.currentTrack == null &&
	            state.playlist.trackOrder.length === 0) {
	            dispatch(openMediaFileDialog());
	        }
	        else {
	            dispatch({ type: "PLAY" });
	        }
	    };
	}
	function pause() {
	    return (dispatch, getState) => {
	        const { status } = getState().media;
	        if (status === MEDIA_STATUS.PLAYING) {
	            dispatch({ type: "PAUSE" });
	        }
	        else {
	            dispatch({ type: "PLAY" });
	        }
	    };
	}
	function stop() {
	    return { type: "STOP" };
	}
	function nextN(n) {
	    return (dispatch, getState) => {
	        const nextTrackId = getNextTrackId(getState(), n);
	        if (nextTrackId == null) {
	            dispatch({ type: "IS_STOPPED" });
	            return;
	        }
	        dispatch(playTrack(nextTrackId));
	    };
	}
	function next() {
	    return nextN(1);
	}
	function previous() {
	    return nextN(-1);
	}
	function seekToTime(seconds) {
	    return function (dispatch, getState) {
	        const state = getState();
	        const duration = getDuration(state);
	        if (duration == null) {
	            return;
	        }
	        dispatch({
	            type: "SEEK_TO_PERCENT_COMPLETE",
	            percent: (seconds / duration) * 100,
	        });
	    };
	}
	function seekForward(seconds) {
	    return function (dispatch, getState) {
	        const timeElapsed = getTimeElapsed(getState());
	        dispatch(seekToTime(timeElapsed + seconds));
	    };
	}
	function seekBackward(seconds) {
	    return seekForward(-seconds);
	}
	function setVolume(volume) {
	    return {
	        type: "SET_VOLUME",
	        volume: clamp(volume, 0, 100),
	    };
	}
	function adjustVolume(volumeDiff) {
	    return (dispatch, getState) => {
	        const currentVolume = getState().media.volume;
	        return dispatch(setVolume(currentVolume + volumeDiff));
	    };
	}
	function scrollVolume(e) {
	    e.preventDefault();
	    return (dispatch, getState) => {
	        const currentVolume = getState().media.volume;
	        // Using pixels as percentage difference here is a bit arbitrary, but... oh well.
	        return dispatch(setVolume(currentVolume + e.deltaY));
	    };
	}
	function setBalance(balance) {
	    balance = clamp(balance, -100, 100);
	    // The balance clips to the center
	    if (Math.abs(balance) < 25) {
	        balance = 0;
	    }
	    return {
	        type: "SET_BALANCE",
	        balance,
	    };
	}
	function toggleRepeat() {
	    return { type: "TOGGLE_REPEAT" };
	}
	function toggleShuffle() {
	    return { type: "TOGGLE_SHUFFLE" };
	}
	function toggleTimeMode() {
	    return { type: "TOGGLE_TIME_MODE" };
	}

	function normalizePresetTypes(preset) {
	    const { name } = preset;
	    if ("butterchurnPresetObject" in preset) {
	        return {
	            type: "RESOLVED",
	            name,
	            preset: preset.butterchurnPresetObject,
	        };
	    }
	    else if ("getButterchrunPresetObject" in preset) {
	        return {
	            type: "UNRESOLVED",
	            name,
	            getPreset: preset.getButterchrunPresetObject,
	        };
	    }
	    else if ("butterchurnPresetUrl" in preset) {
	        return {
	            type: "UNRESOLVED",
	            name,
	            getPreset: async () => {
	                const resp = await fetch(preset.butterchurnPresetUrl);
	                return resp.json();
	            },
	        };
	    }
	    throw new Error("Invalid preset object");
	}
	function initializePresets(presetOptions) {
	    return async (dispatch) => {
	        const { getPresets, importButterchurn } = presetOptions;
	        importButterchurn().then((butterchurnModule) => {
	            const butterchurn = butterchurnModule.default ?? butterchurnModule;
	            dispatch({ type: "GOT_BUTTERCHURN", butterchurn });
	        });
	        const presets = await getPresets();
	        const normalizePresets = presets.map(normalizePresetTypes);
	        dispatch(loadPresets(normalizePresets));
	    };
	}
	function loadPresets(presets) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const presetsLength = state.milkdrop.presets.length;
	        dispatch({ type: "GOT_BUTTERCHURN_PRESETS", presets });
	        if (presetsLength === 0 && getRandomizePresets(state)) {
	            dispatch(selectRandomPreset());
	        }
	        else {
	            dispatch(requestPresetAtIndex(presetsLength, TransitionType.IMMEDIATE, true));
	        }
	    };
	}
	function appendPresetFileList(fileList) {
	    return async (dispatch, getState, { convertPreset }) => {
	        const presets = Array.from(fileList)
	            .map((file) => {
	            const JSON_EXT = ".json";
	            const MILK_EXT = ".milk";
	            const filename = file.name.toLowerCase();
	            if (filename.endsWith(MILK_EXT)) {
	                if (convertPreset == null) {
	                    throw new Error("Invalid type");
	                }
	                return {
	                    type: "UNRESOLVED",
	                    name: file.name.slice(0, file.name.length - MILK_EXT.length),
	                    getPreset: () => convertPreset(file),
	                };
	            }
	            else if (filename.endsWith(JSON_EXT)) {
	                return {
	                    type: "UNRESOLVED",
	                    name: file.name.slice(0, file.name.length - JSON_EXT.length),
	                    getPreset: async () => {
	                        const str = await genStringFromFileReference(file);
	                        // TODO: How should we handle the case where json parsing fails?
	                        return JSON.parse(str);
	                    },
	                };
	            }
	            console.error("Invalid type preset when loading directory");
	            return null;
	        })
	            .filter(Boolean);
	        dispatch(loadPresets(presets));
	    };
	}
	function selectNextPreset(transitionType = TransitionType.DEFAULT) {
	    return (dispatch, getState) => {
	        const state = getState();
	        if (getRandomizePresets(state)) {
	            return dispatch(selectRandomPreset(transitionType));
	        }
	        const currentPresetIndex = getCurrentPresetIndex(state);
	        if (currentPresetIndex == null) {
	            return;
	        }
	        const nextPresetIndex = currentPresetIndex + 1;
	        dispatch(requestPresetAtIndex(nextPresetIndex, transitionType, true));
	    };
	}
	function selectPreviousPreset(transitionType = TransitionType.DEFAULT) {
	    return (dispatch, getState) => {
	        const state = getState();
	        const { presetHistory } = state.milkdrop;
	        if (presetHistory.length < 1) {
	            return;
	        }
	        // Awkward. We do -2 becuase the the last track is the current track.
	        const lastPresetIndex = presetHistory[presetHistory.length - 2];
	        dispatch(requestPresetAtIndex(lastPresetIndex, transitionType, false));
	    };
	}
	function selectRandomPreset(transitionType = TransitionType.DEFAULT) {
	    return (dispatch, getState) => {
	        const state = getState();
	        // TODO: Make this a selector.
	        const randomIndex = Math.floor(Math.random() * state.milkdrop.presets.length);
	        dispatch(requestPresetAtIndex(randomIndex, transitionType, true));
	    };
	}
	// TODO: Technically there's a race here. If you request two presets in a row, the
	// first one may resolve before the second.
	function requestPresetAtIndex(index, transitionType, addToHistory) {
	    return async (dispatch, getState) => {
	        const state = getState();
	        const preset = state.milkdrop.presets[index];
	        if (preset == null) {
	            // Index might be out of range.
	            return;
	        }
	        dispatch({ type: "PRESET_REQUESTED", index, addToHistory });
	        switch (preset.type) {
	            case "RESOLVED":
	                dispatch({ type: "SELECT_PRESET_AT_INDEX", index, transitionType });
	                return;
	            case "UNRESOLVED":
	                const json = await preset.getPreset();
	                // TODO: Ensure that this works correctly even if requests resolve out of order
	                dispatch({ type: "RESOLVE_PRESET_AT_INDEX", index, json });
	                dispatch({ type: "SELECT_PRESET_AT_INDEX", index, transitionType });
	                return;
	        }
	    };
	}
	function handlePresetDrop(e) {
	    return appendPresetFileList(e.dataTransfer.files);
	}
	function toggleRandomizePresets() {
	    return { type: "TOGGLE_RANDOMIZE_PRESETS" };
	}
	function togglePresetCycling() {
	    return { type: "TOGGLE_PRESET_CYCLING" };
	}
	function scheduleMilkdropMessage(message) {
	    return { type: "SCHEDULE_MILKDROP_MESSAGE", message };
	}

	function close() {
	    return (dispatch) => {
	        // TODO: This could probably be improved by adding a "PREVENT_CLOSE" action
	        // or something, but this works okay for now.
	        let defaultPrevented = false;
	        const cancel = () => {
	            defaultPrevented = true;
	        };
	        dispatch({ type: "CLOSE_REQUESTED", cancel });
	        if (!defaultPrevented) {
	            dispatch({ type: "STOP" });
	            dispatch({ type: "CLOSE_WINAMP" });
	        }
	    };
	}
	function open() {
	    return { type: "OPEN_WINAMP" };
	}
	function toggleVisualizerStyle() {
	    return { type: "TOGGLE_VISUALIZER_STYLE" };
	}
	function minimize() {
	    return { type: "MINIMIZE_WINAMP" };
	}
	function setFocus(input) {
	    return { type: "SET_FOCUS", input };
	}
	function unsetFocus() {
	    return { type: "UNSET_FOCUS" };
	}
	function focusBand(band) {
	    return { type: "SET_BAND_FOCUS", input: "eq", bandFocused: band };
	}
	function loadSerializedState(
	// In the future this type should be the union of all versioned types.
	serializedState) {
	    return (dispatch) => {
	        dispatch({ type: "LOAD_SERIALIZED_STATE", serializedState });
	        dispatch(ensureWindowsAreOnScreen());
	    };
	}
	function loadDefaultSkin() {
	    return { type: "LOAD_DEFAULT_SKIN" };
	}
	function toggleMilkdropDesktop() {
	    return (dispatch, getState) => {
	        if (getMilkdropDesktopEnabled(getState())) {
	            dispatch({ type: "SET_MILKDROP_DESKTOP", enabled: false });
	        }
	        else {
	            dispatch({ type: "SET_MILKDROP_DESKTOP", enabled: true });
	        }
	    };
	}
	function setMilkdropFullscreen(enabled) {
	    return { type: "SET_MILKDROP_FULLSCREEN", enabled };
	}
	function toggleMilkdropFullscreen() {
	    return (dispatch, getState) => {
	        dispatch(setMilkdropFullscreen(!getMilkdropFullscreenEnabled(getState())));
	    };
	}
	function togglePresetOverlay() {
	    return (dispatch, getState) => {
	        if (getPresetOverlayOpen(getState())) {
	            dispatch(setFocusedWindow(WINDOWS.MILKDROP));
	        }
	        dispatch({ type: "TOGGLE_PRESET_OVERLAY" });
	    };
	}
	function stepMarquee() {
	    return { type: "STEP_MARQUEE" };
	}

	var mediaMiddleware = (media) => (store) => {
	    const { media: { volume, balance }, equalizer: { sliders }, } = store.getState();
	    // Ensure the default state is the canonical value.
	    media.setVolume(volume);
	    media.setBalance(balance);
	    media.setPreamp(sliders.preamp);
	    // TODO: Ensure other values like bands are in sync
	    media.on("timeupdate", () => {
	        store.dispatch({
	            type: "UPDATE_TIME_ELAPSED",
	            elapsed: media.timeElapsed(),
	        });
	    });
	    media.on("ended", () => {
	        store.dispatch(next());
	    });
	    media.on("playing", () => {
	        store.dispatch({ type: "IS_PLAYING" });
	    });
	    media.on("waiting", () => {
	        store.dispatch({ type: "START_WORKING" });
	    });
	    media.on("stopWaiting", () => {
	        store.dispatch({ type: "STOP_WORKING" });
	    });
	    media.on("fileLoaded", () => {
	        const id = getCurrentTrackId(store.getState());
	        if (id == null) {
	            // Attempted to set the metadata for a track that was already removed.
	            // Really, the media should have been stopped when the track was removed.
	            return;
	        }
	        store.dispatch({
	            id,
	            type: "SET_MEDIA",
	            kbps: "128",
	            khz: "44",
	            channels: 2,
	            length: media.duration(),
	        });
	    });
	    return (next) => (action) => {
	        const returnValue = next(action);
	        const state = store.getState();
	        switch (action.type) {
	            case "PLAY":
	                media.play();
	                break;
	            case "PAUSE":
	                media.pause();
	                break;
	            case "STOP":
	                media.stop();
	                break;
	            case "SET_VOLUME":
	                media.setVolume(getVolume(state));
	                break;
	            case "SET_BALANCE":
	                media.setBalance(getBalance(state));
	                break;
	            case "SEEK_TO_PERCENT_COMPLETE":
	                media.seekToPercentComplete(action.percent);
	                break;
	            case "PLAY_TRACK": {
	                const url = getTrackUrl(store.getState())(action.id);
	                if (url != null) {
	                    media.loadFromUrl(url, true);
	                }
	                break;
	            }
	            case "BUFFER_TRACK": {
	                const url = getTrackUrl(store.getState())(action.id);
	                if (url != null) {
	                    media.loadFromUrl(url, false);
	                }
	                break;
	            }
	            case "SET_BAND_VALUE":
	                if (action.band === "preamp") {
	                    media.setPreamp(action.value);
	                }
	                else {
	                    media.setEqBand(action.band, action.value);
	                }
	                break;
	            case "SET_EQ_OFF":
	                media.disableEq();
	                break;
	            case "SET_EQ_ON":
	                media.enableEq();
	                break;
	            case "LOAD_SERIALIZED_STATE": {
	                // Set ALL THE THINGS!
	                if (getEqualizerEnabled(state)) {
	                    media.enableEq();
	                }
	                else {
	                    media.disableEq();
	                }
	                media.setVolume(getVolume(state));
	                media.setBalance(getBalance(state));
	                objectForEach(state.equalizer.sliders, (value, slider) => {
	                    if (slider === "preamp") {
	                        media.setPreamp(value);
	                    }
	                    else {
	                        // @ts-ignore I don't know how to teach TypeScript about objects
	                        // that use Slider as keys
	                        media.setEqBand(slider, value);
	                    }
	                });
	                break;
	            }
	        }
	        return returnValue;
	    };
	};

	const compose = composeWithDevTools({
	    actionsDenylist: ["UPDATE_TIME_ELAPSED", "STEP_MARQUEE"],
	});
	function createWebampStore(media, actionEmitter, customMiddlewares = [], stateOverrides, extras) {
	    let initialState;
	    if (stateOverrides) {
	        initialState = merge(reducer(undefined, { type: "@@init" }), stateOverrides);
	    }
	    const emitterMiddleware = () => (next) => (action) => {
	        actionEmitter.trigger(action.type, action);
	        return next(action);
	    };
	    const middlewares = [
	        thunk.withExtraArgument(extras),
	        mediaMiddleware(media),
	        emitterMiddleware,
	        ...customMiddlewares,
	    ];
	    // @ts-expect-error Typing of these is too hard to get right, so we cheat
	    const coercedMiddlewares = middlewares;
	    const enhancer = compose(applyMiddleware(...coercedMiddlewares));
	    return legacy_createStore(reducer, initialState, enhancer);
	}

	var key = {
	    fullscreenEnabled: 0,
	    fullscreenElement: 1,
	    requestFullscreen: 2,
	    exitFullscreen: 3,
	    fullscreenchange: 4,
	    fullscreenerror: 5,
	    fullscreen: 6
	};
	var webkit = [
	    'webkitFullscreenEnabled',
	    'webkitFullscreenElement',
	    'webkitRequestFullscreen',
	    'webkitExitFullscreen',
	    'webkitfullscreenchange',
	    'webkitfullscreenerror',
	    '-webkit-full-screen',
	];
	var moz = [
	    'mozFullScreenEnabled',
	    'mozFullScreenElement',
	    'mozRequestFullScreen',
	    'mozCancelFullScreen',
	    'mozfullscreenchange',
	    'mozfullscreenerror',
	    '-moz-full-screen',
	];
	var ms = [
	    'msFullscreenEnabled',
	    'msFullscreenElement',
	    'msRequestFullscreen',
	    'msExitFullscreen',
	    'MSFullscreenChange',
	    'MSFullscreenError',
	    '-ms-fullscreen',
	];
	// so it doesn't throw if no window or document
	var document$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};
	var vendor = (('fullscreenEnabled' in document$1 && Object.keys(key)) ||
	    (webkit[0] in document$1 && webkit) ||
	    (moz[0] in document$1 && moz) ||
	    (ms[0] in document$1 && ms) ||
	    []);
	var fscreen = {
	    requestFullscreen: function (element) { return element[vendor[key.requestFullscreen]](); },
	    requestFullscreenFunction: function (element) { return element[vendor[key.requestFullscreen]]; },
	    get exitFullscreen() { return document$1[vendor[key.exitFullscreen]].bind(document$1); },
	    get fullscreenPseudoClass() { return ":" + vendor[key.fullscreen]; },
	    addEventListener: function (type, handler, options) { return document$1.addEventListener(vendor[key[type]], handler, options); },
	    removeEventListener: function (type, handler, options) { return document$1.removeEventListener(vendor[key[type]], handler, options); },
	    get fullscreenEnabled() { return Boolean(document$1[vendor[key.fullscreenEnabled]]); },
	    set fullscreenEnabled(val) { },
	    get fullscreenElement() { return document$1[vendor[key.fullscreenElement]]; },
	    set fullscreenElement(val) { },
	    get onfullscreenchange() { return document$1[("on" + vendor[key.fullscreenchange]).toLowerCase()]; },
	    set onfullscreenchange(handler) { return document$1[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler; },
	    get onfullscreenerror() { return document$1[("on" + vendor[key.fullscreenerror]).toLowerCase()]; },
	    set onfullscreenerror(handler) { return document$1[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler; },
	};

	function leaveFullScreen() {
	    if (fscreen.fullscreenEnabled) {
	        fscreen.exitFullscreen();
	    }
	}
	function enterFullScreen(node) {
	    if (fscreen.fullscreenEnabled) {
	        fscreen.requestFullscreen(node);
	    }
	}
	function FullScreen(props) {
	    const { onChange, enabled } = props;
	    const ref = reactExports.useRef(null);
	    reactExports.useEffect(() => {
	        function detectFullScreen() {
	            if (onChange) {
	                onChange(fscreen.fullscreenElement === ref.current);
	            }
	        }
	        fscreen.addEventListener("fullscreenchange", detectFullScreen);
	        return () => {
	            fscreen.removeEventListener("fullscreenchange", detectFullScreen);
	        };
	    }, [onChange]);
	    // This must run in response to a click event, so we'll use useLayoutEffect just in case.
	    reactExports.useLayoutEffect(() => {
	        const isEnabled = fscreen.fullscreenElement === ref.current;
	        if (isEnabled && !enabled) {
	            leaveFullScreen();
	        }
	        else if (!isEnabled && enabled && ref.current != null) {
	            enterFullScreen(ref.current);
	        }
	    }, [enabled]);
	    return (jsxRuntimeExports.jsx("div", { ref: ref, style: props.enabled ? { height: "100%", width: "100%" } : undefined, children: props.children }));
	}

	function useUnmountedRef() {
	    const unmountedRef = reactExports.useRef(false);
	    reactExports.useEffect(() => {
	        return () => {
	            unmountedRef.current = true;
	        };
	    }, []);
	    return unmountedRef;
	}
	function usePromiseValueOrNull(propValue) {
	    const [value, setValue] = reactExports.useState(null);
	    reactExports.useEffect(() => {
	        let disposed = false;
	        propValue.then((resolvedValue) => {
	            if (disposed) {
	                return;
	            }
	            setValue(resolvedValue);
	        });
	        return () => {
	            disposed = true;
	        };
	    }, [propValue]);
	    return value;
	}
	function useScreenSize() {
	    const [size] = reactExports.useState(getScreenSize());
	    // TODO: We could subscribe to screen size changes.
	    return size;
	}
	function useWindowSize() {
	    const [size, setSize] = reactExports.useState(getWindowSize$1());
	    const handler = reactExports.useCallback(() => {
	    }, []);
	    reactExports.useEffect(() => {
	        window.addEventListener("resize", handler);
	        return () => {
	            window.removeEventListener("resize", handler);
	        };
	    }, [handler]);
	    return size;
	}
	const cursorPositionRef = { current: { pageX: 0, pageY: 0 } };
	let listenerRefCount = 0;
	// Global mousemove listener - managed with reference counting
	const globalMouseMoveHandler = ({ pageX, pageY }) => {
	    cursorPositionRef.current = { pageX, pageY };
	};
	// Add a reference to the global mouse listener
	function addGlobalMouseListener() {
	    if (listenerRefCount === 0) {
	        window.document.addEventListener("mousemove", globalMouseMoveHandler);
	    }
	    listenerRefCount++;
	}
	// Remove a reference to the global mouse listener
	function removeGlobalMouseListener() {
	    listenerRefCount--;
	    if (listenerRefCount === 0) {
	        window.document.removeEventListener("mousemove", globalMouseMoveHandler);
	    }
	}
	// We use a single global event listener with reference counting because there is no way to get the
	// mouse position aside from an event. The listener is only active when at least one component needs it.
	function useCursorPositionRef() {
	    reactExports.useEffect(() => {
	        addGlobalMouseListener();
	        return () => {
	            removeGlobalMouseListener();
	        };
	    }, []);
	    return cursorPositionRef;
	}
	// CSS hover state is not respected if the cursor is already over the node when
	// it is added to the DOM. This hook allows your component to know its hover
	// state on mount without waiting for the mouse to move.
	// https://stackoverflow.com/a/13259049/1263117
	function useIsHovered() {
	    const cursorRef = useCursorPositionRef();
	    const [hover, setHover] = reactExports.useState(false);
	    const [node, setNode] = reactExports.useState(null);
	    reactExports.useLayoutEffect(() => {
	        if (node == null) {
	            setHover(false);
	            return;
	        }
	        const domRect = node.getBoundingClientRect();
	        const { pageX, pageY } = cursorRef.current;
	        setHover(pageX >= domRect.left &&
	            pageX <= domRect.right &&
	            pageY >= domRect.top &&
	            pageY <= domRect.bottom);
	        const enter = () => setHover(true);
	        const leave = () => setHover(false);
	        node.addEventListener("mouseenter", enter);
	        node.addEventListener("mouseleave", leave);
	        return () => {
	            node.removeEventListener("mouseenter", enter);
	            node.removeEventListener("mouseleave", leave);
	        };
	    }, [node, cursorRef]);
	    return { ref: setNode, hover };
	}
	function useOnClickAway(ref, callback) {
	    reactExports.useEffect(() => {
	        if (ref == null || callback == null) {
	            return;
	        }
	        const handleClickOut = (ee) => {
	            const clickOutTarget = ee.target;
	            if (!(clickOutTarget instanceof Element)) {
	                // TypeScript doesn't realize this will always be true
	                return;
	            }
	            if (ref.contains(clickOutTarget)) {
	                return;
	            }
	            // If the click is _not_ inside the menu.
	            callback();
	            window.document.removeEventListener("click", handleClickOut, {
	                capture: true,
	            });
	        };
	        window.document.addEventListener("click", handleClickOut, {
	            capture: true,
	        });
	        return () => {
	            window.document.removeEventListener("click", handleClickOut, {
	                capture: true,
	            });
	        };
	    }, [ref, callback]);
	}
	// TODO: Return useSelector directly and apply the type without wrapping
	function useTypedSelector(selector) {
	    return useSelector(selector);
	}
	function useActionCreator(actionCreator) {
	    const dispatch = useTypedDispatch();
	    return reactExports.useCallback((...args) => dispatch(actionCreator(...args)), [dispatch, actionCreator]);
	}
	function useTypedDispatch() {
	    // useDispatch does not know about thunks. In theory this should be solvable, but I haven't bothered to figure it out:
	    // https://redux.js.org/usage/usage-with-typescript#type-checking-redux-thunks
	    // @ts-ignore
	    return useDispatch();
	}

	var classnames$1 = {exports: {}};

	/*!
		Copyright (c) 2018 Jed Watson.
		Licensed under the MIT License (MIT), see
		http://jedwatson.github.io/classnames
	*/

	(function (module) {
		/* global define */

		(function () {

			var hasOwn = {}.hasOwnProperty;

			function classNames () {
				var classes = '';

				for (var i = 0; i < arguments.length; i++) {
					var arg = arguments[i];
					if (arg) {
						classes = appendClass(classes, parseValue(arg));
					}
				}

				return classes;
			}

			function parseValue (arg) {
				if (typeof arg === 'string' || typeof arg === 'number') {
					return arg;
				}

				if (typeof arg !== 'object') {
					return '';
				}

				if (Array.isArray(arg)) {
					return classNames.apply(null, arg);
				}

				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
					return arg.toString();
				}

				var classes = '';

				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes = appendClass(classes, key);
					}
				}

				return classes;
			}

			function appendClass (value, newClass) {
				if (!newClass) {
					return value;
				}
			
				if (value) {
					return value + ' ' + newClass;
				}
			
				return value + newClass;
			}

			if (module.exports) {
				classNames.default = classNames;
				module.exports = classNames;
			} else {
				window.classNames = classNames;
			}
		}()); 
	} (classnames$1));

	var classnamesExports = classnames$1.exports;
	var classnames = /*@__PURE__*/getDefaultExportFromCjs(classnamesExports);

	function ResizeTarget(props) {
	    const { currentSize, setWindowSize, widthOnly, ...passThroughProps } = props;
	    const [mouseDown, setMouseDown] = reactExports.useState(false);
	    const [mouseStart, setMouseStart] = reactExports.useState(null);
	    reactExports.useEffect(() => {
	        if (mouseDown === false || mouseStart == null) {
	            return;
	        }
	        const [width, height] = currentSize;
	        const handleMove = (ee) => {
	            const x = getX(ee) - mouseStart.x;
	            const y = getY(ee) - mouseStart.y;
	            const newWidth = Math.max(0, width + Math.round(x / WINDOW_RESIZE_SEGMENT_WIDTH));
	            const newHeight = widthOnly
	                ? width
	                : Math.max(0, height + Math.round(y / WINDOW_RESIZE_SEGMENT_HEIGHT));
	            const newSize = [newWidth, newHeight];
	            props.setWindowSize(newSize);
	        };
	        window.addEventListener("mousemove", handleMove);
	        window.addEventListener("touchmove", handleMove);
	        const handleMouseUp = () => setMouseDown(false);
	        window.addEventListener("mouseup", handleMouseUp);
	        window.addEventListener("touchend", handleMouseUp);
	        return () => {
	            window.removeEventListener("mousemove", handleMove);
	            window.removeEventListener("touchmove", handleMove);
	            window.removeEventListener("mouseup", handleMouseUp);
	            window.removeEventListener("touchend", handleMouseUp);
	        };
	        // We pruposefully close over the props from when the mouse went down
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [mouseStart, mouseDown]);
	    const handleMouseDown = (e) => {
	        setMouseStart({
	            x: getX(e),
	            y: getY(e),
	        });
	        setMouseDown(true);
	    };
	    return (jsxRuntimeExports.jsx("div", { onMouseDown: handleMouseDown, onTouchStart: handleMouseDown, ...passThroughProps }));
	}
	var ResizeTarget$1 = reactExports.memo(ResizeTarget);

	function FocusTarget({ onKeyDown, windowId, children }) {
	    const focusedWindowId = useTypedSelector(getFocusedWindow);
	    const setFocus = useActionCreator(setFocusedWindow);
	    const focusHandler = reactExports.useCallback(() => {
	        if (windowId !== focusedWindowId) {
	            setFocus(windowId);
	        }
	    }, [windowId, focusedWindowId, setFocus]);
	    const [ref, setRef] = reactExports.useState(null);
	    reactExports.useEffect(() => {
	        if (ref == null || onKeyDown == null) {
	            return;
	        }
	        ref.addEventListener("keydown", onKeyDown);
	        return () => ref.removeEventListener("keydown", onKeyDown);
	    }, [onKeyDown, windowId, focusedWindowId, ref]);
	    // It's possible for a child component to gain focus and then become
	    // unmounted. In that case, the browser will return focus to the `<body>`.
	    // In the following hook, use a `MutationObserver` to watch for that behavior
	    // and refocus the containing FocusTarget when it happens.
	    //
	    // I tried a number of other approaches using `focus/blur/focusin/focusout` on
	    // various DOM nodes, and was unable to find a solution which would trigger in
	    // this senario in Firefox. Therefore we use this `MutationObserver` approach.
	    reactExports.useEffect(() => {
	        // Only create the `MutationObserver` within the currently focused target.
	        if (ref == null || windowId !== focusedWindowId) {
	            return;
	        }
	        const observer = new MutationObserver((mutations) => {
	            // In the common case we won't have focused the body, so we can do this
	            // inexpensive check first to avoid calling the more expensive `O(n)`
	            // check of the individual mutations.
	            if (document.activeElement !== document.body) {
	                return;
	            }
	            if (mutations.some((mutation) => mutation.removedNodes.length > 0)) {
	                ref.focus();
	            }
	        });
	        observer.observe(ref, {
	            subtree: true,
	            attributes: false,
	            childList: true,
	        });
	        return () => observer.disconnect();
	    }, [windowId, focusedWindowId, ref]);
	    return (jsxRuntimeExports.jsx("div", { ref: setRef, onPointerDown: focusHandler, onFocus: focusHandler, tabIndex: -1, style: { height: "100%", width: "100%" }, children: children }));
	}

	const ACTIVE_CLASSNAME = "winamp-active";
	const LEFT_MOUSE_NUMBER = 0;
	/**
	 * Renders a `div` with an `.winamp-active` class if the element is being clicked/tapped.
	 *
	 * For now this mimicks the behavior of `:active`, but in the future we will use
	 * this component to mimic Winamp's behavior, which is quite different than
	 * `:active`.
	 *
	 * https://html.spec.whatwg.org/multipage/semantics-other.html#selector-active
	 *
	 * > An element is said to be being actively pointed at while the user indicates
	 * > the element using a pointing device while that pointing device is in the
	 * > "down" state (e.g. for a mouse, between the time the mouse button is pressed
	 * > and the time it is depressed; for a finger in a multitouch environment, while
	 * > the finger is touching the display surface).
	 */
	function WinampButton({ requireClicksOriginateLocally = true, onPointerDown: originalOnPointerDown, className, ...htmlProps }) {
	    const [active, setActive] = reactExports.useState(false);
	    const onPointerDown = reactExports.useCallback((e) => {
	        if (originalOnPointerDown != null) {
	            originalOnPointerDown(e);
	        }
	        // Release the pointer capture
	        // https://w3c.github.io/pointerevents/#implicit-pointer-capture
	        // https://w3c.github.io/pointerevents/#pointer-capture
	        if (!requireClicksOriginateLocally) {
	            // @ts-ignore
	            e.target.releasePointerCapture(e.pointerId);
	        }
	        // We only care about left mouse.
	        // -1 button comes on onPointerEnter so we allow that.
	        if (e.nativeEvent.button !== -1 &&
	            e.nativeEvent.button !== LEFT_MOUSE_NUMBER) {
	            return;
	        }
	        setActive(true);
	        function onRelease(ee) {
	            setActive(false);
	            document.removeEventListener("pointerup", onRelease);
	        }
	        document.addEventListener("pointerup", onRelease);
	    }, [originalOnPointerDown, requireClicksOriginateLocally]);
	    // We watch for events onPointerEnter only when requireClicksOriginateLocally === false
	    // If the pointer enters the WinampButton area, and the pointer button is already down, trigger a PointerDown
	    const onPointerEnter = (e) => {
	        if (e.buttons === 1) {
	            // Emit a CustomEvent pointerup to get the other buttons to release.
	            // Add a special -42 detail value so we can identify this event elsewhere and ignore if needed.
	            document.dispatchEvent(new CustomEvent("pointerup", {
	                detail: -42,
	            }));
	            // Simulate a pointerdown on the current button
	            onPointerDown(e);
	        }
	    };
	    return (jsxRuntimeExports.jsx("div", { ...htmlProps, className: classnames(className, { [ACTIVE_CLASSNAME]: active }), onPointerDown: onPointerDown, onPointerEnter: requireClicksOriginateLocally ? undefined : onPointerEnter }));
	}

	const Text = ({ children }) => {
	    const letters = children.split("");
	    return (jsxRuntimeExports.jsx(reactExports.Fragment, { children: letters.map((letter, i) => (jsxRuntimeExports.jsx("div", { className: `draggable gen-text-letter gen-text-${letter === " " ? "space" : letter.toLowerCase()}` }, i))) }));
	};
	const CHROME_WIDTH = 19;
	const CHROME_HEIGHT = 34;
	// Named export for testing
	const GenWindow = ({ children, title, windowId, onKeyDown }) => {
	    const setWindowSize$1 = useActionCreator(setWindowSize);
	    const closeWindow$1 = useActionCreator(closeWindow);
	    const getWindowPixelSize$1 = useTypedSelector(getWindowPixelSize);
	    const focusedWindow = useTypedSelector(getFocusedWindow);
	    const getWindowSize$1 = useTypedSelector(getWindowSize);
	    const windowSize = getWindowSize$1(windowId);
	    const selected = focusedWindow === windowId;
	    const { width, height } = getWindowPixelSize$1(windowId);
	    return (jsxRuntimeExports.jsx(FocusTarget, { windowId: windowId, onKeyDown: onKeyDown, children: jsxRuntimeExports.jsxs("div", { className: classnames("gen-window", "window", { selected }), style: { width, height }, children: [jsxRuntimeExports.jsxs("div", { className: "gen-top draggable", children: [jsxRuntimeExports.jsx("div", { className: "gen-top-left draggable" }), jsxRuntimeExports.jsx("div", { className: "gen-top-left-fill draggable" }), jsxRuntimeExports.jsx("div", { className: "gen-top-left-end draggable" }), jsxRuntimeExports.jsx("div", { className: "gen-top-title draggable", children: jsxRuntimeExports.jsx(Text, { children: title }) }), jsxRuntimeExports.jsx("div", { className: "gen-top-right-end draggable" }), jsxRuntimeExports.jsx("div", { className: "gen-top-right-fill draggable" }), jsxRuntimeExports.jsx("div", { className: "gen-top-right draggable", children: jsxRuntimeExports.jsx(WinampButton, { className: "gen-close selected", onClick: () => closeWindow$1(windowId) }) })] }), jsxRuntimeExports.jsxs("div", { className: "gen-middle", children: [jsxRuntimeExports.jsx("div", { className: "gen-middle-left draggable", children: jsxRuntimeExports.jsx("div", { className: "gen-middle-left-bottom draggable" }) }), jsxRuntimeExports.jsx("div", { className: "gen-middle-center", children: children({
	                                width: width - CHROME_WIDTH,
	                                height: height - CHROME_HEIGHT,
	                            }) }), jsxRuntimeExports.jsx("div", { className: "gen-middle-right draggable", children: jsxRuntimeExports.jsx("div", { className: "gen-middle-right-bottom draggable" }) })] }), jsxRuntimeExports.jsxs("div", { className: "gen-bottom draggable", children: [jsxRuntimeExports.jsx("div", { className: "gen-bottom-left draggable" }), jsxRuntimeExports.jsx("div", { className: "gen-bottom-right draggable", children: jsxRuntimeExports.jsx(ResizeTarget$1, { currentSize: windowSize, setWindowSize: (size) => setWindowSize$1(windowId, size), id: "gen-resize-target" }) })] })] }) }));
	};

	const TRANSITION_TYPE_DURATIONS = {
	    [TransitionType.DEFAULT]: 2.7,
	    [TransitionType.IMMEDIATE]: 0,
	    [TransitionType.USER_PRESET]: 5.7,
	};
	function Visualizer({ analyser, width, height }) {
	    const visualizerStyle = useTypedSelector(getVisualizerStyle);
	    const playing = useTypedSelector(getMediaIsPlaying);
	    const butterchurn = useTypedSelector(getButterchurn);
	    const trackTitle = useTypedSelector(getCurrentTrackDisplayName);
	    const currentPreset = useTypedSelector(getCurrentPreset);
	    const transitionType = useTypedSelector(getPresetTransitionType);
	    const message = useTypedSelector(getMilkdropMessage);
	    const isEnabledVisualizer = visualizerStyle === VISUALIZERS.MILKDROP;
	    const canvasRef = reactExports.useRef(null);
	    const [visualizer, setVisualizer] = reactExports.useState(null);
	    // Initialize the visualizer
	    reactExports.useEffect(() => {
	        if (canvasRef.current == null || butterchurn == null) {
	            return;
	        }
	        if (visualizer != null) {
	            // Note: The visualizer does not offer anyway to clean itself up. So, we
	            // don't offer any way to recreate it. So, if you swap out the analyser
	            // node, or the canvas, that change won't be respected.
	            return;
	        }
	        const _visualizer = butterchurn.createVisualizer(analyser.context, canvasRef.current, {
	            width,
	            height,
	            meshWidth: 32,
	            meshHeight: 24,
	            pixelRatio: window.devicePixelRatio || 1,
	            // Webamp may support rendering Milkdrop presets from untrusted sources.
	            // By using `onlyUseWASM` here we instruct Butterchurn not to `eval`
	            // JavaScript code included in older Butterchurn preset `.json` files.
	            // https://jordaneldredge.com/blog/speeding-up-winamps-music-visualizer-with-webassembly/#security
	            onlyUseWASM: true,
	        });
	        _visualizer.connectAudio(analyser);
	        setVisualizer(_visualizer);
	    }, [butterchurn, analyser, height, width, visualizer]);
	    // Ensure render size stays up to date
	    reactExports.useEffect(() => {
	        if (visualizer == null) {
	            return;
	        }
	        visualizer.setRendererSize(width, height);
	    }, [visualizer, width, height]);
	    // Load presets when they change
	    const hasLoadedPreset = reactExports.useRef(false);
	    reactExports.useEffect(() => {
	        if (visualizer == null || currentPreset == null) {
	            return;
	        }
	        if (hasLoadedPreset.current) {
	            visualizer.loadPreset(currentPreset, TRANSITION_TYPE_DURATIONS[transitionType]);
	        }
	        else {
	            visualizer.loadPreset(currentPreset, TRANSITION_TYPE_DURATIONS[TransitionType.IMMEDIATE]);
	            hasLoadedPreset.current = true;
	        }
	        // We don't want to trigger the transition if the transition type changes.
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [visualizer, currentPreset]);
	    // Handle title animations
	    reactExports.useEffect(() => {
	        if (visualizer == null || !trackTitle) {
	            return;
	        }
	        visualizer.launchSongTitleAnim(trackTitle);
	    }, [visualizer, trackTitle]);
	    const lastShownMessage = reactExports.useRef(null);
	    reactExports.useEffect(() => {
	        if (visualizer == null || message == null) {
	            return;
	        }
	        if (lastShownMessage.current == null ||
	            message.time > lastShownMessage.current) {
	            lastShownMessage.current = Date.now();
	            visualizer.launchSongTitleAnim(message.text);
	        }
	    }, [visualizer, message]);
	    const shouldAnimate = playing && isEnabledVisualizer;
	    // Kick off the animation loop
	    reactExports.useEffect(() => {
	        if (!shouldAnimate || visualizer == null) {
	            return;
	        }
	        let animationFrameRequest = null;
	        const loop = () => {
	            visualizer.render();
	            animationFrameRequest = window.requestAnimationFrame(loop);
	        };
	        loop();
	        return () => {
	            if (animationFrameRequest != null) {
	                window.cancelAnimationFrame(animationFrameRequest);
	            }
	        };
	    }, [visualizer, shouldAnimate]);
	    return (jsxRuntimeExports.jsx("canvas", { height: height, width: width, style: {
	            height: "100%",
	            width: "100%",
	            display: isEnabledVisualizer ? "block" : "none",
	        }, ref: canvasRef }));
	}

	const Background$1 = (props) => {
	    const { innerRef } = props;
	    return (jsxRuntimeExports.jsx("div", { ref: innerRef, className: "draggable", style: {
	            // This color will be used until Butterchurn is loaded
	            backgroundColor: "#000",
	            position: "absolute",
	            top: 0,
	            bottom: 0,
	            left: 0,
	            right: 0,
	            height: "100%",
	            width: "100%",
	        }, tabIndex: 0, children: props.children }));
	};

	const ENTRY_HEIGHT = 14;
	const HEIGHT_PADDING = 15;
	const WIDTH_PADDING = 20;
	const LOADING_STYLE = {
	    position: "absolute",
	    top: 0,
	    left: 0,
	    color: "white",
	    background: "rgba(0.33, 0.33, 0.33, 0.33)",
	};
	const OUTER_WRAPPER_STYLE = {
	    position: "absolute",
	    top: 0,
	    left: 0,
	    padding: "15px 10px 0 10px",
	};
	const INNER_WRAPPER_STYLE = {
	    display: "inline-block",
	    whiteSpace: "nowrap",
	    overflow: "hidden",
	    background: "rgba(0, 0, 0, 0.815)",
	    fontSize: "12px",
	};
	function presetIndexFromListIndex(listIndex) {
	    return listIndex - 1;
	}
	function listIndexFromPresetIndex(listIndex) {
	    return listIndex + 1;
	}
	function PresetOverlay({ height, width }) {
	    const presetKeys = useTypedSelector(getPresetNames);
	    const currentPresetIndex = useTypedSelector(getCurrentPresetIndex);
	    const requestPresetAtIndex$1 = useActionCreator(requestPresetAtIndex);
	    const togglePresetOverlay$1 = useActionCreator(togglePresetOverlay);
	    const appendPresetFileList$1 = useActionCreator(appendPresetFileList);
	    const unmountedRef = useUnmountedRef();
	    const [selectedListIndex, setSelectedListIndex] = reactExports.useState(() => {
	        if (currentPresetIndex != null) {
	            return listIndexFromPresetIndex(currentPresetIndex);
	        }
	        return 0;
	    });
	    // Number of presets, plus one for the "Load Local Directory" option, minus
	    // one to convert a length to an index.
	    const maxListIndex = presetKeys.length; // - 1 + 1;
	    const renderList = reactExports.useCallback(() => {
	        const maxVisibleRows = Math.floor((height - HEIGHT_PADDING) / ENTRY_HEIGHT);
	        const rowsToShow = Math.floor(maxVisibleRows * 0.75); // Only fill 3/4 of the screen.
	        const [startIndex, endIndex] = getRangeCenteredOnIndex(maxListIndex + 1, // Add one to convert an index to a length
	        rowsToShow, selectedListIndex);
	        const presetElms = [];
	        for (let i = startIndex; i <= endIndex; i++) {
	            const presetIndex = presetIndexFromListIndex(i);
	            const isSelected = i === selectedListIndex;
	            const isCurrent = presetIndex === currentPresetIndex;
	            let color;
	            if (isSelected) {
	                color = isCurrent ? "#FFCC22" : "#FF5050";
	            }
	            else {
	                color = isCurrent ? "#CCFF03" : "#CCCCCC";
	            }
	            presetElms.push(jsxRuntimeExports.jsx("li", { style: { color, lineHeight: `${ENTRY_HEIGHT}px` }, children: i === 0 ? "Load Local Directory" : presetKeys[presetIndex] }, i));
	        }
	        return presetElms;
	    }, [currentPresetIndex, height, maxListIndex, presetKeys, selectedListIndex]);
	    const loadLocalDir = reactExports.useCallback(async () => {
	        const fileReferences = await promptForFileReferences({ directory: true });
	        if (unmountedRef.current) {
	            return;
	        }
	        appendPresetFileList$1(fileReferences);
	    }, [appendPresetFileList$1, unmountedRef]);
	    const handleFocusedKeyboardInput = reactExports.useCallback((e) => {
	        switch (e.keyCode) {
	            case 38: // up arrow
	                setSelectedListIndex((value) => Math.max(value - 1, 0));
	                e.stopPropagation();
	                break;
	            case 40: // down arrow
	                setSelectedListIndex((value) => Math.min(value + 1, maxListIndex));
	                e.stopPropagation();
	                break;
	            case 13: // enter
	                if (selectedListIndex === 0) {
	                    loadLocalDir();
	                }
	                else {
	                    requestPresetAtIndex$1(presetIndexFromListIndex(selectedListIndex), TransitionType.DEFAULT, true);
	                }
	                e.stopPropagation();
	                break;
	            case 27: // escape
	                togglePresetOverlay$1();
	                e.stopPropagation();
	                break;
	        }
	    }, [
	        loadLocalDir,
	        maxListIndex,
	        requestPresetAtIndex$1,
	        selectedListIndex,
	        togglePresetOverlay$1,
	    ]);
	    const handleNode = reactExports.useCallback((node) => {
	        if (node != null && document.activeElement !== node) {
	            node.focus();
	        }
	    }, []);
	    if (presetKeys == null) {
	        return (jsxRuntimeExports.jsx("div", { style: LOADING_STYLE, children: jsxRuntimeExports.jsx("span", { children: "Loading presets" }) }));
	    }
	    return (jsxRuntimeExports.jsx("div", { ref: handleNode, tabIndex: -1, style: OUTER_WRAPPER_STYLE, onKeyDown: handleFocusedKeyboardInput, children: jsxRuntimeExports.jsx("div", { style: {
	                ...INNER_WRAPPER_STYLE,
	                width: width - 20 - WIDTH_PADDING,
	                maxHeight: height - HEIGHT_PADDING,
	            }, children: jsxRuntimeExports.jsx("ul", { style: { listStyleType: "none", padding: 0, margin: 0 }, children: renderList() }) }) }));
	}
	// Find a tuple `[startIndex, endIndex]` representing start/end indexes into an
	// array of length `length`, that descripe a range of size up to `rangeSize`
	// where a best effort is made to center `indexToCenter`.
	function getRangeCenteredOnIndex(length, maxRangeSize, indexToCenter) {
	    const rangeSize = Math.min(length, maxRangeSize);
	    const halfRangeSize = Math.floor(rangeSize / 2);
	    const idealStartIndex = indexToCenter - halfRangeSize;
	    const startIndex = clamp(idealStartIndex, 0, length - rangeSize);
	    const endIndex = startIndex + rangeSize - 1;
	    return [startIndex, endIndex];
	}

	function suppress(e) {
	    e.stopPropagation();
	    e.preventDefault();
	    e.dataTransfer.dropEffect = "link";
	    e.dataTransfer.effectAllowed = "link";
	}
	function DropTarget(props) {
	    const { 
	    // eslint-disable-next-line no-shadow, no-unused-vars
	    handleDrop, windowId, onWheelActive, ...passThroughProps } = props;
	    const divRef = reactExports.useRef(null);
	    const droppedFiles$1 = useActionCreator(droppedFiles);
	    // Register onWheelActive as a non-passive event handler
	    reactExports.useEffect(() => {
	        const element = divRef.current;
	        if (!element || !onWheelActive) {
	            return;
	        }
	        const handleWheel = (e) => {
	            // Convert native WheelEvent to React.WheelEvent
	            onWheelActive(e);
	        };
	        element.addEventListener("wheel", handleWheel, { passive: false });
	        return () => {
	            element.removeEventListener("wheel", handleWheel);
	        };
	    }, [onWheelActive]);
	    const onDrop = reactExports.useCallback((e) => {
	        suppress(e);
	        droppedFiles$1(e, windowId);
	        // TODO: We could probably move this coordinate logic into the playlist.
	        // I think that's the only place it gets used.
	        const { currentTarget } = e;
	        if (!(currentTarget instanceof Element)) {
	            return;
	        }
	        const { left: x, top: y } = currentTarget.getBoundingClientRect();
	        handleDrop(e, { x, y });
	    }, [handleDrop, droppedFiles$1, windowId]);
	    return (jsxRuntimeExports.jsx("div", { ref: divRef, ...passThroughProps, onDragStart: suppress, onDragEnter: suppress, onDragOver: suppress, onDrop: onDrop }));
	}

	const Portal = (props) => {
	    const node = reactExports.useMemo(() => {
	        const div = document.createElement("div");
	        div.id = "webamp-context-menu";
	        div.style.position = "absolute";
	        div.style.top = "0";
	        div.style.left = "0";
	        div.style.zIndex = String(props.zIndex + 1);
	        return div;
	    }, [props.zIndex]);
	    reactExports.useEffect(() => {
	        document.body.appendChild(node);
	        return () => {
	            document.body.removeChild(node);
	        };
	    }, [node]);
	    const style = {
	        top: props.top,
	        left: props.left,
	        position: "absolute",
	    };
	    return reactDomExports.createPortal(jsxRuntimeExports.jsx("div", { style: style, children: props.children }), node);
	};
	const Hr = () => (jsxRuntimeExports.jsx("li", { className: "hr", children: jsxRuntimeExports.jsx("hr", {}) }));
	const Parent = ({ children, label }) => (jsxRuntimeExports.jsxs("li", { className: "parent", children: [jsxRuntimeExports.jsx("ul", { children: children }), label] }));
	const LinkNode = (props) => (jsxRuntimeExports.jsx("li", { children: jsxRuntimeExports.jsx("a", { ...props, children: props.label }) }));
	const Node = (props) => {
	    const { label, checked, className = "", ...passThroughProps } = props;
	    return (jsxRuntimeExports.jsx("li", { className: classnames(className, { checked }), ...passThroughProps, children: label }));
	};
	function ContextMenu({ children, offsetTop, offsetLeft, top, bottom, selected, }) {
	    const zIndex = useTypedSelector(getZIndex);
	    if (!selected) {
	        return null;
	    }
	    return (jsxRuntimeExports.jsx(Portal, { top: offsetTop, left: offsetLeft, zIndex: zIndex, children: jsxRuntimeExports.jsx("ul", { className: classnames("context-menu", { top, bottom }), children: children }) }));
	}

	// Trigger a context menu at the user's cursor position when the user right
	// clicks within this component.
	// For a component that triggers relative to a given component when the user
	// left-clicks see `<ContextMenuTarget />`.
	// TODO: Consider using nested contexts to ensure we don't ever have multiple
	// non-nested context menus open at a time.
	function ContextMenuWraper({ children, renderContents, ...passThroughProps }) {
	    const [openPosition, setOpenPosition] = reactExports.useState(null);
	    const closeMenu = reactExports.useCallback(() => {
	        setOpenPosition(null);
	    }, []);
	    const handleGlobalClick = reactExports.useCallback((e) => {
	        if (e.button !== 2) {
	            closeMenu();
	        }
	    }, [closeMenu]);
	    const handleRightClick = reactExports.useCallback((e) => {
	        const { pageX, pageY } = e;
	        // TODO: We could do an initial render to see if the menu fits here
	        // and do a second render if it does not.
	        setOpenPosition({ x: pageX, y: pageY });
	        e.preventDefault();
	        e.stopPropagation();
	    }, []);
	    // Add click-away listeners when window is open
	    reactExports.useEffect(() => {
	        if (openPosition == null) {
	            return;
	        }
	        document.addEventListener("click", handleGlobalClick);
	        document.body.addEventListener("contextmenu", closeMenu);
	        return () => {
	            document.removeEventListener("click", handleGlobalClick);
	            document.body.removeEventListener("contextmenu", closeMenu);
	        };
	    }, [openPosition, closeMenu, handleGlobalClick]);
	    return (jsxRuntimeExports.jsxs("div", { onContextMenu: handleRightClick, style: { width: "100%", height: "100%" }, ...passThroughProps, children: [jsxRuntimeExports.jsx(ContextMenu, { selected: openPosition != null, offsetTop: openPosition?.y ?? 0, offsetLeft: openPosition?.x ?? 0, children: renderContents() }), children] }));
	}

	const MilkdropContextMenu = (props) => {
	    const desktop = useTypedSelector(getMilkdropDesktopEnabled);
	    const closeWindow$1 = useActionCreator(closeWindow);
	    const toggleDesktop = useActionCreator(toggleMilkdropDesktop);
	    const toggleFullscreen = useActionCreator(toggleMilkdropFullscreen);
	    return (jsxRuntimeExports.jsx(ContextMenuWraper, { renderContents: () => {
	            return (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [fscreen.fullscreenEnabled && (jsxRuntimeExports.jsx(Node, { onClick: toggleFullscreen, label: "Fullscreen", hotkey: "Alt+Enter" })), jsxRuntimeExports.jsx(Node, { onClick: toggleDesktop, checked: desktop, label: "Desktop Mode", hotkey: "Alt+D" }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { onClick: () => closeWindow$1(WINDOWS.MILKDROP), label: "Quit" })] }));
	        }, children: props.children }));
	};

	const Desktop = reactExports.memo(({ children }) => {
	    const [desktopNode] = reactExports.useState(() => document.createElement("div"));
	    reactExports.useEffect(() => {
	        desktopNode.classList.add("webamp-desktop");
	        document.body.appendChild(desktopNode);
	        return () => {
	            document.body.removeChild(desktopNode);
	        };
	    }, [desktopNode]);
	    return ReactDOM$2.createPortal(children, desktopNode);
	});

	const MILLISECONDS_BETWEEN_PRESET_TRANSITIONS = 15000;
	function useKeyHandler() {
	    const trackTitle = useTypedSelector(getCurrentTrackDisplayName);
	    const selectNextPreset$1 = useActionCreator(selectNextPreset);
	    const selectPreviousPreset$1 = useActionCreator(selectPreviousPreset);
	    const toggleRandomize = useActionCreator(toggleRandomizePresets);
	    const togglePresetOverlay$1 = useActionCreator(togglePresetOverlay);
	    const scheduleMilkdropMessage$1 = useActionCreator(scheduleMilkdropMessage);
	    const toggleCycling = useActionCreator(togglePresetCycling);
	    // Handle keyboard events
	    return reactExports.useCallback((e) => {
	        switch (e.keyCode) {
	            case 32: // spacebar
	                selectNextPreset$1();
	                break;
	            case 8: // backspace
	                selectPreviousPreset$1(TransitionType.IMMEDIATE);
	                break;
	            case 72: // H
	                selectNextPreset$1(TransitionType.IMMEDIATE);
	                break;
	            case 82: // R
	                toggleRandomize();
	                break;
	            case 76: // L
	                togglePresetOverlay$1();
	                e.stopPropagation();
	                break;
	            case 84: // T
	                if (trackTitle != null) {
	                    scheduleMilkdropMessage$1(trackTitle);
	                }
	                e.stopPropagation();
	                break;
	            case 145: // scroll lock
	            case 125: // F14 (scroll lock for OS X)
	                toggleCycling();
	                break;
	        }
	    }, [
	        scheduleMilkdropMessage$1,
	        selectNextPreset$1,
	        selectPreviousPreset$1,
	        toggleCycling,
	        togglePresetOverlay$1,
	        toggleRandomize,
	        trackTitle,
	    ]);
	}
	function Milkdrop({ analyser }) {
	    const desktop = useTypedSelector(getMilkdropDesktopEnabled);
	    const fullscreen = useTypedSelector(getMilkdropFullscreenEnabled);
	    const overlay = useTypedSelector(getPresetOverlayOpen);
	    const presetsAreCycling = useTypedSelector(getPresetsAreCycling);
	    const currentPresetIndex = useTypedSelector(getCurrentPresetIndex);
	    const mediaIsPlaying = useTypedSelector(getMediaIsPlaying);
	    const toggleFullscreen = useActionCreator(toggleMilkdropFullscreen);
	    const selectNextPreset$1 = useActionCreator(selectNextPreset);
	    const handlePresetDrop$1 = useActionCreator(handlePresetDrop);
	    const setFullscreen = useActionCreator(setMilkdropFullscreen);
	    const handleKeyDown = useKeyHandler();
	    // Cycle presets
	    reactExports.useEffect(() => {
	        if (!presetsAreCycling || !mediaIsPlaying) {
	            return;
	        }
	        const intervalId = setInterval(selectNextPreset$1, MILLISECONDS_BETWEEN_PRESET_TRANSITIONS);
	        return () => clearInterval(intervalId);
	    }, [presetsAreCycling, currentPresetIndex, mediaIsPlaying, selectNextPreset$1]);
	    const screenSize = useScreenSize();
	    const windowSize = useWindowSize();
	    const toggleFullScreenIfEnabled = reactExports.useCallback(() => {
	        if (fscreen.fullscreenEnabled) {
	            toggleFullscreen();
	        }
	    }, [toggleFullscreen]);
	    if (desktop) {
	        return (jsxRuntimeExports.jsx(Desktop, { children: jsxRuntimeExports.jsx(MilkdropContextMenu, { children: jsxRuntimeExports.jsx(Visualizer, { ...windowSize, analyser: analyser }) }) }));
	    }
	    return (jsxRuntimeExports.jsx(GenWindow, { title: "Milkdrop", windowId: WINDOWS.MILKDROP, onKeyDown: handleKeyDown, children: (genWindowSize) => {
	            const size = fullscreen ? screenSize : genWindowSize;
	            return (jsxRuntimeExports.jsx(MilkdropContextMenu, { children: jsxRuntimeExports.jsx(Background$1, { children: jsxRuntimeExports.jsxs(DropTarget, { windowId: WINDOWS.MILKDROP, handleDrop: handlePresetDrop$1, children: [overlay && jsxRuntimeExports.jsx(PresetOverlay, { ...size }), jsxRuntimeExports.jsx(FullScreen, { enabled: fullscreen, onChange: setFullscreen, children: jsxRuntimeExports.jsx("div", { onDoubleClick: toggleFullScreenIfEnabled, children: jsxRuntimeExports.jsx(Visualizer, { ...size, analyser: analyser }) }) })] }) }) }));
	        } }));
	}

	const PlaybackContextMenu = () => {
	    const previous$1 = useActionCreator(previous);
	    const play$1 = useActionCreator(play);
	    const pause$1 = useActionCreator(pause);
	    const stop$1 = useActionCreator(stop);
	    const next$1 = useActionCreator(next);
	    const seekForward$1 = useActionCreator(seekForward);
	    const seekBackward$1 = useActionCreator(seekBackward);
	    const nextN$1 = useActionCreator(nextN);
	    return (jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [jsxRuntimeExports.jsx(Node, { label: "Previous", hotkey: "Z", onClick: previous$1 }), jsxRuntimeExports.jsx(Node, { label: "Play", hotkey: "X", onClick: play$1 }), jsxRuntimeExports.jsx(Node, { label: "Pause", hotkey: "C", onClick: pause$1 }), jsxRuntimeExports.jsx(Node, { label: "Stop", hotkey: "V", onClick: stop$1 }), jsxRuntimeExports.jsx(Node, { label: "Next", hotkey: "B", onClick: next$1 }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { label: "Back 5 seconds", hotkey: "Left", onClick: () => seekBackward$1(5) }), jsxRuntimeExports.jsx(Node, { label: "Fwd 5 seconds", hotkey: "Right", onClick: () => seekForward$1(5) }), jsxRuntimeExports.jsx(Node, { label: "10 tracks back", hotkey: "Num. 1", onClick: () => nextN$1(-10) }), jsxRuntimeExports.jsx(Node, { label: "10 tracks fwd", hotkey: "Num. 3", onClick: () => nextN$1(10) })] }));
	};

	const SkinContextMenu = () => {
	    const loadDefaultSkin$1 = useActionCreator(loadDefaultSkin);
	    const openSkinFileDialog$1 = useActionCreator(openSkinFileDialog);
	    const setSkin = useActionCreator(setSkinFromUrl);
	    const availableSkins = useTypedSelector(getAvaliableSkins);
	    return (jsxRuntimeExports.jsxs(Parent, { label: "Skins", children: [jsxRuntimeExports.jsx(Node, { onClick: openSkinFileDialog$1, label: "Load Skin..." }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { onClick: loadDefaultSkin$1, label: "<Base Skin>" }), availableSkins.map((skin) => (jsxRuntimeExports.jsx(Node, { onClick: () => setSkin(skin.url), label: skin.name }, skin.url)))] }));
	};

	const OptionsContextMenu = () => {
	    const toggleTimeMode$1 = useActionCreator(toggleTimeMode);
	    const toggleDoubleSizeMode$1 = useActionCreator(toggleDoubleSizeMode);
	    const toggleRepeat$1 = useActionCreator(toggleRepeat);
	    const toggleShuffle$1 = useActionCreator(toggleShuffle);
	    const doubled = useTypedSelector(getDoubled);
	    const timeMode = useTypedSelector(getTimeMode);
	    const repeat = useTypedSelector(getRepeat);
	    const shuffle = useTypedSelector(getShuffle);
	    return (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(SkinContextMenu, {}), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { label: "Time elapsed", hotkey: "(Ctrl+T toggles)", onClick: toggleTimeMode$1, checked: timeMode === TIME_MODE.ELAPSED }), jsxRuntimeExports.jsx(Node, { label: "Time remaining", hotkey: "(Ctrl+T toggles)", onClick: toggleTimeMode$1, checked: timeMode === TIME_MODE.REMAINING }), jsxRuntimeExports.jsx(Node, { label: "Double Size", hotkey: "Ctrl+D", onClick: toggleDoubleSizeMode$1, checked: doubled }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { label: "Repeat", hotkey: "R", onClick: toggleRepeat$1, checked: repeat }), jsxRuntimeExports.jsx(Node, { label: "Shuffle", hotkey: "S", onClick: toggleShuffle$1, checked: shuffle })] }));
	};

	const MainContextMenu = reactExports.memo(({ filePickers }) => {
	    const networkConnected = useTypedSelector(getNetworkConnected);
	    const genWindows = useTypedSelector(getGenWindows);
	    const close$1 = useActionCreator(close);
	    const openMediaFileDialog$1 = useActionCreator(openMediaFileDialog);
	    const loadMediaFiles$1 = useActionCreator(loadMediaFiles);
	    const toggleWindow$1 = useActionCreator(toggleWindow);
	    const menuOpened = useActionCreator(() => ({
	        type: "MAIN_CONTEXT_MENU_OPENED",
	    }));
	    const isMilkdropEnabled = useTypedSelector(getMilkdropEnabled);
	    reactExports.useEffect(() => {
	        menuOpened();
	    }, [menuOpened]);
	    return (jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [jsxRuntimeExports.jsx(LinkNode, { href: "https://webamp.org/about", target: "_blank", label: "Webamp..." }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsxs(Parent, { label: "Play", children: [jsxRuntimeExports.jsx(Node, { onClick: openMediaFileDialog$1, label: "File...", hotkey: "L" }), filePickers != null &&
	                        filePickers.map((picker, i) => (networkConnected || !picker.requiresNetwork) && (jsxRuntimeExports.jsx(Node, { onClick: async () => {
	                                let files;
	                                try {
	                                    files = await picker.filePicker();
	                                }
	                                catch (e) {
	                                    console.error("Error loading from file picker", e);
	                                }
	                                loadMediaFiles$1(files || [], LOAD_STYLE.PLAY);
	                            }, label: picker.contextMenuName }, i)))] }), jsxRuntimeExports.jsx(Hr, {}), Object.keys(genWindows).map((i) => {
	                if (i === WINDOWS.MILKDROP && !isMilkdropEnabled) {
	                    return null;
	                }
	                return (jsxRuntimeExports.jsx(Node, { label: genWindows[i].title, checked: genWindows[i].open, onClick: () => toggleWindow$1(i), hotkey: genWindows[i].hotkey }, i));
	            }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(SkinContextMenu, {}), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Parent, { label: "Options", children: jsxRuntimeExports.jsx(OptionsContextMenu, {}) }), jsxRuntimeExports.jsx(Parent, { label: "Playback", children: jsxRuntimeExports.jsx(PlaybackContextMenu, {}) }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { onClick: close$1, label: "Exit" })] }));
	});

	const abuts = (a, b) => {
	    // TODO: This is kinda a hack. They should really be touching, not just within snapping distance.
	    // Also, overlapping should not count.
	    const wouldMoveTo = snap(a, b);
	    return wouldMoveTo.x !== undefined || wouldMoveTo.y !== undefined;
	};
	function useHandleMouseDown(propsWindows) {
	    const windowsInfo = useTypedSelector(getWindowsInfo);
	    const getWindowHidden$1 = useTypedSelector(getWindowHidden);
	    const browserWindowSize = useTypedSelector(getBrowserWindowSize);
	    const updateWindowPositions$1 = useActionCreator(updateWindowPositions);
	    const [draggingState, setDraggingState] = reactExports.useState(null);
	    // When the mouse is down, attach a listener to track mouse move events.
	    reactExports.useEffect(() => {
	        if (draggingState == null) {
	            return;
	        }
	        const { boundingBox, moving, stationary, mouseStart } = draggingState;
	        const handleMouseMove = (ee) => {
	            const proposedDiff = {
	                x: getX(ee) - mouseStart.x,
	                y: getY(ee) - mouseStart.y,
	            };
	            const proposedWindows = moving.map((node) => ({
	                ...node,
	                ...applyDiff(node, proposedDiff),
	            }));
	            const proposedBox = {
	                ...boundingBox,
	                ...applyDiff(boundingBox, proposedDiff),
	            };
	            const snapDiff = snapDiffManyToMany(proposedWindows, stationary);
	            const withinDiff = snapWithinDiff(proposedBox, browserWindowSize);
	            const finalDiff = applyMultipleDiffs(proposedDiff, snapDiff, withinDiff);
	            const windowPositionDiff = {};
	            moving.forEach((w) => {
	                windowPositionDiff[w.key] = applyDiff(w, finalDiff);
	            });
	            updateWindowPositions$1(windowPositionDiff, false);
	        };
	        function handleMouseUp() {
	            setDraggingState(null);
	        }
	        window.addEventListener("mouseup", handleMouseUp);
	        window.addEventListener("touchend", handleMouseUp);
	        window.addEventListener("mousemove", handleMouseMove, { passive: false });
	        window.addEventListener("touchmove", handleMouseMove, { passive: false });
	        return () => {
	            window.removeEventListener("mousemove", handleMouseMove);
	            window.removeEventListener("touchmove", handleMouseMove);
	            window.removeEventListener("mouseup", handleMouseUp);
	            window.removeEventListener("touchend", handleMouseUp);
	        };
	    }, [browserWindowSize, draggingState, updateWindowPositions$1]);
	    // Mouse down handler
	    return reactExports.useCallback((key, e) => {
	        if (!e.target.classList.contains("draggable")) {
	            return;
	        }
	        const x = getX(e);
	        const y = getY(e);
	        if (getWindowHidden$1(key)) {
	            // The user may be clicking on full screen Milkdrop.
	            return;
	        }
	        const windows = windowsInfo.filter((w) => propsWindows[w.key] != null && !getWindowHidden$1(w.key));
	        const targetNode = windows.find((node) => node.key === key);
	        if (targetNode == null) {
	            throw new Error(`Tried to move a node that does not exist: ${key}`);
	        }
	        let movingSet = new Set([targetNode]);
	        // Only the main window brings other windows along.
	        if (key === "main") {
	            const findAllConnected = traceConnection(abuts);
	            movingSet = findAllConnected(windows, targetNode);
	        }
	        const stationary = windows.filter((w) => !movingSet.has(w));
	        const moving = Array.from(movingSet);
	        const mouseStart = { x, y };
	        const boundingBox$1 = boundingBox(moving);
	        setDraggingState({ boundingBox: boundingBox$1, moving, stationary, mouseStart });
	    }, [getWindowHidden$1, propsWindows, windowsInfo]);
	}
	function WindowManager({ windows: propsWindows }) {
	    const windowsInfo = useTypedSelector(getWindowsInfo);
	    const setFocusedWindow$1 = useActionCreator(setFocusedWindow);
	    const handleMouseDown = useHandleMouseDown(propsWindows);
	    const windows = windowsInfo.filter((w) => propsWindows[w.key]);
	    const onBlur = reactExports.useCallback(
	    // I give up on trying to type things with `relatedTarget`.
	    (e) => {
	        const { currentTarget, relatedTarget } = e;
	        if (currentTarget === relatedTarget ||
	            currentTarget.contains(relatedTarget)) {
	            return;
	        }
	        setFocusedWindow$1(null);
	    }, [setFocusedWindow$1]);
	    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: windows.map((w) => (jsxRuntimeExports.jsx("div", { onBlur: onBlur, onMouseDown: (e) => {
	                handleMouseDown(w.key, e);
	            }, onTouchStart: (e) => {
	                handleMouseDown(w.key, e);
	            }, style: {
	                position: "absolute",
	                top: 0,
	                left: 0,
	                transform: `translate(${w.x}px, ${w.y}px)`,
	                touchAction: "none",
	            }, children: propsWindows[w.key] }, w.key))) }));
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */

	function basePropertyOf$1(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	var _basePropertyOf = basePropertyOf$1;

	var basePropertyOf = _basePropertyOf;

	/** Used to map Latin Unicode letters to basic Latin letters. */
	var deburredLetters = {
	  // Latin-1 Supplement block.
	  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	  '\xc7': 'C',  '\xe7': 'c',
	  '\xd0': 'D',  '\xf0': 'd',
	  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	  '\xd1': 'N',  '\xf1': 'n',
	  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	  '\xc6': 'Ae', '\xe6': 'ae',
	  '\xde': 'Th', '\xfe': 'th',
	  '\xdf': 'ss',
	  // Latin Extended-A block.
	  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	  '\u0134': 'J',  '\u0135': 'j',
	  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	  '\u0174': 'W',  '\u0175': 'w',
	  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	  '\u0132': 'IJ', '\u0133': 'ij',
	  '\u0152': 'Oe', '\u0153': 'oe',
	  '\u0149': "'n", '\u017f': 's'
	};

	/**
	 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	 * letters to basic Latin letters.
	 *
	 * @private
	 * @param {string} letter The matched letter to deburr.
	 * @returns {string} Returns the deburred letter.
	 */
	var deburrLetter$1 = basePropertyOf(deburredLetters);

	var _deburrLetter = deburrLetter$1;

	/** Detect free variable `global` from Node.js. */

	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal$1;

	var freeGlobal = _freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$1 = freeGlobal || freeSelf || Function('return this')();

	var _root = root$1;

	var root = _root;

	/** Built-in value references. */
	var Symbol$4 = root.Symbol;

	var _Symbol = Symbol$4;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */

	function arrayMap$1(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap$1;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */

	var isArray$3 = Array.isArray;

	var isArray_1 = isArray$3;

	var Symbol$3 = _Symbol;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$1.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag$1;

	/** Used for built-in method references. */

	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$2(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString$2;

	var Symbol$2 = _Symbol,
	    getRawTag = _getRawTag,
	    objectToString$1 = _objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$1(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString$1(value);
	}

	var _baseGetTag = baseGetTag$1;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */

	function isObjectLike$1(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike$1;

	var baseGetTag = _baseGetTag,
	    isObjectLike = isObjectLike_1;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$1(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol$1;

	var Symbol$1 = _Symbol,
	    arrayMap = _arrayMap,
	    isArray$2 = isArray_1,
	    isSymbol = isSymbol_1;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString$1(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray$2(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString$1) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	var _baseToString = baseToString$1;

	var baseToString = _baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$2(value) {
	  return value == null ? '' : baseToString(value);
	}

	var toString_1 = toString$2;

	var deburrLetter = _deburrLetter,
	    toString$1 = toString_1;

	/** Used to match Latin Unicode letters (excluding mathematical operators). */
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	/** Used to compose unicode character classes. */
	var rsComboMarksRange = '\\u0300-\\u036f',
	    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange = '\\u20d0-\\u20ff',
	    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

	/** Used to compose unicode capture groups. */
	var rsCombo = '[' + rsComboRange + ']';

	/**
	 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	 */
	var reComboMark = RegExp(rsCombo, 'g');

	/**
	 * Deburrs `string` by converting
	 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	 * letters to basic Latin letters and removing
	 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to deburr.
	 * @returns {string} Returns the deburred string.
	 * @example
	 *
	 * _.deburr('déjà vu');
	 * // => 'deja vu'
	 */
	function deburr(string) {
	  string = toString$1(string);
	  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}

	var deburr_1 = deburr;

	var deburr$1 = /*@__PURE__*/getDefaultExportFromCjs(deburr_1);

	const characterClassName = (char) => `character-${deburr$1(char.toString()).toLowerCase().charCodeAt(0)}`;
	const Character = reactExports.memo(({ children: char, className, ...passThrough }) => {
	    return (jsxRuntimeExports.jsx("span", { ...passThrough, className: `${className || ""} character ${characterClassName(char)}`, children: char }));
	});

	// Sigh. When the display is blinking (say when it's paused) we need to
	// alternate between the actual character and the space character. Not
	// Possible to do that in pure CSS with the background being dynamically generated.
	// All "space" characters is also how Winamp renders no content.
	const Background = () => (jsxRuntimeExports.jsx(reactExports.Fragment, { children: [1, 7, 12, 20, 25].map((left, i) => (jsxRuntimeExports.jsx(Character, { style: { left }, className: "background-character", children: " " }, i))) }));
	const MiniTime = () => {
	    const status = useTypedSelector(getMediaStatus);
	    const duration = useTypedSelector(getDuration);
	    const timeElapsed = useTypedSelector(getTimeElapsed);
	    const timeMode = useTypedSelector(getTimeMode);
	    const toggle = useActionCreator(toggleTimeMode);
	    let seconds = null;
	    // TODO: Clean this up: If stopped, just render the background, rather than
	    // rendering spaces twice.
	    if (status !== MEDIA_STATUS.STOPPED && duration != null) {
	        seconds =
	            timeMode === TIME_MODE.ELAPSED ? timeElapsed : duration - timeElapsed;
	    }
	    const timeObj = getTimeObj(seconds);
	    const showMinus = timeMode === TIME_MODE.REMAINING && status !== MEDIA_STATUS.STOPPED;
	    return (jsxRuntimeExports.jsxs("div", { onClick: toggle, className: classnames("mini-time", "countdown", {
	            blinking: status === MEDIA_STATUS.PAUSED,
	        }), children: [jsxRuntimeExports.jsx(Background, {}), jsxRuntimeExports.jsx(Character, { style: { left: 1 }, children: showMinus ? "-" : " " }), jsxRuntimeExports.jsx(Character, { style: { left: 7 }, children: timeObj.minutesFirstDigit }), jsxRuntimeExports.jsx(Character, { style: { left: 12 }, children: timeObj.minutesSecondDigit }), jsxRuntimeExports.jsx(Character, { style: { left: 20 }, children: timeObj.secondsFirstDigit }), jsxRuntimeExports.jsx(Character, { style: { left: 25 }, children: timeObj.secondsSecondDigit })] }));
	};

	// Winamp has a strange behavior for the buttons at the top of the main window.
	// It shows through to the main background sprite until the first time that it's
	// clicked, and then it shows the dedicated undepressed sprite thereafter.
	// This component is an abstraction that tracks if a div has ever been clicked.
	// Look in `skinSelectors` for CSS selectors that look like `#some-id.clicked`
	// for examples of this functionality in use.
	function ClickedDiv(props) {
	    const [clicked, setClicked] = reactExports.useState(false);
	    function handlePointerDown(e) {
	        setClicked(true);
	        if (props.onPointerDown) {
	            props.onPointerDown(e);
	        }
	    }
	    return (jsxRuntimeExports.jsx(WinampButton, { ...props, className: classnames(props.className, { clicked }), onPointerDown: handlePointerDown }));
	}

	function getNodeOffset(node) {
	    if (node == null) {
	        return { top: 0, left: 0 };
	    }
	    const rect = node.getBoundingClientRect();
	    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
	    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
	    return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
	}
	// Trigger a context menu relative to the child element when the user
	// left-clicks on the child.
	//
	// For a component that triggers relative to the user's cursor on right-click
	// see `<ContextMenuWrapper />`.
	function ContextMenuTarget(props) {
	    const handleNode = reactExports.useRef(null);
	    const [selected, setSelected] = reactExports.useState(false);
	    reactExports.useEffect(() => {
	        if (!selected) {
	            return;
	        }
	        function handleGlobalClick(e) {
	            if (selected &&
	                // Typescript does not believe that these click events are always fired on DOM nodes.
	                e.target instanceof Element &&
	                selected &&
	                // Not sure how, but it's possible for this to get called when handleNode is null/undefined.
	                // https://sentry.io/share/issue/2066cd79f21e4f279791319f4d2ea35d/
	                handleNode.current &&
	                !handleNode.current.contains(e.target)) {
	                setSelected(false);
	            }
	        }
	        document.addEventListener("click", handleGlobalClick);
	        return () => {
	            document.removeEventListener("click", handleGlobalClick);
	        };
	    }, [selected]);
	    const offset = reactExports.useMemo(() => {
	        return selected
	            ? getNodeOffset(handleNode.current)
	            : // Kinda awkward. This is a nonsense return value since we only use
	                //this value when we are selected.
	                { top: 0, left: 0 };
	    }, [selected]);
	    const { renderMenu, children, top, bottom, ...passThroughProps } = props;
	    return (jsxRuntimeExports.jsxs("div", { ...passThroughProps, children: [jsxRuntimeExports.jsx("div", { className: "handle", style: { width: "100%", height: "100%" }, ref: handleNode, onClick: () => setSelected(!selected), children: children }), jsxRuntimeExports.jsx(ContextMenu, { selected: selected, offsetTop: offset.top, offsetLeft: offset.left, top: top, bottom: bottom, children: renderMenu() })] }));
	}

	// The Web Audio API's FFT is bad, so this exists now!
	// Taken from https://github.com/WACUP/vis_classic/tree/master/FFTNullsoft
	class FFT {
	    bitrevtable;
	    envelope;
	    equalize;
	    temp1;
	    temp2;
	    cossintable;
	    // Constants
	    static TWO_PI = 6.2831853; // 2 * Math.PI
	    static HALF_PI = 1.5707963268; // Math.PI / 2
	    constructor() {
	        // Assuming these are your hardcoded values:
	        const samplesIn = 1024; // hardcoded value
	        const samplesOut = 512; // hardcoded value
	        const envelopePower = 1.0; // hardcoded value
	        const mode = false; // hardcoded value
	        const NFREQ = samplesOut * 2;
	        // Initialize the tables and arrays with hardcoded values
	        this.bitrevtable = this.initBitRevTable(NFREQ);
	        this.cossintable = this.initCosSinTable(NFREQ);
	        this.envelope = this.initEnvelopeTable(samplesIn, envelopePower);
	        this.equalize = this.initEqualizeTable(NFREQ, mode);
	        this.temp1 = new Float32Array(NFREQ);
	        this.temp2 = new Float32Array(NFREQ);
	    }
	    initEqualizeTable(NFREQ, mode) {
	        const equalize = new Float32Array(NFREQ / 2);
	        let bias = 0.04; // FFT.INITIAL_BIAS
	        for (let i = 0; i < NFREQ / 2; i++) {
	            const invHalfNfreq = (9.0 - bias) / (NFREQ / 2);
	            equalize[i] = Math.log10(1.0 + bias + (i + 1) * invHalfNfreq);
	            bias /= 1.0025; // FFT.BIAS_DECAY_RATE
	        }
	        return equalize;
	    }
	    initEnvelopeTable(samplesIn, power) {
	        const mult = (1.0 / samplesIn) * FFT.TWO_PI;
	        const envelope = new Float32Array(samplesIn);
	        for (let i = 0; i < samplesIn; i++) {
	            envelope[i] = Math.pow(0.5 + 0.5 * Math.sin(i * mult - FFT.HALF_PI), power);
	        }
	        return envelope;
	    }
	    initBitRevTable(NFREQ) {
	        const bitrevtable = new Array(NFREQ);
	        for (let i = 0; i < NFREQ; i++) {
	            bitrevtable[i] = i;
	        }
	        for (let i = 0, j = 0; i < NFREQ; i++) {
	            if (j > i) {
	                const temp = bitrevtable[i];
	                bitrevtable[i] = bitrevtable[j];
	                bitrevtable[j] = temp;
	            }
	            let m = NFREQ >> 1;
	            while (m >= 1 && j >= m) {
	                j -= m;
	                m >>= 1;
	            }
	            j += m;
	        }
	        return bitrevtable;
	    }
	    initCosSinTable(NFREQ) {
	        const cossintable = [];
	        let dftsize = 2;
	        while (dftsize <= NFREQ) {
	            const theta = (-2.0 * Math.PI) / dftsize;
	            cossintable.push(new Float32Array([Math.cos(theta), Math.sin(theta)]));
	            dftsize <<= 1;
	        }
	        return cossintable;
	    }
	    timeToFrequencyDomain(inWavedata, outSpectraldata) {
	        if (!this.temp1 || !this.temp2 || !this.cossintable)
	            return;
	        // Converts time-domain samples from inWavedata[]
	        //   into frequency-domain samples in outSpectraldata[].
	        // The array lengths are the two parameters to Init().
	        // The last sample of the output data will represent the frequency
	        //   that is 1/4th of the input sampling rate.  For example,
	        //   if the input wave data is sampled at 44,100 Hz, then the last
	        //   sample of the spectral data output will represent the frequency
	        //   11,025 Hz.  The first sample will be 0 Hz; the frequencies of
	        //   the rest of the samples vary linearly in between.
	        // Note that since human hearing is limited to the range 200 - 20,000
	        //   Hz.  200 is a low bass hum; 20,000 is an ear-piercing high shriek.
	        // Each time the frequency doubles, that sounds like going up an octave.
	        //   That means that the difference between 200 and 300 Hz is FAR more
	        //   than the difference between 5000 and 5100, for example!
	        // So, when trying to analyze bass, you'll want to look at (probably)
	        //   the 200-800 Hz range; whereas for treble, you'll want the 1,400 -
	        //   11,025 Hz range.
	        // If you want to get 3 bands, try it this way:
	        //   a) 11,025 / 200 = 55.125
	        //   b) to get the number of octaves between 200 and 11,025 Hz, solve for n:
	        //          2^n = 55.125
	        //          n = log 55.125 / log 2
	        //          n = 5.785
	        //   c) so each band should represent 5.785/3 = 1.928 octaves; the ranges are:
	        //          1) 200 - 200*2^1.928                    or  200  - 761   Hz
	        //          2) 200*2^1.928 - 200*2^(1.928*2)        or  761  - 2897  Hz
	        //          3) 200*2^(1.928*2) - 200*2^(1.928*3)    or  2897 - 11025 Hz
	        // A simple sine-wave-based envelope is convolved with the waveform
	        //   data before doing the FFT, to emeliorate the bad frequency response
	        //   of a square (i.e. nonexistent) filter.
	        // You might want to slightly damp (blur) the input if your signal isn't
	        //   of a very high quality, to reduce high-frequency noise that would
	        //   otherwise show up in the output.
	        // code should be smart enough to call Init before this function
	        //if (!bitrevtable) return;
	        //if (!temp1) return;
	        //if (!temp2) return;
	        //if (!cossintable) return;
	        // 1. set up input to the fft
	        for (let i = 0; i < this.temp1.length; i++) {
	            const idx = this.bitrevtable[i];
	            if (idx < inWavedata.length) {
	                this.temp1[i] =
	                    inWavedata[idx] * (this.envelope ? this.envelope[idx] : 1);
	            }
	            else {
	                this.temp1[i] = 0;
	            }
	        }
	        this.temp2.fill(0);
	        // 2. Perform FFT
	        const real = this.temp1;
	        const imag = this.temp2;
	        let dftsize = 2;
	        let t = 0;
	        while (dftsize <= this.temp1.length) {
	            const wpr = this.cossintable[t][0];
	            const wpi = this.cossintable[t][1];
	            let wr = 1.0;
	            let wi = 0.0;
	            const hdftsize = dftsize >> 1;
	            for (let m = 0; m < hdftsize; m += 1) {
	                for (let i = m; i < this.temp1.length; i += dftsize) {
	                    const j = i + hdftsize;
	                    const tempr = wr * real[j] - wi * imag[j];
	                    const tempi = wr * imag[j] + wi * real[j];
	                    real[j] = real[i] - tempr;
	                    imag[j] = imag[i] - tempi;
	                    real[i] += tempr;
	                    imag[i] += tempi;
	                }
	                const wtemp = wr;
	                wr = wr * wpr - wi * wpi;
	                wi = wi * wpr + wtemp * wpi;
	            }
	            dftsize <<= 1;
	            ++t;
	        }
	        // 3. take the magnitude & equalize it (on a log10 scale) for output
	        for (let i = 0; i < outSpectraldata.length; i++) {
	            outSpectraldata[i] =
	                Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) *
	                    (this.equalize ? this.equalize[i] : 1);
	        }
	    }
	}

	/**
	 * Base class of Visualizer (animation frame renderer engine)
	 */
	class VisPaintHandler {
	    _vis;
	    _ctx;
	    constructor(vis) {
	        this._vis = vis;
	        this._ctx = vis.canvas.getContext("2d");
	    }
	    /**
	     * Attempt to build cached bitmaps for later use while rendering a frame.
	     * Purpose: fast rendering in animation loop
	     */
	    prepare() { }
	    /**
	     * Called once per frame rendering
	     */
	    paintFrame() { }
	    /**
	     * Attempt to cleanup cached bitmaps
	     */
	    dispose() { }
	}
	/**
	 * Feeds audio data to the FFT.
	 * @param analyser The AnalyserNode used to get the audio data.
	 * @param fft The FFTNullsoft instance from the PaintHandler.
	 */
	function processFFT(analyser, fft, inWaveData, outSpectralData) {
	    const dataArray = new Uint8Array(1024);
	    analyser.getByteTimeDomainData(dataArray);
	    for (let i = 0; i < dataArray.length; i++) {
	        inWaveData[i] = (dataArray[i] - 128) / 24;
	    }
	    fft.timeToFrequencyDomain(inWaveData, outSpectralData);
	}
	class BarPaintHandler extends VisPaintHandler {
	    saPeaks;
	    saData2;
	    saData;
	    saFalloff;
	    sample;
	    barPeak;
	    chunk;
	    uVar12;
	    falloff;
	    peakFalloff;
	    pushDown;
	    inWaveData = new Float32Array(1024);
	    outSpectralData = new Float32Array(512);
	    _analyser;
	    _fft;
	    _color = "rgb(255,255,255)";
	    _colorPeak = "rgb(255,255,255)";
	    // Off-screen canvas for pre-rendering a single bar gradient
	    _bar = document.createElement("canvas");
	    _peak = document.createElement("canvas");
	    _16h = document.createElement("canvas"); // non-stretched
	    _bufferLength;
	    _dataArray;
	    colorssmall;
	    colorssmall2;
	    _renderHeight;
	    _smallVis;
	    _pixelDensity;
	    _doubled;
	    _isMWOpen;
	    paintBar;
	    paintFrame;
	    constructor(vis) {
	        super(vis);
	        this._analyser = this._vis.analyser;
	        this._fft = new FFT();
	        this._bufferLength = this._analyser.frequencyBinCount;
	        this._dataArray = new Uint8Array(this._bufferLength);
	        this._renderHeight = vis.renderHeight;
	        this._smallVis = vis.smallVis;
	        this._pixelDensity = vis.pixelDensity;
	        this._doubled = vis.doubled;
	        this._isMWOpen = vis.isMWOpen;
	        this.colorssmall = [
	            vis.colors[17],
	            vis.colors[14],
	            vis.colors[11],
	            vis.colors[8],
	            vis.colors[4],
	        ];
	        this.colorssmall2 = [
	            vis.colors[17],
	            vis.colors[16],
	            vis.colors[14],
	            vis.colors[13],
	            vis.colors[11],
	            vis.colors[10],
	            vis.colors[8],
	            vis.colors[7],
	            vis.colors[5],
	            vis.colors[4],
	        ];
	        this._16h.width = 1;
	        this._16h.height = 16;
	        this._16h.setAttribute("width", "75");
	        this._16h.setAttribute("height", "16");
	        // draws the analyzer and handles changing the bandwidth correctly
	        this.paintFrame = this.paintAnalyzer.bind(this);
	        this.saPeaks = new Int16Array(76).fill(0);
	        this.saData2 = new Float32Array(76).fill(0);
	        this.saData = new Int16Array(76).fill(0);
	        this.saFalloff = new Float32Array(76).fill(0);
	        this.sample = new Float32Array(76).fill(0);
	        this.barPeak = new Int16Array(76).fill(0); // Needs to be specified as Int16 else the peaks don't behave as they should
	        this.chunk = 0;
	        this.uVar12 = 0;
	        this.pushDown = 0;
	        switch (this._vis.coloring) {
	            case "fire":
	                this.paintBar = this.paintBarFire.bind(this);
	                break;
	            case "line":
	                this.paintBar = this.paintBarLine.bind(this);
	                break;
	            default:
	                this.paintBar = this.paintBarNormal.bind(this);
	                break;
	        }
	        switch (this._vis.saFalloff) {
	            case "slower":
	                this.falloff = 3;
	                break;
	            case "slow":
	                this.falloff = 6;
	                break;
	            case "moderate":
	                this.falloff = 12;
	                break;
	            case "fast":
	                this.falloff = 16;
	                break;
	            case "faster":
	                this.falloff = 32;
	                break;
	            default:
	                this.falloff = 12;
	                break;
	        }
	        switch (this._vis.saPeakFalloff) {
	            case "slower":
	                this.peakFalloff = 1.05;
	                break;
	            case "slow":
	                this.peakFalloff = 1.1;
	                break;
	            case "moderate":
	                this.peakFalloff = 1.2;
	                break;
	            case "fast":
	                this.peakFalloff = 1.4;
	                break;
	            case "faster":
	                this.peakFalloff = 1.6;
	                break;
	            default:
	                this.peakFalloff = 1.1;
	                break;
	        }
	    }
	    prepare() {
	        const vis = this._vis;
	        //? paint peak
	        this._peak.height = 1;
	        this._peak.width = 1;
	        let ctx = this._peak.getContext("2d");
	        ctx.fillStyle = vis.colors[23];
	        ctx.fillRect(0, 0, 1, 1);
	        if (this._vis.smallVis) {
	            this.pushDown = 0;
	        }
	        else if (this._vis.doubled && !this._vis.isMWOpen) {
	            this.pushDown = 2;
	        }
	        else if (this._vis.doubled) {
	            this.pushDown = 0;
	        }
	        else {
	            this.pushDown = 2;
	        }
	        //? paint bar
	        this._bar.height = 16;
	        this._bar.width = 1;
	        this._bar.setAttribute("width", "1");
	        this._bar.setAttribute("height", "16");
	        ctx = this._bar.getContext("2d");
	        for (let y = 0; y < 16; y++) {
	            if (this._vis.pixelDensity === 2 && this._vis.smallVis) {
	                ctx.fillStyle = this.colorssmall2[-y + 9];
	            }
	            else {
	                ctx.fillStyle = this._vis.smallVis
	                    ? this.colorssmall[-y + 4]
	                    : vis.colors[2 - this.pushDown - -y];
	            }
	            ctx.fillRect(0, y, 1, y + 1);
	        }
	    }
	    /**
	     * ⬜⬜⬜ ⬜⬜⬜
	     * 🟧🟧🟧
	     * 🟫🟫🟫 🟧🟧🟧
	     * 🟫🟫🟫 🟫🟫🟫
	     * 🟫🟫🟫 🟫🟫🟫 ⬜⬜⬜
	     * 🟫🟫🟫 🟫🟫🟫 🟧🟧🟧
	     * 🟫🟫🟫 🟫🟫🟫 🟫🟫🟫
	     * 1 bar = multiple pixels
	     */
	    /**
	     * ⬜⬜
	     * 🟧
	     * 🟫🟧
	     * 🟫🟫⬜⬜
	     * 🟫🟫🟧
	     * 🟫🟫🟫🟧⬜
	     * 🟫🟫🟫🟫🟧
	     * drawing 1pixel width bars
	     */
	    paintAnalyzer() {
	        if (!this._ctx)
	            return;
	        const ctx = this._ctx;
	        ctx.fillStyle = this._color;
	        const maxFreqIndex = 512;
	        const logMaxFreqIndex = Math.log10(maxFreqIndex);
	        const logMinFreqIndex = 0;
	        let targetSize;
	        let maxHeight;
	        let maxWidth;
	        if (this._vis.pixelDensity === 2) {
	            targetSize = 75;
	            maxHeight = 10;
	        }
	        else {
	            targetSize = this._vis.smallVis ? 40 : 75;
	            maxHeight = this._vis.smallVis ? 5 : 15;
	        }
	        processFFT(this._analyser, this._fft, this.inWaveData, this.outSpectralData);
	        if (this._vis.smallVis) {
	            if (this._vis.pixelDensity === 2) {
	                maxWidth = 75; // this is not 37*2, but if this was 74, we'd be missing a pixel
	                // someone here at Nullsoft screwed up...? or thought 74 didn't look good, I don't know.
	            }
	            else {
	                maxWidth = 37;
	            }
	        }
	        else {
	            maxWidth = 75;
	        }
	        // This is to roughly emulate the Analyzer in more modern versions of Winamp.
	        // 2.x and early 5.x versions had a completely linear(?) FFT, if so desired the
	        // scale variable can be set to 0.0
	        // This factor controls the scaling from linear to logarithmic.
	        // scale = 0.0 -> fully linear scaling
	        // scale = 1.0 -> fully logarithmic scaling
	        const scale = 0.91; // Adjust this value between 0.0 and 1.0
	        for (let x = 0; x < targetSize; x++) {
	            // Linear interpolation between linear and log scaling
	            const linearIndex = (x / (targetSize - 1)) * (maxFreqIndex - 1);
	            const logScaledIndex = logMinFreqIndex +
	                ((logMaxFreqIndex - logMinFreqIndex) * x) / (targetSize - 1);
	            const logIndex = Math.pow(10, logScaledIndex);
	            // Interpolating between linear and logarithmic scaling
	            const scaledIndex = (1.0 - scale) * linearIndex + scale * logIndex;
	            let index1 = Math.floor(scaledIndex);
	            let index2 = Math.ceil(scaledIndex);
	            if (index1 >= maxFreqIndex) {
	                index1 = maxFreqIndex - 1;
	            }
	            if (index2 >= maxFreqIndex) {
	                index2 = maxFreqIndex - 1;
	            }
	            if (index1 === index2) {
	                this.sample[x] = this.outSpectralData[index1];
	            }
	            else {
	                const frac2 = scaledIndex - index1;
	                const frac1 = 1.0 - frac2;
	                this.sample[x] =
	                    frac1 * this.outSpectralData[index1] +
	                        frac2 * this.outSpectralData[index2];
	            }
	        }
	        for (let x = 0; x < maxWidth; x++) {
	            // Based on research of looking at Winamp 5.666 and 2.63 executables
	            // if our bandwidth is "wide", chunk every 5 instances of the bars,
	            // add them together and display them
	            if (this._vis.bandwidth === "wide") {
	                this.chunk = this.chunk = x & 0xfffffffc;
	                this.uVar12 =
	                    (this.sample[this.chunk + 3] +
	                        this.sample[this.chunk + 2] +
	                        this.sample[this.chunk + 1] +
	                        this.sample[this.chunk]) /
	                        4;
	                this.saData[x] = this.uVar12;
	            }
	            else {
	                this.chunk = 0;
	                this.saData[x] = this.sample[x];
	            }
	            if (this.saData[x] >= maxHeight) {
	                this.saData[x] = maxHeight;
	            }
	            // prevents saPeaks going out of bounds when switching to windowShade mode
	            if (this.saPeaks[x] >= maxHeight * 256) {
	                this.saPeaks[x] = maxHeight * 256;
	            }
	            this.saFalloff[x] -= this.falloff / 16.0;
	            // Possible bar fall off values are
	            // 3, 6, 12, 16, 32
	            // Should there ever be some form of config options,
	            // these should be used
	            // 12 is the default of a fresh new Winamp installation
	            if (this.saFalloff[x] <= this.saData[x]) {
	                this.saFalloff[x] = this.saData[x];
	            }
	            if (this.saPeaks[x] <= Math.round(this.saFalloff[x] * 256)) {
	                this.saPeaks[x] = this.saFalloff[x] * 256;
	                this.saData2[x] = 3.0;
	            }
	            this.barPeak[x] = this.saPeaks[x] / 256;
	            this.saPeaks[x] -= Math.round(this.saData2[x]);
	            this.saData2[x] *= this.peakFalloff;
	            // Possible peak fall off values are
	            // 1.05f, 1.1f, 1.2f, 1.4f, 1.6f
	            // 1.1f is the default of a fresh new Winamp installation
	            if (this.saPeaks[x] <= 0) {
	                this.saPeaks[x] = 0;
	            }
	            if (this._vis.smallVis) ;
	            else if (Math.round(this.barPeak[x]) < 1) {
	                this.barPeak[x] = -3; // Push peaks outside the viewable area, this isn't a Modern Skin!
	            }
	            // skip rendering if x is 4
	            if (!(x === this.chunk + 3 && this._vis.bandwidth === "wide")) {
	                this.paintBar(ctx, x, x, Math.round(this.saFalloff[x]) - this.pushDown, this.barPeak[x] + 1 - this.pushDown);
	            }
	        }
	    }
	    /**
	     * 🟥
	     * 🟧🟧
	     * 🟨🟨🟨
	     * 🟩🟩🟩🟩
	     */
	    paintBarNormal(ctx, x, x2, barHeight, peakHeight) {
	        const h = ctx.canvas.height;
	        const y = h - barHeight;
	        ctx.drawImage(this._bar, 0, y, 1, h - y, x, y, x2 - x + 1, h - y);
	        if (this._vis.peaks) {
	            const peakY = h - peakHeight;
	            ctx.drawImage(this._peak, 0, 0, 1, 1, x, peakY, x2 - x + 1, 1);
	        }
	    }
	    /**
	     * 🟥
	     * 🟧🟥
	     * 🟨🟧🟥
	     * 🟩🟨🟧🟥
	     */
	    paintBarFire(ctx, x, x2, barHeight, peakHeight) {
	        const h = ctx.canvas.height;
	        const y = h - barHeight;
	        ctx.drawImage(this._bar, 0, 0, this._bar.width, h - y, x, y, x2 - x + 1, h - y);
	        if (this._vis.peaks) {
	            const peakY = h - peakHeight;
	            ctx.drawImage(this._peak, 0, 0, 1, 1, x, peakY, x2 - x + 1, 1);
	        }
	    }
	    /**
	     * 🟥
	     * 🟥🟧
	     * 🟥🟧🟨
	     * 🟥🟧🟨🟩
	     */
	    paintBarLine(ctx, x, x2, barHeight, peakHeight) {
	        const h = ctx.canvas.height;
	        const y = h - barHeight;
	        // FIXME: Line drawing is currently Fire mode!
	        ctx.drawImage(this._bar, 0, // sx
	        0, // sy
	        this._bar.width, // sw
	        h - y, // sh
	        x, y, //  dx,dy
	        x2 - x + 1, //dw
	        h - y //dh
	        );
	        if (this._vis.peaks) {
	            const peakY = h - peakHeight;
	            ctx.drawImage(this._peak, 0, 0, 1, 1, x, peakY, x2 - x + 1, 1);
	        }
	    }
	}
	function slice1st(dataArray, sliceWidth, sliceNumber) {
	    const start = sliceWidth * sliceNumber;
	    return dataArray[start];
	}
	class WavePaintHandler extends VisPaintHandler {
	    pushDown;
	    _analyser;
	    _bufferLength;
	    _lastX = 0;
	    _lastY = 0;
	    _dataArray;
	    _pixelRatio; // 1 or 2
	    // Off-screen canvas for drawing perfect pixel (no blurred lines)
	    _bar = document.createElement("canvas");
	    _16h = document.createElement("canvas"); // non-stretched
	    paintWav;
	    constructor(vis) {
	        super(vis);
	        this._analyser = this._vis.analyser;
	        this._bufferLength = this._analyser.fftSize;
	        this._dataArray = new Uint8Array(this._bufferLength);
	        this._16h.width = 1;
	        this._16h.height = 16;
	        this._16h.setAttribute("width", "75");
	        this._16h.setAttribute("height", "16");
	        //* see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio#monitoring_screen_resolution_or_zoom_level_changes
	        this._pixelRatio = window.devicePixelRatio || 1;
	        // draws the oscilloscope and handles overly complex operations
	        // in relation to oscilloscope style and main window states
	        this.paintWav = this.paintOscilloscope.bind(this);
	        this.pushDown = 0;
	    }
	    prepare() {
	        const vis = this._vis;
	        //? paint bar
	        this._bar.width = 1;
	        this._bar.height = 5;
	        this._bar.setAttribute("width", "1");
	        this._bar.setAttribute("height", "5");
	        const ctx = this._bar.getContext("2d");
	        if (ctx) {
	            for (let y = 0; y < 5; y++) {
	                ctx.fillStyle = vis.colors[18 + y];
	                ctx.fillRect(0, y, 1, y + 1);
	            }
	        }
	        // @ts-ignore
	        this._ctx.imageSmoothingEnabled = false;
	        // @ts-ignore
	        this._ctx.mozImageSmoothingEnabled = false;
	        // @ts-ignore
	        this._ctx.webkitImageSmoothingEnabled = false;
	        // @ts-ignore
	        this._ctx.msImageSmoothingEnabled = false;
	    }
	    paintFrame() {
	        if (!this._ctx)
	            return;
	        this._analyser.getByteTimeDomainData(this._dataArray);
	        this._dataArray = this._dataArray.slice(0, 576);
	        const bandwidth = this._dataArray.length;
	        // width would technically be correct, but if the main window is
	        // in windowshade mode, it is set to 150, making sliceWidth look
	        // wrong in that mode, concerning the oscilloscope
	        const sliceWidth = Math.floor(bandwidth / 75);
	        // Iterate over the width of the canvas in fixed 75 pixels.
	        for (let j = 0; j <= 75; j++) {
	            const amplitude = slice1st(this._dataArray, sliceWidth, j);
	            this.paintWav(j, amplitude);
	        }
	    }
	    /**
	     *
	     * @param y 0..5
	     * @returns value in use for coloring stuff in
	     */
	    colorIndex(y) {
	        if (this._vis.smallVis) {
	            return 0;
	        }
	        if (y >= 14)
	            return 4;
	        if (y >= 12)
	            return 3;
	        if (y >= 10)
	            return 2;
	        if (y >= 8)
	            return 1;
	        if (y >= 6)
	            return 0;
	        if (y >= 4)
	            return 1;
	        if (y >= 2)
	            return 2;
	        if (y >= 0)
	            return 3;
	        return 3;
	    }
	    paintOscilloscope(x, y) {
	        // we skip rendering of the oscilloscope if we are in windowShade mode
	        // previously the renderWidth variable in Vis.tsx scaled down the width
	        // of the canvas, but i didn't really like the idea since we squished
	        // down the result of y to fit within 35/75 pixels, winamp doesn't
	        // squish it's audio data down in the x axis, resulting in only
	        // getting a small portion of what we hear, they did it, so do we
	        if (this._vis.smallVis && this._vis.doubled) {
	            if (x >= 75) {
	                // SORRY NOTHING
	                return;
	            }
	        }
	        else if (x >= (this._vis.smallVis ? 38 : 75)) {
	            // SORRY NOTHING
	            return;
	        }
	        // pushes vis down if not double size, winamp does this
	        if (this._vis.smallVis) {
	            this.pushDown = 0;
	        }
	        else if (this._vis.doubled && !this._vis.isMWOpen) {
	            this.pushDown = 2;
	        }
	        else if (this._vis.doubled) {
	            this.pushDown = 0;
	        }
	        else {
	            this.pushDown = 2;
	        }
	        // rounds y down to the nearest int
	        // before that even happens, y is scaled down and then doubled again (could've done * 8
	        // but i feel this makes more sense to me)
	        // y is then adjusted downward to be in the center of the scope
	        y = Math.round((y / 16) * 2) - 9;
	        // adjusts the center point of y if we are in windowShade mode, and if pixelDensity is 2
	        // where it's adjusted further to give you the fullest view possible in that small window
	        // else we leave y as is
	        let yadjust;
	        if (this._vis.pixelDensity === 2)
	            yadjust = 3;
	        else
	            yadjust = 5;
	        y = this._vis.smallVis ? y - yadjust : y;
	        // scales down the already scaled down result of y to 0..10 or 0..5, depending on
	        // if pixelDensity returns 2, this serves the purpose of avoiding full sending
	        // y to that really tiny space we have there
	        if (this._vis.smallVis && this._vis.pixelDensity === 2) {
	            y = Math.round(((y + 11) / 16) * 10) - 5;
	        }
	        else if (this._vis.smallVis) {
	            y = Math.round(((y + 11) / 16) * 5) - 2;
	        }
	        // clamp y to be within a certain range, here it would be 0..10 if both windowShade and pixelDensity apply
	        // else we clamp y to 0..15 or 0..3, depending on renderHeight
	        if (this._vis.smallVis && this._vis.pixelDensity === 2) {
	            y = y < 0 ? 0 : y > 10 - 1 ? 10 - 1 : y;
	        }
	        else {
	            y =
	                y < 0
	                    ? 0
	                    : y > this._vis.renderHeight - 1
	                        ? this._vis.renderHeight - 1
	                        : y;
	        }
	        const v = y;
	        if (x === 0)
	            this._lastY = y;
	        let top = y;
	        let bottom = this._lastY;
	        this._lastY = y;
	        if (this._vis.oscStyle === "solid") {
	            if (this._vis.pixelDensity === 2) {
	                if (y >= (this._vis.smallVis ? 5 : 8)) {
	                    top = this._vis.smallVis ? 5 : 8;
	                    bottom = y;
	                }
	                else {
	                    top = y;
	                    bottom = this._vis.smallVis ? 5 : 7;
	                }
	                if (x === 0 && this._vis.smallVis) {
	                    // why? i dont know!!
	                    top = y;
	                    bottom = y;
	                }
	            }
	            else {
	                if (y >= (this._vis.smallVis ? 2 : 8)) {
	                    top = this._vis.smallVis ? 2 : 8;
	                    bottom = y;
	                }
	                else {
	                    top = y;
	                    bottom = this._vis.smallVis ? 2 : 7;
	                }
	                if (x === 0 && this._vis.smallVis) {
	                    // why? i dont know!!
	                    top = y;
	                    bottom = y;
	                }
	            }
	        }
	        else if (this._vis.oscStyle === "dots") {
	            top = y;
	            bottom = y;
	        }
	        else if (bottom < top) {
	            [bottom, top] = [top, bottom];
	            if (this._vis.smallVis) ;
	            else {
	                top++; //top++, that emulates Winamp's/WACUP's OSC behavior correctly
	            }
	        }
	        for (y = top; y <= bottom; y++) {
	            this._ctx.drawImage(this._bar, 0, this.colorIndex(v), // sx,sy
	            1, 1, // sw,sh
	            x, y + this.pushDown, 1, 1 //dw,dh
	            );
	        }
	    }
	}
	class NoVisualizerHandler extends VisPaintHandler {
	    cleared = false;
	    prepare() {
	        this.cleared = false;
	    }
	    paintFrame() {
	        if (!this._ctx)
	            return;
	        this.cleared = true;
	    }
	}

	// Pre-render the background grid
	function preRenderBg(options) {
	    const { width, height, bgColor, fgColor, windowShade, pixelDensity } = options;
	    // Off-screen canvas for pre-rendering the background
	    const bgCanvas = document.createElement("canvas");
	    bgCanvas.width = width;
	    bgCanvas.height = height;
	    const distance = 2 * pixelDensity;
	    const bgCanvasCtx = bgCanvas.getContext("2d");
	    if (bgCanvasCtx == null) {
	        throw new Error("Could not construct canvas context");
	    }
	    bgCanvasCtx.fillStyle = bgColor;
	    bgCanvasCtx.fillRect(0, 0, width, height);
	    if (!windowShade) {
	        bgCanvasCtx.fillStyle = fgColor;
	        for (let x = 0; x < width; x += distance) {
	            for (let y = pixelDensity; y < height; y += distance) {
	                bgCanvasCtx.fillRect(x, y, pixelDensity, pixelDensity);
	            }
	        }
	    }
	    return bgCanvas;
	}
	function Vis({ analyser }) {
	    reactExports.useLayoutEffect(() => {
	        analyser.fftSize = 1024;
	    }, [analyser, analyser.fftSize]);
	    const colors = useTypedSelector(getSkinColors);
	    const mode = useTypedSelector(getVisualizerStyle);
	    const audioStatus = useTypedSelector(getMediaStatus);
	    const getWindowShade$1 = useTypedSelector(getWindowShade);
	    const getWindowOpen$1 = useTypedSelector(getWindowOpen);
	    const isMWOpen = getWindowOpen$1("main");
	    const doubled = useTypedSelector(getDoubled);
	    const toggleVisualizerStyle$1 = useActionCreator(toggleVisualizerStyle);
	    const windowShade = getWindowShade$1("main");
	    const smallVis = windowShade && isMWOpen;
	    const renderHeight = smallVis ? 5 : 16;
	    const renderWidth = 76;
	    const pixelDensity = doubled && smallVis ? 2 : 1;
	    let renderWidthBG;
	    if (!isMWOpen) {
	        renderWidthBG = renderWidth;
	    }
	    else if (windowShade) {
	        renderWidthBG = doubled ? renderWidth : 38;
	    }
	    else {
	        renderWidthBG = renderWidth * pixelDensity;
	    }
	    const width = renderWidth * pixelDensity;
	    const height = renderHeight * pixelDensity;
	    const bgCanvas = reactExports.useMemo(() => {
	        return preRenderBg({
	            width: renderWidthBG,
	            height,
	            bgColor: colors[0],
	            fgColor: colors[1],
	            windowShade: Boolean(windowShade),
	            pixelDensity,
	        });
	    }, [colors, height, renderWidthBG, windowShade, pixelDensity]);
	    const [canvas, setCanvas] = reactExports.useState(null);
	    //? painter administration
	    const painter = reactExports.useMemo(() => {
	        if (!canvas)
	            return null;
	        const vis = {
	            canvas,
	            colors,
	            analyser,
	            oscStyle: "lines",
	            bandwidth: "wide",
	            coloring: "normal",
	            peaks: true,
	            saFalloff: "moderate",
	            saPeakFalloff: "slow",
	            sa: "analyzer", // unused, but hopefully will be used in the future for providing config options
	            renderHeight,
	            smallVis,
	            pixelDensity,
	            doubled,
	            isMWOpen,
	        };
	        switch (mode) {
	            case VISUALIZERS.OSCILLOSCOPE:
	                return new WavePaintHandler(vis);
	            case VISUALIZERS.BAR:
	                return new BarPaintHandler(vis);
	            case VISUALIZERS.NONE:
	                return new NoVisualizerHandler(vis);
	            default:
	                return new NoVisualizerHandler(vis);
	        }
	    }, [
	        analyser,
	        canvas,
	        mode,
	        colors,
	        renderHeight,
	        smallVis,
	        pixelDensity,
	        doubled,
	        isMWOpen,
	    ]);
	    // reacts to changes in doublesize mode
	    reactExports.useEffect(() => {
	        if (canvas && painter) {
	            const canvasCtx = canvas.getContext("2d");
	            if (canvasCtx) {
	                painter.prepare();
	                // wipes the canvas clean if playback is paused and doubled is changing
	                if (audioStatus === MEDIA_STATUS.PAUSED) {
	                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
	                }
	            }
	        }
	        // TODO: Double check expected behavior when pause state changes.
	        // Here we ignore the audioStatus dependency because we don't
	        // want to clear the canvas when the audio is paused.
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [doubled, canvas, painter]);
	    reactExports.useEffect(() => {
	        if (canvas == null || painter == null) {
	            return;
	        }
	        const canvasCtx = canvas.getContext("2d");
	        if (canvasCtx == null) {
	            return;
	        }
	        canvasCtx.imageSmoothingEnabled = false;
	        let animationRequest = null;
	        const loop = () => {
	            canvasCtx.drawImage(bgCanvas, 0, 0);
	            painter.paintFrame();
	            animationRequest = window.requestAnimationFrame(loop);
	        };
	        if (audioStatus === MEDIA_STATUS.PLAYING) {
	            if (mode === VISUALIZERS.NONE) {
	                canvasCtx.clearRect(0, 0, renderWidthBG, height);
	            }
	            else {
	                loop();
	            }
	        }
	        return () => {
	            if (animationRequest !== null) {
	                window.cancelAnimationFrame(animationRequest);
	            }
	        };
	    }, [audioStatus, canvas, painter, bgCanvas, renderWidthBG, height, mode]);
	    if (audioStatus === MEDIA_STATUS.STOPPED) {
	        return null;
	    }
	    return (jsxRuntimeExports.jsx("canvas", { id: "visualizer", ref: setCanvas, style: { width: renderWidth, height: renderHeight }, width: width, height: height, onClick: toggleVisualizerStyle$1 }));
	}

	const ActionButtons = reactExports.memo(() => {
	    const previous$1 = useActionCreator(previous);
	    const play$1 = useActionCreator(play);
	    const pause$1 = useActionCreator(pause);
	    const next$1 = useActionCreator(next);
	    const stop$1 = useActionCreator(stop);
	    return (jsxRuntimeExports.jsxs("div", { className: "actions", children: [jsxRuntimeExports.jsx(WinampButton, { id: "previous", onClick: previous$1, title: "Previous Track" }), jsxRuntimeExports.jsx(WinampButton, { id: "play", onClick: play$1, title: "Play" }), jsxRuntimeExports.jsx(WinampButton, { id: "pause", onClick: pause$1, title: "Pause" }), jsxRuntimeExports.jsx(WinampButton, { id: "stop", onClick: stop$1, title: "Stop" }), jsxRuntimeExports.jsx(WinampButton, { id: "next", onClick: next$1, title: "Next Track" })] }));
	});

	function Balance({ style, className, id }) {
	    const balance = useTypedSelector(getBalance);
	    const setBalance$1 = useActionCreator(setBalance);
	    const setFocus$1 = useActionCreator(setFocus);
	    const unsetFocus$1 = useActionCreator(unsetFocus);
	    return (jsxRuntimeExports.jsx("input", { id: id, className: className, type: "range", min: "-100", max: "100", step: "1", value: balance, style: { ...style, touchAction: "none" }, onChange: (e) => setBalance$1(Number(e.target.value)), onPointerDown: () => setFocus$1("balance"), onPointerUp: unsetFocus$1, title: "Balance" }));
	}

	const offsetFromBalance = (balance) => {
	    const percent = Math.abs(balance) / 100;
	    const sprite = Math.floor(percent * 27);
	    const offset = sprite * 15;
	    return offset;
	};
	const MainBalance = reactExports.memo(() => {
	    const balance = useTypedSelector(getBalance);
	    return (jsxRuntimeExports.jsx(Balance, { id: "balance", style: { backgroundPosition: `0 -${offsetFromBalance(balance)}px` } }));
	});

	const Close = reactExports.memo(() => {
	    const close$1 = useActionCreator(close);
	    return jsxRuntimeExports.jsx(ClickedDiv, { id: "close", onClick: close$1, title: "Close" });
	});

	function setFocusDouble() {
	    return setFocus("double");
	}
	function mouseUp() {
	    return (dispatch) => {
	        dispatch(toggleDoubleSizeMode());
	        dispatch(unsetFocus());
	    };
	}
	const ClutterBar = reactExports.memo(() => {
	    const handleMouseDown = useActionCreator(setFocusDouble);
	    const handleMouseUp = useActionCreator(mouseUp);
	    const doubled = useTypedSelector(getDoubled);
	    return (jsxRuntimeExports.jsxs("div", { id: "clutter-bar", children: [jsxRuntimeExports.jsx(ContextMenuTarget, { bottom: true, renderMenu: () => jsxRuntimeExports.jsx(OptionsContextMenu, {}), children: jsxRuntimeExports.jsx("div", { id: "button-o" }) }), jsxRuntimeExports.jsx("div", { id: "button-a" }), jsxRuntimeExports.jsx("div", { id: "button-i" }), jsxRuntimeExports.jsx("div", { title: "Toggle Doublesize Mode", id: "button-d", className: classnames({ selected: doubled }), onPointerUp: handleMouseUp, onPointerDown: (e) => {
	                    e.preventDefault();
	                    handleMouseDown();
	                } }), jsxRuntimeExports.jsx("div", { id: "button-v" })] }));
	});

	const Eject = reactExports.memo(() => {
	    const openMediaFileDialog$1 = useActionCreator(openMediaFileDialog);
	    return (jsxRuntimeExports.jsx(WinampButton, { id: "eject", onClick: openMediaFileDialog$1, title: "Open File(s)" }));
	});

	function toggleEqualizer() {
	    return toggleWindow("equalizer");
	}
	const EqToggleButton = reactExports.memo(() => {
	    const handleClick = useActionCreator(toggleEqualizer);
	    const windowOpen = useTypedSelector(getWindowOpen)("equalizer");
	    return (jsxRuntimeExports.jsx(WinampButton, { id: "equalizer-button", className: classnames({ selected: windowOpen }), onClick: handleClick, title: "Toggle Graphical Equalizer" }));
	});

	function togglePlaylist() {
	    return toggleWindow("playlist");
	}
	const PlaylistToggleButton = reactExports.memo(() => {
	    const selected = useTypedSelector(getWindowOpen)("playlist");
	    const handleClick = useActionCreator(togglePlaylist);
	    return (jsxRuntimeExports.jsx(WinampButton, { id: "playlist-button", className: classnames({ selected }), onClick: handleClick, title: "Toggle Playlist Editor" }));
	});

	const CharacterString = reactExports.memo((props) => {
	    const text = `${props.children}` || "";
	    const chars = text.split("");
	    return (jsxRuntimeExports.jsx(reactExports.Fragment, { children: chars.map((character, index) => (jsxRuntimeExports.jsx(Character, { children: character }, index + character))) }));
	});

	const Kbps = reactExports.memo(() => {
	    const kbps = useTypedSelector(getKbps);
	    return (jsxRuntimeExports.jsx("div", { id: "kbps", children: jsxRuntimeExports.jsx(CharacterString, { children: kbps || "" }) }));
	});

	const Khz = reactExports.memo(() => {
	    const khz = useTypedSelector(getKhz);
	    return (jsxRuntimeExports.jsx("div", { id: "khz", children: jsxRuntimeExports.jsx(CharacterString, { children: khz || "" }) }));
	});

	const SEPARATOR = "  ***  ";
	const CHAR_WIDTH = 5;
	const MARQUEE_MAX_LENGTH = 31;
	// Always positive modulus
	const mod = (n, m) => ((n % m) + m) % m;
	const isLong = (text) => text.length >= MARQUEE_MAX_LENGTH;
	// Given text and step, how many pixels should it be shifted?
	const stepOffset = (text, step, pixels) => {
	    if (!isLong(text)) {
	        return 0;
	    }
	    const stepOffsetWidth = step * CHAR_WIDTH; // Steps move one char at a time
	    const offset = stepOffsetWidth + pixels;
	    const stringLength = (text.length + SEPARATOR.length) * CHAR_WIDTH;
	    return mod(offset, stringLength);
	};
	// Format an int as pixels
	const pixelUnits = (pixels) => `${pixels}px`;
	// If text is wider than the marquee, it needs to loop
	const loopText = (text) => isLong(text)
	    ? `${text}${SEPARATOR}${text}`
	    : text.padEnd(MARQUEE_MAX_LENGTH, " ");
	// Call `step` every second, except when dragging. Resume stepping 1 second after dragging ceases.
	function useStepper({ step, dragging }) {
	    const [stepping, setStepping] = reactExports.useState(true);
	    reactExports.useEffect(() => {
	        if (stepping === false) {
	            return;
	        }
	        const stepHandle = setInterval(step, 220);
	        return () => clearInterval(stepHandle);
	    }, [step, stepping]);
	    reactExports.useEffect(() => {
	        if (dragging) {
	            setStepping(false);
	            return;
	        }
	        const steppingTimeout = window.setTimeout(() => {
	            setStepping(true);
	        }, 1000);
	        return () => {
	            window.clearTimeout(steppingTimeout);
	        };
	    }, [dragging]);
	}
	// When user calls `handleMouseDown`, and moves the mouse, `dragOffset` will update as they drag.
	function useDragX() {
	    const [mouseDownX, setMouseDownX] = reactExports.useState(null);
	    const [dragOffset, setDragOffset] = reactExports.useState(0);
	    reactExports.useEffect(() => {
	        if (mouseDownX == null) {
	            return;
	        }
	        const xStart = mouseDownX;
	        const handleMouseMove = (ee) => {
	            const diff = getX(ee) - xStart;
	            setDragOffset(-diff);
	        };
	        // TODO: Use `once` or something instead of this flag nonsense
	        let cleanedUp = false;
	        const handleMouseUp = () => {
	            if (cleanedUp) {
	                return;
	            }
	            document.removeEventListener("mousemove", handleMouseMove);
	            document.removeEventListener("touchmove", handleMouseMove);
	            document.removeEventListener("mouseup", handleMouseUp);
	            document.removeEventListener("touchend", handleMouseUp);
	            setMouseDownX(null);
	            cleanedUp = true;
	        };
	        document.addEventListener("mousemove", handleMouseMove);
	        document.addEventListener("touchmove", handleMouseMove);
	        document.addEventListener("touseup", handleMouseUp);
	        document.addEventListener("touchend", handleMouseUp);
	        return handleMouseUp;
	    }, [mouseDownX]);
	    const handleMouseDown = reactExports.useCallback((e) => {
	        setMouseDownX(getX(e));
	    }, []);
	    return { handleMouseDown, dragOffset, dragging: mouseDownX != null };
	}
	const Marquee = reactExports.memo(() => {
	    const text = useTypedSelector(getMarqueeText);
	    const doubled = useTypedSelector(getDoubled);
	    const marqueeStep = useTypedSelector(getMarqueeStep);
	    const stepMarquee$1 = useActionCreator(stepMarquee);
	    const { handleMouseDown, dragOffset, dragging } = useDragX();
	    const offset = stepOffset(text, marqueeStep, dragOffset);
	    const offsetPixels = pixelUnits(-offset);
	    useStepper({ step: stepMarquee$1, dragging });
	    return (jsxRuntimeExports.jsx("div", { id: "marquee", className: "text", onPointerDown: handleMouseDown, title: "Song Title", children: jsxRuntimeExports.jsx("div", { style: {
	                whiteSpace: "nowrap",
	                willChange: "transform",
	                transform: `translateX(${offsetPixels})`,
	            }, children: jsxRuntimeExports.jsx(CharacterString, { children: loopText(text) }) }, doubled ? "doubled" : "not-doubled") }));
	});

	const MonoStereo = reactExports.memo(() => {
	    const channels = useTypedSelector(getChannels);
	    return (jsxRuntimeExports.jsxs("div", { className: "mono-stereo", children: [jsxRuntimeExports.jsx("div", { id: "stereo", className: classnames({ selected: channels === 2 }) }), jsxRuntimeExports.jsx("div", { id: "mono", className: classnames({ selected: channels === 1 }) })] }));
	});

	function usePosition() {
	    const duration = useTypedSelector(getDuration);
	    const timeElapsed = useTypedSelector(getTimeElapsed);
	    const position = duration ? (Math.floor(timeElapsed) / duration) * 100 : 0;
	    const scrubPosition = useTypedSelector(getUserInputScrubPosition);
	    const userInputFocus = useTypedSelector(getUserInputFocus);
	    const displayedPosition = userInputFocus === "position" ? scrubPosition : position;
	    return [position, displayedPosition];
	}
	const Position = reactExports.memo(() => {
	    const [position, displayedPosition] = usePosition();
	    const dispatch = useTypedDispatch();
	    const seekToPercentComplete = reactExports.useCallback((e) => {
	        dispatch({
	            type: "SEEK_TO_PERCENT_COMPLETE",
	            percent: Number(e.target.value),
	        });
	        dispatch({ type: "UNSET_FOCUS" });
	    }, [dispatch]);
	    const setPosition = reactExports.useCallback((e) => {
	        dispatch({ type: "SET_FOCUS", input: "position" });
	        dispatch({
	            type: "SET_SCRUB_POSITION",
	            position: Number(e.target.value),
	        });
	    }, [dispatch]);
	    // In shade mode, the position slider shows up differently depending on if
	    // it's near the start, middle or end of its progress
	    let className = "";
	    if (position <= 33) {
	        className = "left";
	    }
	    else if (position >= 66) {
	        className = "right";
	    }
	    return (jsxRuntimeExports.jsx("input", { id: "position", className: className, type: "range", min: "0", max: "100", step: "1", style: { touchAction: "none" }, value: displayedPosition, onInput: setPosition, onChange: () => { } /* React complains without this, can probably rename onInput to onChange */, onPointerUp: seekToPercentComplete, onPointerDown: setPosition, title: "Seeking Bar" }));
	});

	const Repeat = reactExports.memo(() => {
	    const repeat = useTypedSelector(getRepeat);
	    const handleClick = useActionCreator(toggleRepeat);
	    return (jsxRuntimeExports.jsx(ContextMenuWraper, { renderContents: () => (jsxRuntimeExports.jsx(Node, { checked: repeat, label: "Repeat", onClick: handleClick, hotkey: "(R)" })), children: jsxRuntimeExports.jsx(WinampButton, { id: "repeat", className: classnames({ selected: repeat }), onClick: handleClick, title: "Toggle Repeat" }) }));
	});

	const Shade = reactExports.memo(() => {
	    const handleClick = useActionCreator(toggleMainWindowShadeMode);
	    return (jsxRuntimeExports.jsx(ClickedDiv, { id: "shade", onPointerDown: handleClick, onDoubleClick: (e) => e.stopPropagation(), title: "Toggle Windowshade Mode" }));
	});

	const Minimize = reactExports.memo(() => {
	    const minimize$1 = useActionCreator(minimize);
	    return jsxRuntimeExports.jsx(ClickedDiv, { id: "minimize", title: "Minimize", onClick: minimize$1 });
	});

	const Shuffle = reactExports.memo(() => {
	    const shuffle = useTypedSelector(getShuffle);
	    const handleClick = useActionCreator(toggleShuffle);
	    return (jsxRuntimeExports.jsx(ContextMenuWraper, { renderContents: () => (jsxRuntimeExports.jsx(Node, { checked: shuffle, label: "Shuffle", onClick: handleClick, hotkey: "(S)" })), children: jsxRuntimeExports.jsx(WinampButton, { id: "shuffle", className: classnames({ selected: shuffle }), onClick: handleClick, title: "Toggle Shuffle" }) }));
	});

	const Time = reactExports.memo(() => {
	    const toggleTimeMode$1 = useActionCreator(toggleTimeMode);
	    const timeElapsed = useTypedSelector(getTimeElapsed);
	    const duration = useTypedSelector(getDuration) || 0;
	    const timeMode = useTypedSelector(getTimeMode);
	    const seconds = timeMode === TIME_MODE.ELAPSED ? timeElapsed : duration - timeElapsed;
	    const timeObj = getTimeObj(seconds);
	    return (jsxRuntimeExports.jsxs("div", { id: "time", onClick: toggleTimeMode$1, className: "countdown", children: [timeMode === TIME_MODE.REMAINING && jsxRuntimeExports.jsx("div", { id: "minus-sign" }), jsxRuntimeExports.jsx("div", { id: "minute-first-digit", className: `digit digit-${timeObj.minutesFirstDigit}` }), jsxRuntimeExports.jsx("div", { id: "minute-second-digit", className: `digit digit-${timeObj.minutesSecondDigit}` }), jsxRuntimeExports.jsx("div", { id: "second-first-digit", className: `digit digit-${timeObj.secondsFirstDigit}` }), jsxRuntimeExports.jsx("div", { id: "second-second-digit", className: `digit digit-${timeObj.secondsSecondDigit}` })] }));
	});

	function Volume({ id, style, className }) {
	    const volume = useTypedSelector(getVolume);
	    const setFocus$1 = useActionCreator(setFocus);
	    const unsetFocus$1 = useActionCreator(unsetFocus);
	    const setVolume$1 = useActionCreator(setVolume);
	    return (jsxRuntimeExports.jsx("input", { id: id, type: "range", min: "0", max: "100", step: "1", value: volume, style: { ...style, touchAction: "none" }, className: className, onChange: (e) => setVolume$1(Number(e.target.value)), onPointerDown: () => setFocus$1("volume"), onPointerUp: unsetFocus$1, title: "Volume Bar" }));
	}

	const MainVolume = reactExports.memo(() => {
	    const volume = useTypedSelector(getVolume);
	    const percent = volume / 100;
	    const sprite = Math.round(percent * 28);
	    const offset = (sprite - 1) * 15;
	    const style = {
	        backgroundPosition: `0 -${offset}px`,
	    };
	    return (jsxRuntimeExports.jsx("div", { id: "volume", style: style, children: jsxRuntimeExports.jsx(Volume, {}) }));
	});

	function loadMediaAndPlay(e) {
	    return loadMedia(e, LOAD_STYLE.PLAY);
	}
	const MainWindow = reactExports.memo(({ analyser, filePickers }) => {
	    const mainShade = useTypedSelector(getWindowShade)("main");
	    const status = useTypedSelector(getMediaStatus);
	    const focused = useTypedSelector(getFocusedWindow);
	    const loading = useTypedSelector(getLoading);
	    const doubled = useTypedSelector(getDoubled);
	    const llama = useTypedSelector(getLlamaMode);
	    const working = useTypedSelector(getWorking);
	    const className = classnames({
	        window: true,
	        play: status === MEDIA_STATUS.PLAYING,
	        stop: status === MEDIA_STATUS.STOPPED,
	        pause: status === MEDIA_STATUS.PAUSED,
	        selected: focused === WINDOWS.MAIN,
	        shade: mainShade,
	        draggable: true,
	        loading,
	        doubled,
	        llama,
	    });
	    const toggleMainWindowShadeMode$1 = useActionCreator(toggleMainWindowShadeMode);
	    const scrollVolume$1 = useActionCreator(scrollVolume);
	    const loadMedia = useActionCreator(loadMediaAndPlay);
	    return (jsxRuntimeExports.jsx(DropTarget, { id: "main-window", windowId: WINDOWS.MAIN, className: className, handleDrop: loadMedia, onWheelActive: scrollVolume$1, children: jsxRuntimeExports.jsxs(FocusTarget, { windowId: WINDOWS.MAIN, children: [jsxRuntimeExports.jsxs("div", { id: "title-bar", className: "selected draggable", onDoubleClick: toggleMainWindowShadeMode$1, children: [jsxRuntimeExports.jsx(ContextMenuTarget, { id: "option-context", bottom: true, renderMenu: () => jsxRuntimeExports.jsx(MainContextMenu, { filePickers: filePickers }), children: jsxRuntimeExports.jsx(ClickedDiv, { id: "option", title: "Winamp Menu" }) }), mainShade && jsxRuntimeExports.jsx(MiniTime, {}), jsxRuntimeExports.jsx(Minimize, {}), jsxRuntimeExports.jsx(Shade, {}), jsxRuntimeExports.jsx(Close, {})] }), jsxRuntimeExports.jsxs("div", { className: "webamp-status", children: [jsxRuntimeExports.jsx(ClutterBar, {}), !working && jsxRuntimeExports.jsx("div", { id: "play-pause" }), jsxRuntimeExports.jsx("div", { id: "work-indicator", className: classnames({ selected: working }) }), jsxRuntimeExports.jsx(Time, {})] }), jsxRuntimeExports.jsx(Vis, { analyser: analyser }), jsxRuntimeExports.jsxs("div", { className: "media-info", children: [jsxRuntimeExports.jsx(Marquee, {}), jsxRuntimeExports.jsx(Kbps, {}), jsxRuntimeExports.jsx(Khz, {}), jsxRuntimeExports.jsx(MonoStereo, {})] }), jsxRuntimeExports.jsx(MainVolume, {}), jsxRuntimeExports.jsx(MainBalance, {}), jsxRuntimeExports.jsxs("div", { className: "windows", children: [jsxRuntimeExports.jsx(EqToggleButton, {}), jsxRuntimeExports.jsx(PlaylistToggleButton, {})] }), jsxRuntimeExports.jsx(Position, {}), jsxRuntimeExports.jsx(ActionButtons, {}), jsxRuntimeExports.jsx(Eject, {}), jsxRuntimeExports.jsxs("div", { className: "shuffle-repeat", children: [jsxRuntimeExports.jsx(Shuffle, {}), jsxRuntimeExports.jsx(Repeat, {})] }), jsxRuntimeExports.jsx("a", { id: "about", target: "_blank", href: "https://webamp.org/about", title: "About" })] }) }));
	});

	function PlaylistResizeTarget({ widthOnly }) {
	    const windowSize = useTypedSelector(getWindowSize);
	    const setWindowSize$1 = useActionCreator(setWindowSize);
	    const currentSize = windowSize("playlist");
	    return (jsxRuntimeExports.jsx(ResizeTarget$1, { currentSize: currentSize, id: "playlist-resize-target", setWindowSize: (size) => {
	            setWindowSize$1("playlist", size);
	        }, widthOnly: widthOnly }));
	}

	function PlaylistShade() {
	    const focused = useTypedSelector(getFocusedWindow);
	    const getWindowSize$1 = useTypedSelector(getWindowSize);
	    const playlistSize = getWindowSize$1("playlist");
	    const duration = useTypedSelector(getDuration);
	    const name = useTypedSelector(getMinimalMediaText);
	    const closeWindow$1 = useActionCreator(closeWindow);
	    const toggleShade = useActionCreator(togglePlaylistShadeMode);
	    const focusWindow = useActionCreator(setFocusedWindow);
	    const addedWidth = playlistSize[0] * WINDOW_RESIZE_SEGMENT_WIDTH;
	    const trimmedName = reactExports.useMemo(() => {
	        if (name == null) {
	            return "[No file]";
	        }
	        const MIN_NAME_WIDTH = 205;
	        const nameLength = (MIN_NAME_WIDTH + addedWidth) / CHARACTER_WIDTH;
	        return name.length > nameLength
	            ? name.slice(0, nameLength - 1) + UTF8_ELLIPSIS
	            : name;
	    }, [addedWidth, name]);
	    const time = reactExports.useMemo(() => {
	        return name == null ? "" : getTimeStr(duration);
	    }, [duration, name]);
	    return (jsxRuntimeExports.jsx("div", { id: "playlist-window-shade", className: classnames("window", "draggable", {
	            selected: focused === WINDOWS.PLAYLIST,
	        }), style: { width: `${WINDOW_WIDTH + addedWidth}px` }, onPointerDown: () => focusWindow("playlist"), onDoubleClick: toggleShade, children: jsxRuntimeExports.jsx("div", { className: "left", children: jsxRuntimeExports.jsxs("div", { className: "right draggable", children: [jsxRuntimeExports.jsx("div", { id: "playlist-shade-track-title", children: jsxRuntimeExports.jsx(CharacterString, { children: trimmedName }) }), jsxRuntimeExports.jsx("div", { id: "playlist-shade-time", children: jsxRuntimeExports.jsx(CharacterString, { children: time }) }), jsxRuntimeExports.jsx(PlaylistResizeTarget, { widthOnly: true }), jsxRuntimeExports.jsx(WinampButton, { id: "playlist-shade-button", onClick: toggleShade }), jsxRuntimeExports.jsx(WinampButton, { id: "playlist-close-button", onClick: () => closeWindow$1("playlist") })] }) }) }));
	}

	// We implement hover ourselves, because we hate ourselves and https://stackoverflow.com/a/13259049/1263117
	function PlaylistMenuEntry({ children }) {
	    const { ref, hover } = useIsHovered();
	    return (jsxRuntimeExports.jsx("li", { ref: ref, className: classnames({ hover }), children: children }));
	}
	var PlaylistMenuEntry$1 = reactExports.memo(PlaylistMenuEntry);

	function PlaylistMenu(props) {
	    const [selected, setSelected] = reactExports.useState(false);
	    const [ref, setRef] = reactExports.useState(null);
	    const callback = reactExports.useCallback(() => {
	        // If we've clicked on a Context Menu spawed inside this menu, it will
	        // register as an external click. However, hiding the menu will remove
	        // the Context Menu from the DOM. Therefore, we wait until the next
	        // event loop to actually hide ourselves.
	        setTimeout(() => {
	            // Close the menu
	            setSelected(false);
	        }, 0);
	    }, []);
	    useOnClickAway(ref, selected ? callback : null);
	    return (jsxRuntimeExports.jsxs("div", { id: props.id, className: classnames("playlist-menu", {
	            selected,
	        }), ref: setRef, onClick: () => setSelected((selected_) => !selected_), children: [jsxRuntimeExports.jsx("div", { className: "bar" }), selected && (jsxRuntimeExports.jsx("ul", { children: reactExports.Children.map(props.children, (child, i) => (jsxRuntimeExports.jsx(PlaylistMenuEntry$1, { children: child }, i))) }))] }));
	}
	var PlaylistMenu$1 = reactExports.memo(PlaylistMenu);

	const AddMenu = () => {
	    const nextIndex = useTypedSelector(getTrackCount);
	    const addDirAtIndex$1 = useActionCreator(addDirAtIndex);
	    const addFilesAtIndex$1 = useActionCreator(addFilesAtIndex);
	    const addFilesFromUrl$1 = useActionCreator(addFilesFromUrl);
	    return (jsxRuntimeExports.jsxs(PlaylistMenu$1, { id: "playlist-add-menu", children: [jsxRuntimeExports.jsx("div", { className: "add-url", onClick: () => addFilesFromUrl$1(nextIndex) }), jsxRuntimeExports.jsx("div", { className: "add-dir", onClick: () => addDirAtIndex$1(nextIndex) }), jsxRuntimeExports.jsx("div", { className: "add-file", onClick: () => addFilesAtIndex$1(nextIndex) })] }));
	};

	/* eslint-disable no-alert */
	const RemoveMenu = () => {
	    const removeSelected = useActionCreator(removeSelectedTracks);
	    const removeAll = useActionCreator(removeAllTracks);
	    const crop = useActionCreator(cropPlaylist);
	    return (jsxRuntimeExports.jsxs(PlaylistMenu$1, { id: "playlist-remove-menu", children: [jsxRuntimeExports.jsx("div", { className: "remove-misc", onClick: () => alert("Not supported in Webamp") }), jsxRuntimeExports.jsx("div", { className: "remove-all", onClick: removeAll }), jsxRuntimeExports.jsx("div", { className: "crop", onClick: crop }), jsxRuntimeExports.jsx("div", { className: "remove-selected", onClick: removeSelected })] }));
	};

	function SelectionMenu() {
	    const invert = useActionCreator(invertSelection);
	    const zero = useActionCreator(selectZero);
	    const all = useActionCreator(selectAll);
	    return (jsxRuntimeExports.jsxs(PlaylistMenu$1, { id: "playlist-selection-menu", children: [jsxRuntimeExports.jsx("div", { className: "invert-selection", onClick: invert }), jsxRuntimeExports.jsx("div", { className: "select-zero", onClick: zero }), jsxRuntimeExports.jsx("div", { className: "select-all", onClick: all })] }));
	}

	/* eslint-disable no-alert */
	/* TODO: This should really be kitty-corner to the upper right hand corner of the MiscMenu */
	function SortContextMenu() {
	    const reverseList$1 = useActionCreator(reverseList);
	    const randomizeList$1 = useActionCreator(randomizeList);
	    const sortListByTitle$1 = useActionCreator(sortListByTitle);
	    return (jsxRuntimeExports.jsx(ContextMenuTarget, { style: { width: "100%", height: "100%" }, top: true, renderMenu: () => (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Node, { label: "Sort list by title", onClick: sortListByTitle$1 }), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { label: "Reverse list", onClick: reverseList$1 }), jsxRuntimeExports.jsx(Node, { label: "Randomize list", onClick: randomizeList$1 })] })), children: jsxRuntimeExports.jsx("div", {}) }));
	}

	const MiscOptionsContextMenu = () => {
	    const downloadHtmlPlaylist$1 = useActionCreator(downloadHtmlPlaylist);
	    return (jsxRuntimeExports.jsx(ContextMenuTarget, { style: { width: "100%", height: "100%" }, top: true, renderMenu: () => (jsxRuntimeExports.jsx(Node, { onClick: downloadHtmlPlaylist$1, label: "Generate HTML playlist" })), children: jsxRuntimeExports.jsx("div", {}) }));
	};

	const MiscMenu = () => (jsxRuntimeExports.jsxs(PlaylistMenu$1, { id: "playlist-misc-menu", children: [jsxRuntimeExports.jsx("div", { className: "sort-list", onClick: (e) => e.stopPropagation(), children: jsxRuntimeExports.jsx(SortContextMenu, {}) }), jsxRuntimeExports.jsx("div", { className: "file-info", onClick: () => alert("Not supported in Webamp") }), jsxRuntimeExports.jsx("div", { className: "misc-options", onClick: (e) => e.stopPropagation(), children: jsxRuntimeExports.jsx(MiscOptionsContextMenu, {}) })] }));

	/* eslint-disable no-alert */
	function ListMenu() {
	    const removeAllTracks$1 = useActionCreator(removeAllTracks);
	    const addFilesFromList$1 = useActionCreator(addFilesFromList);
	    const saveFilesToList$1 = useActionCreator(saveFilesToList);
	    return (jsxRuntimeExports.jsxs(PlaylistMenu$1, { id: "playlist-list-menu", children: [jsxRuntimeExports.jsx("div", { className: "new-list", onClick: removeAllTracks$1 }), jsxRuntimeExports.jsx("div", { className: "save-list", onClick: saveFilesToList$1 }), jsxRuntimeExports.jsx("div", { className: "load-list", onClick: addFilesFromList$1 })] }));
	}

	// While all the browsers I care about support String.prototype.padEnd,
	// Not all node versions do, and I want tests to pass in Jest...
	// Sigh.
	function rightPad(str, len, fillChar) {
	    while (str.length < len) {
	        str += fillChar;
	    }
	    return str;
	}
	const RunningTimeDisplay = () => {
	    const runningTimeMessage = useTypedSelector(getRunningTimeMessage);
	    const text = reactExports.useMemo(() => rightPad(runningTimeMessage, 18, " "), [runningTimeMessage]);
	    return (jsxRuntimeExports.jsx("div", { className: "playlist-running-time-display draggable", children: jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(CharacterString, { children: text }) }) }));
	};

	const PlaylistWindow$1 = () => {
	    const play$1 = useActionCreator(play);
	    const pause$1 = useActionCreator(pause);
	    const stop$1 = useActionCreator(stop);
	    const openMediaFileDialog$1 = useActionCreator(openMediaFileDialog);
	    const next$1 = useActionCreator(next);
	    const previous$1 = useActionCreator(previous);
	    return (jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [jsxRuntimeExports.jsx(RunningTimeDisplay, {}), jsxRuntimeExports.jsxs("div", { className: "playlist-action-buttons", children: [jsxRuntimeExports.jsx("div", { className: "playlist-previous-button", onClick: previous$1 }), jsxRuntimeExports.jsx("div", { className: "playlist-play-button", onClick: play$1 }), jsxRuntimeExports.jsx("div", { className: "playlist-pause-button", onClick: pause$1 }), jsxRuntimeExports.jsx("div", { className: "playlist-stop-button", onClick: stop$1 }), jsxRuntimeExports.jsx("div", { className: "playlist-next-button", onClick: next$1 }), jsxRuntimeExports.jsx("div", { className: "playlist-eject-button", onClick: openMediaFileDialog$1 })] }), jsxRuntimeExports.jsx(MiniTime, {})] }));
	};

	function TrackCell({ children, handleMoveClick, index, id }) {
	    const skinPlaylistStyle = useTypedSelector(getSkinPlaylistStyle);
	    const selectedTrackIds = useTypedSelector(getSelectedTrackIdsSet);
	    const currentTrackId = useTypedSelector(getCurrentTrackId);
	    const selected = selectedTrackIds.has(id);
	    const current = currentTrackId === id;
	    const dispatch = useTypedDispatch();
	    const playTrackNow$1 = useActionCreator(playTrackNow);
	    const onMouseDown = reactExports.useCallback((e) => {
	        if (e.shiftKey) {
	            e.preventDefault();
	            dispatch({ type: "SHIFT_CLICKED_TRACK", index });
	            return;
	        }
	        else if (e.metaKey || e.ctrlKey) {
	            e.preventDefault();
	            dispatch({ type: "CTRL_CLICKED_TRACK", index });
	            return;
	        }
	        if (!selected) {
	            dispatch({ type: "CLICKED_TRACK", index });
	        }
	        handleMoveClick(e);
	    }, [dispatch, handleMoveClick, index, selected]);
	    const handleTouchStart = reactExports.useCallback((e) => {
	        if (!selected) {
	            dispatch({ type: "CLICKED_TRACK", index });
	        }
	        handleMoveClick(e);
	        // There's no touch equivalent of onDoubleClick, so we fake one:
	        function handleSecondTap() {
	            playTrackNow$1(id);
	        }
	        e.target.addEventListener("touchstart", handleSecondTap);
	        setTimeout(() => {
	            // Technically we might be unmounted here, but that's fine since you
	            // can't tap an unmounted element and we will clean up eventually.
	            e.target.removeEventListener("touchstart", handleSecondTap);
	        }, 250);
	    }, [dispatch, handleMoveClick, id, index, playTrackNow$1, selected]);
	    const style = {
	        backgroundColor: selected ? skinPlaylistStyle.selectedbg : undefined,
	        color: current ? skinPlaylistStyle.current : undefined,
	    };
	    return (jsxRuntimeExports.jsx("div", { className: classnames("track-cell", { selected, current }), style: style, onClick: (e) => e.stopPropagation(), onMouseDown: onMouseDown, onTouchStart: handleTouchStart, onContextMenu: (e) => e.preventDefault(), onDoubleClick: () => playTrackNow$1(id), children: children }));
	}

	const TrackTitle = ({ id, paddedTrackNumber }) => {
	    const title = useTypedSelector(getTrackDisplayName)(id);
	    return (jsxRuntimeExports.jsxs("span", { children: [paddedTrackNumber, ". ", title] }));
	};

	function getNumberLength(number) {
	    return number.toString().length;
	}
	function TrackList() {
	    const offset = useTypedSelector(getScrollOffset);
	    const trackIds = useTypedSelector(getVisibleTrackIds);
	    const tracks = useTypedSelector(getTracks);
	    const numberOfTracks = useTypedSelector(getNumberOfTracks);
	    const selectZero$1 = useActionCreator(selectZero);
	    const dragSelected$1 = useActionCreator(dragSelected);
	    const scrollPlaylistByDelta$1 = useActionCreator(scrollPlaylistByDelta);
	    const [node, setNode] = reactExports.useState(null);
	    const [moving, setMoving] = reactExports.useState(false);
	    const [mouseStartY, setMouseStartY] = reactExports.useState(null);
	    const _handleMoveClick = (e) => {
	        setMoving(true);
	        setMouseStartY(getY(e));
	    };
	    reactExports.useEffect(() => {
	        if (node == null || mouseStartY == null || moving === false) {
	            return;
	        }
	        const { top, bottom, left, right } = node.getBoundingClientRect();
	        let lastDiff = 0;
	        const handleMouseMove = (ee) => {
	            const x = getX(ee);
	            const y = getY(ee);
	            if (y < top || y > bottom || x < left || x > right) {
	                // Mouse is outside the track list
	                return;
	            }
	            const proposedDiff = Math.floor((y - mouseStartY) / TRACK_HEIGHT);
	            if (proposedDiff !== lastDiff) {
	                const diffDiff = proposedDiff - lastDiff;
	                dragSelected$1(diffDiff);
	                lastDiff = proposedDiff;
	            }
	        };
	        // A little indirect here. Basically, we set `moving` false here which
	        // causes our useEffect to rerun which removes all of these event listeners.
	        // It might be a little tigher to actually remove these listeners in the
	        // `handleMouseUp` callback, but... I'm lazy.
	        const handleMouseUp = () => setMoving(false);
	        window.addEventListener("mouseup", handleMouseUp);
	        window.addEventListener("mousemove", handleMouseMove);
	        window.addEventListener("touchend", handleMouseUp);
	        window.addEventListener("touchmove", handleMouseMove);
	        return () => {
	            window.removeEventListener("mousemove", handleMouseMove);
	            window.removeEventListener("touchmove", handleMouseMove);
	            window.removeEventListener("mouseup", handleMouseUp);
	            window.removeEventListener("touchend", handleMouseUp);
	        };
	        // I'm not 100% sure how well this would work if it rebound mid drag, so
	        // we'll just pretend it's okay that we have stale values in there.
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [moving]);
	    function _renderTracks(format) {
	        return trackIds.map((id, i) => (jsxRuntimeExports.jsx(TrackCell, { id: id, index: offset + i, handleMoveClick: _handleMoveClick, children: format(id, i) }, id)));
	    }
	    const maxTrackNumberLength = getNumberLength(numberOfTracks);
	    const paddedTrackNumForIndex = (i) => (i + 1 + offset).toString().padStart(maxTrackNumberLength, "\u00A0");
	    reactExports.useEffect(() => {
	        if (node == null) {
	            return;
	        }
	        // Chome changed wheel events to be passive be default. We need active (so
	        // we can prevent default) and React does not have a way to control this, so
	        // we must bind our own events.
	        //
	        // https://github.com/facebook/react/issues/14856#issuecomment-806052402
	        node.addEventListener("wheel", scrollPlaylistByDelta$1, { passive: false });
	        return () => {
	            node.removeEventListener("wheel", scrollPlaylistByDelta$1);
	        };
	    }, [node, scrollPlaylistByDelta$1]);
	    return (jsxRuntimeExports.jsxs("div", { ref: setNode, className: "playlist-tracks", style: { height: "100%", userSelect: "none" }, onClick: selectZero$1, children: [jsxRuntimeExports.jsx("div", { className: "playlist-track-titles", children: _renderTracks((id, i) => (jsxRuntimeExports.jsx(TrackTitle, { id: id, paddedTrackNumber: paddedTrackNumForIndex(i) }))) }), jsxRuntimeExports.jsx("div", { className: "playlist-track-durations", children: _renderTracks((id) => getTimeStr(tracks[id].duration)) })] }));
	}

	// `<input type="range" />` can be rotated to become a vertical slider using
	// CSS, but that makes it impossible to style the handle in a pixel perfect
	// manner. Instead we reimplement it in React.
	function VerticalSlider({ value, height, width, handle, handleHeight, onBeforeChange, onChange, onAfterChange, requireClicksOriginateLocally = true, disabled, }) {
	    const ref = reactExports.useRef(null);
	    const handleRef = reactExports.useRef(null);
	    function registerMoveListener({ target, clientY }) {
	        const sliderNode = ref.current;
	        const handleNode = handleRef.current;
	        if (sliderNode == null || handleNode == null) {
	            // I don't think this could ever happen in practice
	            return null;
	        }
	        const sliderRect = sliderNode.getBoundingClientRect();
	        const handleRect = handleNode.getBoundingClientRect();
	        const { top: sliderTop, height: sliderHeight } = sliderRect;
	        const { top: handleTop, height: realHandleHeight } = handleRect;
	        // If the user clicks on the handle we want them to continue to hold onto
	        // that point of te handle. If they click outside of the handle (in the
	        // slider itself) we want to center the handle at that point and have them
	        // move the handle from the center.
	        const handleOffset = handleNode.contains(target)
	            ? clientY - handleTop
	            : realHandleHeight / 2;
	        const baseOffset = sliderTop + handleOffset;
	        // Measure the actual rect height rather than use the `height` prop, becuase
	        // we might be in double-size mode.
	        const spanSize = sliderHeight - realHandleHeight;
	        function moveToPosition(y) {
	            // Ensure dragging does not cause elements/text to be selected.
	            // https://stackoverflow.com/a/19164149/1263117
	            const startOffset = y - baseOffset;
	            onChange(clamp(startOffset / spanSize, 0, 1));
	        }
	        const handlePointerMove = (event) => {
	            event.preventDefault();
	            moveToPosition(event.clientY);
	        };
	        const handleRelease = () => {
	            if (onAfterChange != null) {
	                onAfterChange();
	            }
	            document.removeEventListener("pointermove", handlePointerMove);
	            document.removeEventListener("pointerup", handleRelease);
	        };
	        document.addEventListener("pointermove", handlePointerMove);
	        document.addEventListener("pointerup", handleRelease);
	        if (onBeforeChange != null) {
	            onBeforeChange();
	        }
	        // Move the slider to where they've started.
	        moveToPosition(clientY);
	    }
	    function handlePointerDown(e) {
	        e.preventDefault();
	        registerMoveListener({
	            target: e.target,
	            clientY: e.clientY,
	        });
	    }
	    // We watch for events onPointerEnter only when requireClicksOriginateLocally === false
	    // If the mouse/touch enters the Slider area, and the button/touch is already down, trigger a PointerDown
	    function handlePointerEnter(e) {
	        if (e.buttons === 1) {
	            handlePointerDown(e);
	        }
	    }
	    const offset = Math.floor((height - handleHeight) * value);
	    return (jsxRuntimeExports.jsx("div", { style: { height, width }, onPointerDown: disabled ? undefined : handlePointerDown, onPointerEnter: disabled || requireClicksOriginateLocally
	            ? undefined
	            : handlePointerEnter, ref: ref, children: jsxRuntimeExports.jsx("div", { style: { transform: `translateY(${offset}px)` }, ref: handleRef, children: handle }) }));
	}

	const HANDLE_HEIGHT = 18;
	const Handle$1 = () => (jsxRuntimeExports.jsx("div", { className: "playlist-scrollbar-handle", style: { height: HANDLE_HEIGHT } }));
	function PlaylistScrollBar() {
	    const getWindowPixelSize$1 = useTypedSelector(getWindowPixelSize);
	    const playlistHeight = getWindowPixelSize$1(WINDOWS.PLAYLIST).height;
	    const playlistScrollPosition = useTypedSelector(getPlaylistScrollPosition);
	    const allTracksAreVisible = useTypedSelector(getAllTracksAreVisible);
	    const setPlaylistScrollPosition$1 = useActionCreator(setPlaylistScrollPosition);
	    return (jsxRuntimeExports.jsx("div", { className: "playlist-scrollbar", style: { marginLeft: 5 }, children: jsxRuntimeExports.jsx(VerticalSlider, { height: playlistHeight - 58, handleHeight: HANDLE_HEIGHT, width: 8, value: playlistScrollPosition / 100, onChange: (val) => setPlaylistScrollPosition$1(val * 100), handle: jsxRuntimeExports.jsx(Handle$1, {}), disabled: allTracksAreVisible }) }));
	}

	function _maxTrackIndex(state) {
	    return state.playlist.trackOrder.length - 1;
	}
	function PlaylistWindow({ analyser }) {
	    const offset = useTypedSelector(getScrollOffset);
	    const getWindowSize$1 = useTypedSelector(getWindowSize);
	    const selectedWindow = useTypedSelector(getFocusedWindow);
	    const getWindowShade$1 = useTypedSelector(getWindowShade);
	    const getWindowOpen$1 = useTypedSelector(getWindowOpen);
	    const maxTrackIndex = useTypedSelector(_maxTrackIndex);
	    const skinPlaylistStyle = useTypedSelector(getSkinPlaylistStyle);
	    const getWindowPixelSize$1 = useTypedSelector(getWindowPixelSize);
	    const selected = selectedWindow === WINDOWS.PLAYLIST;
	    const playlistShade = Boolean(getWindowShade$1(WINDOWS.PLAYLIST));
	    const playlistSize = getWindowSize$1(WINDOWS.PLAYLIST);
	    const playlistWindowPixelSize = getWindowPixelSize$1(WINDOWS.PLAYLIST);
	    const close = useActionCreator(closeWindow);
	    const toggleShade = useActionCreator(togglePlaylistShadeMode);
	    const scrollUpFourTracks$1 = useActionCreator(scrollUpFourTracks);
	    const scrollDownFourTracks$1 = useActionCreator(scrollDownFourTracks);
	    const scrollPlaylistByDelta$1 = useActionCreator(scrollPlaylistByDelta);
	    const loadMedia$1 = useActionCreator(loadMedia);
	    const showVisualizer = playlistSize[0] > 2;
	    const activateVisualizer = !getWindowOpen$1(WINDOWS.MAIN);
	    const handleDrop = reactExports.useCallback((e, targetCoords) => {
	        const top = e.clientY - targetCoords.y;
	        const atIndex = clamp(offset + Math.round((top - 23) / TRACK_HEIGHT), 0, maxTrackIndex + 1);
	        loadMedia$1(e, LOAD_STYLE.NONE, atIndex);
	    }, [loadMedia$1, maxTrackIndex, offset]);
	    if (playlistShade) {
	        return jsxRuntimeExports.jsx(PlaylistShade, {});
	    }
	    const style = {
	        color: skinPlaylistStyle.normal,
	        backgroundColor: skinPlaylistStyle.normalbg,
	        fontFamily: `${skinPlaylistStyle.font}, Arial, sans-serif`,
	        height: `${playlistWindowPixelSize.height}px`,
	        width: `${playlistWindowPixelSize.width}px`,
	    };
	    const classes = classnames("window", "draggable", { selected });
	    const showSpacers = playlistSize[0] % 2 === 0;
	    return (jsxRuntimeExports.jsx(FocusTarget, { windowId: WINDOWS.PLAYLIST, children: jsxRuntimeExports.jsxs(DropTarget, { id: "playlist-window", windowId: WINDOWS.PLAYLIST, className: classes, style: style, handleDrop: handleDrop, onWheelActive: scrollPlaylistByDelta$1, children: [jsxRuntimeExports.jsxs("div", { className: "playlist-top draggable", onDoubleClick: toggleShade, children: [jsxRuntimeExports.jsx("div", { className: "playlist-top-left draggable" }), showSpacers && (jsxRuntimeExports.jsx("div", { className: "playlist-top-left-spacer draggable" })), jsxRuntimeExports.jsx("div", { className: "playlist-top-left-fill draggable" }), jsxRuntimeExports.jsx("div", { className: "playlist-top-title draggable" }), showSpacers && (jsxRuntimeExports.jsx("div", { className: "playlist-top-right-spacer draggable" })), jsxRuntimeExports.jsx("div", { className: "playlist-top-right-fill draggable" }), jsxRuntimeExports.jsxs("div", { className: "playlist-top-right draggable", children: [jsxRuntimeExports.jsx(WinampButton, { id: "playlist-shade-button", onClick: toggleShade }), jsxRuntimeExports.jsx(WinampButton, { id: "playlist-close-button", onClick: () => close(WINDOWS.PLAYLIST) })] })] }), jsxRuntimeExports.jsxs("div", { className: "playlist-middle draggable", children: [jsxRuntimeExports.jsx("div", { className: "playlist-middle-left draggable" }), jsxRuntimeExports.jsx("div", { className: "playlist-middle-center", children: jsxRuntimeExports.jsx(TrackList, {}) }), jsxRuntimeExports.jsx(WinampButton, { className: "playlist-middle-right draggable", children: jsxRuntimeExports.jsx(PlaylistScrollBar, {}) })] }), jsxRuntimeExports.jsxs("div", { className: "playlist-bottom draggable", children: [jsxRuntimeExports.jsxs("div", { className: "playlist-bottom-left draggable", children: [jsxRuntimeExports.jsx(AddMenu, {}), jsxRuntimeExports.jsx(RemoveMenu, {}), jsxRuntimeExports.jsx(SelectionMenu, {}), jsxRuntimeExports.jsx(MiscMenu, {})] }), jsxRuntimeExports.jsx("div", { className: "playlist-bottom-center draggable" }), jsxRuntimeExports.jsxs("div", { className: "playlist-bottom-right draggable", children: [showVisualizer && (jsxRuntimeExports.jsx("div", { className: "playlist-visualizer", children: activateVisualizer && (jsxRuntimeExports.jsx("div", { className: "visualizer-wrapper", children: jsxRuntimeExports.jsx(Vis, { analyser: analyser }) })) })), jsxRuntimeExports.jsx(PlaylistWindow$1, {}), jsxRuntimeExports.jsx(ListMenu, {}), jsxRuntimeExports.jsx("div", { id: "playlist-scroll-up-button", onClick: scrollUpFourTracks$1 }), jsxRuntimeExports.jsx("div", { id: "playlist-scroll-down-button", onClick: scrollDownFourTracks$1 }), jsxRuntimeExports.jsx(PlaylistResizeTarget, {})] })] })] }) }));
	}

	const MAX_VALUE = 100;
	// Given a value between 1-100, return the sprite number (0-27)
	const spriteNumber = (value) => {
	    const percent = value / MAX_VALUE;
	    return Math.round(percent * 27);
	};
	// Given a sprite number, return the x,y
	const spriteOffsets = (number) => {
	    const x = number % 14;
	    const y = Math.floor(number / 14);
	    return { x, y };
	};
	const Handle = () => {
	    const style = { width: 11, height: 11, marginLeft: 1 };
	    return jsxRuntimeExports.jsx("div", { style: style, className: "slider-handle" });
	};
	function Band({ id, onChange, band, clickOriginatedInEq, }) {
	    const sliders = useTypedSelector(getSliders);
	    const value = sliders[band];
	    const backgroundPosition = reactExports.useMemo(() => {
	        const { x, y } = spriteOffsets(spriteNumber(value));
	        const xOffset = x * 15; // Each sprite is 15px wide
	        const yOffset = y * 65; // Each sprite is 15px tall
	        return `-${xOffset}px -${yOffset}px`;
	    }, [value]);
	    const focusBand$1 = useActionCreator(focusBand);
	    const unsetFocus$1 = useActionCreator(unsetFocus);
	    // Note: The band background is actually one pixel taller (63) than the slider
	    // it contains (62).
	    return (jsxRuntimeExports.jsx(WinampButton, { id: id, className: "band", style: { backgroundPosition, height: 63 }, requireClicksOriginateLocally: !(band !== "preamp" && clickOriginatedInEq), children: jsxRuntimeExports.jsx(VerticalSlider, { height: 62, width: 14, handleHeight: 11, value: 1 - value / MAX_VALUE, onBeforeChange: () => focusBand$1(band), onChange: (val) => onChange((1 - val) * MAX_VALUE), onAfterChange: unsetFocus$1, requireClicksOriginateLocally: !(band !== "preamp" && clickOriginatedInEq), handle: jsxRuntimeExports.jsx(Handle, {}) }) }));
	}

	const EqOn = () => {
	    const toggleEq$1 = useActionCreator(toggleEq);
	    const on = useTypedSelector(getEqualizerEnabled);
	    return (jsxRuntimeExports.jsx(WinampButton, { id: "on", className: classnames({ selected: on }), onClick: toggleEq$1 }));
	};

	const EqAuto = reactExports.memo(() => {
	    const selected = useTypedSelector((state) => state.equalizer.auto);
	    const toggleAuto = useActionCreator(toggleEqAuto);
	    return (jsxRuntimeExports.jsx(WinampButton, { id: "auto", className: classnames({ selected }), onClick: toggleAuto }));
	});

	// Adapted from https://github.com/morganherlocker/cubic-spline

	function spline(xs, ys) {
	  const ks = getNaturalKs(xs, ys);
	  const maxX = xs[xs.length - 1];
	  const allYs = [];
	  let i = 1;
	  for (let x = 0; x <= maxX; x++) {
	    while (xs[i] < x) i++;
	    const t = (x - xs[i - 1]) / (xs[i] - xs[i - 1]);
	    const a = ks[i - 1] * (xs[i] - xs[i - 1]) - (ys[i] - ys[i - 1]);
	    const b = -ks[i] * (xs[i] - xs[i - 1]) + (ys[i] - ys[i - 1]);
	    const q = (1 - t) * ys[i - 1] + t * ys[i] + t * (1 - t) * (a * (1 - t) + b * t);
	    allYs.push(q);
	  }
	  return allYs;
	}
	function getNaturalKs(xs, ys) {
	  const ks = xs.map(() => 0);
	  const n = xs.length - 1;
	  const matrix = zerosMatrix(n + 1, n + 2);
	  for (let i = 1; i < n; i++ // rows
	  ) {
	    matrix[i][i - 1] = 1 / (xs[i] - xs[i - 1]);
	    matrix[i][i] = 2 * (1 / (xs[i] - xs[i - 1]) + 1 / (xs[i + 1] - xs[i]));
	    matrix[i][i + 1] = 1 / (xs[i + 1] - xs[i]);
	    matrix[i][n + 1] = 3 * ((ys[i] - ys[i - 1]) / ((xs[i] - xs[i - 1]) * (xs[i] - xs[i - 1])) + (ys[i + 1] - ys[i]) / ((xs[i + 1] - xs[i]) * (xs[i + 1] - xs[i])));
	  }
	  matrix[0][0] = 2 / (xs[1] - xs[0]);
	  matrix[0][1] = 1 / (xs[1] - xs[0]);
	  matrix[0][n + 1] = 3 * (ys[1] - ys[0]) / ((xs[1] - xs[0]) * (xs[1] - xs[0]));
	  matrix[n][n - 1] = 1 / (xs[n] - xs[n - 1]);
	  matrix[n][n] = 2 / (xs[n] - xs[n - 1]);
	  matrix[n][n + 1] = 3 * (ys[n] - ys[n - 1]) / ((xs[n] - xs[n - 1]) * (xs[n] - xs[n - 1]));
	  return solve(matrix, ks);
	}
	function solve(matrix, ks) {
	  const m = matrix.length;
	  // column
	  for (let k = 0; k < m; k++) {
	    // pivot for column
	    let iMax = 0;
	    let vali = Number.NEGATIVE_INFINITY;
	    for (let i = k; i < m; i++) if (matrix[i][k] > vali) {
	      iMax = i;
	      vali = matrix[i][k];
	    }
	    swapRows(matrix, k, iMax);

	    // for all rows below pivot
	    for (let i = k + 1; i < m; i++) {
	      for (let j = k + 1; j < m + 1; j++) matrix[i][j] = matrix[i][j] - matrix[k][j] * (matrix[i][k] / matrix[k][k]);
	      matrix[i][k] = 0;
	    }
	  }
	  // rows = columns
	  for (let i = m - 1; i >= 0; i--) {
	    const v = matrix[i][m] / matrix[i][i];
	    ks[i] = v;
	    // rows
	    for (let j = i - 1; j >= 0; j--) {
	      matrix[j][m] -= matrix[j][i] * v;
	      matrix[j][i] = 0;
	    }
	  }
	  return ks;
	}
	function zerosMatrix(rows, columns) {
	  const matrix = [];
	  for (let i = 0; i < rows; i++) {
	    matrix.push([]);
	    for (let j = 0; j < columns; j++) {
	      matrix[i].push(0);
	    }
	  }
	  return matrix;
	}
	function swapRows(m, k, l) {
	  const p = m[k];
	  m[k] = m[l];
	  m[l] = p;
	}

	const GRAPH_HEIGHT = 19;
	const GRAPH_WIDTH = 113;
	function EqGraph() {
	    const sliders = useTypedSelector(getSliders);
	    const preampLineImagePromise = useTypedSelector(getPreampLineImage);
	    const preampLineImage = usePromiseValueOrNull(preampLineImagePromise);
	    const [canvasNode, setCanvasNode] = reactExports.useState(null);
	    const canvasCtx = reactExports.useMemo(() => canvasNode?.getContext("2d") ?? null, [canvasNode]);
	    const colorPattern = useColorPattern(canvasCtx);
	    reactExports.useLayoutEffect(() => {
	        if (canvasCtx == null ||
	            canvasNode == null ||
	            preampLineImage == null ||
	            colorPattern == null) {
	            return;
	        }
	        const width = Number(canvasNode.width);
	        const height = Number(canvasNode.height);
	        canvasCtx.clearRect(0, 0, width, height);
	        drawEqLine({ colorPattern, sliders, canvasCtx, preampLineImage });
	    }, [canvasCtx, canvasNode, colorPattern, preampLineImage, sliders]);
	    return (jsxRuntimeExports.jsx("canvas", { id: "eqGraph", ref: setCanvasNode, width: GRAPH_WIDTH, height: GRAPH_HEIGHT }));
	}
	function useColorPattern(canvasCtx) {
	    const lineColorsImagePromise = useTypedSelector(getLineColorsImage);
	    const lineColorsImage = usePromiseValueOrNull(lineColorsImagePromise);
	    return reactExports.useMemo(() => {
	        if (canvasCtx == null || lineColorsImage == null) {
	            return null;
	        }
	        return canvasCtx.createPattern(lineColorsImage, "repeat-x");
	    }, [canvasCtx, lineColorsImage]);
	}
	function drawEqLine({ colorPattern, sliders, canvasCtx, preampLineImage, }) {
	    const preampValue = percentToRange(sliders.preamp / 100, 0, GRAPH_HEIGHT - 1);
	    canvasCtx.drawImage(preampLineImage, 0, preampValue, preampLineImage.width, preampLineImage.height);
	    const amplitudes = BANDS.map((band) => sliders[band]);
	    canvasCtx.fillStyle = colorPattern;
	    const paddingLeft = 2; // TODO: This should be 1.5
	    const min = 0;
	    const max = GRAPH_HEIGHT - 1;
	    const xs = [];
	    const ys = [];
	    amplitudes.forEach((value, i) => {
	        const percent = (100 - value) / 100;
	        // Each band is 12 pixels widex
	        xs.push(i * 12);
	        ys.push(percentToRange(percent, min, max));
	    });
	    const allYs = spline(xs, ys);
	    const maxX = xs[xs.length - 1];
	    let lastY = ys[0];
	    for (let x = 0; x <= maxX; x++) {
	        const y = clamp(Math.round(allYs[x]), 0, GRAPH_HEIGHT - 1);
	        const yTop = Math.min(y, lastY);
	        const height = 1 + Math.abs(lastY - y);
	        canvasCtx.fillRect(paddingLeft + x, yTop, 1, height);
	        lastY = y;
	    }
	}

	var type = "Winamp EQ library file v1.1";
	var presets = [
		{
			name: "Classical",
			hz60: 33,
			hz170: 33,
			hz310: 33,
			hz600: 33,
			hz1000: 33,
			hz3000: 33,
			hz6000: 20,
			hz12000: 20,
			hz14000: 20,
			hz16000: 16,
			preamp: 33
		},
		{
			name: "Club",
			hz60: 33,
			hz170: 33,
			hz310: 38,
			hz600: 42,
			hz1000: 42,
			hz3000: 42,
			hz6000: 38,
			hz12000: 33,
			hz14000: 33,
			hz16000: 33,
			preamp: 33
		},
		{
			name: "Dance",
			hz60: 48,
			hz170: 44,
			hz310: 36,
			hz600: 32,
			hz1000: 32,
			hz3000: 22,
			hz6000: 20,
			hz12000: 20,
			hz14000: 32,
			hz16000: 32,
			preamp: 33
		},
		{
			name: "Laptop speakers/headphones",
			hz60: 40,
			hz170: 50,
			hz310: 41,
			hz600: 26,
			hz1000: 28,
			hz3000: 35,
			hz6000: 40,
			hz12000: 48,
			hz14000: 53,
			hz16000: 56,
			preamp: 33
		},
		{
			name: "Large hall",
			hz60: 49,
			hz170: 49,
			hz310: 42,
			hz600: 42,
			hz1000: 33,
			hz3000: 24,
			hz6000: 24,
			hz12000: 24,
			hz14000: 33,
			hz16000: 33,
			preamp: 33
		},
		{
			name: "Party",
			hz60: 44,
			hz170: 44,
			hz310: 33,
			hz600: 33,
			hz1000: 33,
			hz3000: 33,
			hz6000: 33,
			hz12000: 33,
			hz14000: 44,
			hz16000: 44,
			preamp: 33
		},
		{
			name: "Pop",
			hz60: 29,
			hz170: 40,
			hz310: 44,
			hz600: 45,
			hz1000: 41,
			hz3000: 30,
			hz6000: 28,
			hz12000: 28,
			hz14000: 29,
			hz16000: 29,
			preamp: 33
		},
		{
			name: "Reggae",
			hz60: 33,
			hz170: 33,
			hz310: 31,
			hz600: 22,
			hz1000: 33,
			hz3000: 43,
			hz6000: 43,
			hz12000: 33,
			hz14000: 33,
			hz16000: 33,
			preamp: 33
		},
		{
			name: "Rock",
			hz60: 45,
			hz170: 40,
			hz310: 23,
			hz600: 19,
			hz1000: 26,
			hz3000: 39,
			hz6000: 47,
			hz12000: 50,
			hz14000: 50,
			hz16000: 50,
			preamp: 33
		},
		{
			name: "Soft",
			hz60: 40,
			hz170: 35,
			hz310: 30,
			hz600: 28,
			hz1000: 30,
			hz3000: 39,
			hz6000: 46,
			hz12000: 48,
			hz14000: 50,
			hz16000: 52,
			preamp: 33
		},
		{
			name: "Ska",
			hz60: 28,
			hz170: 24,
			hz310: 25,
			hz600: 31,
			hz1000: 39,
			hz3000: 42,
			hz6000: 47,
			hz12000: 48,
			hz14000: 50,
			hz16000: 48,
			preamp: 33
		},
		{
			name: "Full Bass",
			hz60: 48,
			hz170: 48,
			hz310: 48,
			hz600: 42,
			hz1000: 35,
			hz3000: 25,
			hz6000: 18,
			hz12000: 15,
			hz14000: 14,
			hz16000: 14,
			preamp: 33
		},
		{
			name: "Soft Rock",
			hz60: 39,
			hz170: 39,
			hz310: 36,
			hz600: 31,
			hz1000: 25,
			hz3000: 23,
			hz6000: 26,
			hz12000: 31,
			hz14000: 37,
			hz16000: 47,
			preamp: 33
		},
		{
			name: "Full Treble",
			hz60: 16,
			hz170: 16,
			hz310: 16,
			hz600: 25,
			hz1000: 37,
			hz3000: 50,
			hz6000: 58,
			hz12000: 58,
			hz14000: 58,
			hz16000: 60,
			preamp: 33
		},
		{
			name: "Full Bass & Treble",
			hz60: 44,
			hz170: 42,
			hz310: 33,
			hz600: 20,
			hz1000: 24,
			hz3000: 35,
			hz6000: 46,
			hz12000: 50,
			hz14000: 52,
			hz16000: 52,
			preamp: 33
		},
		{
			name: "Live",
			hz60: 24,
			hz170: 33,
			hz310: 39,
			hz600: 41,
			hz1000: 42,
			hz3000: 42,
			hz6000: 39,
			hz12000: 37,
			hz14000: 37,
			hz16000: 36,
			preamp: 33
		},
		{
			name: "Techno",
			hz60: 45,
			hz170: 42,
			hz310: 33,
			hz600: 23,
			hz1000: 24,
			hz3000: 33,
			hz6000: 45,
			hz12000: 48,
			hz14000: 48,
			hz16000: 47,
			preamp: 33
		}
	];
	var builtin = {
		type: type,
		presets: presets
	};

	const PresetsContextMenu = () => {
	    const openEqfFileDialog$1 = useActionCreator(openEqfFileDialog);
	    const downloadPreset$1 = useActionCreator(downloadPreset);
	    const setEqFromObject$1 = useActionCreator(setEqFromObject);
	    return (jsxRuntimeExports.jsx(ContextMenuTarget, { top: true, id: "presets-context", renderMenu: () => (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(Parent, { label: "Load", children: [builtin.presets.map((preset) => (jsxRuntimeExports.jsx(Node, { onClick: () => setEqFromObject$1(preset), label: preset.name }, preset.name))), jsxRuntimeExports.jsx(Hr, {}), jsxRuntimeExports.jsx(Node, { onClick: openEqfFileDialog$1, label: "From Eqf..." })] }), jsxRuntimeExports.jsx(Node, { onClick: downloadPreset$1, label: "Save" })] })), children: jsxRuntimeExports.jsx(WinampButton, { id: "presets" }) }));
	};

	function EqTitleButtons() {
	    const focusedWindow = useTypedSelector(getFocusedWindow);
	    const selected = focusedWindow === WINDOWS.EQUALIZER;
	    const closeWindow$1 = useActionCreator(closeWindow);
	    const toggleEqualizerShadeMode$1 = useActionCreator(toggleEqualizerShadeMode);
	    return (jsxRuntimeExports.jsxs(ClickedDiv, { id: "eq-buttons", children: [jsxRuntimeExports.jsx(WinampButton, { id: "equalizer-shade", onClick: toggleEqualizerShadeMode$1 }), jsxRuntimeExports.jsx(WinampButton, { id: "equalizer-close", onClick: () => closeWindow$1(WINDOWS.EQUALIZER) })] }, selected ? "selected" : "unselected"));
	}

	const EqualizerShade = () => {
	    const volume = useTypedSelector(getVolume);
	    const balance = useTypedSelector(getBalance);
	    const toggleEqualizerShadeMode$1 = useActionCreator(toggleEqualizerShadeMode);
	    const classes = ["left", "center", "right"];
	    const eqVolumeClassName = segment(0, 100, volume, classes);
	    const eqBalanceClassName = segment(-100, 100, balance, classes);
	    return (jsxRuntimeExports.jsxs("div", { className: "draggable", onDoubleClick: toggleEqualizerShadeMode$1, style: { width: "100%", height: "100%" }, children: [jsxRuntimeExports.jsx(EqTitleButtons, {}), jsxRuntimeExports.jsx(Volume, { id: "equalizer-volume", className: eqVolumeClassName }), jsxRuntimeExports.jsx(Balance, { id: "equalizer-balance", className: eqBalanceClassName })] }));
	};

	const bandClassName = (band) => `band-${band}`;
	const EqualizerWindow = () => {
	    const doubled = useTypedSelector(getDoubled);
	    const focusedWindow = useTypedSelector(getFocusedWindow);
	    const getWindowShade$1 = useTypedSelector(getWindowShade);
	    const selected = focusedWindow === WINDOWS.EQUALIZER;
	    const shade = getWindowShade$1(WINDOWS.EQUALIZER);
	    const setPreampValue = useActionCreator(setPreamp);
	    const setEqToMin$1 = useActionCreator(setEqToMin);
	    const setEqToMid$1 = useActionCreator(setEqToMid);
	    const setEqToMax$1 = useActionCreator(setEqToMax);
	    const setHertzValue = useActionCreator(setEqBand);
	    const toggleEqualizerShadeMode$1 = useActionCreator(toggleEqualizerShadeMode);
	    const className = classnames({
	        selected,
	        doubled,
	        shade,
	        window: true,
	        draggable: true,
	    });
	    // Track whether the click originated in the "hertz" area of the EQ
	    // We only want to allow drag across the EQ when the click originated in that area
	    const [clickOriginatedInEq, setClickOriginatedInEq] = reactExports.useState(false);
	    const onPointerDownHz = (e) => {
	        e.stopPropagation();
	        // Release the pointer capture
	        // https://w3c.github.io/pointerevents/#implicit-pointer-capture
	        // https://w3c.github.io/pointerevents/#pointer-capture
	        const target = e.target;
	        target.releasePointerCapture(e.pointerId);
	        setClickOriginatedInEq(true);
	        function onReleaseHz(ee) {
	            // Release only if it is the actual pointer release, not the simulated one coming from WinampButton
	            // Simulated pointer release coming from WinampButton has ee.detail == -42
	            // Actual pointer release here will come in as ee.detail === 0
	            if (ee.detail === 0) {
	                setClickOriginatedInEq(false);
	                document.removeEventListener("pointerup", onReleaseHz);
	            }
	        }
	        document.addEventListener("pointerup", onReleaseHz);
	    };
	    return (jsxRuntimeExports.jsx("div", { id: "equalizer-window", className: className, children: jsxRuntimeExports.jsx(FocusTarget, { windowId: WINDOWS.EQUALIZER, children: shade ? (jsxRuntimeExports.jsx(EqualizerShade, {})) : (jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("div", { className: "equalizer-top title-bar draggable", onDoubleClick: toggleEqualizerShadeMode$1, children: jsxRuntimeExports.jsx(EqTitleButtons, {}) }), jsxRuntimeExports.jsx(EqOn, {}), jsxRuntimeExports.jsx(EqAuto, {}), jsxRuntimeExports.jsx(EqGraph, {}), jsxRuntimeExports.jsx(PresetsContextMenu, {}), jsxRuntimeExports.jsx(Band, { id: "preamp", band: "preamp", onChange: setPreampValue }), jsxRuntimeExports.jsx("div", { id: "plus12db", onClick: setEqToMax$1 }), jsxRuntimeExports.jsx("div", { id: "zerodb", onClick: setEqToMid$1 }), jsxRuntimeExports.jsx("div", { id: "minus12db", onClick: setEqToMin$1 }), jsxRuntimeExports.jsx("div", { onPointerDown: onPointerDownHz, children: BANDS.map((hertz) => (jsxRuntimeExports.jsx(Band, { id: bandClassName(hertz), band: hertz, onChange: (value) => setHertzValue(hertz, value), clickOriginatedInEq: clickOriginatedInEq }, hertz))) })] })) }) }));
	};

	const imageSelectors = {
	    MAIN_BALANCE_BACKGROUND: ["#balance"],
	    MAIN_BALANCE_THUMB: [
	        "#balance::-webkit-slider-thumb",
	        "#balance::-moz-range-thumb",
	    ],
	    MAIN_BALANCE_THUMB_ACTIVE: [
	        "#balance:active::-webkit-slider-thumb",
	        "#balance:active::-moz-range-thumb",
	    ],
	    MAIN_PREVIOUS_BUTTON: [".actions #previous"],
	    MAIN_PREVIOUS_BUTTON_ACTIVE: [".actions #previous.winamp-active"],
	    MAIN_PLAY_BUTTON: [".actions #play"],
	    MAIN_PLAY_BUTTON_ACTIVE: [".actions #play.winamp-active"],
	    MAIN_PAUSE_BUTTON: [".actions #pause"],
	    MAIN_PAUSE_BUTTON_ACTIVE: [".actions #pause.winamp-active"],
	    MAIN_STOP_BUTTON: [".actions #stop"],
	    MAIN_STOP_BUTTON_ACTIVE: [".actions #stop.winamp-active"],
	    MAIN_NEXT_BUTTON: [".actions #next"],
	    MAIN_NEXT_BUTTON_ACTIVE: [".actions #next.winamp-active"],
	    MAIN_EJECT_BUTTON: ["#eject"],
	    MAIN_EJECT_BUTTON_ACTIVE: ["#eject.winamp-active"],
	    MAIN_WINDOW_BACKGROUND: ["#main-window"],
	    MAIN_STEREO: [".media-info #stereo", ".stop .media-info #stereo.selected"],
	    MAIN_STEREO_SELECTED: [".media-info #stereo.selected"],
	    MAIN_MONO: [".media-info #mono", ".stop .media-info #mono.selected"],
	    MAIN_MONO_SELECTED: [".media-info #mono.selected"],
	    NO_MINUS_SIGN: ["#time #minus-sign"],
	    MINUS_SIGN: ["#time.countdown #minus-sign"],
	    DIGIT_0: [".digit-0"],
	    DIGIT_1: [".digit-1"],
	    DIGIT_2: [".digit-2"],
	    DIGIT_3: [".digit-3"],
	    DIGIT_4: [".digit-4"],
	    DIGIT_5: [".digit-5"],
	    DIGIT_6: [".digit-6"],
	    DIGIT_7: [".digit-7"],
	    DIGIT_8: [".digit-8"],
	    DIGIT_9: [".digit-9"],
	    NO_MINUS_SIGN_EX: ["#time #minus-sign"],
	    MINUS_SIGN_EX: ["#time.countdown #minus-sign"],
	    DIGIT_0_EX: [".digit-0"],
	    DIGIT_1_EX: [".digit-1"],
	    DIGIT_2_EX: [".digit-2"],
	    DIGIT_3_EX: [".digit-3"],
	    DIGIT_4_EX: [".digit-4"],
	    DIGIT_5_EX: [".digit-5"],
	    DIGIT_6_EX: [".digit-6"],
	    DIGIT_7_EX: [".digit-7"],
	    DIGIT_8_EX: [".digit-8"],
	    DIGIT_9_EX: [".digit-9"],
	    MAIN_PLAYING_INDICATOR: [".play #play-pause"],
	    MAIN_PAUSED_INDICATOR: [".pause #play-pause"],
	    MAIN_STOPPED_INDICATOR: [".stop #play-pause"],
	    MAIN_NOT_WORKING_INDICATOR: ["#work-indicator"],
	    MAIN_WORKING_INDICATOR: ["#work-indicator.selected"],
	    PLAYLIST_TOP_TILE: [
	        ".playlist-top-left-fill",
	        ".playlist-top-left-spacer",
	        ".playlist-top-right-fill",
	        ".playlist-top-right-spacer",
	    ],
	    PLAYLIST_TOP_LEFT_CORNER: [".playlist-top-left"],
	    PLAYLIST_TITLE_BAR: [".playlist-top-title"],
	    PLAYLIST_TOP_RIGHT_CORNER: [".playlist-top-right"],
	    PLAYLIST_TOP_TILE_SELECTED: [
	        ".selected .playlist-top-left-fill",
	        ".selected .playlist-top-left-spacer",
	        ".selected .playlist-top-right-fill",
	        ".selected .playlist-top-right-spacer",
	    ],
	    PLAYLIST_TOP_LEFT_SELECTED: [".selected .playlist-top-left"],
	    PLAYLIST_TITLE_BAR_SELECTED: [".selected .playlist-top-title"],
	    PLAYLIST_TOP_RIGHT_CORNER_SELECTED: [".selected .playlist-top-right"],
	    PLAYLIST_LEFT_TILE: [".playlist-middle-left"],
	    PLAYLIST_RIGHT_TILE: [".playlist-middle-right"],
	    PLAYLIST_SCROLL_HANDLE: [".playlist-scrollbar-handle"],
	    PLAYLIST_SCROLL_HANDLE_SELECTED: [
	        ".playlist-middle-right.winamp-active .playlist-scrollbar-handle",
	    ],
	    PLAYLIST_BOTTOM_TILE: [".playlist-bottom"],
	    PLAYLIST_BOTTOM_LEFT_CORNER: [".playlist-bottom-left"],
	    PLAYLIST_BOTTOM_RIGHT_CORNER: [".playlist-bottom-right"],
	    PLAYLIST_VISUALIZER_BACKGROUND: [".playlist-visualizer"],
	    PLAYLIST_SHADE_BACKGROUND: ["#playlist-window-shade"],
	    PLAYLIST_SHADE_BACKGROUND_LEFT: ["#playlist-window-shade .left"],
	    PLAYLIST_SHADE_BACKGROUND_RIGHT: ["#playlist-window-shade .right"],
	    PLAYLIST_SHADE_BACKGROUND_RIGHT_SELECTED: [
	        "#playlist-window-shade.selected .right",
	    ],
	    PLAYLIST_ADD_MENU_BAR: ["#playlist-add-menu.selected .bar"],
	    PLAYLIST_ADD_URL: ["#playlist-add-menu .add-url"],
	    PLAYLIST_ADD_URL_SELECTED: ["#playlist-add-menu .hover .add-url"],
	    PLAYLIST_ADD_DIR: ["#playlist-add-menu .add-dir"],
	    PLAYLIST_ADD_DIR_SELECTED: ["#playlist-add-menu .hover .add-dir"],
	    PLAYLIST_ADD_FILE: ["#playlist-add-menu .add-file"],
	    PLAYLIST_ADD_FILE_SELECTED: ["#playlist-add-menu .hover .add-file"],
	    PLAYLIST_REMOVE_MENU_BAR: ["#playlist-remove-menu.selected .bar"],
	    PLAYLIST_REMOVE_ALL: ["#playlist-remove-menu .remove-all"],
	    PLAYLIST_REMOVE_ALL_SELECTED: ["#playlist-remove-menu .hover .remove-all"],
	    PLAYLIST_CROP: ["#playlist-remove-menu .crop"],
	    PLAYLIST_CROP_SELECTED: ["#playlist-remove-menu .hover .crop"],
	    PLAYLIST_REMOVE_SELECTED: ["#playlist-remove-menu .remove-selected"],
	    PLAYLIST_REMOVE_SELECTED_SELECTED: [
	        "#playlist-remove-menu .hover .remove-selected",
	    ],
	    PLAYLIST_REMOVE_MISC: ["#playlist-remove-menu .remove-misc"],
	    PLAYLIST_REMOVE_MISC_SELECTED: ["#playlist-remove-menu .hover .remove-misc"],
	    PLAYLIST_SELECT_MENU_BAR: ["#playlist-selection-menu.selected .bar"],
	    PLAYLIST_INVERT_SELECTION: ["#playlist-selection-menu .invert-selection"],
	    PLAYLIST_INVERT_SELECTION_SELECTED: [
	        "#playlist-selection-menu .hover .invert-selection",
	    ],
	    PLAYLIST_SELECT_ZERO: ["#playlist-selection-menu .select-zero"],
	    PLAYLIST_SELECT_ZERO_SELECTED: [
	        "#playlist-selection-menu .hover .select-zero",
	    ],
	    PLAYLIST_SELECT_ALL: ["#playlist-selection-menu .select-all"],
	    PLAYLIST_SELECT_ALL_SELECTED: ["#playlist-selection-menu .hover .select-all"],
	    PLAYLIST_CLOSE_SELECTED: ["#playlist-close-button.winamp-active"],
	    PLAYLIST_COLLAPSE_SELECTED: [
	        "#playlist-window #playlist-shade-button.winamp-active",
	    ],
	    PLAYLIST_EXPAND_SELECTED: [
	        "#playlist-window-shade #playlist-shade-button.winamp-active",
	    ],
	    PLAYLIST_MISC_MENU_BAR: ["#playlist-misc-menu.selected .bar"],
	    PLAYLIST_MISC_OPTIONS: ["#playlist-misc-menu .misc-options"],
	    PLAYLIST_MISC_OPTIONS_SELECTED: ["#playlist-misc-menu .hover .misc-options"],
	    PLAYLIST_FILE_INFO: ["#playlist-misc-menu .file-info"],
	    PLAYLIST_FILE_INFO_SELECTED: ["#playlist-misc-menu .hover .file-info"],
	    PLAYLIST_SORT_LIST: ["#playlist-misc-menu .sort-list"],
	    PLAYLIST_SORT_LIST_SELECTED: ["#playlist-misc-menu .hover .sort-list"],
	    PLAYLIST_LIST_BAR: ["#playlist-list-menu.selected .bar"],
	    PLAYLIST_NEW_LIST: ["#playlist-list-menu .new-list"],
	    PLAYLIST_NEW_LIST_SELECTED: ["#playlist-list-menu .hover .new-list"],
	    PLAYLIST_LOAD_LIST: ["#playlist-list-menu .load-list"],
	    PLAYLIST_LOAD_LIST_SELECTED: ["#playlist-list-menu .hover .load-list"],
	    PLAYLIST_SAVE_LIST: ["#playlist-list-menu .save-list"],
	    PLAYLIST_SAVE_LIST_SELECTED: ["#playlist-list-menu .hover .save-list"],
	    EQ_WINDOW_BACKGROUND: ["#equalizer-window:not(.shade)"],
	    EQ_TITLE_BAR: [".equalizer-top"],
	    EQ_TITLE_BAR_SELECTED: [".selected .equalizer-top"],
	    EQ_SLIDER_BACKGROUND: [".band"],
	    EQ_SLIDER_THUMB: [".band .slider-handle"],
	    // Put the "active" pseudo selector on the parent, since clicking
	    // anywhere on the track moves the slider.
	    EQ_SLIDER_THUMB_SELECTED: [".band.winamp-active .slider-handle"],
	    EQ_ON_BUTTON: ["#on"],
	    EQ_ON_BUTTON_DEPRESSED: ["#on.winamp-active"],
	    EQ_ON_BUTTON_SELECTED: ["#on.selected"],
	    EQ_ON_BUTTON_SELECTED_DEPRESSED: ["#on.selected.winamp-active"],
	    EQ_AUTO_BUTTON: ["#auto"],
	    EQ_AUTO_BUTTON_DEPRESSED: ["#auto.winamp-active"],
	    EQ_AUTO_BUTTON_SELECTED: ["#auto.selected"],
	    EQ_AUTO_BUTTON_SELECTED_DEPRESSED: ["#auto.selected.winamp-active"],
	    EQ_GRAPH_BACKGROUND: ["#eqGraph"],
	    EQ_PRESETS_BUTTON: ["#presets"],
	    EQ_PRESETS_BUTTON_SELECTED: ["#presets.winamp-active"],
	    EQ_PREAMP_LINE: ["#preamp-line"],
	    EQ_SHADE_BACKGROUND: ["#equalizer-window.shade"],
	    EQ_SHADE_BACKGROUND_SELECTED: ["#equalizer-window.shade.selected"],
	    EQ_SHADE_VOLUME_SLIDER_LEFT: [
	        "#equalizer-volume.left::-webkit-slider-thumb",
	        "#equalizer-volume.left::-moz-range-thumb",
	    ],
	    EQ_SHADE_VOLUME_SLIDER_CENTER: [
	        "#equalizer-volume.center::-webkit-slider-thumb",
	        "#equalizer-volume.center::-moz-range-thumb",
	    ],
	    EQ_SHADE_VOLUME_SLIDER_RIGHT: [
	        "#equalizer-volume.right::-webkit-slider-thumb",
	        "#equalizer-volume.right::-moz-range-thumb",
	    ],
	    EQ_SHADE_BALANCE_SLIDER_LEFT: [
	        "#equalizer-balance.left::-webkit-slider-thumb",
	        "#equalizer-balance.left::-moz-range-thumb",
	    ],
	    EQ_SHADE_BALANCE_SLIDER_CENTER: [
	        "#equalizer-balance.center::-webkit-slider-thumb",
	        "#equalizer-balance.center::-moz-range-thumb",
	    ],
	    EQ_SHADE_BALANCE_SLIDER_RIGHT: [
	        "#equalizer-balance.right::-webkit-slider-thumb",
	        "#equalizer-balance.right::-moz-range-thumb",
	    ],
	    EQ_MAXIMIZE_BUTTON_ACTIVE: ["#equalizer-shade.winamp-active"],
	    EQ_MINIMIZE_BUTTON_ACTIVE: [
	        "#equalizer-window.shade #equalizer-shade.winamp-active",
	    ],
	    EQ_CLOSE_BUTTON: [
	        "#equalizer-window.selected #eq-buttons.clicked #equalizer-close",
	    ],
	    EQ_CLOSE_BUTTON_ACTIVE: [
	        "#equalizer-window.selected #eq-buttons.clicked #equalizer-close.winamp-active",
	    ],
	    EQ_SHADE_CLOSE_BUTTON: [
	        "#equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close",
	    ],
	    EQ_SHADE_CLOSE_BUTTON_ACTIVE: [
	        "#equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close.winamp-active",
	    ],
	    MAIN_POSITION_SLIDER_BACKGROUND: ["#position"],
	    MAIN_POSITION_SLIDER_THUMB: [
	        "#position::-webkit-slider-thumb",
	        "#position::-moz-range-thumb",
	    ],
	    MAIN_POSITION_SLIDER_THUMB_SELECTED: [
	        "#position:active::-webkit-slider-thumb",
	        "#position:active::-moz-range-thumb",
	    ],
	    MAIN_SHUFFLE_BUTTON: ["#shuffle"],
	    MAIN_SHUFFLE_BUTTON_DEPRESSED: ["#shuffle.winamp-active"],
	    MAIN_SHUFFLE_BUTTON_SELECTED: ["#shuffle.selected"],
	    MAIN_SHUFFLE_BUTTON_SELECTED_DEPRESSED: ["#shuffle.selected.winamp-active"],
	    MAIN_REPEAT_BUTTON: ["#repeat"],
	    MAIN_REPEAT_BUTTON_DEPRESSED: ["#repeat.winamp-active"],
	    MAIN_REPEAT_BUTTON_SELECTED: ["#repeat.selected"],
	    MAIN_REPEAT_BUTTON_SELECTED_DEPRESSED: ["#repeat.selected.winamp-active"],
	    MAIN_EQ_BUTTON: ["#equalizer-button"],
	    MAIN_EQ_BUTTON_SELECTED: ["#equalizer-button.selected"],
	    MAIN_EQ_BUTTON_DEPRESSED: ["#equalizer-button.winamp-active"],
	    MAIN_EQ_BUTTON_DEPRESSED_SELECTED: [
	        "#equalizer-button.selected.winamp-button",
	    ],
	    MAIN_PLAYLIST_BUTTON: ["#playlist-button"],
	    MAIN_PLAYLIST_BUTTON_SELECTED: ["#playlist-button.selected"],
	    MAIN_PLAYLIST_BUTTON_DEPRESSED: ["#playlist-button.winamp-active"],
	    MAIN_PLAYLIST_BUTTON_DEPRESSED_SELECTED: [
	        "#playlist-button.selected.winamp-active",
	    ],
	    MAIN_TITLE_BAR: ["#title-bar"],
	    MAIN_TITLE_BAR_SELECTED: [".selected #title-bar"],
	    MAIN_EASTER_EGG_TITLE_BAR: [".llama #title-bar"],
	    MAIN_EASTER_EGG_TITLE_BAR_SELECTED: [".llama.selected #title-bar"],
	    MAIN_OPTIONS_BUTTON: [".selected #title-bar #option.clicked"],
	    MAIN_OPTIONS_BUTTON_DEPRESSED: [
	        ".selected #title-bar #option:active",
	        ".selected #title-bar #option.selected",
	    ],
	    MAIN_MINIMIZE_BUTTON: [".selected #title-bar #minimize.clicked"],
	    MAIN_MINIMIZE_BUTTON_DEPRESSED: [
	        ".selected #title-bar #minimize.winamp-active",
	    ],
	    MAIN_SHADE_BUTTON: [".selected #title-bar #shade.clicked"],
	    MAIN_SHADE_BUTTON_DEPRESSED: [".selected #title-bar #shade.winamp-active"],
	    MAIN_CLOSE_BUTTON: [".selected #title-bar #close.clicked"],
	    MAIN_CLOSE_BUTTON_DEPRESSED: [".selected #title-bar #close.winamp-active"],
	    MAIN_CLUTTER_BAR_BACKGROUND: ["#clutter-bar"],
	    MAIN_CLUTTER_BAR_BACKGROUND_DISABLED: ["#clutter-bar.disabled"],
	    MAIN_CLUTTER_BAR_BUTTON_O_SELECTED: [
	        "#button-o:active",
	        "#button-0.selected",
	    ],
	    MAIN_CLUTTER_BAR_BUTTON_A_SELECTED: [
	        "#button-a:active",
	        "#button-a.selected",
	    ],
	    MAIN_CLUTTER_BAR_BUTTON_I_SELECTED: [
	        "#button-i:active",
	        "#button-i.selected",
	    ],
	    MAIN_CLUTTER_BAR_BUTTON_D_SELECTED: [
	        "#button-d:active",
	        "#button-d.selected",
	    ],
	    MAIN_CLUTTER_BAR_BUTTON_V_SELECTED: [
	        "#button-v:active",
	        "#button-v.selected",
	    ],
	    MAIN_SHADE_BACKGROUND: [".shade #title-bar"],
	    MAIN_SHADE_BACKGROUND_SELECTED: [".shade.selected #title-bar"],
	    MAIN_SHADE_BUTTON_SELECTED: [".shade.selected #title-bar #shade"],
	    MAIN_SHADE_BUTTON_SELECTED_DEPRESSED: [
	        ".shade #title-bar #shade.winamp-active",
	    ],
	    MAIN_SHADE_POSITION_BACKGROUND: [".shade #position"],
	    MAIN_SHADE_POSITION_THUMB: [
	        ".shade #position::-moz-range-thumb",
	        ".shade #position::-webkit-slider-thumb",
	    ],
	    MAIN_SHADE_POSITION_THUMB_LEFT: [
	        ".shade #position.left::-moz-range-thumb",
	        ".shade #position.left::-webkit-slider-thumb",
	    ],
	    MAIN_SHADE_POSITION_THUMB_RIGHT: [
	        ".shade #position.right::-moz-range-thumb",
	        ".shade #position.right::-webkit-slider-thumb",
	    ],
	    MAIN_VOLUME_BACKGROUND: ["#volume"],
	    MAIN_VOLUME_THUMB: [
	        "#volume input::-webkit-slider-thumb",
	        "#volume input::-moz-range-thumb",
	    ],
	    MAIN_VOLUME_THUMB_SELECTED: [
	        "#volume input:active::-webkit-slider-thumb",
	        "#volume input:active::-moz-range-thumb",
	    ],
	    GEN_TOP_CENTER_FILL: [".gen-window .gen-top"],
	    GEN_TOP_LEFT: [".gen-window .gen-top-left"],
	    GEN_TOP_LEFT_END: [".gen-window .gen-top-left-end"],
	    GEN_TOP_RIGHT: [".gen-window .gen-top-right"],
	    GEN_TOP_RIGHT_END: [".gen-window .gen-top-right-end"],
	    GEN_TOP_LEFT_RIGHT_FILL: [
	        ".gen-window .gen-top-left-fill",
	        ".gen-window .gen-top-right-fill",
	    ],
	    GEN_TOP_CENTER_FILL_SELECTED: [".gen-window.selected .gen-top"],
	    GEN_TOP_LEFT_SELECTED: [".gen-window.selected .gen-top-left"],
	    GEN_TOP_LEFT_END_SELECTED: [".gen-window.selected .gen-top-left-end"],
	    GEN_TOP_RIGHT_SELECTED: [".gen-window.selected .gen-top-right"],
	    GEN_TOP_RIGHT_END_SELECTED: [".gen-window.selected .gen-top-right-end"],
	    GEN_TOP_LEFT_RIGHT_FILL_SELECTED: [
	        ".gen-window.selected .gen-top-left-fill",
	        ".gen-window.selected .gen-top-right-fill",
	    ],
	    GEN_BOTTOM_LEFT: [".gen-window .gen-bottom-left"],
	    GEN_BOTTOM_RIGHT: [".gen-window .gen-bottom-right"],
	    GEN_BOTTOM_FILL: [".gen-window .gen-bottom"],
	    GEN_MIDDLE_LEFT: [".gen-window .gen-middle-left"],
	    GEN_MIDDLE_LEFT_BOTTOM: [".gen-window .gen-middle-left-bottom"],
	    GEN_MIDDLE_RIGHT: [".gen-window .gen-middle-right"],
	    GEN_MIDDLE_RIGHT_BOTTOM: [".gen-window .gen-middle-right-bottom"],
	    GEN_CLOSE_SELECTED: [".gen-window .gen-close.winamp-active"],
	};
	Object.keys(FONT_LOOKUP).forEach((character) => {
	    const key = imageConstFromChar(character);
	    const code = character.charCodeAt(0);
	    imageSelectors[key] = [`.character-${code}`];
	});
	LETTERS.forEach((character) => {
	    imageSelectors[`GEN_TEXT_${character}`] = [
	        `.gen-text-${character.toLowerCase()}`,
	    ];
	    imageSelectors[`GEN_TEXT_SELECTED_${character}`] = [
	        `.gen-window.selected .gen-text-${character.toLowerCase()}`,
	    ];
	});
	const cursorSelectors = {
	    CLOSE: ["#title-bar #close"],
	    // This is not quite right. There are some areas that show this cursor
	    // but are not clickable.
	    EQSLID: ["#equalizer-window .band"],
	    EQNORMAL: ["#equalizer-window"],
	    EQCLOSE: ["#equalizer-window #equalizer-close"],
	    EQTITLE: [
	        "#equalizer-window .title-bar",
	        "#equalizer-window.shade",
	        "#equalizer-window.shade input",
	    ],
	    MAINMENU: ["#main-window #option", "#webamp-context-menu .context-menu"],
	    MIN: ["#main-window #minimize"],
	    NORMAL: [
	        // Use this as the default cursor.
	        ".window",
	        ".window input", // Otherwise
	        "#main-window",
	        "#main-window.shade #title-bar",
	    ],
	    MMENU: ["#main-window.shade #option"],
	    PNORMAL: ["#playlist-window"],
	    // TODO: This is should really only apply to the top part of the top.
	    // The chrome around the playlist window is larger than others. The
	    // cursor only applies to the same height as the other window's chrome.
	    PTBAR: ["#playlist-window .playlist-top"],
	    PCLOSE: [
	        "#playlist-window #playlist-close-button",
	        "#playlist-window-shade #playlist-close-button",
	    ],
	    PWINBUT: [
	        "#playlist-window #playlist-shade-button",
	        "#playlist-window-shade #playlist-shade-button",
	    ],
	    POSBAR: ["#main-window #position"],
	    PSIZE: ["#playlist-window #playlist-resize-target"],
	    PWSSIZE: ["#playlist-window-shade #playlist-resize-target"],
	    PWSNORM: ["#playlist-window-shade"],
	    // TODO: The target for this is not quite right.
	    PVSCROLL: ["#playlist-window .playlist-scrollbar"],
	    SONGNAME: ["#main-window #marquee"],
	    TITLEBAR: ["#main-window #title-bar"],
	    VOLBAL: ["#volume", "#volume input", "#balance"],
	    WINBUT: ["#main-window #shade"],
	    WSNORMAL: ["#main-window.shade #title-bar"],
	    WSPOSBAR: ["#main-window.shade #position"],
	};

	function Css({ children, id }) {
	    const style = reactExports.useMemo(() => {
	        const s = document.createElement("style");
	        s.type = "text/css";
	        if (id != null) {
	            s.id = id;
	        }
	        return s;
	    }, [id]);
	    reactExports.useLayoutEffect(() => {
	        document.head.appendChild(style);
	        return () => style.remove();
	    }, [style]);
	    return reactDomExports.createPortal(children, style);
	}

	// this.props.children should be an object containing arrays of strings. The
	// keys are ids, and the arrays are arrays of polygon point strings
	function ClipPaths({ children }) {
	    const paths = reactExports.useMemo(() => {
	        return document.createElement("div");
	    }, []);
	    reactExports.useLayoutEffect(() => {
	        document.body.appendChild(paths);
	        return () => paths.remove();
	    }, [paths]);
	    return reactDomExports.createPortal(jsxRuntimeExports.jsx("svg", { height: 0, width: 0, children: jsxRuntimeExports.jsx("defs", { children: Object.keys(children).map((id) => (jsxRuntimeExports.jsx("clipPath", { id: id, children: children[id].map((points, i) => (jsxRuntimeExports.jsx("polygon", { points: points }, i))) }, id))) }) }), paths);
	}

	/*
	 * Copyright (c) 2017-2018 Rafael da Silva Rocha.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	/**
	 * @fileoverview A function to swap endianness in byte buffers.
	 * @see https://github.com/rochars/endianness
	 */

	/** @module endianness */

	/**
	 * Swap the byte ordering in a buffer. The buffer is modified in place.
	 * @param {!Array|!Uint8Array} bytes The bytes.
	 * @param {number} offset The byte offset.
	 * @param {number=} start The start index. Assumes 0.
	 * @param {number=} end The end index. Assumes the buffer length.
	 * @throws {Error} If the buffer length is not valid.
	 */
	function endianness(bytes, offset, start=0, end=bytes.length) {
	  if (end % offset) {
	    throw new Error("Bad buffer length.");
	  }
	  for (let index = start; index < end; index += offset) {
	    swap$1(bytes, offset, index);
	  }
	}

	/**
	 * Swap the byte order of a value in a buffer. The buffer is modified in place.
	 * @param {!Array|!Uint8Array} bytes The bytes.
	 * @param {number} offset The byte offset.
	 * @param {number} index The start index.
	 * @private
	 */
	function swap$1(bytes, offset, index) {
	  offset--;
	  for(let x = 0; x < offset; x++) {
	    /** @type {*} */
	    let theByte = bytes[index + x];
	    bytes[index + x] = bytes[index + offset];
	    bytes[index + offset] = theByte;
	    offset--;
	  }
	}

	/*
	 * Copyright (c) 2018 Rafael da Silva Rocha.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	/**
	 * @fileoverview Functions to serialize and deserialize UTF-8 strings.
	 * @see https://github.com/rochars/utf8-buffer
	 * @see https://encoding.spec.whatwg.org/#the-encoding
	 * @see https://encoding.spec.whatwg.org/#utf-8-encoder
	 */

	/** @module utf8-buffer */

	/**
	 * Read a string of UTF-8 characters from a byte buffer.
	 * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).
	 * @see https://encoding.spec.whatwg.org/#the-encoding
	 * @see https://stackoverflow.com/a/34926911
	 * @param {!Uint8Array|!Array<number>} buffer A byte buffer.
	 * @param {number=} start The buffer index to start reading.
	 * @param {?number=} end The buffer index to stop reading.
	 *   Assumes the buffer length if undefined.
	 * @return {string}
	 */
	function unpack$1(buffer, start=0, end=buffer.length) {
	  /** @type {string} */
	  let str = '';
	  for(let index = start; index < end;) {
	    /** @type {number} */
	    let lowerBoundary = 0x80;
	    /** @type {number} */
	    let upperBoundary = 0xBF;
	    /** @type {boolean} */
	    let replace = false;
	    /** @type {number} */
	    let charCode = buffer[index++];
	    if (charCode >= 0x00 && charCode <= 0x7F) {
	      str += String.fromCharCode(charCode);
	    } else {
	      /** @type {number} */
	      let count = 0;
	      if (charCode >= 0xC2 && charCode <= 0xDF) {
	        count = 1;
	      } else if (charCode >= 0xE0 && charCode <= 0xEF ) {
	        count = 2;
	        if (buffer[index] === 0xE0) {
	          lowerBoundary = 0xA0;
	        }
	        if (buffer[index] === 0xED) {
	          upperBoundary = 0x9F;
	        }
	      } else if (charCode >= 0xF0 && charCode <= 0xF4 ) {
	        count = 3;
	        if (buffer[index] === 0xF0) {
	          lowerBoundary = 0x90;
	        }
	        if (buffer[index] === 0xF4) {
	          upperBoundary = 0x8F;
	        }
	      } else {
	        replace = true;
	      }
	      charCode = charCode & (1 << (8 - count - 1)) - 1;
	      for (let i = 0; i < count; i++) {
	        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {
	          replace = true;
	        }
	        charCode = (charCode << 6) | (buffer[index] & 0x3f);
	        index++;
	      }
	      if (replace) {
	        str += String.fromCharCode(0xFFFD);
	      } 
	      else if (charCode <= 0xffff) {
	        str += String.fromCharCode(charCode);
	      } else {
	        charCode -= 0x10000;
	        str += String.fromCharCode(
	          ((charCode >> 10) & 0x3ff) + 0xd800,
	          (charCode & 0x3ff) + 0xdc00);
	      }
	    }
	  }
	  return str;
	}

	/*
	 * Copyright (c) 2017-2018 Rafael da Silva Rocha.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	/**
	 * @fileoverview Encode and decode int numbers to and from byte buffers.
	 * @see https://github.com/rochars/byte-data
	 */

	/**
	 * A class to write and read integer numbers to and from byte buffers.
	 */
	class IntParser {
	  
	  /**
	   * @param {number} bits The number of bits used by the integer.
	   * @param {boolean} [signed=false] True for signed, false otherwise.
	   * @param {boolean} [clamp=false] True to clamp on overflow.
	   */
	  constructor(bits, signed=false, clamp=false) {
	    /**
	     * The number of bits used by one number.
	     * @type {number}
	     */
	    this.bits = bits;
	    /**
	     * The number of bytes used by one number.
	     * @type {number}
	     */
	    this.bytes = bits < 8 ? 1 : Math.ceil(bits / 8);
	    /**
	     * @type {number}
	     * @protected
	     */
	    this.max = Math.pow(2, bits) - 1;
	    /**
	     * @type {number}
	     * @protected
	     */
	    this.min = 0;
	    /** @type {number} */
	    let r = 8 - ((((bits - 1) | 7) + 1) - bits);
	    /**
	     * @type {number}
	     * @private
	     */
	    this.lastByteMask_ = Math.pow(2, r > 0 ? r : 8) - 1;
	    /**
	     * @type {Function}
	     * @protected
	     */
	    this.unpack = this.unpackUnsigned_;
	    if (signed) {
	      this.max = Math.pow(2, bits) / 2 - 1;
	      this.min = -this.max - 1;
	      this.unpack = this.unpackSigned_;
	    }
	    if (clamp) {
	      this.overflow_ = this.overflowClamp_;
	    }
	  }

	  /**
	   * Write one unsigned integer to a byte buffer.
	   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.
	   * @param {number} num The number. Overflows are truncated.
	   * @param {number} [index=0] The index being written in the byte buffer.
	   * @return {number} The next index to write on the byte buffer.
	   */
	  pack(buffer, num, index=0) {
	    if (num !== num || num.constructor != Number) {
	      throw new TypeError();
	    }
	    num = this.overflow_(num);
	    buffer[index] = (num < 0 ? num + Math.pow(2, this.bits) : num) & 255;
	    index++;
	    for (let i = 2, len = this.bytes; i < len; i++) {
	      buffer[index] = Math.floor(num / Math.pow(2, ((i - 1) * 8))) & 255;
	      index++;
	    }
	    if (this.bits > 8) {
	      buffer[index] = Math.floor(
	        num / Math.pow(2, ((this.bytes - 1) * 8))) & this.lastByteMask_;
	      index++;
	    }
	    return index;
	  }

	  /**
	   * Read one unsigned integer from a byte buffer.
	   * Does not check for overflows.
	   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.
	   * @param {number} [index=0] The index to read.
	   * @return {number}
	   */
	  unpack_(buffer, index=0) {
	    /** @type {number} */
	    let num = 0;
	    for(let x = 0; x < this.bytes; x++) {
	      num += buffer[index + x] * Math.pow(256, x);
	    }
	    return num;
	  }

	  unpackUnsigned_(buffer, index=0) {
	    return this.overflow_(this.unpack_(buffer, index));
	  }

	  /**
	   * Read one two's complement signed integer from a byte buffer.
	   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.
	   * @param {number} [index=0] The index to read.
	   * @return {number}
	   */
	  unpackSigned_(buffer, index=0) {
	    return this.overflow_(this.sign_(this.unpack_(buffer, index)));
	  }

	  /**
	   * Truncate values in case of overflow.
	   * @param {number} num The number.
	   * @private
	   */
	  overflow_(num) {
	    if (num > this.max || num < this.min) {
	      throw new RangeError();
	    }
	    return num;
	  }

	  /**
	   * Truncate values in case of overflow.
	   * @param {number} num The number.
	   * @private
	   */
	  overflowClamp_(num) {
	    if (num > this.max) {
	      return this.max;
	    } else if (num < this.min) {
	      return this.min;
	    }
	    return num;
	  }

	  /**
	   * Sign a number.
	   * @param {number} num The number.
	   * @return {number}
	   * @private
	   */
	  sign_(num) {
	    if (num > this.max) {
	      num -= (this.max * 2) + 2;
	    }
	    return num;
	  }
	}

	/*
	 * Copyright (c) 2018-2019 Rafael da Silva Rocha.
	 * Copyright (c) 2013 DeNA Co., Ltd.
	 * Copyright (c) 2010, Linden Research, Inc
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	/**
	 * @fileoverview Encode and decode IEEE 754 floating point numbers.
	 * @see https://github.com/rochars/ieee754-buffer
	 * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js
	 * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js
	 */

	/** 
	 * @module ieee754-buffer
	 */

	/**
	 * A class to encode and decode IEEE 754 floating-point numbers.
	 */
	class IEEE754Buffer {

	  /**
	   * Pack a IEEE 754 floating point number.
	   * @param {number} ebits The exponent bits.
	   * @param {number} fbits The fraction bits.
	   */
	  constructor(ebits, fbits) {
	    /**
	     * @type {number}
	     * @private
	     */
	    this.ebits = ebits;
	    /**
	     * @type {number}
	     * @private
	     */
	    this.fbits = fbits;
	    /**
	     * @type {number}
	     * @private
	     */
	    this.bias = (1 << (ebits - 1)) - 1;
	    /**
	     * @type {number}
	     * @private
	     */
	    this.numBytes = Math.ceil((ebits + fbits) / 8);
	    /**
	     * @type {number}
	     * @private
	     */
	    this.biasP2 = Math.pow(2, this.bias + 1);
	    /**
	     * @type {number}
	     * @private
	     */
	    this.ebitsFbits = (ebits + fbits);
	    /**
	     * @type {number}
	     * @private
	     */
	    this.fbias = Math.pow(2, -(8 * this.numBytes - 1 - ebits));
	  }

	  /**
	   * Pack a IEEE 754 floating point number.
	   * @param {!Uint8Array|!Array<number>} buffer The buffer.
	   * @param {number} num The number.
	   * @param {number} index The index to write on the buffer.
	   * @return {number} The next index to write on the buffer.
	   * @throws {TypeError} If input is not a number.
	   */
	  pack(buffer, num, index) {
	    // Only numbers can be packed
	    if (typeof num != 'number') {
	      throw new TypeError();
	    }
	    // Round overflows
	    if (Math.abs(num) > this.biasP2 - (this.ebitsFbits * 2)) {
	      num = num < 0 ? -Infinity : Infinity;
	    }
	    /**
	     * sign, need this to handle negative zero
	     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/
	     * @type {number}
	     */
	    let sign = (((num = +num) || 1 / num) < 0) ? 1 : num < 0 ? 1 : 0;
	    num = Math.abs(num);
	    /** @type {number} */
	    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);
	    /** @type {number} */
	    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));
	    // NaN
	    if (num !== num) {
	      fraction = Math.pow(2, this.fbits - 1);
	      exp = (1 << this.ebits) - 1;
	    // Number
	    } else if (num !== 0) {
	      if (num >= Math.pow(2, 1 - this.bias)) {
	        if (fraction / Math.pow(2, this.fbits) >= 2) {
	          exp = exp + 1;
	          fraction = 1;
	        }
	        // Overflow
	        if (exp > this.bias) {
	          exp = (1 << this.ebits) - 1;
	          fraction = 0;
	        } else {
	          exp = exp + this.bias;
	          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);
	        }
	      } else {
	        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));
	        exp = 0;
	      } 
	    }
	    return this.packFloatBits_(buffer, index, sign, exp, fraction);
	  }

	  /**
	   * Unpack a IEEE 754 floating point number.
	   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. 
	   * Adapted to handle NaN. Should port the solution to the original repo.
	   * @param {!Uint8Array|!Array<number>} buffer The buffer.
	   * @param {number} index The index to read from the buffer.
	   * @return {number} The floating point number.
	   */
	  unpack(buffer, index) {
	    /** @type {number} */
	    let eMax = (1 << this.ebits) - 1;
	    /** @type {number} */
	    let significand;
	    /** @type {string} */
	    let leftBits = "";
	    for (let i = this.numBytes - 1; i >= 0 ; i--) {
	      /** @type {string} */
	      let t = buffer[i + index].toString(2);
	      leftBits += "00000000".substring(t.length) + t;
	    }
	    /** @type {number} */
	    let sign = leftBits.charAt(0) == "1" ? -1 : 1;
	    leftBits = leftBits.substring(1);
	    /** @type {number} */
	    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);
	    leftBits = leftBits.substring(this.ebits);
	    if (exponent == eMax) {
	      if (parseInt(leftBits, 2) !== 0) {
	        return NaN;
	      }
	      return sign * Infinity;  
	    } else if (exponent === 0) {
	      exponent += 1;
	      significand = parseInt(leftBits, 2);
	    } else {
	      significand = parseInt("1" + leftBits, 2);
	    }
	    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);
	  }

	  /**
	   * Pack a IEEE754 from its sign, exponent and fraction bits
	   * and place it in a byte buffer.
	   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.
	   * @param {number} index The buffer index to write.
	   * @param {number} sign The sign.
	   * @param {number} exp the exponent.
	   * @param {number} fraction The fraction.
	   * @return {number}
	   * @private
	   */
	  packFloatBits_(buffer, index, sign, exp, fraction) {
	    /** @type {!Array<number>} */
	    let bits = [];
	    // the sign
	    bits.push(sign);
	    // the exponent
	    for (let i = this.ebits; i > 0; i -= 1) {
	      bits[i] = (exp % 2 ? 1 : 0);
	      exp = Math.floor(exp / 2);
	    }
	    // the fraction
	    let len = bits.length;
	    for (let i = this.fbits; i > 0; i -= 1) {
	      bits[len + i] = (fraction % 2 ? 1 : 0);
	      fraction = Math.floor(fraction / 2);
	    }
	    // pack as bytes
	    /** @type {string} */
	    let str = bits.join('');
	    /** @type {number} */
	    let numBytes = this.numBytes + index - 1;
	    /** @type {number} */
	    let k = index;
	    while (numBytes >= index) {
	      buffer[numBytes] = parseInt(str.substring(0, 8), 2);
	      str = str.substring(8);
	      numBytes--;
	      k++;
	    }
	    return k;
	  }
	}

	/**
	 * Round a number to its nearest even value.
	 * @param {number} n The number.
	 * @return {number}
	 * @private
	 */
	function roundToEven(n) {
	  /** @type {number} */
	  let w = Math.floor(n);
	  let f = n - w;
	  if (f < 0.5) {
	    return w;
	  }
	  if (f > 0.5) {
	    return w + 1;
	  }
	  return w % 2 ? w + 1 : w;
	}

	/*
	 * Copyright (c) 2017-2019 Rafael da Silva Rocha.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */


	/**
	 * Read a string of UTF-8 characters from a byte buffer.
	 * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.
	 * @param {number} [index=0] The buffer index to start reading.
	 * @param {number} [end=buffer.length] The index to stop reading, non inclusive.
	 * @return {string}
	 */
	function unpackString(buffer, index=0, end=buffer.length) {
	  return unpack$1(buffer, index, end);
	}

	/**
	 * Unpack a array of numbers from a byte buffer to a array or a typed array.
	 * All other unpacking functions are interfaces to this function.
	 * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.
	 * @param {!{bits:number,
	 *   fp: (boolean|undefined),
	 *   signed: (boolean|undefined),
	 *   be: (boolean|undefined)}} theType The type definition.
	 * @param {!(TypedArray|Array<number>)} output The output array or typed array.
	 * @param {number} [start=0] The buffer index to start reading.
	 * @param {number} [end=buffer.length] The buffer index to stop reading.
	 * @param {boolean} [safe=false] If set to false, extra bytes in the end of
	 *   the array are ignored and input buffers with insufficient bytes will
	 *   write nothing to the output array. If safe is set to true the function
	 *   will throw a 'Bad buffer length' error.
	 * @param {boolean} [clamp=false] True to clamp ints on overflow.
	 * @throws {Error} If the type definition is not valid
	 * @throws {RangeError} On overflow
	 */
	function unpackArrayTo(
	    buffer, theType, output, start=0, end=buffer.length,
	    safe=false, clamp=false) {
	  theType = theType || {};
	  /** @type {!Object} */
	  let packer = getParser_(theType.bits, theType.fp, theType.signed, clamp);
	  /** @type {number} */
	  let offset = Math.ceil(theType.bits / 8);
	  // getUnpackLen_ will either fix the length of the input buffer
	  // according to the byte offset of the type (on unsafe mode) or
	  // throw a Error if the input buffer has a bad length (on safe mode)
	  end = getUnpackLen_(buffer, start, end, offset, safe);
	  /** @type {number} */
	  let index = 0;
	  let j = start;
	  try {
	    if (theType.be) {
	      endianness(buffer, offset, start, end);
	    }
	    for (; j < end; j += offset, index++) {
	      output[index] = packer.unpack(buffer, j);
	    }
	    if (theType.be) {
	      endianness(buffer, offset, start, end);
	    }
	  } catch (e) {
	    throwValueError_(e, buffer.slice(j, j + offset), j);
	  }
	}

	/**
	 * Unpack a array of numbers from a byte buffer.
	 * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.
	 * @param {!{bits:number,
	 *   fp: (boolean|undefined),
	 *   signed: (boolean|undefined),
	 *   be: (boolean|undefined)}} theType The type definition.
	 * @param {number} [start=0] The buffer index to start reading.
	 * @param {number} [end=buffer.length] The buffer index to stop reading.
	 * @param {boolean} [safe=false] If set to false, extra bytes in the end of
	 *   the array are ignored and input buffers with insufficient bytes will
	 *   output a empty array. If safe is set to true the function
	 *   will throw a 'Bad buffer length' error.
	 * @param {boolean} [clamp=false] True to clamp ints on overflow.
	 * @return {!Array<number>}
	 * @throws {Error} If the type definition is not valid
	 * @throws {RangeError} On overflow
	 */
	function unpackArray(
	    buffer, theType, start=0, end=buffer.length, safe=false, clamp=false) {
	  /** @type {!Array<number>} */
	  let output = [];
	  unpackArrayTo(buffer, theType, output, start, end, safe, clamp);
	  return output;
	}

	/**
	 * Unpack a number from a byte buffer.
	 * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.
	 * @param {!{bits:number,
	 *   fp: (boolean|undefined),
	 *   signed: (boolean|undefined),
	 *   be: (boolean|undefined)}} theType The type definition.
	 * @param {number} [index=0] The buffer index to read.
	 * @param {boolean} [clamp=false] True to clamp ints on overflow.
	 * @return {number}
	 * @throws {Error} If the type definition is not valid
	 * @throws {Error} On bad buffer length.
	 * @throws {RangeError} On overflow
	 */
	function unpack(buffer, theType, index=0, clamp=false) {
	  return unpackArray(
	    buffer, theType, index, index + Math.ceil(theType.bits / 8),
	    true, clamp)[0];
	}

	/**
	 * Throw a error with information about the problem.
	 * @param {!Object} err The Error object that is being raised.
	 * @param {*} value The value that caused the error.
	 * @param {number} index The index of the value that caused the error.
	 * @throws {RangeError|TypeError|Error} A Error with a message.
	 * @private
	 */
	function throwValueError_(err, value, index) {
	  err.message = err.constructor.name +
	    ' at index ' + index + ': ' + value;
	  throw err;
	}

	/**
	 * Unpack a array of numbers to a typed array.
	 * All other unpacking functions are interfaces to this function.
	 * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.
	 * @param {number} start The buffer index to start reading.
	 * @param {number} end The buffer index to stop reading.
	 * @param {number} offset The number of bytes used by the type.
	 * @param {boolean} safe True for size-safe buffer reading.
	 * @throws {Error} On bad buffer length, if safe.
	 * @private
	 */
	function getUnpackLen_(buffer, start, end, offset, safe) {
	  /** @type {number} */
	  let extra = (end - start) % offset;
	  if (safe && (extra || buffer.length < offset)) {
	    throw new Error('Bad buffer length');
	  }
	  return end - extra;
	}

	/**
	 * Return a parser for int, uint or fp numbers.
	 * @param {number} bits The number of bits.
	 * @param {boolean|undefined} fp True for fp numbers, false otherwise.
	 * @param {boolean|undefined} signed True for signed ints, false otherwise.
	 * @param {boolean|undefined} clamp True to clamp ints on overflow, false otherwise.
	 * @return {!Object}
	 * @private
	 */
	function getParser_(bits, fp, signed, clamp) {
	  if (fp) {
	    validateFloatType(bits);
	  } else {
	    validateIntType(bits);
	  }
	  if (fp && bits === 16) {
	    return new IEEE754Buffer(5, 11);
	  } else if (fp && bits == 32) {
	    return new IEEE754Buffer(8, 23);
	  } else if(fp && bits == 64) {
	    return new IEEE754Buffer(11, 52);
	  }
	  return new IntParser(bits, signed, clamp);
	}

	/**
	 * The type definition error message.
	 * @type {string}
	 * @private
	 */
	const TYPE_ERR = 'Unsupported type';

	/**
	 * Validate the type definition of floating-point numbers.
	 * @param {number} bits The number of bits.
	 * @throws {Error} If the type definition is not valid.
	 * @private
	 */
	function validateFloatType(bits) {
	  if (!bits || bits !== 16 && bits !== 32 && bits !== 64) {
	    throw new Error(TYPE_ERR + ': float, bits: ' + bits);
	  }
	}

	/**
	 * Validate the type definition of integers.
	 * @param {number} bits The number of bits.
	 * @throws {Error} If the type definition is not valid.
	 * @private
	 */
	function validateIntType(bits) {
	  if (!bits || bits < 1 || bits > 53) {
	    throw new Error(TYPE_ERR + ': int, bits: ' + bits);
	  }
	}

	/*
	 * Copyright (c) 2017-2019 Rafael da Silva Rocha.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */


	/**
	 * A class to perform low-level reading of RIFF/RIFX files.
	 */
	class RIFFFile {

	  constructor() {
	    /**
	     * The container identifier.
	     * 'RIFF', 'RIFX' and 'RF64' are supported.
	     * @type {string}
	     */
	    this.container = '';
	    /**
	     * The main chunk size, in bytes.
	     * @type {number}
	     */
	    this.chunkSize = 0;
	    /**
	     * The format identifier.
	     * @type {string}
	     */
	    this.format = '';
	    /**
	     * An object representing the signature of all chunks in the file.
	     * @type {{
	      chunkId: string,
	      chunkSize: number,
	      format: string,
	      chunkData: {start: number, end: number},
	      subChunks: Array
	      }|null}
	     */
	    this.signature = null;
	    /**
	     * @type {number}
	     * @protected
	     */
	    this.head = 0;
	    /**
	     * @type {
	      {bits: number, be: boolean, signed: boolean, fp: boolean}
	     }
	     * @protected
	     */
	    this.uInt32 = { bits: 32, be: false, signed: false, fp: false };
	    /**
	     * The list of supported containers.
	     * Any format different from RIFX will be treated as RIFF.
	     * @type {!Array<string>}
	     * @protected
	     */
	    this.supported_containers = ['RIFF', 'RIFX'];
	  }

	  /**
	   * Read the signature of the chunks in a RIFF/RIFX file.
	   * @param {!Uint8Array} buffer The file bytes.
	   * @protected
	   */
	  setSignature(buffer) {
	      this.head = 0;
	      this.container = this.readString(buffer, 4);
	      if (this.supported_containers.indexOf(this.container) === -1) {
	        throw Error('Not a supported format.');
	      }
	      this.uInt32.be = this.container === 'RIFX';
	      this.chunkSize = this.readUInt32(buffer);
	      this.format = this.readString(buffer, 4);
	      // The RIFF file signature
	      this.signature = {
	          chunkId: this.container,
	          chunkSize: this.chunkSize,
	          format: this.format,
	          subChunks: this.getSubChunksIndex_(buffer),
	          chunkData: {start: 0, end: this.chunkSize}
	      };
	  }

	  /**
	    * Find a chunk by its fourCC_ in a array of RIFF chunks.
	    * @param {string} chunkId The chunk fourCC_.
	    * @param {boolean} multiple True if there may be multiple chunks
	    *    with the same chunkId.
	    * @return {Object}
	    * @protected
	    */
	  findChunk(chunkId, multiple=false) {
	    /** @type {!Array|null} */
	    let chunks = this.signature.subChunks;
	    /** @type {!Array<!Object>} */
	    let chunk = [];
	    for (let i=0; i<chunks.length; i++) {
	      if (chunks[i].chunkId == chunkId) {
	        if (multiple) {
	          chunk.push(chunks[i]);
	        } else {
	          return chunks[i];
	        }
	      }
	    }
	    if (chunkId == 'LIST') {
	      return chunk.length ? chunk : null;
	    }
	    return null;
	  }

	  /**
	   * Read bytes as a string from a RIFF chunk.
	   * @param {!Uint8Array} bytes The bytes.
	   * @param {number} maxSize the max size of the string.
	   * @return {string} The string.
	   * @protected
	   */
	  readString(bytes, maxSize) {
	    /** @type {string} */
	    let str = '';
	    str = unpackString(bytes, this.head, this.head + maxSize);
	    this.head += maxSize;
	    return str;
	  }

	  /**
	   * Read a number from a chunk.
	   * @param {!Uint8Array} bytes The chunk bytes.
	   * @return {number} The number.
	   * @protected
	   */
	  readUInt32(bytes) {
	    /** @type {number} */
	    let value = unpack(bytes, this.uInt32, this.head);
	    this.head += 4;
	    return value;
	  }

	  /**
	   * Return the sub chunks of a RIFF file.
	   * @param {!Uint8Array} buffer the RIFF file bytes.
	   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.
	   * @private
	   */
	  getSubChunksIndex_(buffer) {
	      /** @type {!Array<!Object>} */
	      let chunks = [];
	      /** @type {number} */
	      let i = this.head;
	      while(i <= buffer.length - 8) {
	          chunks.push(this.getSubChunkIndex_(buffer, i));
	          i += 8 + chunks[chunks.length - 1].chunkSize;
	          i = i % 2 ? i + 1 : i;
	      }
	      return chunks;
	  }

	  /**
	   * Return a sub chunk from a RIFF file.
	   * @param {!Uint8Array} buffer the RIFF file bytes.
	   * @param {number} index The start index of the chunk.
	   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.
	   * @private
	   */
	  getSubChunkIndex_(buffer, index) {
	      /** @type {!Object} */
	      let chunk = {
	          chunkId: this.getChunkId_(buffer, index),
	          chunkSize: this.getChunkSize_(buffer, index),
	      };
	      if (chunk.chunkId == 'LIST') {
	          chunk.format = unpackString(buffer, index + 8, index + 12);
	          this.head += 4;
	          chunk.subChunks = this.getSubChunksIndex_(buffer);
	      } else {
	          /** @type {number} */
	          let realChunkSize = chunk.chunkSize % 2 ?
	              chunk.chunkSize + 1 : chunk.chunkSize;
	          this.head = index + 8 + realChunkSize;
	          chunk.chunkData = {
	              start: index + 8,
	              end: this.head
	          };
	      }
	      return chunk;
	  }

	  /**
	   * Return the fourCC_ of a chunk.
	   * @param {!Uint8Array} buffer the RIFF file bytes.
	   * @param {number} index The start index of the chunk.
	   * @return {string} The id of the chunk.
	   * @private
	   */
	  getChunkId_(buffer, index) {
	      this.head += 4;
	      return unpackString(buffer, index, index + 4);
	  }

	  /**
	   * Return the size of a chunk.
	   * @param {!Uint8Array} buffer the RIFF file bytes.
	   * @param {number} index The start index of the chunk.
	   * @return {number} The size of the chunk without the id and size fields.
	   * @private
	   */
	  getChunkSize_(buffer, index) {
	      this.head += 4;
	      return unpack(buffer, this.uInt32, index + 4);
	  }
	}

	const DWORD = { bits: 32, be: false, signed: false, fp: false };
	function parseAni(arr) {
	    const riff = new RIFFFile();
	    riff.setSignature(arr);
	    const signature = riff.signature;
	    if (signature.format !== "ACON") {
	        throw new Error(`Expected format. Expected "ACON", got "${signature.format}"`);
	    }
	    // Helper function to get a chunk by chunkId and transform it if it's non-null.
	    function mapChunk(chunkId, mapper) {
	        const chunk = riff.findChunk(chunkId);
	        return chunk == null ? null : mapper(chunk);
	    }
	    function readImages(chunk, frameCount) {
	        return chunk.subChunks.slice(0, frameCount).map((c) => {
	            if (c.chunkId !== "icon") {
	                throw new Error(`Unexpected chunk type in fram: ${c.chunkId}`);
	            }
	            return arr.slice(c.chunkData.start, c.chunkData.end);
	        });
	    }
	    const metadata = mapChunk("anih", (c) => {
	        const words = unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);
	        return {
	            cbSize: words[0],
	            nFrames: words[1],
	            nSteps: words[2],
	            iWidth: words[3],
	            iHeight: words[4],
	            iBitCount: words[5],
	            nPlanes: words[6],
	            iDispRate: words[7],
	            bfAttributes: words[8],
	        };
	    });
	    if (metadata == null) {
	        throw new Error("Did not find anih");
	    }
	    const rate = mapChunk("rate", (c) => {
	        return unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);
	    });
	    // chunkIds are always four chars, hence the trailing space.
	    const seq = mapChunk("seq ", (c) => {
	        return unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);
	    });
	    const lists = riff.findChunk("LIST", true);
	    const imageChunk = lists === null || lists === void 0 ? void 0 : lists.find((c) => c.format === "fram");
	    if (imageChunk == null) {
	        throw new Error("Did not find fram LIST");
	    }
	    let images = readImages(imageChunk, metadata.nFrames);
	    let title = null;
	    let artist = null;
	    const infoChunk = lists === null || lists === void 0 ? void 0 : lists.find((c) => c.format === "INFO");
	    if (infoChunk != null) {
	        infoChunk.subChunks.forEach((c) => {
	            switch (c.chunkId) {
	                case "INAM":
	                    title = unpackString(arr, c.chunkData.start, c.chunkData.end);
	                    break;
	                case "IART":
	                    artist = unpackString(arr, c.chunkData.start, c.chunkData.end);
	                    break;
	                case "LIST":
	                    // Some cursors with an artist of "Created with Take ONE 3.5 (unregisterred version)" seem to have their frames here for some reason?
	                    if (c.format === "fram") {
	                        images = readImages(c, metadata.nFrames);
	                    }
	                    break;
	                // Unexpected subchunk
	            }
	        });
	    }
	    return { images, rate, seq, metadata, artist, title };
	}

	const JIFFIES_PER_MS = 1000 / 60;
	// Generate CSS for an animated cursor.
	//
	// This function returns CSS containing a set of keyframes with embedded Data
	// URIs as well as a CSS rule to the given selector.
	function convertAniBinaryToCSS(selector, aniBinary) {
	    const ani = readAni(aniBinary);
	    const animationName = `ani-cursor-${uniqueId()}`;
	    const keyframes = ani.frames.map(({ url, percents }) => {
	        const percent = percents.map((num) => `${num}%`).join(", ");
	        return `${percent} { cursor: url(${url}), auto; }`;
	    });
	    // CSS properties with a animation type of "discrete", like `cursor`, actually
	    // switch half-way _between_ each keyframe percentage. Luckily this half-way
	    // measurement is applied _after_ the easing function is applied. So, we can
	    // force the frames to appear at exactly the % that we specify by using
	    // `timing-function` of `step-end`.
	    //
	    // https://drafts.csswg.org/web-animations-1/#discrete
	    const timingFunction = "step-end";
	    // Winamp (re)starts the animation cycle when your mouse enters an element. By
	    // default this approach would cause the animation to run continuously, even
	    // when the cursor is not visible. To match Winamp's behavior we add a
	    // `:hover` pseudo selector so that the animation only runs when the cursor is
	    // visible.
	    const pseudoSelector = ":hover";
	    // prettier-ignore
	    return `
    @keyframes ${animationName} {
        ${keyframes.join("\n")}
    }
    ${selector}${pseudoSelector} {
        animation: ${animationName} ${ani.duration}ms ${timingFunction} infinite;
    }
   `;
	}
	function readAni(contents) {
	    var _a;
	    const ani = parseAni(contents);
	    const rate = (_a = ani.rate) !== null && _a !== void 0 ? _a : ani.images.map(() => ani.metadata.iDispRate);
	    const duration = sum(rate);
	    const frames = ani.images.map((image) => ({
	        url: curUrlFromByteArray(image),
	        percents: [],
	    }));
	    let elapsed = 0;
	    rate.forEach((r, i) => {
	        const frameIdx = ani.seq ? ani.seq[i] : i;
	        frames[frameIdx].percents.push((elapsed / duration) * 100);
	        elapsed += r;
	    });
	    return { duration: duration * JIFFIES_PER_MS, frames };
	}
	/* Utility Functions */
	let i = 0;
	const uniqueId = () => i++;
	function base64FromDataArray(dataArray) {
	    return window.btoa(Array.from(dataArray)
	        .map((byte) => String.fromCharCode(byte))
	        .join(""));
	}
	function curUrlFromByteArray(arr) {
	    const base64 = base64FromDataArray(arr);
	    return `data:image/x-win-bitmap;base64,${base64}`;
	}
	function sum(values) {
	    return values.reduce((total, value) => total + value, 0);
	}

	const CSS_PREFIX = "#webamp";
	const mapRegionNamesToIds = {
	    normal: "mainWindowClipPath",
	    windowshade: "shadeMainWindowClipPath",
	    equalizer: "equalizerWindowClipPath",
	    equalizerws: "shadeEqualizerWindowClipPath",
	};
	const mapRegionNamesToMatcher = {
	    normal: "#main-window:not(.shade)",
	    windowshade: "#main-window.shade",
	    equalizer: "#equalizer-window:not(.shade)",
	    equalizerws: "#equalizer-window.shade",
	};
	const numExIsUsed = (skinImages) => Boolean(skinImages.DIGIT_0_EX);
	const FALLBACKS = {
	    MAIN_BALANCE_BACKGROUND: "MAIN_VOLUME_BACKGROUND",
	    MAIN_BALANCE_THUMB: "MAIN_VOLUME_THUMB",
	    MAIN_BALANCE_THUMB_ACTIVE: "MAIN_VOLUME_THUMB_SELECTED",
	    EQ_MAXIMIZE_BUTTON_ACTIVE: "EQ_MAXIMIZE_BUTTON_ACTIVE_FALLBACK",
	};
	// Cursors might appear in context menus which are not nested inside the window layout div.
	function normalizeCursorSelector(selector) {
	    return `${
    // TODO: Fix this hack
    // Maybe our CSS name spacing should be based on some other class/id
    // than the one we use for defining the main div.
    // That way it could be shared by both the player and the context menu.
    selector.startsWith("#webamp-context-menu") ? "" : CSS_PREFIX} ${selector}`;
	}
	const getCssRules = createSelector_1(getSkinImages, getSkinCursors, getSkinLetterWidths, getSkinRegion, (skinImages, skinCursors, skinGenLetterWidths, skinRegion) => {
	    if (!skinImages || !skinCursors) {
	        return null;
	    }
	    const cssRules = [];
	    Object.keys(imageSelectors).forEach((imageName) => {
	        const imageUrl = skinImages[imageName] || skinImages[FALLBACKS[imageName]];
	        if (imageUrl) {
	            imageSelectors[imageName].forEach((_selector) => {
	                const selector = _selector; // .replace(":active", ".active");
	                cssRules.push(`${CSS_PREFIX} ${selector} {background-image: url(${imageUrl})}`);
	            });
	        }
	    });
	    if (skinGenLetterWidths != null) {
	        LETTERS.forEach((letter) => {
	            const width = skinGenLetterWidths[`GEN_TEXT_${letter}`];
	            const selectedWidth = skinGenLetterWidths[`GEN_TEXT_SELECTED_${letter}`];
	            cssRules.push(`${CSS_PREFIX} .gen-text-${letter.toLowerCase()} {width: ${width}px;}`);
	            cssRules.push(`${CSS_PREFIX} .selected .gen-text-${letter.toLowerCase()} {width: ${selectedWidth}px;}`);
	        });
	    }
	    Object.entries(cursorSelectors).forEach(([cursorName, cursorSelector]) => {
	        const cursor = skinCursors[cursorName];
	        if (cursor == null) {
	            return;
	        }
	        const cursorRules = cursorSelector
	            .map(normalizeCursorSelector)
	            .map((selector) => {
	            switch (cursor.type) {
	                case "cur":
	                    return `${selector} {cursor: url(${cursor.url}), auto}`;
	                case "ani": {
	                    try {
	                        return convertAniBinaryToCSS(selector, cursor.aniData);
	                    }
	                    catch (e) {
	                        console.error(e);
	                        return null;
	                    }
	                }
	            }
	        })
	            .filter(Boolean);
	        cssRules.push(...cursorRules);
	    });
	    if (numExIsUsed(skinImages)) {
	        // This alternate number file requires that the minus sign be
	        // formatted differently.
	        cssRules.push(`${CSS_PREFIX} .webamp-status #time #minus-sign { top: 0px; left: -1px; width: 9px; height: 13px; }`);
	    }
	    for (const [regionName, polygons] of Object.entries(skinRegion)) {
	        if (polygons) {
	            const matcher = mapRegionNamesToMatcher[regionName];
	            const id = mapRegionNamesToIds[regionName];
	            cssRules.push(`${CSS_PREFIX} ${matcher} { clip-path: url(#${id}); }`);
	        }
	    }
	    return cssRules.join("\n");
	});
	const getClipPaths = createSelector_1(getSkinRegion, (skinRegion) => {
	    const clipPaths = {};
	    for (const [regionName, polygons] of Object.entries(skinRegion)) {
	        if (polygons) {
	            const id = mapRegionNamesToIds[regionName];
	            clipPaths[id] = polygons;
	        }
	    }
	    return clipPaths;
	});
	function Skin() {
	    const cssRules = useTypedSelector(getCssRules);
	    const clipPaths = useTypedSelector(getClipPaths);
	    if (cssRules == null) {
	        return null;
	    }
	    return (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Css, { id: "webamp-skin", children: cssRules }), jsxRuntimeExports.jsx(ClipPaths, { children: clipPaths })] }));
	}

	var css_248z = "#webamp #balance {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAGkCAMAAABq7Kf7AAACvlBMVEUVfwoWFiMXFyQXGCUYFyUYGCYYkgsZLhwbGyschRIeaRYfHzIjIzgomRwpOCEujhYunBIvL0QvL0kvgBwxMU0xMU4yMU4yMk8zM1AzNFEzNFI0M1E0M1I0NFE0NFM0shU1NVQ1NlM1NlQ2NVM2NVQ2NlU2NlY2NyE3N1c3OFc3OFg4Jh04N1c4N1g4OFc4OFk5Gh05LSA5OVo7TkFCtiZHhidIcy1JSWNMi0BMlSVPU0RPpCNRQkBRmyxSMT5TUm9WqypauihbgTZcmyxcwCpixDFlvjdnoCxnsStp2TBrpU1rwCpuboRuj0Nw1T5xci5yxypz3D50QiR0xzF3JSJ3VCl3oDF3tCt30zB62jB7epB8e458fJB9fZB9fZJ+fpJ/1T6BxyqC3D6Eq1WEtDGEwF2F4jeGi0KGoYiHh5iIoDGJVi6KKSiKRC2KYzaKxDCLfjiLi5yLmCyMjJyNmiyOWxeOjp6OmyyQxzGRODmRTT2RWj2RbkKS4TCTk6KUyjiXXCGXrI+XtDGawmCa4z6bXSGbaSebfieb2jmeYhKeayaeriufFhufKhufPiGfSSGfVyGfbCefgSefkCyfmyygaTqho1Cj4Tik20Wk4jimNDemxzGpfEqprI+p40atkouuV0auag2uwCqwYh+xv16yERayKBayRx6ydiWynCqyriuyxDG3RUu94Ti/bRu/dRC/uyq/0zDAhFPB4kbCb1PCk1fCs1zDciPD1T7FDBLFJxLFQxvFURvFZRvFgCPFnCPFsSrFwCrF2TDGeA/G2jDIxdPI2z7JVyLJgSDJhSnJoCnJtDHJxDHJ3D7Zbx7ZfB/ZjifZlDfZrCfZsTfZwzDZxj7bhC/b1jXfsSjgDhXgHybgLBXgPCbgTB7gWC7gXB7gZy7gch7gfC7gkijgsijgyTDg2zfhmTfhtjfhzD7A/9hgAAAEC0lEQVRo3u3U+VeUZRTA8VeyQtQgKd6XZnGEmXEcmxkLG8YlBdTUCaRGSFFTA02zFBPTssUFF1zac4UKQkXUUrNUIHBLzX0PK3et9L/ouc8z2g+ec2/HX/I93u+ZMz/d877n3Ps5rxYI+J4O+AI+n88Dud0ut8vldDpSUlPtVrvdarNZDEPXAiIx4/V7/Z5Ocs7tcrqcDpGYs1qTYczQ5JDI740+DR7nTEnpYE+1i4dZbRaLoRvaY60fbCl6AP5axoifqEVMi9vFxLZpZ9O11g/HUT2abmixcRpVMFvX2sS1egivVWiarrVLS2yLFxpfomvuQO/sYaNUI0eNhEbcarjo5dc+KEnXNR+s1uv3dZL7cLlgt05HqgO2a7Ulwzp0PUmD1Xr9fo/nSbk0OAGs1gFLs1mSxWoNPUmMyRvAkJjyiCmXw5HSAcasVssTcAFdjkXv6Zc3UC8VQ/KVNptxawyO5fdFXymnHE71SnFPiwXunvR4krbvP6Xd45AS8eLSJKT4BLx4CSkxoT1egoIU6ooXZkhmg/RI8Bm8oIQU7NYDr1sIIAUzMvEywgrSc3jh2QzJdJCexYtCysjsi5WZISGF+g3E66cghQe9iDVoLEMyH6Q+eFFIA57HG5ADkLIGDy3AGjq4SEEaXYg1miGZEVJ/rH8hvYB1G1LBq1gFClL3cCE6VsiQTANJSjIAUn+irLR0LTZryCtEQ3KyBaTi94mKi6YBpLK5aGWls0tISCDpzXSGdI9AynqJSEEaU/w2WvEYgJQzs2z5SqTlZTMlpKIVX6GtKP2SITEkhnQfQuqYO4Eot7uAlDunnGjOOIBU/i1R+TKAtGwr0WqGZDpIU6ZOR5o6RUFa/A3RYoA0bsOWPT8j7dmyQUHasf8o0v4dDIkhMSSGxJAYEkNiSP8zpC+IFKT1m3ejbV4PkCYfaW7+C6m5+YiChE6JuW0MyXSQPifK7QmQancR1UpIh8/8iXbmsIJ09ibaWYbEkBgSQ2JIDOluIT2Vv+AztAVRSDuJaicDpEOnzl1HOnfqkIRUcfoG2mmGZD5I8xd9irRofj5Ayl/XRLTuPQFp0sET19BOHKwQkHpWnPwb7eSPXzMkhsSQ7kNInSOz5qHNUpCqvyOqniQgvb79ONF2CWnpr0TfMyTTQXqLKAKQIguriBYCpPyqTXvRNlUpSE2/oDVVMCTTQfqESH6RItWNRNXvwhep8dgVtGONCtJVIv4imQ/Sx0SRXgCp5ieiGoA08cAlogMSUuVloh8Ykskgdcn7iCgKqYGoZgZAarhA1FApIPWqvEjEkMwH6UOiPICUt7aeaO07AtIb9X8Q1UtIq84TVTIk00FaQqQgrakjWiMh1f1GVLdRQvqdaCNDuqN/AItpcu8L5wnUAAAAAElFTkSuQmCC)}\n#webamp #balance::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}\n#webamp #balance::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}\n#webamp #balance:active::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}\n#webamp #balance:active::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}\n#webamp .actions #previous {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAASFBMVEUfHzEgHzIgIDMhITQiITMiITQiIjUjIzYjJDgkIzckIzgkJDklJTolJjsmJTsmJjtKWmtSY3N7hJSElKWXqLmttca9ztbv//8qmLzOAAAAcklEQVQY022QMQ7DMAwDj7KQvqD/f2UXD2YGN43cWAuNo0wI1JvNjE8SGzwiwf/Ywwr2k1M6HFMPwDgvvxnoU2DN6fl7xh7X/YJx4a/yte67FaPmV2O5pxi5ZN/Gt5+rI998DD/ridxiLAQiHBKEJYGaT1TOJE+BDpf2AAAAAElFTkSuQmCC)}\n#webamp .actions #previous.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAAS0lEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOChcPAAsQwDmOIi4MoEocRieMgiMRhROYEInNckTkugcgcVzgnNASIwRxTZOcoIHwDAI4lI4lOrG7eAAAAAElFTkSuQmCC)}\n#webamp .actions #play {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAARVBMVEUmJTsmJTwnJz0nKD4oJz4oKD8pKUAqKUEqKUIqKkMrK0QrLEQsK0MsK0QsK0ZKWmtSY3N7hJSElKWXqLmttca9ztbv//93JWkaAAAAcElEQVQY022QQQ7FIAhEHzJpL/Dvf8y/MBG70VZbYEPeAIGxH0nEX5QEB4L+xj26CnkMXus2QJv92hXXrETluHnT07MqrnV6UbSfcY6rY+N+/1KUUTBl9Nl/vtxow5+PRyKif+1xpZhmmIEZMxFh+AXgtiNLLYv6agAAAABJRU5ErkJggg==)}\n#webamp .actions #play.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAARUlEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOChcOAzGFkQOYIMiBzwDw4B8RDcEKROKFIykKRDAhFMjoUbqkpsnMUEL4BAGRUIvLymjxCAAAAAElFTkSuQmCC)}\n#webamp .actions #pause {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAARVBMVEUsLEUsLEYtLUctLkguLUguLkkvL0ovMEswL0swL0wwMEsxMU0xMU4xMk0yMU5KWmtSY3N7hJSElKWXqLmttca9ztbv//90IK75AAAAY0lEQVQYGW3BwQ3DQAwDwRVPsBtI/3UGfpCBDfiT00x9GPjbiI2dhvAnjsSsuV3AARdwAMHNo1kBmhVuEjMxEyOLkcRMzMRIze3kcfJyQyA8wqsaO2zSdtitogqqqEoJIgTLP/lyHlITiB2JAAAAAElFTkSuQmCC)}\n#webamp .actions #pause.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAAOUlEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOCyXFgYAEyYBzBEBdGUdpzXENDXEJDwRxTZOcoIHwDAEquItl9JSARAAAAAElFTkSuQmCC)}\n#webamp .actions #stop {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAAP1BMVEUyMU4yMk8zM1AzNFE0M1E0M1I0NFE0NFM1NVQ1NlQ2NVM2NVQ2NlVKWmtSY3N7hJSElKWXqLmttca9ztbv//8mgTHJAAAAXElEQVQYGW3BQQ7DMAwDwRUttPf+/6FFD2SBBLnYmqkPA38bcbBpCJs4ErPm8uPxAgLNrbmtcBGjiFHETIyWGFmMIkarubzZNAQIm8YOB7cdTqsooERWkEXJheoPfCIcRKB1vkQAAAAASUVORK5CYII=)}\n#webamp .actions #stop.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAAMklEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOChQPWC+MwCgoKitKBA3YamGOK7BwFhG8A34IfFkPmwnYAAAAASUVORK5CYII=)}\n#webamp .actions #next {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAALVBMVEUICBA2NlU2NlY3N1c4N1g4OFk4OFpKWmtSY3N7hJSElKWXqLmttca9ztbv//8TuYuxAAAAaUlEQVQI12M4AwenDjCcewcDJ4Ccu1BwZzkmp/zu3evld+9MB3Oqa+9e3wfnbEfm7K5F5mxH5uxD5rxF4uxDNuAtEufd3bv33kE4cFcDOWdWzoSC6QkMK8rhgIFB0MjY2NjFxSU0NJQBAK7vnSRnYMknAAAAAElFTkSuQmCC)}\n#webamp .actions #next.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAATElEQVQI12NgwAVMXCDAWYGBwTUUChyAbKi4CyabAcSAshlZXBxEYWwBJLYgCxJbAIktisQOQbBFkfSGINihLi6uoSC2KZIbFOCuBwDE5iIH3QcLbQAAAABJRU5ErkJggg==)}\n#webamp #eject {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAQBAMAAADgw5IVAAAAIVBMVEU4OFk4OFo5OVpKWmtSY3N7hJSElKWXqLmttca9ztbv//8Mnk1wAAAAVUlEQVQI12PogIM2hq5VMNDC0DUTCmYEQ9iWCPbkYgTbvNwSxp5cXl4MY5uXlwMlwOxZYBPh5sDNnGwMAlA2UHl5FYZ6uNuCGTpSQ6EgmEGISQkKmAB+iFckwoyJQwAAAABJRU5ErkJggg==)}\n#webamp #eject.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAQBAMAAADgw5IVAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAATUlEQVQI12NgwAVMXCDAWYGBwTUUChyAbJAgCxBD2Q4CCDajIAuM7SAoKABjMwoKAiXAbIhJMPVgAGY7gO2EsoHKBUXR1ZsiqVeAuxIAu8seNVNafDwAAAAASUVORK5CYII=)}\n#webamp #main-window {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAB0CAMAAACR8SbcAAACEFBMVEUAAAAAUoQAarID9gUNDRQPDxcQEBkRERsTEh0TFB0UEx4UFBQUFBsUFB8VFSAVFSIVFiEVFiIWFSEWFSIWFiEWFiIXFyIXFyQXGCQYFyQYGCUYGCkZGSYZGicZGigaGScaGSgaGicaGikbGyobHCsbHCwcGyscGywcHCscHCwdHS0dHS4dHi0dHi4eHS0eHS4eHi0eHi8fHzAfHzIfIDEgHzEgIDEgIDMhITQhIjMhIjQiITMiITQiIjMiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklHAolJTolJTwlJjslJjwmJTsmJTwmJjsmJz0nJz4nKD4oJz0oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0MsK0QsLEUsLUUtLUYtLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMCUvMEswL0swMEswMEwxMU0xMU4xMk0xMk4yMU0yMU4yMk0yMk8zM1AzM1IzNFE0M1E0NFE0NFM1NVQ1NlQ2LRE2NVM2NVQ2NlU2NlY3N1c3N1g3OFg4N1c4N1g4OFc4OFk4OFo5OVpCQThISEhORj1ZQxxcXGNelepfX2hiYm1lW0JlZXJmZnVoaHZpaXhra3ttbX9vb4NxcYZzc4hzc4p0c4p0dIt1dYx3d3d6h4mHd02PkJKhoK2jlGumhTGnZB+njlatr7X////Zgun4AAAl/ElEQVR42tWdz6+ta1LXP/Xj3VGjA6IRELykww/p7gQJhgkOhLED/wETHRtmRjstbRva295E06djggNDQhwQ0BjEaIJOHECHCFFQsH/Rl+4b7m0aaAINGgPu9VSVg6rnXWufs8/tNs1Orvvk3n32WWuvtd7nrafqW9/6Vj3izJfAc3+V2x8U6x/rmL+hoPPoISWACgapKv1rAq5S868oeOCpOg+KIaDzah51l5ooIP3NwiARFMKpBx8TKCnIskBJysIIIDUFWJ4sSACSAlZJAcnyZQtYIgEUrH5G4XyUx770hX+Rt3nO7SLKS9f40ZeRx344v5fM/4WSQqBe/BwlfaHULNK5WlAPnsjLfrr5ez1z+LtCeRgCTjpaImgpisWRWgrCASJwoAgm4fgScEXLEUVT76gj8DYB7goFS0wUHEQFDOk/FuogbXTpAOKBhcvVONukFJRUSH3k9iWa/Z3Si+ZcYhUsg20pUVIkGRRFSlBkpnEPoZkWSS2o0n6B2LfemdvR725LeklkcTVzSIPl5oCUF6CoLsAsou90ColhLmQ6Iv05o++LrHmxAFUHcFYhLrXvm9FLkpCpj1pvPTA1LdLoCwDwiLUgUwgokkoKpIj+1b6mQixy3nXp2KoB+FopogJS2Z9Xk0QwVaRQnd0p8zlc56dMUC0NUk0AvBKsn65KRmoyhoJgx3gyE0nAcXzvG5lH9HnbqOdNRCgkx5SIZQTSdhJrLTMAleoL1IxCqOqPtUKUlWCRJMnyKrxfy8ZrOoqkACYomKaq9uKAUAtVgaLACVXB51ZDimChMrZvwpGYXE3QtkW23c3FZ6+/R8xl770jGYBmKqpK5gveSClEE1hk5hKvvpIqxA5s4Q4IEUBmClVI9dNU17pPpZK2Ixa3N0GkbVj6n2YzpbaZkCICdYCASQkecpcUy8N74VwqsaIQ3LUOQs+7XpK3/rHvVPvBdGAtWC5+NQcpvOMRZGapPuJKzhVPUNfMoKo3T1w8hLVog23T69+o2VxqqGQJWnRwg0qFWTTgPkNKAZG5vSqo7EVEj1QKquMkCxDHJElcKZSssd3kopbj8e7YO8VF2pB0KQiEnfvX49w9hSF13Sqq8vzGGf+S28EClW2EFIj7sprb3c4i1wQkrSgyaWPNkNzrSjsIIWa57/R8kd5SVD/xmM2fEylKYEkHhUWUprJ0O8Z5IzDQRPpNVOdiBwVw10+3NkzHItrO22+GlG1koZoJ/ckfmEk/CCgZSRw2Owfqsix6M1S1C1EPkJJqq0i0n1toZpvqTSBZAvjavvNq5JoKXLIjtSZSs2Y+ocnj6JdRkcPQ6MfF0YBUKt1z4oNvV6G0d7AiE5ww4ML1nkjleM5bs8jnzUSFbA9vimbMK1DhhOGwqt9LV4ZCVQ2A075HhSR6gENR0ZgRHPDlY54lp5mkSmGHAixDKTFQ3JGlIK5H+567XvK0Xtf+/Gp9H2NMZA0SU3NHKIuOXcsNKN+fE0ywiSdK5nYm+tBKZr+oZpISG691cMXw1Y7YKFAqbqJXMpunSiMvlVRR2LxH+7o7EUFB5o1jY/CcWLGd2lycJ+JcUvWE5whRhbsKx2FZfZF55JilCJRUzK2KWUFfROB9F0XAKg1tb5F8WaidqmSJBUghwqWWyewGhXgIWtualkBCCGEgLGlg4wCXCw/A9HMgW6Tzjs5ezquffXbMHpTxJSoTa+7WxqmJM7B3X4r4cmG5Xi9vHqt9sRYWRja2kCJVbvd1SUlleYUUCmEBqQlSstDM1NwrVlxOJJiZ/dcFaC/P/Ti6+tv/kQkgb5vbiFRDnsLzcr2GrAfurtr9pGxkfb+dR3+yNe6yX9KXC3mzJO6ZV4swjDCMpISIDDbSuX42KVEiTEQbMU8yUIKqquuJNDJS/BrC2HhVNQDy/ooGk5hnPnvb/E/ezmzlxRz6JTnf26R/p33WTf43qLsffTH363+ZTE8e5H985enfg031DErMwQL4gbvsiJnaMdRAq/fE0b4EuQMxCWt84cCBhqLqCh7Wu0ScsjqgVLQQT+sX8lQBQXyTBVbaLj4s6xgCAbC+WxvaP5r+JXqmf6mUZvSWKkouvqydSFZSUiy9AFWpFVDcH8lKotAg28EVCKF0FPT78RCqqqAZEIKKcKzB5p4IUQbuhoMIUop30oAhGIIvrAiygqw22vEyWQhiq6OjQbVXWoT5NY0ixFiQ13D8IohV3dsgcUQuzYP0hcksSeZONXT1R1ACKtMbwand7KhKdsiF8XY1IGZCfynVzo9CRbUjhwCxkWMHJ9eqS9AmtCBVDRED9esmSVGhqPTsfNxokBjSXFBVW6SChr4Yd5+3lF4zlBW15Dj3Y13mViNak54tbehWi6pEQptFKA3L9LVOwkqvPMFN4gNY58BCh1HpDKVMKHyhrgiOTDhP4bDcGQGSubHPIuc5PpzTURPcg0YMXqT7qg0KKJGSnX+SiuajxMkZq1WTuoyTEdax3UQggdRmaK67syqdcRwB6/RlcdqJnu+ag09ykF7qxvraXkxYVOc6S4XMxFU7JvdH8YLDQAXB4TKpOSLItkkBE8Sb/yvqGPgKYJW34DXRRwGKnpRSzSaQhFpy8Q5066SY9BKMmXRaZGtlboNQh+F2cuNYMk0GdF1BtO7EqQrLMaEARFOhzPOiqoou/EL7S9wx1cgM6aTWvS+pfTN3xRoIWDvLay6rZHvewYvayYVqPpIAjtvVTEC14sym3CT6Vls1h5u5pINYeaev0i5BB0jk5i4vV5L5bhLeMRKzKzhVREQUpDApBzehrUc9AU8tDiSG4ViVZgqdy+zrtmry4v7gTqkqIzueisUA5c7h4wgj89wYGxI+smk6/YPV9tXkT03aT4kSVKGN2xk4X1ALIHIi4LqBBT7Wmmn6ew845oeEvTTftN2v7KSmPYg20tV17BTPd0zNDhz+nYSHilCdCAtWiIEvj7TFMZhDsLjo0PxnwEl9PvdrbiebqL1JXqVYEIYvJMdjgN8jTaz0VipvbJhCY8WCJKDEN/ZxQe55sq8f+QUL/ptufOaNfa4oFjS1pAYfhfW+rs7o0x5AthIKKSnCCgiLvvJOx6aEMXaUKbAa1SVkYos10aWAXIPr392+tfxmb9Y3/PqT/SlQ0Z/hHfz1wz81+0SOZz/AH/DsH4jy+09qJ2r84jt8TeqT8b5/Lx/f29QE5Rue8A9ZxTv8a4LwtpMfFJ7aTlTe6XYiH4/3/Vv9+Di4DhdPaSeu73QraWCtetrJh0C/9JR28t+13ul28h/4Jd737/SXt53w1dqJmb3t4/VI8fud9hXAusfPpFPg17+KP8Hb/76+85eEbGZYTzORr85OvpfvfdvH80qOvFO/Nistx7MfzP/Fsw+B/85T+pNfEuQX3uH+JD7O+/4Nn1a47/RS60n9yf8HX1Fd83DQxYgwntKfvPO/zmLHxiYlKE+Y7zTJ/SMv0vfyOIWvqfWoYGx/fKlCqsmBekDCn/T9Seh/GcJ+s/12aeJIjmc/KL/Hs1eBJ8Unvywl4l2ERzVrK3B8NY8q1eU/PwkCqeep6dRUSkjtelaSaNRkylRJhTbDVpsBSIavl86DM5R7zcrSIImEqhDhInw83/+TfEph5dZVPGm+UyLeLEgZJU3nu0hsnYHAEWlXgqRQ8gE9rc0E3hK0KtXL1+nUMmI9kAEscSikibjMYSSlJLjWgTcpO3byofp9+cirWvK7/+dJ7QQ5JBUpsdiFaifx0tEmWXg1sZKo0jbxOIw4/xJGaLSNdDg1FoTWDT1SU+MuuFdhkRRRCcWiilAii0/F+3+CT/pZYhGe1J+A8HO+C2lbxuH8Jb8cNUW1kFbCpKL8jG3mSAC+58rz9LbRhNRlTTS347j48tV14BrPsuZvXSHIqSRAlpKSJ+l4OUqaozY5nn2I3+cjr6LyO09pJ/8D5L++iE/+xVvrGGmRAEemeFOw//knbp/3o1+89Sm7Op5AZbU7KS7HaqXdIre08R7JNpMKQrOmqhMUKUsXRYUVF1l8kvf/RL5+1bNxi0/kj96f7PrO86DgFMYAXMp0ahTxNiRHW0q2gqSDUBX4KnCnl6QpVu8lyVpBaa4ujYzyBj0LzqGk927UHYwEuUETXx1W+X/BJ+a8F+U9NZq7XWC8Zqbn17seVvAVqDjmjop06c9GZ0OsJmC7kqbSirMjp0RjwZZrtbqjlt6ju5YkMhqw6139oSewk+ORy7zBG42SzvLaS+zkXfCuJDsMJ9RKo06NgfVVchaJm50WqqIkcnIa2Uvi16iN916U9M3tU7c49PufwE4u9jiRA/KeT/FuPmXfxqft2/gsu6rz4oq8AaDvAj6LpmJBRUdioTwKX7uuNC616zqyEJS05Tvyau7iDh11uqJ4rTmWPMiLn8CfyPFSM3nPp+CTn3p38OlvT17fup3Hl+Rd7yI/9wafnVLDVERPj9R6h2rJAiN4kJpSa6b6yiS6j8PWaokkYS09lr2TdBdFn9if5NulGtIlKH39W6fYGY8jkzfeQOtdn81RPp1Fd4paxd4781Cani9fkUkulJp62qW1s5XkZc2nE9tUT2+pJ/Un+uhuoIBPvqd497s/Bd/6Ot8KmqjmIzvtjW/ushV887fOfl9BTdV5BWZNkpW00jE1kqKIxm+q86gSuf2oioI4SYaQIMezV/kSH/lHAk+KTz7u6f/lP72ITz5/ohOVb/sVnaYU4Gd/8jF8klPen+/rRr516S2zqNRuRSEvQkq74yJZtkjNfk6N2C+ESEIX+Zn6e//yxCf6HB/7R+9PfL2MuFeRQjDJ14VTrKX6EnQyXSvJFjoMCMaZsCMyMXhxVMnofLp8LmiyVNEshTGyFJmukHKQ49mH9Et89MOgv/2UdvJJhV/46y+yBL9eMsnFUdceHU1+7q898LNfZAP60ZxoZtk6zaSWFLZ8jZAhqMwckdKCkqCNgcmCl66t9bog3EN+kr//Y7yusoUtT+xPFPS7P/OZz3z2c5/73BtvvPXWW2+98cbn3/r8588lkQjjKq7Q7/mt3/7tL16/2kqmOaPzZbWwM+iEGywfyXwElTodACM5IEcwHlZxAV+TS0fMkmz4eveRV/mSPPuwwtPaSbNXNr0z3gp/kdpKx6rqpiE0X7bN5oGlja5YtRODWoyZLHbX472vU8zW7qRIJRca5JLOdSo7Yi9Yr/P+f71eV66Sqyf1J3lCVd0xT3xde9eibCPKfGnU1gEZsziXQScyipvV8nqwtoC9JLX6VQ9HMxHCUqQFjJF6iYJFLgjWGXc++mH0ae3k09qqLAH1hROOXA5oD4vYOkJvFbHPxWwhtWq8q5Jha4MTClbtVIcYO8lLb49uIsrUYpG1OwNP5uQidWm66dP5wR+vX1Vp0ZE+tT+ZlEpBWRABi5Y1iYCxvFpq6dNn8UIOoJSqJunanVstYk+KqpKd/ZV0r1emRhWC9lN1bdXO2RXamsMWSU50r/Yn+rs8+7Biv/m0diIlNlvHlxMc1VqvlvIKqZpo6iNE7Aljz7bZtLDLpttLagG2gBidNGtHnQYrSyfqZJ1mQmgBa7UtXX6FD/54/apybVx9Un+iglgN/7kc3C9yICVSDeVTSbybZR5HJyp9N1uTybkkIhUiHZlpkTCZWsegl4BMFe1WiQLbPKy2PNZ7pftdS+4+8mH5XZ69xhPbyWd2QlOtr0esM/pO8w8q7JYbeVns2XayXC7Y2gTbBWw5a1lTCCRk9CZpdyLZLSkNcOXeN097oTTvIbN+hQ/+GK/rpprM5IE/EX4I/SP7b+qAvSStUJ3O6Al5WTftfqqP7J1uZTnt5KiLWEw15yiH8LWw1OyUOFcgVE6vd5Zyr9pZYcpwOZMvr6WadLPmSrn76D/U3+HZa4b+xh8+oZ283msybV0h13KbgKVXjYvVlxhJDrhMlCS0ru6EivJazmr4xm7Cl6JSomiP4veEplwYvp6q6ShdSVL5K3zwx9ZnlanuRD6tTqnq7Ery3vV1BhSLLVZO3d4/n2cXdAMXJaFCLlP067kEu3ErdpDKDecCac0sC4wKRdAWgAo29nljm3L30Vfld3j2j1PlN5/STj4zvSkGeMAxQnIpadFHFyn08Yhz/VqekEjV7nouKoaRprrW08M8Lmeu090DiyQ0yi7d0NhAL4pcZJLCp/jgj/L65r7CRPhnj/Jbt1D7tk9Qbsq7zz38SFlYwChNfFNBtSsvUIacXCD50mXpYJyp2RilZJvbTDMpxQIpMutSUFUW1U1g3bUUcKFknWXilFzcVA7X2fBLSfy5jyCWHEgJd9WTOcrAs7wnE5Si2l0MasOW3y1DsRwx9DnAYz+OKTqTTMa1WeyJJr114gjZTkRnqMdzJcBrbx/aLvbMSgpbXdU5S+qp6EVKQrT7MGbJ0qI69AELgyWrt2tq7y/b3CMm0WMnyqFE5XL2iw+rULtAB7rK1WQaDLYy3gHuutelwKbAKId2I7rFzEFxsksxcztiQkm2HcxHkhf7q7cdZVpfUPVbrEWwejdE0F3YC6RsW8OBk61szFy9c6aPqgcisM0lT5lZzh0MA5Gt3NTCcB8kRfowiEYYJSqIdA/7LgAv1+kei9JCipr3krBKYS0PjJrGldmEcq13dpWinst5JhJPIV3jYgQzGuFsn6dy9xiEVVURE4QqWd2cce2OEkzjAqyVHWSGntzv6z284aBnJWS6inQb7boOJCpS4Y7AosfeFHonre2v4cZ6YopYz2qQu+5nQW2nxBVxTAvPLstkN/elzofqTu2HZtIWlNPpEcd0+YJ7NQHRTdezO3cTXUe0Xuzph/PcntlOZcGaj5KB1n7+fBub3hJfF3dqKSIHAp6Q6lyse4QEDTjOcThnU3VN63dd2HNLtHtmlpiVHGzHP01AOxDfNuY8WJTJ1HRGy1w2OT2vCkiWWUsJYorIARIgumaluu432pe4COseyLPJ2izH0runTtAuwkzVw6qKta5TDZZmzxc4IHZHdU/HiTghRj+9nQii01kd4w9ciBVXBgArRONs23oUxJLZDkazFST99s0ySFA+xbuIKtQnQx6XmCw8i0jVgCDnzmevT0KlepNuqE4rvEHKOe5CtZn+HoNiu1s9HRRd1binDamEbYIlaM4LbmlUk6wFWuEKPS2HSy+YdNdT95ADKrs49Twg0J2i3dbXRYpLWU1JNGboxvW3R6MmxlJBKyPpHqHuJ0NSp4+fBZHYOmv9Uj2yIj9X8iIU2XfOttzKSfErcrHzOX7NLwejAhLH8ttJZXcPwHurtmazf0Vi51s5Wi4fXNb3+TrnZ48nUKjY/HZstmHJ7LgCoj764y9E/dIUgfSXSMCzwyvXmv8NG6Yb/jzsQZVZkplDUhtP6MMi6V6Sr2xF4mTWrp9t3VQ0ejRUnG2IE262y95Jg+5CYz9mcu3EwCGP6+oo1Nci+DTSWrqUCC66oVhZu+68kxIc6fg84j0DCQfBExWOwEidUG8WGJoCylT6jEIpLdmVzkfuyh5LV0KlLhtYT062EuX3UwHTZgfkYlOqSI1k+YhxBogU3BusdfbADbxe3OQX3SopCOa9JKM3kFle6dUYDKh3lJSrXIueEzDC244VhUv2AKHZ8JjRw1syx7pCVHJShLeRf8qeO1WUDoq6mYOR9zfQLukJclXEtMt6beve4/0WxDppJDiBVKOr89pvtk5j0Wy29sgzH4g93QVA1h744VQMypwBbIkVehDj8nxHTKqsk+Tuzm/zFUoQEXnJotTwICU6/Z11K5Lv1t3dpqrnDjeKSFi51gJdbSbCfY9v6I0mMzjrxAC9r0zgaEcY63QH3gMMylHE9sJ0M4cMXJltiyeqkeNKXae611HL7fyYPZJKO5CGykK7PDqqtJe0yM0aSKXYucPWOKxRN8WN91vRlqk9lUZ9Inq1X71r48+bnDWvA296sl7N91lz5TrJTkTWjr1l7SAbc3heNWq1lMRsZMyrEcklIME6AdAAzEN7Zxagy6dqtWOHPKrcmSl2WZJnoSvxTc7FdSkvCSldOlqaEXDTKVMnA230PLQudFCsVefe2S3xMW3haO31y+4OFx/fimancbrlTZ0fuJ+m2kMu3Zsxm+mG2xYbm/THmr5tHyXM5D9Sj+kxtrRRrbCZFEUoXDSJAZBxnYEzw27Ks8xuRvRlyokB18PgTnYFrR4gxnFcoicyGuuo4Cw4Kh4nsF1am+zYDHMPZmG1rerMKXNjhsGCHA90v4nsGSV1OyfnoZXUZoCkRAykJMk9fYBdDDj3mc6ELzQ2jUuiGO2MdeHdjn0ijPaNNSGyNqeuBbz/uVrk870CUi+OCPrKJgRdhwtdX2IM5CqJeNzB7nGwhTxsOSh52SDYL9dycNO1MLSUkDkceg/0sXQK+Rb756iAp0HDDzl/wDVtJntKHVlHcfRoEcXR8NQpUgh45R1IiZVIeJOOTpicYy459h58Met70Hqwg31gaZd9QSUVZQtfRdXwuK0brv55dDiwNPsfmvSpgKxBLLUomlWZsY+6RbOrE9+Z6SjRxKlSLdVQcO0pqpkiJaoSaKRG9VAPFBUh5tYtvSOlhMiaJTGW+HrQR1SjcVS9FvleLJ3vEgaWemmWoAauBL6QEJkl0fFMM+KxJahLqtC+4B6VmiP8yyWz68x7FbeQWLAeKr1cT8Fdjx6E8jhQkpVoHaA2cv52onse6hBzvoearMyunKu0nVnApSdYSDEOeNLyzcY+ZiznpDUsewxSCVJVlFsD1JEtKhXV0zOts912pt6kyIxmK7AOJJlI9l1yrvlRnuUohLse7GoTl0NVER8uAbT27BERdxS14TGvnSRWM5nTvD2ATRa9CMG9B/VNsDsaBGrXzfVFK8mHPmILv3cnkzTtEEVGj1vWVl7URKeBEBVFanUhvVkdWTd6bFg1pIBcsX2H8GWuHdYEPHZi1A/qXXJs4SVoJBaaM1MpK1v6P5fbgUjEwnqEri9KYrWUQAqktNJ6z8g54PMFAVvtYeaZWNlVMSPBaoH9FiRles1It00Nrug9Ynu6dcfDaGIPCEaFfoqJrzekpBOephb0pj6bO5FAuSiihgidLEiZCemOlqMl2Ay8mbzTwqrKwRcm1DH6iJ5Ndpb9quuU+agQJ6+fIQbWl9QqW1a1Fu4nOXAZ45RoBxJu55ww4b7bMCSiRx9qptiJiXvpLidvr93KMHMuTQocX2qCI01pzuyonmTlHqhOwVbXYBtphNoXrEqX4QadSWBOhzIBqknQ4YpEH5sllVPVS7RHOdkpePK1iNYr5gw308Wl25sCIRNRVk9MK7JwihITS5Vce2cWZJp724npbpdKLxUO74HT0vXc5S2kkcoZv8vNwOODtNC2NlfZ+u2uZSHl7dGsZiM2nrxQcjPXMXfmlY9q7FPJmrmfGLG2+YnUcjdbLCo7W22GsvHMhpB7nF709LopnMdplfpzP/9c2WSI8q0KY7X/tlXCYruT7Elpdz1mtGeIzRaz7BF9K1N61s9g9rs6UlVEjNIdx9xjteakUZJJj81KeElVVK+7pyn3M76VWMTJ6k4lZ8/urasuQ6SKSFOF+wVEFiYzEZifffXVn6+6/8xvjCqdUhVSQEyREvcpI5iDx4zePkd2KWimXecxHGTn/M4ecbdnwy1jTxCT0ygEjvNDm44gTa9j7HmZnmA+gOyOyFaA1sCsPdZWOwmozkSSLFb12OUgIx2kRJRAGu787GuvvPLqL771V//p38TPzqFqYU9YN+XtKlw73OxA3LSEk4rZuXW0NCzbRpcTpggMXyai604nAqTia4lxOW6m6QUe4usqSdLHQH2zGppJKuu4nDkhCyzw1QFhxs3VFazX7lHOLB0KfpO2e5N87LVX4M/+na/5hrpOI1suPZTUSgRn3SEzB9BXG+pyKTv7xC6HUEKJSykG4UjeTQHxrK4LsTFQoQGrT5+4yEl7Wkp6XfnsR92JjLvJ1NRoR7QzHN8nP9QmgZL07Cl1a3PIZFdKLHc1VQu7yD1+nx977RXuf1Pfo/WJf/Wn9obzMYn2BbmmrpGIL9kcyYynTgo9suuD7dECk5jTD5ql36qb49Bz0ywbhUvZYejQf1Eq67ZYoY+ptHQLTpLcqKTdUS2f4xtk19e04aNcWfxuTWkU4ppUg7wL3LH42GuvXH79i9/49Vqf+CdfM85o97E0kyNdyCnKRcBt3SvSgv0ZCaKNzqQcSThM0jQ1ax9tEchUmjadYKU+wLlcLvscAhANtbxdCX3EvY4yqccX7h1fYwvrxLaDdi/VErU4z/+YwYdEsjib/1RI+Nhrr/zBb3391xf1iW959ZdAZWZETtlWSprbFGmV3CL0jplAvRLImunxlCxPQYOwah/USSm2O/ouJFKYRi//AkPqaN/Y4j5bcZanNOsx+XTebqtYhwwb1bpyY+FblCGZuPRpGA05VrKULCIxcueeOYnPT7/2yq/9z68vlHrvF1959RNUDE152xXlrk1RWUedhkvVxXH1xpApLX1C6fl6qq5TOO/ZhEhP8i8hppSOD59PzaoZ4LZrBiPVfBGd1HWeIiKXjq5Z03LfSZQ2NaBMsVvmtJgNMhKNy8k5iXIB9KdfewX7M7NH/hivvPqJPiEpb6Zt77mutjvrtF95jjtgdVqiBrjeKZhpBCRLRzPYfl+g1PeA8qvIJELO9Nmic2vtCaNdJtMXAZtkaxkystSPaS4XymvDN8uNvxnhfXRs3PqAATmTQEjE7UzLshKafMtx1QocZ81GkZ4VDJFr14xzH65xWEWfC7G6h17cQdu8WtY0DlT2IShNkLmDSVmd9aE41j7aIdkNRi8Ak+rd36ccSLY2qaBYFx/d9ClsU1bte1CVibA2kQdS43661Jbrr7z/TeILJVV84a2v5c0PfHtGQUYpcJn46QNOSnA38abbah9aAoFYdvVvHxjQvqImzYl2TnqsMTJbje9Wa7vkSszXHOs1pUp5FMJKZZOpmVE5PYK7WLi7cXZhdnpAz5m0AU4RK4k8weQMDM7kL7//Tf06FeQT/k13b37gPdqC/Y473co9MWWEs0RT87uWf9fP6IqwpxdEECXa0qeumY3Dy9iThLEzt7GZTdyGYtFHZuijYfi6efSUFdQuiWaXjVadtdDZhTFMbxMdqwc0FFZhIyyqCoiSXGjqd//qN2rxhbf+wtfx5gfeXZPKNm9/sXOoiPTAh+nJLiFzSuJeGKVTaoi53EFpW563Bu3UNRtTP4s9HLKZjwNrGdW1G+IFniDJMxnqDqTrYJOqJTPUo2TnwMO/9dbRGUguEnARz24WMiKrJXV/+B3fV8gn/vQ33fHmB96rFTFnmWiLjDjRSnQNZtI/p3Ufvk69x4QRneOdkppTUvD05opKnmOdXYKQqJIbXd+pGLyZ+PxY+jcNgktG5duFv2k5SJGuruoWXEyltdtDkyozdM35ATnhdkF++vuSL/yNb//j8OYH3ltL5oSn1YRAME0sLY4oIbSH9BM66XwdsE+iSi2xCIk5+2rcyVBg45ik6aVUX76cKG+fWwJcRJadmd3LBbHdvJKE+Sqpm7CFhe8azpC70QOWptkpdPn9DD7poR571EtP11VKfvjX5Dde4c0PvLdLZnXdqGBwadRlPQbY9DwBo03A5TJ0Qmd/hIm4SborqSolJ3o8+wCMKvXlENHnau2S1lFlyaYU+yY+lhbXGItNhbCnNVygKqxxfEVLGzvJbrFjzcl0MAcbWWvJQ+AibTbJJ/7W//7a7/rAm7Mk11E6jtg6myF2JF7emk6qb+ZddvVuBpO3RhRCSxc+E6ZtxzmZcf3NnCwWYhEYlA51Us7tCQc5p9w8LxFOvXYH7sE3JeW1x+FcDWr5ZQizObWutjpUw+qq7b80zk34jp96N/BdH+AvrvMAPCbD61H0xmoQUeJLcKXE+z71ZCOgqzQsBw3TND1PmUEIb5kFl6OHnA+p6wsLbsJoo6xTS57PTSV/mOzME08NSCGsQ5btzH+qwdrdCDlEWlbpNO5Y5oY/mqJULdCV8iejivzOSQWiZAQV+2blugb75cicP+ab8ikup9DACzXLFKnEddAptkdndEp8CrKWe7isae/slHhNoNWXtqaQuQ87ShRZslPiQi6j6gvJHmiRulYhUj0xXSftG4ghXT6uxUz5GkXQboIbgf0chXHeInNNEaxE/KZQ10IVvaFGOhYRqEwuLBuyTqHk2EPtt5xtOlQpEZXW4fjsidwHO7xY5L1FLZGbeioozImF+1RpG+3edTmgJwWxyLnouGTNG2gfXZB3J5ztetiKyhhWtjYy4319hNmWHu9tr9a5iA2rssfX+7pDejx9h+qhkPasdj+zpBMD7zOYspVR1nE0LexR/VoDmaBJ8JnVvhMbzeXrbIPLvNIlsBrxLz1FKWs/HppdHYOUsLaj3BvufvxqoXvkBT7dTXml5g+6irE11X7exB5hZnF73FZeyRji9Fmpc5roHLimW5cRSYnlllzXbeE/5FT7jUw0bkSa0/ByTq2zs3NGt1Z6PSIhIFeHxpZ5xW56OhVbPrOXXIE///0vI3au2oq3P4LpK1FY3CajcqO4ePQMJuQWjlwVyI9qKr78SMfb1XnhFKd87pM3XP0hLwexUgFH1l0DNlemhnE0eEFQL8X2cAFPv7TgRrIftkmR+3xIXx7gzBS2lsNV6fUk5x7imC+vnPeZLJ3r9AJN0CFLRsapa9qMm4ZclqtThiKy9H4PsOAi3LeqoLFIrsJX9RCm6n5CvZZCZYt/Y3nDej8FXEdQ2uNkNDVtXIk7XndaQ+r3vR/C1YiC5T2n5bj2Q8qSHFGe7mD7SC/+hiiLXIH0rD4Eak1hZ805oPhWx03h/D4TTyEIgtW0bwVwkbx2vtSojVcTlussIv2JAeQu1wzlPNvb5yDvfcpdX5efXGtuMYHFNGQMk/Ag4XHy6onUYuulqrDUMKTC6zwctesCS1qQQOom5edUHFKXr7OJMtAYA1rT+tgutoHL/Xn8dYw4cLT1ucm0fqXL/GrA/wXAZHzoHrq/wAAAAABJRU5ErkJggg==)}\n#webamp .media-info #stereo {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAMCAMAAACpx0YDAAAAk1BMVEUlJTklJTolJjsmJTsmJjsnJz0nJz4oJz4oKD8pKUApKkEqKUEqKUIqKkEqKkIrK0MrK0QsK0QsLEUtLUYtLUguLUcuLUguLkcvL0U8PFNDQ1hJSWFQUGNaWm9lZXZpaXpvcH5wcX9xcYF3d4Z5eYh8e4x+fpCBgY+Dg5KKipaLi5mMi5mRkZ2bmqaioqypqbKqqrTexa8FAAAAvUlEQVQYGQXBQW4aURAFwOrPIJCjEY5Hytq73P9giCj2YBTy+7mqfkUTiURmtUiqRY8eJBJRFAGULIemEipBQySka0xQL+9Bz4FEwbBUj9PP+ffF22P1cXbc1+fnsv7br5ExRr9mz911M99Op+d2P1+22/yRitHttr9eUPP5cH+w/3ftQ4cFx9VX93a7nD+ObufVn/nbdSRqk4qWSCfERHS1USq6ggwkKTCMLBERpCuoVAQdYyAl4dASNJjKN1/Kh0LDHtt2AAAAAElFTkSuQmCC)}\n#webamp .stop .media-info #stereo.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAMCAMAAACpx0YDAAAAk1BMVEUlJTklJTolJjsmJTsmJjsnJz0nJz4oJz4oKD8pKUApKkEqKUEqKUIqKkEqKkIrK0MrK0QsK0QsLEUtLUYtLUguLUcuLUguLkcvL0U8PFNDQ1hJSWFQUGNaWm9lZXZpaXpvcH5wcX9xcYF3d4Z5eYh8e4x+fpCBgY+Dg5KKipaLi5mMi5mRkZ2bmqaioqypqbKqqrTexa8FAAAAvUlEQVQYGQXBQW4aURAFwOrPIJCjEY5Hytq73P9giCj2YBTy+7mqfkUTiURmtUiqRY8eJBJRFAGULIemEipBQySka0xQL+9Bz4FEwbBUj9PP+ffF22P1cXbc1+fnsv7br5ExRr9mz911M99Op+d2P1+22/yRitHttr9eUPP5cH+w/3ftQ4cFx9VX93a7nD+ObufVn/nbdSRqk4qWSCfERHS1USq6ggwkKTCMLBERpCuoVAQdYyAl4dASNJjKN1/Kh0LDHtt2AAAAAElFTkSuQmCC)}\n#webamp .media-info #stereo.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAMCAMAAACpx0YDAAABXFBMVEUA/wAD+AQG7gkG8QkH4wwI6A0K2g8K3xAL2xIL4hIM2RMN2BUN3RUOxRYO1RUQ0xkSxh0SzBwS0RwTuR0VvCEVxSEapCkbnyscrSwfczAgpzIhkzQinDUlJTklJTolJjslJzklKDolLjslkzomJjsmKTsmKzsmLDomMjsmMjwmNjsmOjsmRjsmWjwmdzsmiDwnJz0nKT0nLT0nNT0nOj0nQjwnTj0nYj0oKz4oLT8oND4oOT8oRz4oSz4oZT8pL0ApO0ApTEApTkApZkApZ0EqMEIqMkMqPEEqTEMqT0IqUEIqZUIqZkMqa0IrLkIrL0UrNEQrPEQrPUQrQEMrSkUrYkQrfUQsMUQsNkUsQkQsS0MsTkYsVEQsWEUsYEYsZ0UtLkUtLkctL0gtMEYtM0YtM0gtNEgtNUctNkctOUYtP0YtQkctR0YtS0Yti0cuLUguLkcuMUcuM0cuN0c2LFEQAAABDklEQVQYGQXBvVHDQBCA0W/3TrJkBBhmPAQkBATUQA+0QEROT9RBwtADCQQkDMaBLIOk8+nnlvfkUfYq0HKgtzIMMIBBxNpR/+Qsy+pcxLnj46iFiKrquJeuw/xp51QvayeuxkSikk+YHuFmxLdetRH//HXnCIuoxiSxpzS1hFfRlw+/DrxWO1YdqdgXV9vd4mrZmWgl9UdaUnD/LX4bo9ue9O8/N/lnkFG0g+tquwGSy5dUR1BlABio2fmmoVzL00XfZMluV027WL3tK8DkIWtUJRBMJGCMQKQve5vT4C2tRDd5LSaS2wEDcjqz2cbZM0l7Nh/KHiPCCERIKfjR8EmnEApqAGMASDD9uiHBP3bmjPqWVRjwAAAAAElFTkSuQmCC)}\n#webamp .media-info #mono {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAMCAMAAACk2TZEAAAAclBMVEUtLUguLkcuLkgvL0ovMEswL0swMEsxMU0xMU4xMk0xMk4yMU4yMk8zM1AzNFE0M1E0M1I0NFE0NFI0NVM3N1E8PFNJSWFQUGdSUmtaWm9gYHZuboJ2dol8e4x+fpCGhpeOjp2VlaOdnaqlpbKsrLetrbnuzsEEAAAAp0lEQVQYGQXBQU4bURQEwOrvkcA4iRS4/+VYwI6VEyTPzGuq8ppyrjHKIVPQsSnnGpReZkQnQzfImKJUU8saWUEWQZyV0g7dqs6X349tf7qfN3uf6t/N/imLDL7WY1/Xx8d1m/+X6+P9+U1XSADNH8Xkr9aqmTW7fY5+r9v9OHp859f9i7z2vJwZpUdUjWpqSZQytlYJUrOpWaR1FhhgbcLQRiEFTH4AmtR0pKKbMGAAAAAASUVORK5CYII=)}\n#webamp .stop .media-info #mono.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAMCAMAAACk2TZEAAAAclBMVEUtLUguLkcuLkgvL0ovMEswL0swMEsxMU0xMU4xMk0xMk4yMU4yMk8zM1AzNFE0M1E0M1I0NFE0NFI0NVM3N1E8PFNJSWFQUGdSUmtaWm9gYHZuboJ2dol8e4x+fpCGhpeOjp2VlaOdnaqlpbKsrLetrbnuzsEEAAAAp0lEQVQYGQXBQU4bURQEwOrvkcA4iRS4/+VYwI6VEyTPzGuq8ppyrjHKIVPQsSnnGpReZkQnQzfImKJUU8saWUEWQZyV0g7dqs6X349tf7qfN3uf6t/N/imLDL7WY1/Xx8d1m/+X6+P9+U1XSADNH8Xkr9aqmTW7fY5+r9v9OHp859f9i7z2vJwZpUdUjWpqSZQytlYJUrOpWaR1FhhgbcLQRiEFTH4AmtR0pKKbMGAAAAAASUVORK5CYII=)}\n#webamp .media-info #mono.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAMCAMAAACk2TZEAAABJlBMVEUA/wAD9wUG8QkI6A0J5g4L4hIM2RMM3xMN2BUN3RUP2hgQ0xkSzBwS0RwVvCEVxSEWySIZwicZwigcrSwgpzIhkzQkpzkmdzsmiDwnmD0olD8qa0IrfUQtL0gtMUgtQkcti0cuLkcuMEguMUcuNkguOkkuR0ovL0ovMEsvM0ovNEkvNEovNkovOkovPUovUUkvXEovZkswMEswM0swNUswNkwwP0swQkowTEswT0swUEwwVkswZkswaksxNU0xN04xP04xRE0xZk4xbk0yNU8yNk4yNlAyOE8yQ00yTk4yU04yVk4yY04yaU8ybE8yek4zNFEzOVEzPVAzQ1EzRlEzTFEzU1AzXlE0M1E0NFE0NFI0NVM0NlE0NlI0OlE0PlI0QVI0RlJbMtAUAAAA50lEQVQYGQXBTW7CMBCA0W9mrJKEAKr4WXXTu3TXG3Dc7nuOIiohKLHjGJzpe3IUreZ6BxJkIIHjnlxxbDBVs7EXaVV1u1UtpehDAdloNB3Xo6p1XbF7CN2kj0YFEYmasmUz05yb3KjmfW5LcBnEvk7L1N8P4UwvN+HwS/c+iqIrAT68XTyvq7frZNt6W33+nUAFHADAHAyw+ZsA6tXx0AxtaHTz/Nm9dGGxqef9bkKOntdRUh8BIFGIOD42KSBLn6WtFQAWN7zBL68plYDXQVwYASABGTy6h4DMOHEOyATMOHWmJh7hH8HfcsJFco7ZAAAAAElFTkSuQmCC)}\n#webamp #time #minus-sign {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAABCAYAAAAW/mTzAAAAF0lEQVQYV2OUUNT8/+L+dQYJRU0GGA0AVz4HY4h207oAAAAASUVORK5CYII=)}\n#webamp #time.countdown #minus-sign {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAABCAYAAAAW/mTzAAAAEElEQVQYV2Nk+MHwnwENAAAjgQH5sdp7TQAAAABJRU5ErkJggg==)}\n#webamp .digit-0 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAFklEQVQI12OYGtrA4ACEHh0ORNFA9QAiPQsl393R7gAAAABJRU5ErkJggg==)}\n#webamp .digit-1 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAE0lEQVQI12PsYNjBwMDgwEgCDQAItwpIh/66WgAAAABJRU5ErkJggg==)}\n#webamp .digit-2 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAH0lEQVQI12OYGtrAwMDgwNDR4YBCg8RBLI8OVBooDgAebgr//9NFIgAAAABJRU5ErkJggg==)}\n#webamp .digit-3 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAGElEQVQI12OYGtrAwMDgwNDR4YBC4xEHAB3uCv9NUBWtAAAAAElFTkSuQmCC)}\n#webamp .digit-4 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAGklEQVQI12Pw6HBgAEF0emqoAwMDkO7owKABD8wKi451feQAAAAASUVORK5CYII=)}\n#webamp .digit-5 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAIElEQVQI12OYGtrA4MDAwODRgUqDxBmArI4OBxQaKA4AHm4K/5vyk78AAAAASUVORK5CYII=)}\n#webamp .digit-6 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAH0lEQVQI12OYGtrA4MDAwODRgUqHgsUdgHwHFBqoHgAbbgr/DdfRzgAAAABJRU5ErkJggg==)}\n#webamp .digit-7 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAFklEQVQI12MMZdBmYGBwYOxg2EEsDQDjggmI1L+I9wAAAABJRU5ErkJggg==)}\n#webamp .digit-8 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAFklEQVQI12OYGtrA4ACEHh0OKDQecQArbgt/wD0r9gAAAABJRU5ErkJggg==)}\n#webamp .digit-9 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAIUlEQVQI12OYGtrA4ACEHh0OKPTUUAcGBiDd0YFKA9UDACFuCv9mR03UAAAAAElFTkSuQmCC)}\n#webamp .play #play-pause {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAACVBMVEUAAAAA6AAYISlH3xqZAAAAH0lEQVQI12Po8GhgYAhgYOgIAdKhQDrUAUKHQMU9GgCL+gfA1jUO8AAAAABJRU5ErkJggg==)}\n#webamp .pause #play-pause {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAACVBMVEUAAAAA6AAYISlH3xqZAAAAGklEQVQI12Po6GhgAIGQVgeGEFYHFBoEgPIAiaIHnsCfw8kAAAAASUVORK5CYII=)}\n#webamp .stop #play-pause {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAACVBMVEUAAAAA6AAYISlH3xqZAAAAGUlEQVQI12Po6GhgAIHWkAYG1hBUGgSA8gCN1wfe41RVhgAAAABJRU5ErkJggg==)}\n#webamp #work-indicator {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEUAAAAAAAAA6AARQDMYISlODwD/KDN/MQZsAAAAAXRSTlMAQObYZgAAAB9JREFUCNdjUFI2ZmBgQCYFBQWBpKOLCJwdGpaGSgIAfI8Fm6vX5/8AAAAASUVORK5CYII=)}\n#webamp #work-indicator.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEUAAAAAAAARQDMYISn/KDPWqFE6AAAAAXRSTlMAQObYZgAAABpJREFUCNdjUFJgAAJkUlAARBoaINguDmgkAEabAvbVxDW5AAAAAElFTkSuQmCC)}\n#webamp .playlist-top-left-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWUlEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TllWjvk7ZyX9pb0jeRDhFvYqBDe5+kxzjR3hK6xImKqibtfUKXzEiXsosulowWkKRUQYx0SV10sYQeqQsAf0Ul/5LwY0QAAAAASUVORK5CYII=)}\n#webamp .playlist-top-left-spacer {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWUlEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TllWjvk7ZyX9pb0jeRDhFvYqBDe5+kxzjR3hK6xImKqibtfUKXzEiXsosulowWkKRUQYx0SV10sYQeqQsAf0Ul/5LwY0QAAAAASUVORK5CYII=)}\n#webamp .playlist-top-right-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWUlEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TllWjvk7ZyX9pb0jeRDhFvYqBDe5+kxzjR3hK6xImKqibtfUKXzEiXsosulowWkKRUQYx0SV10sYQeqQsAf0Ul/5LwY0QAAAAASUVORK5CYII=)}\n#webamp .playlist-top-right-spacer {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWUlEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TllWjvk7ZyX9pb0jeRDhFvYqBDe5+kxzjR3hK6xImKqibtfUKXzEiXsosulowWkKRUQYx0SV10sYQeqQsAf0Ul/5LwY0QAAAAASUVORK5CYII=)}\n#webamp .playlist-top-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAAA/FBMVEUdHS0dHS4eHi8fHyIfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDckJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pKUApKUEqKUEqKkEqKkIrKUIrKkMrK0QsK0MsK0QsLEMsLEUtLUYuLUcuLUguLkcuLkkvL0owMEsxMEwyMU0yMU4yMk8zM1A0MCw0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4N1g4OFg5OFk6OVo7Olw8O109O149PF9FQTtnXEJqanpra3xsbHxsbH1tbX9uboFwb4NxcYZzcoh0c4p0dIp1dYx4do54d5CGd02OkZDLe86vAAAAvUlEQVQYGQXBMUodUBQFwDnnXdMq2LuWQFy/nYVFQAIu47+bmSDSpFFtmyRp452oiIhIIjJ8Nr/2nD1Nc5ppJS3idhVqIRii93wDABiC79/PAACDdbwAABju8fAXAMBg7/EKAGBYu/YFAGAg9+0DAMDgNo/XSdLm5JxW0sH+JE2TJm1a9aQI2NiSYD0Mlj9JEiKSkAzY/XrKnPQkpydJUoDrXnvFQlIAu67aLVDAfbAgu4k1gHX/pZ2cJKme/xmiNhnfUYYUAAAAAElFTkSuQmCC)}\n#webamp .playlist-top-title {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAMAAABMHminAAABd1BMVEUdHS0dHS4eHS4eHi8fHyIfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pJ0ApKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEUtLUYtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEsxMEwyMU0yMU4yMk8zM1A0MCw0MlA0M1E0NFE1NFM2NVM2NVQ2Nk82NlU3NVY3N1Y4N1c4N1g4OFg5OFM5OFk6OVo7Olo7Olw8O109O149O2A9PFs9PF89PGA+PGBAQFhCQV9FQTtIR2ZMTGFVVG1WVmNbWnZfYGpgX3dlZXdlZnRnXEJnaHZoaHhpaXtqanpraoBra3xsbHxsbH1tbX9uboFwb4NxcYZzcohzc4p0c4p0dIp1dYZ1dYx4do54d5B5eIl9fY6FhJSGd02LjJqOkZCQj6CXlqeioq+srbettMQFH6KtAAADiklEQVQYGQXBTa8VVhkG0PW8+1zuRYuN4gfgpV4q3PpRNTFGw8Q4MlaJsUPjr/D3OHJgjANnNR2hxA6MNW00mKJAC0YSSZu2SkmBnrP361o5gsY09UL3Ymrd3bq7073obgAQSoUYJJKoqIgoY0DYvAgaaFbr1tA0mrawAABKQghBEIkBQXTY3AG7mrpZbfYylzVr123ZrWx199TLWsBYo6vYJEYqoySxFzV6qEqhGIUCGmKJXlqoKRoaWbozWwKzDYvVDYDRmFmAAGTDFVZtdbN69WQuvey6Lbu1stOzrc4uC1ClspkjGTGGSmKjkhpJRUnsbfdeYvNz9399xXze354/8dqFT7z+rfGnb9fNunTr3/393H3Djzz53Qsn/ea7h6x//Hnxs32eXL14fPeVTD8++ejlH+7fvPXC9vc/2P5Bff7SuzeOT5tv1UXsro+XfnpGVZ1DPqqTJzz99AOQI8zz6bPB/pcOSLv5cj1rwC9v738F9Djog/VqX7ycN8PQ+Nzp7Y23//f+a++5fV2cq9pc85iu/1w44my9B+yfpc6s7f7pd8xxyXavpxMXbWvC5T0LJd/MvcNv/P3uhU/d/1dYo8Hel7cPPwDaNer4+OvEEwe7+XHvB+aTp3Dqow99Ju733mMW559555UZ+MKZu3/E0odz69Bfp9ehFN6+M+0dLcHg+Ph4c8Zb8GiOD058bAuLf34tzmc85dwNHp+8d6R481WrFvyKcPo7/nKwDvsgWYMYz3iAz5697Tk05p4Pn7X5hYdXiAeffNcXH2qK/9694OyTa763/2nuXbx+JBu6uxZgcOqU+G0uH371DWh1yS08Gs+ZtwtYV65elZ8AW61ZbfYyl6V3utc0s9U9Wy89QWpupMgoNoY9STKSUpWNFAmbLnIENHNaTbduk2XRemltsRoARFEiBokkKpJEijEgFOgGQNC0poGGBQBIWokINAgJLABsXgQ0DaZumoamad1YAEChCCEIIWFAkA6bO2CZui169uq1dPeu25q92k6bbWXtohlzswbJJjJkZCTJiCqjYkRJ2IMC5gTFAugpFhB2pa01emCOXVplQ0iNClAMelDAahTYjQHoDkEIMaJmM2Z3d7cFU2CubtoEWExMAAkKbOYEizRTLLSYbQ0SCd0WkvRCNVitgVAI0OwgR9CYJqvp7ja17tZtac3S3QCQiJJIIpLEEBWkjAHh/7B25tuthDwsAAAAAElFTkSuQmCC)}\n#webamp .playlist-top-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABNVBMVEULDxYMDAwOFQsUFBQdHS0dHS4eHS4eHi8fEQofHyIfHzAfHzIgHzIhITQhIjQiITQiIjUjIzYkIzckIzgkJDklJTomJjsmJjwnJz0oJz4oKD8pKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEUtLUYtLkguLUcuLUguLkcuLkkvL0ovMSUwL0swMEsxMEwyMU0yMU4yMk0yMk8zM1A0LhA0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4OFg5OFk5OVc6OVo7Olo7Olw8O109O149PFs9PF89PGA+PGBFQTtGQh9ORDBQPx5YVjxnXEJqanpra3xsbHxsbH1tbX9uboFwTyxwb4NxcYZzcohzk5p0c4p0dIp1dYx4do54d5B4h4yGd02LjJqNcTiOkZC/uXdbAAABJElEQVQYGQXBsWpTYRyH4ff7cig5a8FCKAge2slNqFvoBai4e5d26h0UrCnYpaCSrbV2cA0k5/97fZ42WYVR1ZCgZWC4REGDSEAVuRpeUoayyiqddU6IdIGeDkCHBQFgpo2s1dXR/mj/66BvHm/h4vSunocv/67XrpYsWb69L5yAadsaw+IV8hMAAl8/Tbtxe/tahhtAAKAXuBt30KCfnUEHAAL8HXcnQKcfH2huAPje4fO0/fNjujC0kbXMNwds75ydHr/B+9NNntuHlJZWYpWpOcb4NDxYpUTVSAzzx03RoQECIAQomGG4RESDSFCuABheUv2AVTFV2ScamnRCNYiYKAsUhA5g0pqNRpgVADq01gCaxNIgAMODVZJz+F2WWisA+A8o2vB09xIFIgAAAABJRU5ErkJggg==)}\n#webamp .selected .playlist-top-left-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TkVWnvkzfnqmhvyf///2lviaujNe0tWTcplfaW0CVOVFQ1ae8TumRGupRddLFktIAkpQpipEvqoosl9EhdAAvFKfTd8tQbAAAAAElFTkSuQmCC)}\n#webamp .selected .playlist-top-left-spacer {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TkVWnvkzfnqmhvyf///2lviaujNe0tWTcplfaW0CVOVFQ1ae8TumRGupRddLFktIAkpQpipEvqoosl9EhdAAvFKfTd8tQbAAAAAElFTkSuQmCC)}\n#webamp .selected .playlist-top-right-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TkVWnvkzfnqmhvyf///2lviaujNe0tWTcplfaW0CVOVFQ1ae8TumRGupRddLFktIAkpQpipEvqoosl9EhdAAvFKfTd8tQbAAAAAElFTkSuQmCC)}\n#webamp .selected .playlist-top-right-spacer {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TkVWnvkzfnqmhvyf///2lviaujNe0tWTcplfaW0CVOVFQ1ae8TumRGupRddLFktIAkpQpipEvqoosl9EhdAAvFKfTd8tQbAAAAAElFTkSuQmCC)}\n#webamp .selected .playlist-top-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAAA/FBMVEUdHS0dHS4eHi8eHyUfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDckJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pKUApKUEqKUEqKkEqKkIrKUIrKkMrK0QsK0MsK0QsLEMsLEUtLUYuLUcuLUguLkcuLkkvL0owMEsxMEwyMU0yMU4yMk8zM1A0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4N1g4OFg5OFk6OVo7Olw8O109O149PF9FQTtqanpra3xsbHxsbH1tbX9uboFwb4NxcYZzbFJzcoh0c4p0dIp1dYx4do54d5CukmXsznr///9ua7yBAAAAvklEQVQYGQXBsU0dQBAFwHnvFsshErl7MQVQtlsgIEGWSMkd/FvPBJEmjWrbJEkbr0RFRFQSkeG9+bHn7GmaNtNKWsTtKsRCMETv+QQAMASfbwEAGKyjAACGezx8AwAY7D2eAQAMa9e/nwAAA7m//gAAGNzm8TJJ2jTntJIO9itpmjRp06onRcDGlgTrYbD8TpIQlYRkwO7HU+akTU5PkqQA1712xUJSALuu2C1QwH2wILuJNYB1/6adnCSpnv/+0TYBQOmyqAAAAABJRU5ErkJggg==)}\n#webamp .selected .playlist-top-title {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAMAAABMHminAAABd1BMVEUdHS0dHS4eHS4eHi8eHyUfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pJ0ApKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEUtLUYtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEsxMEwyMU0yMU4yMk8zM1A0MlA0M1E0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4N1g4OE44OFg5OFM5OFk6OVo7Olw8O109O149O2A9PF89PGA+PGA/QitAQFhCQV9FQTtIR2ZMTGFVVG1WVmNbWnZgX3djY3BlZXdlZnRqanpraoBra3xsbHxsbH1tbX9uboFwb4NxcYZzbFJzcohzc4p0c4p0dIp1dYZ1dYx4do54d5B9fY6FhJSLjJqQj6CXlqeioq+srbettMSukmW8u8XHx83KydLW1tzk5Ojsznry8vT////NCpc8AAADfklEQVQYGQXBS6tfBxUH0PXb5+Q+Y2oFI5ZoknpLiU8cCELopANJG+M38Ds48nM4ciw4cVJ0INhBK5T6KPVRChVFIzHUB4IQvYbEe+//7O1auQGDzWYaM81mzMyYmclMMzMAIJQKsZBIoqIioiwLhPUuGGDoMaNhGAyj0QAAJSGEICiJBYKYsD4EW9oMM3bTunVnm9G2zoWZ2UzrBpZepoo1saRSJYk1qmaxVIKiCgUMxIhpI6TFwCBtJttIYBuLpmcAUINOAwKQlTt07cww073Rbdo2o23d2Zlt9GSXBlSprNuSLLGUSmJRSZZURSTW3fo667edf+eO/pL3vrj/7mf3f/OVS29/df3Dwc0H9+dry3/eds/Zj1858oN7V9j+9Ivmm3uc/+rqC6c/yuYbR09+cnf//u9f3b3x6sWb6vmbj3/95eNcPLj8HC7er9e/taeqDpDz5XjftYMzkOfR15c5CPZvHRLu/3y5aYHv/XXvC2CWwzns387Nl+vPoQyeu3z+u6ePPnz3sb+/Lw6q1g9sTM4Ob/DMegpm/yq5ttv2P/XQbj1xvjdcPbTVBrevaJS8lNMrt985feb4vw/CZMD+586e/TcwPqBOTl4k/ubwYnc8HwZ2Z8c4ON+5Hk9n7ynN0ccfv7cFrh+c/hBtnt21j3pz5y2Iwj8eXdi/PqA4OTlZ9/wTnu7Ws6zn0Pzx83F9ucQBnh49uaL4yy91NXyflPX2vHO4Hc1h0oi84DE+uX/fLUCvHn3C+l2P7xD/u3zq+MJQ/OvRx1w7+6mX9z/Nk8O37glmphqwtKPPOPRaXvnISz+Dsd70AGfLLRf3A/Sd18jXgZ0xzNhN69ZmM9Nty4WZbUybDaS2VYosxWqxSpJKSiqXJCQsU+QGMGybHmbM2GjNmDZG0wMAoigRC4kkKpJEimWBUGAGAMEwhgEGGgCQjBIRGBASaACsdwHDgM0MzcAwjBk0AFAoQghCkbBAkAnrQ9DajGF20zNtZrYZ3dNjZ2yj07sYlm3thWSNLLKkkqSiSlWsEQkrFNANQgNMiwbCrozuZRZsyy6jshJSlQBFMSsBelBgqwJMF0EIUVHbsGwzMzMaNoGtZxgN0DR2ABIUWLrBUE2LxogevZBImNFIMo0a0GOAEBQwbJAbMNhs9DAzYzNmxow2hjYzAJCIkkgiksQiKkhZFgj/B6KI5O4cXV8dAAAAAElFTkSuQmCC)}\n#webamp .selected .playlist-top-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABI1BMVEUdHS0dHS4eHS4eHi8eHyUfHzAfHzIgHzIhITQhIjQiITQiIjUjIzYkIzckIzgkJDklJTomJjsmJjwnJz0oJz4oKD8pKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEUtLUYtLkguLUcuLUguLkcuLkkvL0owL0swMEsxMEwyMU0yMU4yMk0yMk8zM1A0LhA0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4OFg4QlY5OFk5OVc6OVo7Olo7Olw8O109O149PFs9PF89PGA+PGA/QitFQTtYVjxnXEJqanpra3xsbHxsbH1tbX9uboFwb4NxcYZzbFJzcoh0c4p0dIp1dYx4do54d5CNcTisrbeukmWwmV7O4tDsznr////5EmU+AAABC0lEQVQYGQXBMUpcYRiG0ef7708qu4mgxYCFVdbgtIGsIesLZAOuQ0GIlfXFMEMgTOXc7308p/Z2Y1Q1JGgMzAcUVIIIqsjjPKUNm912a+uWEBkCIwsAAwYBYKMmB3UP8Oeid65wW8/9Pn/274P7BeDbS+PXsnbHKmZN5B8ABNba9XJalbkCWgCOBvvLhxTMa2BggQSo5WMpGMzlTMUS+D+a293J2vk3zF8crPMVwBmt4wqWUN/T2rETu022GOM6X+1Womokhv7x1AwoQACEAIEN5gMiKkFEeQRgntLjglvHdOeSaCgZhC6ImCgLCsIAMF1lUcimADCgqgBKYmsQgPlqt8R73tpWcwMAn2oG882E0Lr4AAAAAElFTkSuQmCC)}\n#webamp .playlist-middle-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAdAgMAAADjkWVKAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAD0lEQVQI12OoilvCQGcMALzxKw1EtyFgAAAAAElFTkSuQmCC)}\n#webamp .playlist-middle-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdAgMAAADX6KRWAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAEklEQVQI12OwmrXq1UuGIUICAIEjYC7HaOXEAAAAAElFTkSuQmCC)}\n#webamp .playlist-scrollbar-handle {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAASBAMAAACUbIJFAAAAG1BMVEUJAgJ1XCKNcTibgkmwmV6+sX3aypzy8vT06sbDyd/kAAAAKElEQVQI12NIAwKGJCWlAoakiHYHhqRGD/KJimYHhnQXFwEGBQYGBgB4dhfwKIryTQAAAABJRU5ErkJggg==)}\n#webamp .playlist-middle-right.winamp-active .playlist-scrollbar-handle {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAASBAMAAACUbIJFAAAAGFBMVEUgDABsURh1XCKNcTihhkuwmV7DrnXaypzxKekLAAAAKklEQVQI12MIDQ0NYAgUFCxgCHRLN2AITDQjnyhLMmAINzYWYFBgYGAAAIGKEsehmtv8AAAAAElFTkSuQmCC)}\n#webamp .playlist-bottom {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAmAgMAAABMq9iIAAAACVBMVEUnJz04OFh0dIo98+79AAAAGUlEQVQY02NYBQYNDKFg4DDiaHSAKzygAADHT1L3iexI4AAAAABJRU5ErkJggg==)}\n#webamp .playlist-bottom-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAAmCAMAAADeF2QjAAABpFBMVEUODhYPDxgQERkREhsTFB4UFB8UFSAVFSIVFiEVFiIWFiEWFyMXFyQXGCQYGCUYGSYZGigaGykbGyobHCsbHCwcHCscHSwdHS0dHS4dHi0dHi4eHS4eHi8fHzAfHzIfIDEgHzIgITMhITQhIjQhIzYiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJjsmJTsmJjsmJjwnJz0nJz4nKD0nKD4oJz4oKD8pKUApKUEpKkEqKkEqKkIrKUIrKkMrK0QrLEMrLEQsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMEwvN00wL0swMEsxMEwxMU4xMk0xMk4yMU0yMU4yMk8zM1AzNFE0MlA0M1E0NFE1NFM1NVQ1NlQ2NVQ2NlU3NVY3N1Y3N1g3OFc3OFg4N1c4N1g4OFg4OFk5OFk5OVdGUF1OWG5XZHZbXGRfYGpjY3BlZnRnaHZoaHhpaXlpaXtqanlqanpra3xsbH1tbX9uboFwb4NxcYZzcohzc4p0dIp1dYx5gpaBkqWttMS/zdPt//+lzFndAAAFVklEQVRYw4WYPa4sSRGFvxOZvYQnYBc4gGoVSGgkVjBiLFgBDj5IYKGxsdBI7GDcksCADWCOhB4G5n39OjMORmZV/9zqnpRu3e4+lRkZJ34yIvWDL7/l33z5bTu//dyAAcTj0NEXzU8q26/zT7eviaf/6/jkdn77/JdzZhpQbEsIoRAqAUIKRIUoeUKgQkFBcVAGpHozo4JKotILkuQAogLRKoohvZ/fzudzpg2K8KBgVw5y58QCTE1AYRIghRLK1DyhYmppTWQQFCRvyzZIJBjSL347fzpn9majvOHZEFjI89uckS23/UnbewiYKlnQUDXOsXdDxtgxGZQ2mOCSPn+6ZMvU2JEZ8sZWU95JAhtUcUwXsW5MDfTsDUPrVGJQEwONkHGGW4DLWLRl+u1zNjflpqI9VhUkKXKoGoMEN06BUOJo4LBJ1AyleqOtdVOu+5JtBWFqZkd24M/nbL649w4bi1MXY4gQY5shD7OPDUCCUkKpBFSFSQjR6wmKEwyis5GPrRYUkhL0y1u7kC374JhbsyNICzx0n5hEB6BAODEUYERMDnMayBE9w1p4urJqJZDkevHb28X0bEK/+hEHw38A4Itj8BtA/OQY/CcGPhyD32VNv31K3DLgd98R79/Kj4D4zTMwwL94AiYU/fgJaNX0pwtJkvHVRtj9Fm0s//IpKPGzZ2DNwodnYK/R3DLBgX/I4TAInoPp56BfgcVxoXcPX+TZSI6o20a8wLZIPx6KpF+4zxeHGvJqby+wl1PDvvh+l+sK6/6YUH8AV2C9Jj+u8IYO7LoqsLJuKwy0mtSdCuvCunB9ANaVwGVdWIB12UQU7+C6AMutcu10xVbmimNV5NjSonfzrev7w/3K7rpMpdcDJpf1AcgbnxjYcoW9Hx5SbhKW5b3d407A0HA5qDw2dBvlZuIEbsRTmYcncec9K8t8ACj1DjwSvs/aZoperuK3V5YBy/UdScu+zeWAo2WCNwa+mvYRgWuoLjeTJ+6I7wmnecDvPn8wyouZzlfxnrHVSy/F+7WIV9L9Mtsc1awHCev7CTqW/irXaXdmE/mfmf3vx8SfgrJ4Dqafg7MAnJn2z0A6H8fQ/q/PQIf992dgVvHx6bJ3Pp+//coffWw+Tn/84hlI+G8/PQYF6F8fjsFU3WOKDL4elaSsvSmRrAgp4xsRBFKBKCiQ5gEn/qEgFIFUHCHECUQW4L//6wVBjP4gKllb7UWzCGeW9gnWNIqQtrNvFGZjsjvyrNhinP7GwSyxy8haLoYyw30m9FEByq3RTME38Z65p3ONatbGeJSypOdxppLjbROZGlVuJEYJtIgAKm3LNS6zWGZ0aKJGKfTbqiF2J3woq8mhhTDq4B4mnIiMQmxNlqGCqzMx6qdR8I+6uHvfQWaFFpciYvuRjJjHbM4CGDzshMpsbFTwrJJjK7hj+k2AkdqwZqvG3WEcnVJk7EwPOcSlmodMO8I/uNp7rtyHsMhhftc5qwMywtNs3mh0AxWlGJ6HwDGSTxvForeI+/1tutN97z07aUsabhh7dzt2qem7dfgqkUWuvQwN6hZYIvCNl8s1rnnaB/cDnv5uD4+56bGuDfY0ErsRZ68/j/A6zm4RvisfTa8Ap1+/uql494t4R0w83Fvo6LLi7kpD1rhcMH+axLC5obQ3bChcYpAbLnKERJSsQiGhiEF7FAJVZQVx6lWlR0GUaTmXabg6CYotzYutvBQSZnd8CNNzc7jR10cPPNNHzFAcrWYnEiFXTA3jgI61JaJUpQ8n1QG5erzxGa417ikcN6x4JImRl8sehwVBma+V1EzHgcMbqRbS/wFHTmME7id3UQAAAABJRU5ErkJggg==)}\n#webamp .playlist-bottom-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAmCAMAAAARFZKlAAAByFBMVEUAAAAA+AAODhYPDxgQERkREhsTFB4UFB8UFSAVFSIVFiEVFiIWFiEWFyMXFyQXGCQYGCUYGCkYGSYZGigaGykbGyobHCsbHCwcHCscHSwdHS0dHS4dHi0dHi4eHS4eHi8fHzAfHzIfIDEgHzIgITMhITQhIjQhIzYiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJjsmJTsmJjsmJjwnJz0nJz4nKD0nKD4oJz4oKD8pKUApKUEpKkEqKUEqKkEqKkIrKkMrK0QrLEQsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkkvL0ovMDkvMEsvN00wL0swMEsxMEwxMU4xMk0xMk4yMU0yMU4yMk8zMz0zM1AzNFE0MlA0M1E0NFE1NFM1NVQ1NlQ2NVQ2NkE2NlU3NVY3N1Y3N1g3OFc3OFg4N1c4N1g4OEY4OFg4OFk5OFk5OVc5OVo7PEtGUF1OWG5QUFlTU11WVmNXZHZbXGRfYGpjY3BlZnRnaHZoaHhpaXlqanlqanpra3xsbH1tbX9uboFwb4NxcYZzbFJzcohzc4p0c4p0dIp1dYx5gpaBkqWttMS/zdPsznrt///////YTLulAAAHJklEQVQYGbXBTaim91kH4Ov+P8/p4tD90ERFpaCouBGxCxX7QpmCOxHBj40LP1ra0JLUTbeCO+lON/YDk6B12RYyLl4REVyK0DpCa2tTJwxmVzokeZ///fN5zzkzySQjdjPXVZ/zRKkkqCDO2rW4EgRBCFoQxJV4gkIpiiq7O9x25Y5v+fgd31q/M1KjBz1c6yw6Qnd1S7AJSW2NWZs4iXQ6zIiT2GTXobOJLelKTKoXRtWSCxejailrKdfueMwoRtOGG6medm3UMlaFzZW2jMFQKhQZhcIsQhRlm1NMVUNk6GkmnZ455ZT0FlvEI7dve2RQbRjtoRKpGK3fMmOwCmHOJj0jCGnMiIGMKjIYI9pSEmel2yk9s9vyVmSLLeLGbW57aFQMu+FtS0kx+mKlus0e5Wwso7GsFFJDM0rZ1bCb1fRcsUnJwFRpp9mzu7et3zx1trZFXLltd9uNkdLDNN3oMZoouqfYlY4r01AmlZVK9QUdtLOwBGv1OlSoijKKTs3OW53K3ObszLZFgtuu3HZtLcJicWN0FlOlTmNbrNtooxHGpE1j0m1X68ayiWUTHVTYxlRZtkqlGq3SVdtSpwtd62b0mMa2KtzxmDWV+hcpN1KiMuMsztJUp0JvS3cqwhSTELZgNiJII5FPv5gKxoyusa11WoZt2dTFmL1uC8rj1krJP3uaqlG/86OeIF9a56LyUdfuuDJSUZ6qrmqfZXkv97OZiVdcuePasIunKaR+267fbWab2cwZr9jdcWMkJZ62+hFnRxyPR45Hx+ORmDNTZrzCHQ+tVVk8XaO9w+F4cDxwOB7spt2SudQr5ZGBHp6minc7HD20zTl7JjPikUGN9jQl3uNwdCPbzOxOZsRDg3R5mmp45Hh0dHQ8HtyYvZ0yuzsz4sYqlKcqHjrggIPdwVmnNhczS4+5VMqVtSKbpyloV44cjg6OHBwdcLrY1k29rxlzqbiy2o3PeVxK0BVnsWvX4lrsQgiCFkQqrsSuwnDtcORwPByOB8eDs5wW67b0djGNuVQPuzX4pe/1cNaDNloELU7VdBLCjCaxRTaJbDJFbElmJJ3obdnEFtO7HA/ODseD3WmobXhrnC6mMT/yzbYbRZUbA2PMEVVsA2U3lFIsdqe2rTU3VBPDrpEhGGUUMatUxWMOrh2OdunTNnvO7lNmf+QNGislc/EO1SVBd6nYZVQwh926LTa7+LoWYhPatEuIRiKffnG0h44eOTrYhS3CvDhdfPSNl+YiZVWouXioGbOUrG9V6YtTGI1gSbNuFaNV+tv+f+2hAw52Bw6u9NDJBeN08etv/PUf/OUk1h7DHLdeM265zy2vMRn9jP9+37O+W1s+aHeXn/H1ufzcv3X1Youz4Yf0vR9HvFenFrNXxm+8+YWPvUFSPcrs6svxgZ+4xK3Lyw98IEslz1y+/9lnL9//Y2s+eHn207j8xZ932U56/ppa/R+qvMdLmOl3I52ZTp/mb33/83/8xhebLVbK4NblaLvh0jPuiRtbMWjCuPxZrOpXx4f/gWhPEI8bzfjT38v9zXs1Zemsv/v633zi+y9+7C86NmvJMsvlcGO49MxrHlo3NwrjkrRfGcaH/17FDyGxqxdlihDRomsO1S1Z/P7rLz/3gy994s2UHnMkNYsH7Ub3gwf3Ejc279QPqPELutsvY3iCKu9UzkrPQYgrRYZu6fT8w1e/+MnX/+rj3/98J7MNNSrcf9DOuh88uHevPFIr3Y3QD77u7MGZXXuCxGPKLmrpKLFrpOghXVt/7NW/ff7VLz33+hf+qNuc1mg8cN8t3L/lvhrNvWf81/qs78zlP3/S7j+UB9+YeYDLYdfih1JhmM6iInaRSnWp9sm7X33h1S8///rLz/0gbep1kKVfG9y3e40xpHrcm07fft+oLd+ku/iGxL/iHxeb3lQvf0YIQROCuBJnTRIypko8NJpqfOruVz5z92svvPrl519/mTRrKovhoWFOS6VitOU0LmwhY9p1Zd1Sa1Con/qnsYWNbCLJ1B3pOmlbJTFaxa4rro1WulJNPnX3K5+5+9UX/v1rL7z6d8//+ep0MetDi5JCypUwR3WCOEuqM6Zddy9Odlsl5mghmYKZ2LUujUZCptgFcS3iRpyVKlX1Jy+N/xmLoohylmA1K3Zll66my9lYbM6KMlAo7xAGA4OgU87ibfFIXIlEErN7/c3yBLFLVOziSjuLa7ELQRCaEOJKPBLvkoonKDJl/a6yG942l1khPbZi03SHmGNq6Y44kcQmuiWb6E7MiK2czESnOt1jmokIqTk6tCR6NLGrZYylxiqjJIamXZvLXFJS/VY4xa6dzdEMelmZq+go17rsQgqdOZuiCmO0VJVSyGiEKkZLRJLZc6a3basPWZSUs1RQPbZlCuIsXbTYdWxBTBItgi0kLUREIxGJaBG7uBbiWrytVKn6X7ReQxYUKuw2AAAAAElFTkSuQmCC)}\n#webamp .playlist-visualizer {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAAAmBAMAAAB+CntdAAAAIVBMVEUAAAAAAAwAABAACCEAa7UYGCkZGSMnJz04OFhjnPd0dIrCNSsmAAAAW0lEQVQ4y2NYRQxYwNBBDGgYDsrKiQELGIgCCxhYiQFEm8aiSpRpTMSZxkmcaYxEus2MmqaNum0Yuk1FU0VTRFPF0sQSOwZBovNCFXEFF1HZuYBYZQNSWhLnNgDqVFE4O/Zo0wAAAABJRU5ErkJggg==)}\n#webamp #playlist-window-shade {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAOAgMAAACnVF/TAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAHUlEQVQI12MIBQMHhv9gcIBhFRg0MFALwMyD2gMAcRoULw29bBMAAAAASUVORK5CYII=)}\n#webamp #playlist-window-shade .left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAOAgMAAACnVF/TAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAIklEQVQI12MIBQMHhvr/IHCAoWoVCDQwVDFAAMU01DyoPQAU7xeZEgCs6QAAAABJRU5ErkJggg==)}\n#webamp #playlist-window-shade .right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAOCAMAAABaWb9VAAAANlBMVEUAAAALDxYMDAwdHS0fEQopKUA0LhBGQh9ORDBQPx5YVjxnXEJqanpwTyxzk5p5ip6NcTiOkZBJ6prXAAAAbUlEQVQoz6XSORaAIAxFUQjyFTEO+9+sBI82ajT6KgpukYAL5txgLbhoLbjLfpFGkkMGESHfk2kXGEtiegbA0MiGUEm5GKnjxCCdCMJykDZxekdKqASc5idSZ6nk5SznjXnvtY2p7/Lh9e3fcgVRHAwq+Kdj5gAAAABJRU5ErkJggg==)}\n#webamp #playlist-window-shade.selected .right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAOCAMAAABaWb9VAAAAM1BMVEUAAAAdHS0pKUA0LhBFQTtPSThYVjxnXEJqanpzk5p5ip6NcTiOkZCsrbewmV7O4tD///+ogWxMAAAAbElEQVQoz52SSQ7AIAgAsQjU3f+/tpIup9ZI58SBCSs4M7BbcbBZcfDKHyXeCV7RQBgRWb6VfkmeQilBHa7CUnmmnBJRGdCIUGqqgnNFJWqPwqknXlIGtFxFG/O5tUyLs0TrxuLsLj+ub3/LA63jB8yJpQTsAAAAAElFTkSuQmCC)}\n#webamp #playlist-add-menu.selected .bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}\n#webamp #playlist-add-menu .add-url {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWElEQVQI14WOsQ2AMAwEv3LPKBYTABsgorTfxCtkfRyUOIiGq04v62Sk4EKugxPZOmVzpxAGKeoupInwcWD6e3eP+9FpTnppOvm3g6307cTPinSsHcW+BDd3RTueo3YTtwAAAABJRU5ErkJggg==)}\n#webamp #playlist-add-menu .hover .add-url {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAV0lEQVQI14WOyQ2AMAwE9+MCEEkDdEAnGwmXACWQ9skFmx/zGq2skbEJLALBB8eOmF8S4n11zupOIxzW3Eg3Y3NAPu/Fv/tB77CU5OTfDtZSQpg6q/5/AGMtMU3PzLN0AAAAAElFTkSuQmCC)}\n#webamp #playlist-add-menu .add-dir {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWUlEQVQI122OsQ2AMAwEv/qeUSwmADZARG6/iVdgfRrHScFVp5d1MlrxwN/BDY+kH/AQhQC7wYNSkOoGD2D6ulPzfnQsO2K6gtLifzuF4Uunfja0a08M51Z82fg51vPZ5kgAAAAASUVORK5CYII=)}\n#webamp #playlist-add-menu .hover .add-dir {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAV0lEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEDs0gDWAIZSBFcxmDQgIZWUNALMZGBBsZHEgG64eCuDmBLBC2QFgLQg2NnGQehBbBMkcYYT7AQVAL9EsAFyYAAAAAElFTkSuQmCC)}\n#webamp #playlist-add-menu .add-file {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXklEQVQI12WOsQ2AMAwEv3LPKBYTABsgorTfxCuwPpZJDIJzc3q9LaMkB+o52FGt0xZ3CmGQpu5CmgjDgcffuXv2xx13wseIcPOW8c4lXH65xQa+d/JnRdnmjmKdkguiDDkEOAftpAAAAABJRU5ErkJggg==)}\n#webamp #playlist-add-menu .hover .add-file {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI12WOwQ2AMAwD/ckAiHYBNmATI+ERYARYnzQttBKXz8lyomDpYOogqbGvyPfLhnydlaO4aIRg4UbKjOFA9zF3//qN4oSPiHB5S6y5hdsvV2x4Pw135v7/A+euLyJ1PQpNAAAAAElFTkSuQmCC)}\n#webamp #playlist-remove-menu.selected .bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAABIAgMAAABO2aeDAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYMghgCdAlLABvUy/BqCAQTQAAAABJRU5ErkJggg==)}\n#webamp #playlist-remove-menu .remove-all {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWklEQVQI13WOMQqAQBADp0rvUw5foP5AlG23MV/w+xbenSI41RBCCHtnI87GSrhyTIQxknUUwpJM3o4xPLnU/Om3nULYSmf1zJfzk2eS+LvTPxf2ZawU5qFzAa7rOIxN5zmHAAAAAElFTkSuQmCC)}\n#webamp #playlist-remove-menu .hover .remove-all {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAWElEQVQI13WO0QmAMAxE7ycDiO0CbuAmJ3gj6Ai6vtGmpD8+CDwuIRyWBFOComBfUe/OhnqdjeN1QTCTfW5uoPVcQOY+4XkfNDeK4eTg+MnpG7iX4c+c/R8m4y6+oJDkfgAAAABJRU5ErkJggg==)}\n#webamp #playlist-remove-menu .crop {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAR0lEQVQI12MIhYMQhvByGAhiCE+DglRHJLYhHjZDAlsCEIPYCWkJYABlswGZyOIw9QlA9fjNxMGGu9mQIdTZGAoMGZwE4QAAjAZBLD2pp6oAAAAASUVORK5CYII=)}\n#webamp #playlist-remove-menu .hover .crop {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAASElEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEBumCC+bIYA1AIhB7IDQADCAslmBTGRxmPoAoPpQ4swXQWILI9wPAIC4Ne4ZKh5qAAAAAElFTkSuQmCC)}\n#webamp #playlist-remove-menu .remove-selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXUlEQVQI112OvQnDUBgDr1KfUR6ZIMkGxuZr1VgreP0Ufj/gqw4hhDgmO3UNNiqd80OFIEVnoyIp+HZCYOXS8NUfO41KMO7uOMMja7pXbhmT58783Dh+707j+5r8AVpzN34SgZTJAAAAAElFTkSuQmCC)}\n#webamp #playlist-remove-menu .hover .remove-selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAWklEQVQI102O0QmAMAwF388bQGwXcAM3iWBG0BF0fWOb+rxSOI40FIvAJFA82VfUe7ChXmfneN3hIJ3NGQbj6A6ox03XfNIdBku3drLT+LmpR40X4eW3Z9b/H/ZpLd3ACl8TAAAAAElFTkSuQmCC)}\n#webamp #playlist-remove-menu .remove-misc {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYUlEQVQI102Ouw0CQRQDJ3JOKSsqADpAd3qpk3ULtE+wn7uJLGtkmXNzUL/Fl8qkv6gQpKg3KpKCRyYErl5a+fLXTqMcO4TeKIs4Hj04mtl27O1bw7/v7M+N8/OcNN6PzR8ABzaO5fDK/gAAAABJRU5ErkJggg==)}\n#webamp #playlist-remove-menu .hover .remove-misc {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXklEQVQI102O7QmAMAxE788NILYLuIGbRPBG0BF0fZN+EB8UXo9LCLYES4KiwbmjvpMD9bk7V7ggkGJzusE4cwGZ+xue/UG4ySwmmhPyf88BE4c7UZt9Y/TLb8+a93++ly0VHemPIgAAAABJRU5ErkJggg==)}\n#webamp #playlist-selection-menu.selected .bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}\n#webamp #playlist-selection-menu .invert-selection {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXUlEQVQI113OsQ3DQAwEwY0udymEK7DdgSCBKZO/FtS+k39K0EYDgiDI0e3kudpIz8aHNFKVNYJ0mbu5LIxHzP3ldSdIu4Q0LcvLZdrWNccIPe/0z8Hxe8+C76v7A5OQN+oVjwHMAAAAAElFTkSuQmCC)}\n#webamp #playlist-selection-menu .hover .invert-selection {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI103OwQ2AMAxDUV88AIIswAZs4kh4BBihrM+BhvafnqooKfYRlhE2984D8VSJaPfXlYgmyKSciGaKkzFZFP3Pd9eBRDSLgrppuSyLZXO8w4LgxDbtWcf/X0qvMI9I7cp+AAAAAElFTkSuQmCC)}\n#webamp #playlist-selection-menu .select-zero {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYElEQVQI102OwQ2AMAwD/cqfUSomADZAVHz9oSuwPm4aAtfPyXKtoCYHzvtlx9mCa+kOgvIip7/hzWjp/HKl+hF57Mh7SGs2OqoL9z5jw30+cu8z+r+dvLmgbnNQsE7JAyOvPXLeVffRAAAAAElFTkSuQmCC)}\n#webamp #playlist-selection-menu .hover .select-zero {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAX0lEQVQI102Oyw2AMAxDc8kAiHYBNmATI+ERYARYn3wK4fXyZLlWZClkKqRxsK/S75dN+nUmhzspEJDhiJdOhX6Oyi21HyNP3D2EUrNjdSPcZzQ95kcefXi//Xbmuv8BohAy09WnmqwAAAAASUVORK5CYII=)}\n#webamp #playlist-selection-menu .select-all {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAUklEQVQI12MIhYMQhvByGAhiCE+DglRHEJshgSEByDYEshPAEMJOY0tgg7MTEOJAUaAOqDjUHKh6hBpk9Qw4xBOwmgN3syFDqLMxFBgyOAnCAQD0WT/cwFbKdgAAAABJRU5ErkJggg==)}\n#webamp #playlist-selection-menu .hover .select-all {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAVElEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEDs0lCGAISA0FMwOAEMIO5Q1gBXODkCIA0WBOqDiEABTj1CDrJ4Bh3gA1BwRJHOEEe4HAB23NNar7KHYAAAAAElFTkSuQmCC)}\n#webamp #playlist-close-button.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEU0MCxnXEKGd02ukmX///8tdlhEAAAAKElEQVQI12MwBgIDBkMBBkEgySjIaMBgIKAgACSFnARgbIg4RA1YPQCfwgXpyvsxsgAAAABJRU5ErkJggg==)}\n#webamp #playlist-window #playlist-shade-button.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEVFQTtPSThYVjxnXEKukmW0r4e+sX1mGpZYAAAANklEQVQI12NwAQIHBpe0tBQHBrfUtDAHBmdjY2MHBidjYyMgqWys5MDgqKSkCFQjKCACJEHqAT9eCss1JzHfAAAAAElFTkSuQmCC)}\n#webamp #playlist-window-shade #playlist-shade-button.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEVFQTtPSThYVjyukmW0r4e+sX3BsGNteY1yAAAAMUlEQVQI12MwBgIDBmMBAWEDBkORkEADBiPV0CAgmQom09KUgOJpaYogNYLMQBKkHgD8fwlqtoGUgQAAAABJRU5ErkJggg==)}\n#webamp #playlist-misc-menu.selected .bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}\n#webamp #playlist-misc-menu .misc-options {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYElEQVQI112OsQ0CQQwEN9qcUiwqADpAvJxOctsC7RPgPyEmmmA9so7NS/0+eaozrJuaQBStUmOFkFVqJOJxIIwH8He/O6VGmLMDv7eO4/HEYfaJ8X9n/1w6HtehdL9sPlWoO+DkW3+GAAAAAElFTkSuQmCC)}\n#webamp #playlist-misc-menu .hover .misc-options {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAYElEQVQI102O2xGAIAwE7ycFOEIDdmAn54xXgpag7Rsembj8LMwSwJZgSVA0OXfUNzhQn3twNadIQehukO/VHaBsutOy6GmjjwdGT2PMaX3eNfmaLnfO3p1+Xn5z1vz/BxcjMYQLzDa1AAAAAElFTkSuQmCC)}\n#webamp #playlist-misc-menu .file-info {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAX0lEQVQI12WOsQ2AMAwEv/qeUSwmADZARGndxCuwPomJTcGlOb0+L6MkF+odnKg2aRuqoj9TNOluxu7mTnf+cvMf3s+d4WOG4JtTSVo4iHSN3PvR+XbyZkE51olgX5IHU8k5In6uSFkAAAAASUVORK5CYII=)}\n#webamp #playlist-misc-menu .hover .file-info {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI12WOyw2AMAxDffEAiHYBNmCTIJERYAS6Pq1LKBIvlycrPywDTAMkf9hX5BJsyNfZOZobarlB7s7qLqecv9w1of44IG9rCPacRtLDQbxukau/efrsmcf/N3ldLzugWMN5AAAAAElFTkSuQmCC)}\n#webamp #playlist-misc-menu .sort-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXklEQVQI102OsQ2AQAwDXaVnlIgJgA0Qr7Ru3iuwPgVJ4Corsk/BaC7EXZwIJXNDCASNmI6gSFI2HSEjaZn53WlEd8rzbiGUR0ZlXzLZL5cHRPt/nv7ZMY41cexL8wCXGToqpM1dFQAAAABJRU5ErkJggg==)}\n#webamp #playlist-misc-menu .hover .sort-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI102O0Q2AMAhE74cBjO0CbuAmZyIj6Ai6vtBS6fvpCzmOYkuwJCganDvqOzhQn7tzuSsICuFOpaHS5mIq4cy5Z/9MELvwru62rZG3V2Xy0dPuupepZ83/f5v5MBfSedE0AAAAAElFTkSuQmCC)}\n#webamp #playlist-list-menu.selected .bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}\n#webamp #playlist-list-menu .new-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYElEQVQI123OsQ2DQBBE0R9NTiknKgB3YIE2nYRpgfYd3PlEwI9esBot5+yg7n9fKqNroxwhRVejLClSNyLQbSm4+3E/dxrlmGC6I2dsJooe9jDGLzvz58b5WUeNfZn9AKbQNSZ12uygAAAAAElFTkSuQmCC)}\n#webamp #playlist-list-menu .hover .new-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXklEQVQI112O0QmAMAxE7+cGENsF3MBNIngj6Ai6vk3T0uKDwCM5kmAbYBkgqXHuyG/nQH7u4HI3EaRYnW4MByEgvAwE4z/fD0TfSt4QLnp1Fye35iVrtZ+mPev4/wORlyvp1GfF2gAAAABJRU5ErkJggg==)}\n#webamp #playlist-list-menu .load-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWklEQVQI12MIhYMQhvByGAhiCE+DglRHhvCEtAQGIGRLNQSzwQDOZkBiw8RBqhMg6uHmQNQwpAHlIOw0NhCGsUEQzk6AssG2pmGYA3ezIUOoszEUGDI4CcIBAJZqO86fMyFaAAAAAElFTkSuQmCC)}\n#webamp #playlist-list-menu .hover .load-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAV0lEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEDsgNIABCFmhbDCAsxmQ2DBxkOoAiHqYBTBzQoFyEHYoKwjD2CAIZwdA2WBbQWwRJHOEEe4HAE6RMXWXqbP6AAAAAElFTkSuQmCC)}\n#webamp #playlist-list-menu .save-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYklEQVQI102OuQ3EQAwDGSl3KYIrsK+Dwy2UTrJswe1fsA880YCgCKltfqpn8VV50i+VhQD1VGEA3FPlQED0VBlAIyfAMfp7Z9zKWjsO7FjueDnThZj5e2f/nGqfc5K6j80fAQw6zDOWMCAAAAAASUVORK5CYII=)}\n#webamp #playlist-list-menu .hover .save-list {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAYElEQVQI102O0Q2AIAxE76cDGHEBN3CTM7Ej6Ai6vlwL4iMkL5ejBesA0wDFG8eG5ensWO4rOeUOgiTkdAqP3CK3cKXInFYLlv2+oL2FZqXXRr3ddT5nc+2NvPzmzOP/L+cIMJ5Oo2aQAAAAAElFTkSuQmCC)}\n#webamp #equalizer-window:not(.shade) {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAB0CAMAAACR8SbcAAAByFBMVEUNDRQPDxYQEBgRERoRERsREhsSEhsSEh0TEx4TFB0UEx4UFB8VFSEWFiIXFyQXGCQYGCUYGCYZGScZGigaGScaGigbGyobHCsbHCwcGyscGywcHCscHCwdHS0dHS4dHi0dHi4eHS0eHS4eHi0eHi8fHzAfIDEgHzEgIDIhITQhITUhIjQhIjYiITQiITYiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTklJTolJTwlJjklJjslJjwmJTsmJTwmJjsnJz0nJz4nKD4oJz4oKD0oKD8pKT8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEMrLEQsK0MsK0QsLEMsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0swL0owMEsxMU0xMU4xMk0xMk4yMU0yMU4yMk0yMk8yMlAzM1AzM1IzNFE0M1E0NFE0NFM1NVQ1NVY1NlM1NlQ2NVM2NVQ2NlM2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVk5OVpcXGRgX2pkZHFoaHhsbH5vb4JxcYZzc4hzc4p0c4p0dIt1dYzUqAzU1NnX192pRLExAAAnOklEQVQYGQTBP8+20ZoX5ON3rrXu+5m992QGDcRCDbEwRk0oJCEUJnZ8AkJDSIgyBXEKvgEJjXYUU4z/YkOHH0ALC8sJlSFSQGECGQviVicO2e/73Os6T44jAAIIEAgVhOoFMhEgFIJQQSy6KgJhVyYKhLC7ylBkCQXKufPuaoWBAiJCb00BgK5mptqI0aWB4O72oUEb3K4W7e5roNMYbhuM+K8BAAACAAAEAAAEAAACACAAQAAAAQSQCTIRkxEmAAAmk4FhMsBkYACAAQADAJgM/v7m78bUhEAgJBTVlcAh4ShRgpCdWbOlZOptikVRXqPYj11hs4SaImQ9tSkLekNO2/cgBGtSxeoKYQIwwQTuyoXhqe/1mIxh+LnxofGM0fph6LTJ3F4+3Opn3zaXnmK6ZxAkEBIydMUgl1CAGcFGzR5ErQu6ETratl9lZluLYYYMuYrMPFRtOD6PHBIJtWUXefAwEzNAAA+rx1q1UFPPnhkgzr2fD93xMNq0GUZjJISWfduAW6AEmCHIDIEhrCoZVTQkwA4keqJqikwVsafZHkj05wIFrLMxsZLGcbwBGKqyd7spZZZhngTAyMzyTI1HnvA85Soj3B8/P3tDZSxD9TOCGSb3s8od9n20dne3XZRKMBCZoKJQCjyKmKsqjDGhktk8VOgEs4rCitdjF6BIGCJyQURPw7m3gQyh09/KnieShGQNACF5rJqsus/M/ZkzW8gM+8v+OAfxPEN3B4wis+v7fia6uQwfdNFAIgkTaGaiCyydhDmEykTstM7dz65K2Jm2aDV717zcFYBZGwBGowZ64/Phc9bBRJBxEFvTT4IAgFYzw5OM3u+6c80YuD/Ojc/HNEtgNfRkGGqJ6bKGKOgukiDDDIJMSVAID4M6XYYREGRbaeMso3SUDu279tPAyyaoFRB1y4RnFYh9+iDB2NIDrBpVnpkBAGqS4VkzaHnaZATO+eyBxNMz9AWqZgwu6JsHqkWrIgaQAJmCqAScs0FvokzE7qqJ65nq+NTQFNAPm2oSUsA0MLwQa3XBsW8fYIiu2d2U50k9nVmSAYBhJuLpuLd9vzbDYH5+9vVBz2jTaj8YGtwuBm11cy+KwjCEAQgGDfi0sFXLkDBuYeznUKGSKtNUka0uXczePQQlgpQmrNHNcTd+AAXTT+0SiqkIDABE6Dxm2K9tdQ/Afbnb4Y6WqNtPMUzGxA5o9agX27RuhSIggBlkCAnrFNylTIoQ+5bUrvOAtxkqVYGiWbslPKsNOgyptbdk1sMuPmfjOcBE7fK6LXrHI0EoAGaQTK+VzHXne3QwUNd2PpSxpinzAAjdLnSv29/TerRSgAyBkCoSqhg0RGjBCOyebJ+uUqBo3WPvitdrP6Ogz60ESYR5aCPPSuB83OurQFDz7N5lZp6xhAEAA2aImUl5UusSwU+fvXw+SHEHADPNjBuGW+4mbgmPDb8BZAICoUQmSiYEAUJCECoIFipBeN1NFITAphhq3x13Fyg4FAZUK5CMotqkoAvo6uqZ3Z0xoKshk6v66Wqga3yGJszTDAba4JthzN/5nykEQAAiGGqkugWDAYEGYAio7hjM+N4EQAZaMar23dG7QOGcbg1QCoiJ7nlYBQpAdcXTlYyABhNVVae6AP10NkAKAA39zQAezwb+KwBAAABAAACAAABAAACZAIAAgExARgAZxQiZmAAATGBgZJgMMGAAAAMAAwAw8PfJrE0Gf49AJhSFCsERQV6kZELUZl7qKVWnCGJT26x5MVUZ2X0QVhchu5CwpoTj7nm+IGSy9dEV60Yp8+wJEwBm8iye5Zm7PdXXpDOZyc/92Xegp3XMrQ9GZwbzfdodt62rH3pmGE8xAYBQZDADzgW1d4s2JGxSMmWVT4OlxL7WuJ6+RjZaMGnIuppYTAIftw5kZOKm+iczT0oZtiAATCo7UfOMY9b3NSaMqM++g+7ElFE3gcpg7L7o2kAVpqEIAELSTFRVgI1RqQqRgAHzVIVTM01XSV26/rOtapPNX1SBSfmPmd5d0v78sgZu9r/bBWLyZ1epuxbW7zB04FcGwK/C7Sbtd32+88lLAjw/uBtSwxhuzcA8GPOUS5t1d/e+tyOgGCCADGqAcBqJ0UzFCLUjtiwZdJRUgZJ2FbiaDCrAmcYUzIMzxvk5xEBPpvYk65H1VDIDAjDGrE4/j9F7XfNtAPfrATzySNMbhgCZ3tgXl0taQBGQAbSKCT2gS4JSJkNQLnIresapUoxm2INNldgwQQPuLhQiG5/UY76CiQyvadAl3BYzABCRZz0xK1Oms8mY4VM/Dx/cagzq8zB4MPS6d8YFajM8aAUwQYgiUBH0ZcZqEkRGddFr96cqpa40S5G9rSrPc0tsNhkkhNe4ZMLMAHUEmSCZvrWxJDe1a3QCAHB3PHIHe/U1A5xdbcMaQ6X7BpiF+I6NLmjThkZTIUhgGEyiBKiSJEVGZZigpKjdOF2j6KFwp7dFm2HChALyfbzKmKUnkH2ByQTzurvuNQ9TirIAMJjhsmpi+CSFgImASXmme8oMQ3sw5MLtBXEBRGEwgwQlGSuRrLVUxTg20WOE3qX3dVXiUwWrAKWuZ++SUA10NcxqqKyRHccx+wOoYbtVd5/sKgo0AIRJeu1xk0n0pJv0BD9/PHc7pMcS2EAGdD0bdg2tMYyHUQABBFlFtrWqTgJNDZUK7GcUFjiGXo8FKva2G8JzBUUlqNaKJ2b4HHtyIBA367Fj7hOZ6R4AYMiozNh3zPTz+hSZGHyxPx8Qj+HezzYwGJ2+l763fdNX66ct2AgATKqEqMqEGNnRBSZh3yP77qhwulSXVZIdz/ZgE8NBEGDfTVgPG1xOYGJg7pth3yfj2UZhAGLE0J4MOt/qiUnGZNbjfD48GTJU+ci0wWSk6gPWlU8AEEUAoKpqRl7nlWQlxXulrqJKgjK0F0x8turyDLXD167NxeyNRJIpgbtVzcyzRoO9V/+EkCiZuYSsSpYOCACBwcINa25MIO6zwR3uDN/Xx0hVEKofh8tlTqOJBzYThCCKyqriFDJd1+t7I10mUV2buptKJqYaC1MG+cv8pwDiLwDgPyIAfx4I/DkBMvNnJRMwv5oA+BUAfilmwsz8G/6fajD4wQesplq85zsy08SgyiP2tb919qXaIGYTwIRJV3Jynlck6OWMF2AKXQVMTGKlFXqdMkXyR/7SH8VmCX/hf18E4j/8J7tia/x7/xzn8/oc68/9S5QJ+8/83y/sZ02e3/0Tlek14Vd/Chh++0+nZnrI/M6vRxsjzPeqTwZdoeqma17tQ+ma6Ax1qdf3rdGtdQ/csgGAUoup9UqwfZaOR0bUlLBN0tmquibvllhPrRgvzwJsFYFFsNaUV2LfvQIyzsfnQIx4fS7EUxolUgJAJxMxo5481VqMGOT9szMZ6lYXUa3z2HfUoxp8ZLrWZX1ryuOhygYgUEveZ1XtJYv1dGZWC2QycWvzunp1JbpMCLvmFS+xSSqfgzCJTEKroZecD8fNTd6IAj5TXnfP6l4UQUYAlMFMVx5ThtfPYRh4m/w4PraMB1Hsi6k8iHn5OdWpzmdfeWYANgAo5H3WeueVenf9Zn1Pf6iZar0IO58zd/eewioDWzqvZ9/XAae+6whKeT3P6smIqIjP+aA6E1CA0W5Jm2cJIEyAicwzUk1Gr5lvMSNpGM/mfAhLt8lTl0x6Kj1wX33re3WXMfXU0/iwAYBaWWet97vetar7F1P95BtpZWLi7jNiDYnqUqqrtqJ+SQrlPbAy7M/esLDypCDJcwgESKW+k82w+hEmQAAxsUyv9Ri6ZJBMOow8NfMNM/XUrEwXmaEyI/XERjz7+xn0NDgfG0CosPZa79cv8soh3535Id+TKSaE3VVZJgVFMTtE3ixBYqJ6mchaEpNhzOZwufs6BHa5+9Oe9/dAJtazTHR1AWAiYj2zn3Am1QwRZCz5cT5Ietm6sd31mJEaazqWz+v7vvIZJtPAbMhgQlbWWtm/rNdZL5zvevzm7rkmU0CVLrm7a7K6ZkpJrZ3yFlKjNBNyvCKYhIijpmZ7ZQ0m0Pfk5Xt7BZFZ1tVZpQCgy0OrfkDsb5gMk4HHBVPu7llPNR4yMTFZ0+p89v3OmpFW8GEjEyLBqpNf/qJ+sd97ZXrW6189v+Xn7GsyCdvnJGp2ZeqIIrLf388rL7EQ6aVVnErC8pxnxQ58nxxCCMI9NfGiBdZMsmzMJACjZM9YAMNrvskQA8q+g7BV3dOq9x3CuWIi34s1091mGIPeGIRJrexXvdf6xXu/s/CsH7/0/Vv9QQTuPtBpq9TddKm462UnK0BKFpbYmaTPZCKcu74gACJrEWRWoPQyQAJARjqypgGC90/7jpGMka8fjg/AxlDrM07n3H1Zz/umurV6GjBqI2GigKqv93t/rZzqm/v1492fNe65w0SVid2r1nj9fE+pVSzbWVlxqvknArHl/6yEks0/51wH/MsMIZz/975AJv6E9eTxVPlTAPwpCCb//wPA/8eovjJhMvj59bkbxyebT07fqpZt8/Lqj8y67uvH67tVMzBdBAJyXuv1Oq/1tfZvvV/vr/fO1/vrfGUfkrD/9u9N/a2/ZTF/I3/tDVrZqUxWznvVXvVKNvaraq3XOefgQK4vSVIzCRO4L0lkAp71rL0LAAAeup7UgrXK5rvYCCLF+2M751xxrxN2qderKlWnUifFjru+Xa0nQ6IYgFoqdb5Wfa3X69SrznnvnFR2PJjfr/sHMv/9f/c3RwWtms2+2z6xq/Zau/LazzmnzCruzSTn45zwJZGoEDW85iWsDLDMCtAwAFjumnU9xSKeeN2nC2xBOOfee6/7fn993RxFoZK1a5+qlaRmb3uAixmbAEFWfh/+KPucu646PfNXwH9z2+/7239Y4r8g/gbHX/M/kS75KxD/OKvA4z8B/qncd6z9078P/AsEMv828MdvqGfN828Cv96A8jvAnwCo3wV+XTyruh7/FvDHuTlux/w7wD87wZcf5/MfAP/HKmLZz18a/K9z7YuujDEbwESO+sNf/vZv/3K/99nblx+1P/nf7r/6+Zuf2bf+4L/8wy4T/0OFf/DXP/7hX1Wysut/eeedVe8Tx6dG/WMix5kD+Xr+GW+RCdZD/hh4E+Kxfw2VDcCfAADUr1VjobTm/2Kw7+nc2Vf+hfn5/mkt4P3TP53LZJXjo3LPP3rm5zxkdCUGnQJQVZx6fb1WUq8ria+z3uv9VPJG+4Ou3/N7/Od/E38df5U26GNn5bVzcm9k75Bs5x5JwnojTMnrvdebAm+Cx6pnQQIAAAD2slgZk7HwUnh3quzXI8j7p68jEfI+skxWnHuTE5XYQke1ew1sgJCElZx19v1KSE8leT/76zf7e82k93+bfv2PU+ofcP6hUfactWWIuF/8yP70fljhCzEx+foRRF7Y/f7uat4E6/GsZV8VAAAAQOapmBrPWo+M18PrMy+F10/w8yyQMD8xS8TNKz+uajWsu78fap63wWyAoE69ar+Wylfy5mdOOhSvp0x10wWl63RNtaib52XLrpyLr89Vz6KcuyVk4AtigbLTB7BYac+aPQEAAABQxYxnh/XAWj7rAs4nw5dnIWR8/WCNKfHm68fR59v6XEU9c9dPpVsBjMqq5F0rOUfeeMet13rnRb1musqU24X41FB2bOwstdwvOGLFIBIhAkQtBPVxIQCzEAAAAACMkTEJBLQXgnoJLBIIDvOU44v4uhZuVrXCpocoQA0ke16cuiEJeUu8Kkkn9amEvaZSOadSTc9WlVDlHEniC6nl3DfsNwESIRG81kZYMBUCAAAAAEPIjmERPKcQwTcBgRDvS23HFwEq9izKo/uRoVWA2ckKqTmrfDngnZzIya48hhp7S3oGKEvULsUoKxI4wFuSd3mTBNgCwb3ASJLBAAAAAEBiwoxkMBiAEAYI71dEHPhcIvE+gQO2apMZoxAQjtdar6WOVBDcdWLjtUuRe5+pClUGT3HUlryWS0i4B+dGFLwhSQAIe4MKSMgAAAAAYDAiiCX61kUgXhIIFgjgQEhuWHE9+mo8ZCmApqxJPQkAUFXyWgfKsDcm5xrUCd8PQiyALzgWbEBgvAUAhAgQMgAAAAAGGBjzoPQLAAGG2rzgfXEuCYGKueVMcx+Dpgik5KFOvWRdWGvxzpusKlI7hR3EeAa6J1UiUc5JBHC4JQABAiwAAQAZAQAAABBkBKILegPAAInAGxyHLwBs2RgB6KsALLvyWjt2yQmIRImpRfZW6oGkVhSror2UmFy8X2/h697jLLxJeG0kNtQsJQiWAEwAAAAAIGOSCViBFwRgEQk2kMQ9HwjEG6hNjX0GNsUQWImrpHwpAM4iLzLthluYnLsHHtnRYk4AjoALCLgSPJDQJAwACAAAAABmBgQwAGARW2QGAOPNuQRvfFsogG+Mb4ow1JB9zC6EJRYQ+ynvKltqpxY+m8KCXQgIlLDcUwQIG3iJhbUwmQCAAQAAAEAwAKIBALgGoRA2uNcxBHkfRdwPRgaYgoRUJU/W61EHRMBl2Zsabdxr1DoUFrtespVaDgE4yyeiAB5QAB5EAIAAAAAAQDAGAAAsUDKIEER8wxJe3jDisY9uJS02hYxs8Ep5BQCIvKxbazrsXdmUKtNtBTweAx9eEOF8fcEIxAtsAAsAAAAAAADAxIQBMEAAFJmgIApvgAMYPO5TJdfDuBQm9MPO8OACIFawqaqnGRhtStFVhjkpyfkK8AIDNoB3yhkgAFgCwAAAAAAgpkkASwQGAAQKAAAXuJu8WB69MRiFoIpKXnYsBJCXAzX6WEenqCi6RPp1kWACJEgIogCwtwIRlgUAQAAAAAAwLAYABsJiAREQAG/nTbwgCLKH8hMYCkFHMjtVQt5WkEWoRK0qeZ4dK7yLYlr16z57IwUAAMAC3FsEQzweAAAAAAAAwAQABmAAgAGAYH0iQGAMSZfR9SAUBiwTswEAANmDWnrMOBctq9TtlwubKwQAggBBv8GCsQAAAAAAAAAYACQAASAmAGDwYABQQqtxjy6gSFCeQ1XFLgDAAUXJnqkUZTCj+qW9pIBZwAbCvy4IDlv3b++7sL8+n+9x/v6XZXBFc41tNpcQWNPCKBuYtgFhjRUUx7oaNMKg+Az2GGR7BqPPQHtHE6euWJng1sDAahQGXUfX3siNJMVhYvO/5e88v8fxee/1gssF1gOgKFwAAAAAAAAABYAcAABEBYCieBEAoFpmtL7NIKZB4ToltmofCgBQFgrdS+hW3Up7m+pFVEMBDhAKaOhGAdCBCwAAAAAAQEWUAC4KAKChACh8+ORDKQ94A01hrLgatgahPPqNazUFALgY68qjyoDZMnSN06V1FQCUN0B5w6EAQAFVQAEAAAAAAExKFCAAgEYBAKLIhk0BzkgMT2aAJiCNBgAo2LoU1WWa8rgvWsElmOCCBWwKFXBxAECAcy4QAAAAAAAAEwAMAQAYCgCABwBA4+BD0QJdGqrElAYAwEp3NNM03Jc0Tbe0EfCoosBSEABNsQEF5boCVQAAAAAAAFejArgoACgg+AAA6oY3ACqsS+YZKNM6hRJVJRcaAGDDhH50U0Xr4Wj0aFWgETBQCkABAIBTEAAAAAAAAKoIoAAADiKwAYADAFBsUxhg6wJwNCsAAGjW0jwZ5frQNc1FOavLI8AjAA0pBQAsAMDlcgEAAAAAAAAUIAGgAT6oKi4AcH8CFEAOpUPYYtNCUdLRrQAAoLVSwYX//psprr+Rb8hcLxyUogCghAIAwAUgAAAAAAAAQBwCUANAAbwIBqAA2AKgiVHYoLVSAIAHAADQ+oO/lfbrf+/v/03tKLpVqWsBUABUEQVcAARAhQIAAAAAAKA0FUCuC8CBC4ANEDgA4IEZS6Ak9FgAusFfKPwQAPwM4p+OqV/3t34TB3+D9mt+Kw8n+AXghwB8CfhR6oLDZ8CPqwC+AHwE4FPgIwCfAh8B+BT4GMDxReDHQPBngR8C8CXgBxbg/grxHa7aAxgWAswF/+cnP/X4Uw0A/ijP9/2uO/nNX/87Tbdp//Ab47d+1eyl6O/2h7fHqgLgh0HVG+cCfgRKFOAnnAUAPgIA+AgA4CeVlHMB8OOAAgZ/HFEA8IN4/4RCgccf3v9h38EBQBYa6CrOAgAAaGMev8njW9/0bXxD+1V6ncZcBAAAWrkAoJgLAA0AAAAAAICYywUAAOA6AAAAKZCCG4a9DQmDWjQUA5fyAAAAmB6l99/X7duX/sdtHQCpvQAAGJwL1wFSACqYqhQAAAAAAFABAAAADgAAgP3ANAAez63PTaUG0QwltHkgbgAAYFruR0ENrQvzxjhQswCAwMKlACgugIJKAQAAAAAAFAAAAAARAgCw4AaAmEzILiBNEXWlAAAAAHQ97jwsaaql1+qXa1GoAYCSohxxBBRwAQTn2gUAAAAAAJAcBwBgIxwAKACId08AYMio1ENEkdIFOEXfAwAAgCbULdplBpulLYpcAAAADQBxFFDocwEAAAAAAAAJAMICmgMgAAAAAYAR0qUQHaWLS9BeAAAIMLofHx4pnKtaz+rq7NZYAABAUHAIFAIIdQEAAAAAAKBQEwHAa4Oh8UIACAER4AZscA/ZQ9EwjcBoA4AAMNNOzIBSTO+JCaF2FQCUAlEAAACCOAAAAAAAABGcLiAo3hoAQPACAJ4EhBVkCtgFoQtCF9gNAIAM9OiamzTQrDEWnVgBAoyIIA4AAKCo0gAAAAAAAIA6gAAABgsIAhAACILHzEDPdIGGKgaMAACwQGvbfFgFTU+vWcW2G7sQAFCBAgACAMJsAAAAAAAAByBQxGxPkMARhADwBAAB2fQ8x8veAU1XoyEFEgCAMMtc1qjm0j1N6zeLFEsAAFEQAAAAQF8AAAAAAADAQQHo67aFGRgCQGxYawkATLgMZWkQDQBRDAAAduFOowPQ7M6ASSE3AIACAKAAAAoAAAAAAKAAAkGYVwOaAABYAjzxBO4zsCHbNBLNCIpwsjOeOABgMmpA4RpqrEVvXRaEAAARBQAAAJwDAAAAAABAAEqiwNzGgAJAAngBFgGgycvUI0cZoTS6YFUJCC8XAI4Mc6GnoClrDrOwdrFTig1sFATiHIAAgOsCAAAAAAAAAEgOeuGNcEAARkLiLPcN8JR3bhtxz+UGaDpgZ6ZgRyIA3IJCl8qQdE9319HbZC8Fj5tLiAUFUC4AxQGEEAAAAAAAQBwSHFDw2ngCeBHADXDvm3tFPIE4NTuiBCHRKLB0HxOBTJDjmcDeMWZ02lWX4dXVLF0LwX14AVskEYOAAC4AiAIAAAAAAIACIWAu8AIIAGDDAhuegmBX1IxaQDQB7spt+hVnARB5msiVai3DNaF6La3XISAdgDBAIAYAcS5AYQAAAAAAAAACODAbhCCIvJ8IgyPcwn0EWCFbw5gbFN0aqMic1wIAAIoMNCkj9BlrX9RhqgcCCICtOAcACEilGgEAAAAAAABw4joiABCEuiBuBs8l4oEAIyXGu94lwdABMPpasyU3iACHBAbTui7d9nRTWVxHZQAEAETQAHAAFaoAAAAAAAAEKWFUAiQJCOB+P/cTvNwimORegeTcNZK1Z94AaOkAV2kzI0cIRxxYNdj7pNFk9Fjr6GZ6nKAAgCQoGgwBcClITomqAgAAAJAAiIEAZwYzCJ4IT7GsJRIZcE/mhKck3M49IPfsDDB0AecAM3B7BsBtZ6OMQingYda+7F5X6wqWGHgpkBiAwsxLEOCiBQAAAABVAgCBAIJQCQDluTDglljqcHKDgJx5DYoNoKNKAfad2TNzguPIK5xMvUZfLQZXaYS9jra7Hea4VW6IFCgAMLPflEMiBQkBAAAAEACBAACiBPGCpwT3nfudgEMMsd4lrEzYmWPGAERforhajZhLbgscJO8GixlQbdLAm2O1NaODedwpL14ISLwEEuQNOEoloBQAAABACgEcsJEAeycRyADe141FROK+zxnjnFvwfmdkX7rvAQJ0lHB4So1JnBtBIGJvZEY33aD1XhZ2d4xOOUYmAYALKEwBWpIaRQEAAACgZESSAKwXCqIViLjPfkq4wSISlsrMjLKevC9n7NhJ7BCALlJcschr9ktG8hQ8WRmRGpoRw1iVtthNFbFe5aa4XyS4wdmCsCcIp6jKlagAAAAAQKpMCg6B60WSxOuWgGAfyCLjvt9JeHdO3GZObu/v686c02SPjQgYjUKzuasmx5xnvCRjcp97xBi6u65u3ZSZbfUu11bVewkSAAaRRYLX9XZBQORAAQAAABDCJUDg7AugCCCBxPOWOHiHrLvG7d6viazFHjLPM2JmkyBtAZRF5tmz172WeL29wtNIzNbnOjR63nZNeVOzJnUezMXolYoSkecnnVI8PyCsM/FoxbGyr0vZLAAAAICji5RzHeBJ7/MG9gT38eH5CUG8I841ncf7o5+S4ymYo29m7mRH9/s8clCAhqJSkohK5H5P8oyxjuT5KjsK9Y1fM7/2V9eU/hV/cU1LQPbI/cRE8Mn7eSHxAq/pqLklyLnOkd2uAQAAAAxzGK6D8MTI8/Uih/BY6/kgibCW2TvnjHvdz7VkXkLsOZOZM47zuu/kvICB0VBNDWpOXic5Z0mS8X7PE9dMj435X+jf+id/leaYVrUOlDY8RWDeyTNR6onXo25yiqJxXY5pdQAAAMAMHNc5B+EJkPV6vojned9W3iG83/ccMhF3ct+zJ5kzktfsfe59J69dMVlzdkTDWDCF2h+S2t+Ef7NuF7xnxlfBP2D+Jv+w8au0v8zlL/pOahe+WuB7+34Q3v0M8H01nXplz08D//ahp5vMF4GfFIBPgY8A9heBH63LITx/GvghNwz/OfC99+uRus+65+eA3+uryji5vyrwr67no82d47+GvzvpJ6QEFh5VINz/0d/9Uz/1U5+s9+u2Pzyt1/3M776/7rNV+tudHvitt4r//VfKd35ZLRf+1eVx1arHfuA+1h8trrlEzavS44csmbdUXacZP9bTyrkAPgIA4sdAnR7w8kOjoIjgjxY3j9Q7a91nfn9m5zEt5Tr27btHFOe6kZPnPzv3c2JnbUmCOWnchaKo12S/zsl93znJa++cIzU9wXS+4df41b8SfgW/jM3QsY/kXu/3eT/WDvueoyA9aHvnjRxXObRRQwcAAJADCNMJgi6QBLyv+77D7V4r933K7Ir77Fdm7tm3HJF9kp1kn5z7nO2lhlAtoi08QPe5nIfsc1/n+eG+ntxzJvdrdm1Qrn+sHv+ki39mnf+jqyzm6mlp5ypLWDcs+yFgJD1WV5ScFAyXq6JIAQBMAVDicK8bCCrAXrfdc01XbqR2Xg7COcstRzyl1r3qEOeus0+cmFsAoou7KNPteL2e536+T973fd/P52vPeeWeM3Xh6qE4WHU0it0mct3jzJe/fN/rZ77M477v27vPfelLX6r89Jda7Nccn33GZ3zxi1zOKV/4QvjCp/j0U4D96fxpX9AA8dln/Kev/6wlSSE+/5zP379MLp3K/KyvfGXunzs/nySJ+K9yv76aX/BLc0TuM1/b55e+9ry/fv+3M5PahcoMnMviMQpSnboy3/Tbr6/77usX+Nf56u+ev/DP/9L/+td8K3eTaFgaC6m4SFHnIfVz/2/x5T/0lT+88dje+b7P5/Mf+NIPitoPP/LZj/nij33xT7gqX/hIvvAxX/j46UeffgS5EOY6xOut8iOf/X9iIsTzQ/7c998fLLcaTor79/0Xv2fDiB6ZX8xJ3LHH2uxf/h0TL1Ovk7lJVQ1ka3YnPBanZju+9d8c3/mFk3/5u/urv/u1218y/sE3V6vSjelYtr1VaWeoxi3xs1+x4eAhPuDz7wNI7vuzz34c4BwHn35aRQFAMf70T85FvLztuz777N8dP/2DUBIfvHz+M3378vdkzjlqIjPGn//XOUeY5Pziv8TXvhPnXFeu4+nrX79v/92385zaFsYI0C0Ud0axXnzzW7df/p13v3ievuaF8de/taky0Gl7Vb8tWatNq0R4Kb//B1+5iMZ9P96eoKCCij/+0RcLYl1tx8effAoAkHKBqCxmnn/87/7jC4Kq3O/xve/9ucVr9sQMR+bn/6+bk0iSwC/Z5PXa83q97pfjn/72X3mRmC2bQiA01wa9hDvb39kvv/31p995jX9u/CPlW6A0lo6FTe0tDwBmAzPg8bCX+/PvC6QQMY7AyVyrnQIARBE/+YIzySAVL9sPv0SC0Yvb7f/5WdeYmf3i+V/+m813f2nA2eP5L77j9jtfv7LlzkTc2/b3vvncMyEUAGt4FH3Zy1wlstvL+Lr/zcvLCNMkC/ai97rO6qLVdGGaxe/9vP97/cHP+YOKuj36AvX9z32/k05Z/4kftfrRZ37c06f7T/6Mj/n4qY8+fuojgHL0pDJ9yvizfsgInrHq9Pe+7A/BzvQYN/687xridel5yQuO19RtduL1j/6abx/HOGaTMqkjUJ/8T/9z/Ym//Ru1muqq1Y/rw+XqtmxjpobRF01b6V6OXtRy3lCUrlVaV65KqZmF4hNQQRXaA9VznSvlLEgBgCmkTk8YJwEGTyEe9+OWyBhDeSFMpJ64doozc/Gq2cyAjMy93Y4dSU34t/nbv+HfL8DVPRdkf9ie/eHurtltwmkDaJZmrytLQe2l0Di52rRziVIpqKcPzw9CVVi7L/bKJJdZuVIowLlAQxi8OtVbKoGsWzz27WZUAbkhTKipWXtztrfdvNc9zORKbyPuiWmbqURlkMpqwv+oUKhKl7qU61wOcB2X8VBQa7+pqEalKBaKXj0dDdBDP9AI0KZRVdPTGgCA0YbR02fa9ACK6bkfNwPwunhBMdiCYBCvt5eQGByQyhEyBAKINQoAREvlqN51AA4spMAipacJCqZbzIu3w9JgmgcIoGe6UVIdTKqNBpg+l2lU5OjRANDjcTMAr2b3FFF7GRBMKlhbgJ4DIo5IDQEVQo3V+DP/AwoAUAAAABQAoAAABQAoUAAlBZWCkgIAiEoFBAIIQABAAEAqAAABAEAAAALKQvmNlUV1qhRvykPTD22aNO2i9Upbk9WKNet+K3RNK/qiS13najzux+ZxvX+iUigeSevS03OpVNQ0AKmUwCEVzL02EfC+uDGpYypb7xBkiH3NFkZsI/aYgynjns5R87KvLWSIyRbRCKcpCuGOVabK8zljVNNV9NLTs/RC1rLyJnSmq6JS3YLLCffD4s4nBMWq+zp7i1GOHBWNAEoxhau57eera0dQnPe1N+w06bK6gmIGXjNW2Lbt5ezNDKbGfY/J7NddihDENkD9VKFQgKIpFF3TBRe6FGppFA2qUiya9LRF0UDzMIsAemjQ0alpPbNGYxrTpndFTx8VA1AY0/fjTmA4+sQUtt4EwRBehFScCcTUBCKBQBCE/x8RUYSGZ4cLTgAAAABJRU5ErkJggg==)}\n#webamp .equalizer-top {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACBFBMVEUICBALFRINDRQOFQsPDxYQEBgRERoRERsREhsSEhsSEh0TEx4TFB0UEx4UFB8VFSEWFiIXFyQXGCQYFBIYGCUYGCYZGScaGScaGigbGyobHCscGyscHCscHCwdHS0dHS4dHi0dHi4eHS4eHi8fHyIfHzAfIDEgHzEgIDIhITQhITUhIjQiITQiITYiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDkkJSklJTklJTolJTwlJjsmJTsmJTwmJjsnJz0nJz4nKD4oJz4oKD8pKT8pKUApKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0MsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0svMiQwL0owMEsxMC0xMU0xMU4xMk0xMk4yMU0yMU4yMk8yMlAzM1AzM1IzNFE0M1E0NEs0NFE0NFM1LxI1NVQ1NVY1NlQ2NVM2NVQ2NlM2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVk5OVo6Plg+PldBQipCQl1EQTxISGRNTWZYWHJZVjxcXGRgX2pkW0RkZHFoaHhsbH5vb4JxcYZzc4hzc4p0c4p0dIt1dYx2kZ13Qyh3d4t4eIh4h4x7e4+Dg5WHd0yNjp2QkJCSkqKTk6OVlaaZmaidnamfn62pqbWvr7tT7jRLAAAFcklEQVQYGa3Bz49WdxnG4c/9fM+ZH7wglAGGgVZGQmKiAWuj3TQu1Gi0uujamPQPqOx0rSs37a7WvYk2ujCNCauauOmOmCaFdGGsMEwgIzD8ahyGd97zfW7PeWeo0KBSwnUp2BFsE1OiJwgBgsjCQBZiSlAAAQIJEAGWhOgJiiKDYCAQFCswBKggCAaFkm4zkgBML5gSQpAFg3iQZbAjMcJkkEwJqCWpUBkkBrqMRCS1VEwvlUBCJgZMw+v8F+KRgkcRjyA+TTxEPExsE9tkAbIQlhFYfJplmZ7BMlOW6ZmHmAeZh1kG3mjg58JhgeiJnkABAbIkegUkaBBBIECgIhc3KIgsLQ4oIAgaE1CSIkEDBUHJAgEqNQoEhV629KJJmq4FBAKKFQElQyCw2GEBFr2uqKNnqLFVKpYxGLYKMIEKVGNMVkioUbHcZWECNTJLTZyQDnCmDQiQ6AkUIIMlDChBEGyzEVCAcGMgKFEZZAKCFEmhNMJuKAUMaYgEdQTIrlBKS6+lS9SChATRoCZAFahgC5spsa1CSVNKFCActbHNlGhqnUygZlDBGCeZYCpgJBAYlZqYQTYMgkUen6lsm/A/HE9RyAIIMtUwKEyVQs/hEtQC7aRlZov7LCJUyOjaqIELBmfhE5ZM4Tc8sa+45btN13RnKvGdC2/C6eNniAYiQ4de289TdvOtE7T5Y37/yuh339x75pW5P/xg9qN2eeUDfliuvK/vsfHeS7v588klyEur0H51Hjbff/ZwTC6vf318/rnFD3LPcS5s+Evjf4j9iyvzi8DKMnCVRchLY1F/+9p+ntDNt57f+v4cDc0rf6TWU6fh1DlwA0nvAE/bAdpJLXf3vDjipYUbQIOOXgNOFu/DMDoxYrAy/uKhVSbAe00eOfLP1ZPH1knAjKzRXUMWerdu7V0a32N8EZ5hpTtx5GJGcIAndYDgPFNR+ekvT10/eO7Nb9sNCMG7fCaVxzCJkjf3HIb5mTED79oF2r01GR1bZWvmKJvzwBwYCPja1t/muaePFw8yUF34+HML14GwgDp72Fdg5gs378CzMCEs3uXxVR7WBduS3vWD18GoAdniBZ66sxS4eGzP3WbRfxW9cR4CFjbvjhYucePw/L8KvYXuxjq0Fa6agYEA/Exzb2521wZIHVCO6upY1LUEbhzMyxbmBZ7Y2WBHTGDt1PWja8g0gAXjJZ6yNaIWVu/N3YnFzQQE518UJ0vZw76Ajd3rixS4cqHQTmoBdGiTOfa688yBhawj7yuMNijzdMDcvDfnOyBmYXNzNLOFzHiJJ7QGvP0jer9+Ocobe8+xdur0h0kDBFx7h8/kBv/fiQwibi2N4U6dAcOV1WPs3vgL3xo9B+ujvy9SgQKTlt4ynJ09fJiN25c+v5yrMwvXrunLCzdpllkBltAyKzTLjG/DndGhy6BX3+Hx3eAhz9N94224ve/lmlnO/Qp+cvzDQPH6L0DIQvQECkCyJECgAAkVUBA4ZFFA0VCLggItDkCEIgjcQqpYosmmNqKnAkGvBRFWIQS0k7bCrAXo6NKl9ca1JRgosiCweIBlhFFXcEU1xrNd2QKMYWtmPNNpQs/UtAFnGhKnwbDVuDN0sssEnKSS+lFDb5NtshiIniAQsghkgQAxJVCAAIEECAhAEiBoMiAIegLRKxBgiKZrRNcEg0KvQABmEEkwkEyAjCV6FlOWZbs4ZcwgI+nJqshZS2Uqw0wMCQJnggHTSxLowGD8sz9BAOI+sUMIMIRRZCLAgBmIXuUTBjGQLQzYdAHBfTI9E2Aimq4R2QSDApRik+wIgilhkemEEANxnyyRGZIRg2RgIYVKqYVtWVMNOyT+I+m5A7Otkv8GlLRudA0dHtMAAAAASUVORK5CYII=)}\n#webamp .selected .equalizer-top {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACAVBMVEUNDRQPDxYQEBgRERoRERsREhsSEhsSEh0TEx4TFB0UEx4UFB8VFSEWFiIXFyQXGCQYGCUYGCYZGScaGScaGigbGyobHCscGyscHCscHCwdHS0dHS4dHi0dHi4eHS4eHi8eHyUfHzAfIDEgHzEgIDIhITQhITUhIjQiITQiITYiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDkkJSklJTklJTolJTwlJjsmJTsmJTwmJjsnJz0nJz4nKD4oJz4oKD8pKT8pKUApKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0MsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0swL0owMEsxMU0xMU4xMk0xMk4yMU0yMU4yMk8yMlAzM1AzM1IzNFE0M1E0NFE0NFM1LxI1NVQ1NVY1NlQ2NVM2NVQ2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVE5OVk5OVo6Plg+PldBQipCQl1EQTxISGRNTWZYWHJZVjxcXGRgX2pkW0RkZHFoaHhsbH5vb4JxcYZzbFJzc4hzc4p0c4p0dIt1dYx3d4t7e4+Dg5WHd0yNjp2SkqKTk6OTk6WVlaadnamfn62pmGWpqbWvr7u6usTHx87JydLO4tHU1NnX193d5unsznr5/v/0rKtaAAAFXklEQVQYGbXBT4udZx3G8e/1u+9ncmYm/5OaYWImqYQQJcWKSKFUBHUlChaUbtz4FnwDpSjd+hpEI7pwJ3UhbhRBTFAQtCHGkknS1rSGmJM/MznPuX+XzzmTqZkSNQ3x8xHbxBYxJwaCECCILMzIQswJAhAgkAARYEmIgaAoMghmBIJiBYYAFQTBTKGku4wkADMI5oQQZMEgHmYZ7EiMMBkkcwJaSRo0ZhID04xEJK00zCCVQEImBox4nf9APFLwKOIRxIeJHcROwRaxRRYgC2EZgcWHWZYZGCwzZ5lBsoN5mNnJMvD9Ct8VDgvEQAwEEgTIkhgUkKAigkCAQEUuriiILB0OKCAIqgkoSZGgQkEQDhCotCgQFAZZGURNSquAQECxIqBkBAgsHrAAi0Ff1TMwtJiUhmUMhr4APSTQjDHZwJBKLE+z0EOLzNISJ6QDnGkDAiQGAglksIQBJQiCLTYCChCuBoISjZlMQJAiKZQq7EopYLBBBk0JkN0gojLomCaqICFBVFQD1IAp2MJmTmyZQm2m1qhAOFq1zZyorfU9ZIoGxjixwSRgJBAYlZaYmazMBB/j8ZnGlp7/4hMpClkAQaYqM8FcKQwcLiIDur6j69lmEaFCxrSLFmTF4Fb5gCVT+RFP7NPueJnBTxvxxbYOx8sviAqRoWdeXeIpu/faSbr8Nj98ZfSDry7/7Ju7zn5914XRicvneTn+8Wt9jc1ffmmRN148AHlpHboXF2Dy208ejPa3916anDuz7/e5/xQXx/7M5M/Bs3uv7N8LXD0GjNkLeWUspj95dYkndO+15yffqAxe+TGtrZZWjrwDrpAMlnnalun6VjaXXhjxhb1joMKJvwPPBbsxjE4tMrN+91Nr6/TAr2oePXzrTy+cfI8ZswIrtw0ZgC7z8YOTm8cmF+AEV++eXh23UljmSS0TvMtcNNbLkc3R9XXsCkLwJh9J8hj6KHljaQ0O1TFzo8Og1daPTv2VVp5lsgDsW8RAwOcnfzzCP7Wxbw0Qast3di8ziAxgunSQy7Bw+s41WIUJxeJNHl+y0zRaYdASaJuHbjSMKsgWa/wfFLhxbOl+2cPvxOC+dwNL9xsrFxkfWNgoDPa0O1ega/DufUBs8+GSk4U9Ywj14HqC8YZo1zeAu7vzLQuzxpMLaAUa0UMZ3RgVZCpgwc2jPGVvE63whzP1brdnMwHBpTPwXESwO2Bj8fZ+Cly7EHR9K8Cutev79rHIHRZOLWdbYVRYGVMOcA/YP+LWgXvA4gLc6hZHm8jcPMoTehuY1gZsEuX4keutHGkXkgoEvH+Wj+QG/9vJDCLGB8fsudcWwPCXA0dZ3XyDr4xOwu3F81+mAQF9x+A4/ObgwZfYuPn+oWfy2sLy+KI+u9xR1rgCrMAxrlKOMdmEO4urb4G+dZbHd4Mdnmd67nMMzrfM8s46tEIgXv8eCFmIgUACJEsCBAqQUAEFgUMWBRSVVhQU6HAAIhRB4A5SxRI1a6tioAAx6ECEVZCAru8aLFiATh++crW6dQQziqwILB5iGWHUV7KhFvd3TcsEMIa+m3RNPQOTaQPONBjbYJhUTw1T2aUHJ6mkXaoMNtgiixkxEARCFoEsECDmBBIIEEiAgAAkAYKaAUEwEIhBgQBD1GkV0xrMFAYFAjDngEiCGckEyFhiYDFnWbaLU8bMZCQDWQ05W2nMZZjekCBwJhgwgySBKRiMv/NzCEBsEw8IAYYwikwEGDAzYpB8wCBmZAsDNtOAYJvMwASYiDqtImswU4BSbJIHgmBOWGQ6IcSM2CZLZIZkxEwyYyGFSmmFLdlSlQck/i0ZeApmSyP/BQLQYu4DqTgYAAAAAElFTkSuQmCC)}\n#webamp .band {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANEAAACBCAMAAABpaq8qAAABEVBMVEUAxv8SEh0SWwQTEx4XFyQaGigcGysdMBwfIDEhITQqKUIqKkEqmhYsK0MuLUcuLkgvL0ovL0svMiQwMEsxMC0xMU0xMU4yMU4yMk8yMlAzM1AzNFE0M1E0NFE0NFM1NVQ1NlQ2IRs2NVM2NlQ2NlU3N1Y3N1c3N1g4N1g4OFg4OFk5OFk5OVk9dCpCQl1EQTxNTWZYWHJZVjxasCxlmUVoaHhrcC1xzTR3QyiDg5WHd0yJ4jCNjp2QkJCQxz2SkqKTk6OTk6WWrI+ZmaidpDWfn62k4jipmGWrrZCtLSOvk4yvwziwcR3DcCrE2zLFVCrFhzDGeA/GszXOxtbTIhvTSR/cdx/gVB7gkijgsijgzTBk+3VYAAADm0lEQVR42u3bX09bNxjH8a8fP/lTombrhEC01TSkSuNik/Ym9q73XnKxqVs6VnUbNIFzbPcikNiIk4ZCIY4eXyB98OGIn+JjB4Wf+0aZN0l1KL5p4q+/VU91wqW0YXR0qsEnnHApPyJpUz5/dRe+4eJrU70nBjgaeG2jw3viyYTjYUaIOfs4t+KrtXwTSo75cBd+bO5OFSH+NAHtBfEREeIEJj+v2KeY7UPqZVTabjoFWXF4yV7TyfGAb88L8gVU8TCByS+hl5wgHgB8N5U2o4Lm1OLiQcDH7GeHzH0nB57B/N4U59zid+459Y7PU0E3vvgJqKpcDRdEqJ8iIVwJxVE/ld51QInaUj9l9Yo5glA/ZRlv+aVySlh+A6dQPxV3lfJqH6+esnyqHJDtE9VScRSjekoxFaifslOvz+qRupajfkqRTqmf4rxfPlIO6me5M+zC2MFEu3Yc2aqzRJbIElkiS2SJLJElskSWyBJZIktUT6JUun7u9KqL5UytFGIswlVPTalYjvVTs+crpET9LHaG1FI/7YTd/qHF+eSpn7JchiFBS/3UlJbHVFrshJXz+l8CiZAaqJ/Slu/56qcsT9wU8In6qeH6E7LkUhupn5r84kxypJZI/ZTUtg7AN8kHqJ8SQ9BjOBFPmwK38BJcxgCDjfkR2JgX0N6fGhMix4Nns1ZjhJgQOWGc0xVs2NNuxou1nLN31sn3eDe7NzW2DKZHvXYW274/Y8HhbB2bpptvP8Phv2uYhtyfGgQNfwBeIFA/Nfv7opXEDnDnhtvNRtUDNpteHzJ7Wuo9uksLHvA+4+H+3XgaunnINOcL2IQqQnwN4z+zdtK4LCut5UvhYLrivvLdP910JWG/nM15CIfvMvbpZ3wxgg+3UW9pNo2HMN+UDJjljaryVjfonhUX06NZM3ujfsW6ntcIRv9/YaPqBgXkcTpTIjlHMLJGlTWqrFH1lWiNqu2nNaq2n9ao2n5ao2r7aY0qa1TZJ8sPkMgaVbbqLJElskSWyBJZIktkiSyRJbJElsgSPVUia1TVtOqsUYU1qh6H1qjaftoJu/3DGlXbT2tUbT+tUWWNqsenNaq2hg5cd6PqPzjP2kl34l8l38GsmwkuM55C0z07LZtclzHGjGflxefLW+mijjQo2kmezTn/u2g2zeczf97J30fPc86mB8Xs976YnceQ3fntDyVf9ptbqQ9XZdqA06NUclpQhg9Aa1RtPz8But0Pz3B64+AAAAAASUVORK5CYII=)}\n#webamp .band .slider-handle {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALBAMAAABbgmoVAAAAGFBMVEUAAAAICBApKUJKWmt7hJSLm6etvcbd5ukLNggsAAAAMElEQVQI12NQZGBgYFRgEC8vLy8WYBBPS0tzRqIExXDyQlxcQJQxEAgwAE1hFFQAAB9KDSykox1vAAAAAElFTkSuQmCC)}\n#webamp .band.winamp-active .slider-handle {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALBAMAAABbgmoVAAAAD1BMVEUAAAApKUJKWmvd5un5/v8UiEZ+AAAAJ0lEQVQI12MQYAACAQZmY2NjIwYGZiCHCYlyccDNg1BKQAAyAGQKAHJPAsUS1KniAAAAAElFTkSuQmCC)}\n#webamp #on {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAIVBMVEUAAAASWwQvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v8M+RL1AAAATklEQVQI12MoRwIJDFWr4GC5A0NVBxyUGjBUNRsbdzRpNHVoQHiCkh0aTU0aKDwlKG/mTBCvCcID6UfoQzUTYTmQV54aCgcGDCnGCGAAAPUyQLvRdOj2AAAAAElFTkSuQmCC)}\n#webamp #on.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAFVBMVEUICBASWwRSZnNje4R7jJyLm6etvcYvdU+XAAAAQElEQVQI12NgwAdMXODAgYHBLQ0OEoA8VDkgdnFgcXBhgfAERV1YHBxYUHgMUF5oKIjnAOGB9cP0maGYqYDkEgAFZxmn+1/+wgAAAABJRU5ErkJggg==)}\n#webamp #on.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAIVBMVEUAAAAA1gAvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v911B9qAAAATklEQVQI12MoRwIJDFWr4GC5A0NVBxyUGjBUNRsbdzRpNHVoQHiCkh0aTU0aKDwlKG/mTBCvCcID6UfoQzUTYTmQV54aCgcGDCnGCGAAAPUyQLvRdOj2AAAAAElFTkSuQmCC)}\n#webamp #on.selected.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAFVBMVEUA1gAICBBSZnNje4R7jJyLm6etvcapTzEQAAAARElEQVQI12MQRAYMaDwTFzhwZBB0S4ODRCAPVc5RUNDFUcTRRQTCY2B1EXF0FEHhCUJ5oaEgniOEB9YP02eGYqYiklsAdNMdgDKFw2kAAAAASUVORK5CYII=)}\n#webamp #auto {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAHlBMVEUSWwQvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v/WADVeAAAAV0lEQVQI12NIQwWpDJkzUUAyQ2Y5MihzYsgsUlIqLxQvLBcXFC8UBwswcJSLFwIFQAgmICiILNDRgaoCZBaQI1heWA4xA8MWVIc5MaSFuCADJ4ZgJVQAABsNRRhxaDvQAAAAAElFTkSuQmCC)}\n#webamp #auto.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAFVBMVEUICBASWwRSZnNje4R7jJyLm6etvcYvdU+XAAAAS0lEQVQI14WOsQ2AQBDDAh8GYKMUHgF6ihP7j0CFxF+DS8tSIv0ymIh8T1xy9aIkI5wIEbmW/Qh2cPAr9BXb2QogOMaIaPSVtR19ACp1H3+cU6+ZAAAAAElFTkSuQmCC)}\n#webamp #auto.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAHlBMVEUA1gAvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v+vLTjBAAAAV0lEQVQI12NIQwWpDJkzUUAyQ2Y5MihzYsgsUlIqLxQvLBcXFC8UBwswcJSLFwIFQAgmICiILNDRgaoCZBaQI1heWA4xA8MWVIc5MaSFuCADJ4ZgJVQAABsNRRhxaDvQAAAAAElFTkSuQmCC)}\n#webamp #auto.selected.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAFVBMVEUA1gAICBBSZnNje4R7jJyLm6etvcapTzEQAAAATElEQVQI12WOwQmAQBADtwSjsaDAlKAFCIf9l+BL8NZ5DgNJqVE/sTGR8j1xlUcvhmSEEyFSHksdwQ4OfoW+Yj9bAQTHGJHa+sranj59DSTnUdDwigAAAABJRU5ErkJggg==)}\n#webamp #eqGraph {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAATCAMAAACQnBKzAAAAw1BMVEUqKUEqKUIqKkMrK0QrLEQsK0MsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0swL0owMEsxMU0xMU4xMk0xMk4yMU0yMU4yMk0yMk8yMlAzM1AzM1IzNFE0M1E0NFE0NFM1NVQ1NVY1NlM1NlQ2NVM2NVQ2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVk5OVpsbH5vb4JxcYZzc4hzc4p0c4p0dIt1dYwbWqB2AAAC2klEQVQYGQXBIQ9lSRkFwDpf930zCQqBxaLQ/H+PRuDXrCQkbObd7kNVzD/+qSay+fu/BDL87d/MMtL5628iiP2X31cQ5M//6cp3nrJ//u+upgM//2gAfv7BO6aOP/33ndQx4HVJMQGeXnSgB0/V/lWicJvObrKOrDNJCwJQ1XVzz1F3DxYTsaHBBbx7MIhsfDNHfwSNlE8vuCO8V7QAEJGzTnSlYxL3nojNJkVC+NRLGtoC8wjSIOl9Z2NJ3syeugkAwLvjyFtMl6FaGhoGyK/HZ1SX20D2CzQN+nn3vK8eOoaxAFC0vKxplMlx14qEucCdC10XJquy4/Ho/gKmbO/Mu5/sGQZcAAhN7tr1Jk3cWcu6EM4rGCbBXNdwouX72M0DgXizjh19T6S9twBASU1a+632nn2wiPIgCLDfTViHDV52oFHo+4Oy35M6Ww0KEBXlOilu9uKs6AMCHYH3McpZdQe29gshzE17tlSWZLkDAkCKhnV4wxwW8t4ZCqUAZC8xeL5yLihY6Xx3NGfclqEAgLg30dPcW3dcNzBCigBAigvI95kPSMp36Udti+be6kkBoK0knVTXJzKLwnYgzBAea8Y0hwGery9I2vjkheSMe5iJjABwG5G0Rm6v27ksCXNfEMDXoLHSAq/nM0grfDs+r46LIUgLwKRoj1wd5TOzSG2ZLUgFmCu1dALPd7sFSVDXO3L1rDWARAElTmXuEe5qf8290uDdUqZDyHJnJAfwePrc7wtVsz+SPdou5xwKCCDK0pNFuehkkaI0dC7YXDe6kzP4ft/j+bGJ4J5fH4WIZSnXBYBGxDrvgt2MPRW2hhB30nDHIHTw4OXXD9BBn3yCNF3W62aNAYA7Dtfc4867j2sOxBkCiWIGUsrw5bXyA9FRJj0SzVJZ9qK3ANqRvWql7crWMitq27OBlNAro0E6+OKeF6Sy7XOPNhk3CmQCIORWVk/inPcO/g8Gk8tpHAw47gAAAABJRU5ErkJggg==)}\n#webamp #presets {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAMBAMAAADrBkIEAAAAGFBMVEUvN01KWmtSZnN7hJSLm6ettca9ztb5/v8/TtPPAAAAXUlEQVQY022PsQ2AQAwDXblnlBcbwAYI9K0bbgXWpwAEErnSuii2topV/ShY1PmzN3UiZOQIWY7uGDsBEwj+2pHjyCF+bJwACdfBGyNfD9Bt102qOU3bPP5pmoaKE9BgTHfswQ68AAAAAElFTkSuQmCC)}\n#webamp #presets.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAMBAMAAADrBkIEAAAAElBMVEUAAAAICBBSZnNje4R7jJytvcYlh7IyAAAAW0lEQVQY03WPsQ2AMAwEv/gFMgI7QP+RLgNQsP8qFAGBlOTK01m2VaZopXdGqkq7Rk6VtqiJkJEjZDl6NHYCJhD8ryPHkUP81jgBEvrAp5H7AmSqyjG/ZJt9eQMWOi9EkrQa+gAAAABJRU5ErkJggg==)}\n#webamp #preamp-line {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAABCAYAAADpXEERAAAAE0lEQVQoU2Pcdfruf4ZRMKRDAAD1lwNjTqcaUQAAAABJRU5ErkJggg==)}\n#webamp #equalizer-window.shade {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAAChVBMVEULFRIMDAwNDRQNDhQODRQODhUPDxYPDxgPEBgQDxgQEBgRERsREhsSERsSEhwTEx0TEx4TFB0TFB4UEx0UEx4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyMXFyQXGCQYFyUYGCUZGCYZGSgZGicaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS8eHi8fHyIfHzAfHzIfIDEfIDIgHzEgHzIgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJjsmJTsmJjsmJj0nJz4nKD0nKD4oJz0oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvJwgvL0ovMEsvMSUwL0swL0wwMEsxKQgxMC0xMUwxMU4xMk0xMk4yMU0yMU4yMk8zM1AzNFEzNFI0M1E0M1I0NFE0NFI1NVM1NVQ1NlQ2NVU2Nhg2NlU3KxA3N1Y3N1g3OFc3OFg4N1c4N1g4OFc4OFk5OVpGQh9JRjlORDBQPx5aWmFbW2JbXGNcW2NcXGNcXWVdVztdXWddXmZeXWVeXWZeXmdeXmhgX2phYGphYWxiWkViYm5jY29jY3BkZHFlZXJlZnRmZXRmZnNmZnVoZ3VoaHdoaHhpaXlpanlpanpqaXpqanlqanprXUFra3xrbH1sa3xsbH1sbH9tbYBtbn9ubYBuboFvb4NvcINwTyxwb4Nwb4RwcINxcIRxcYZxcodycYdycodyk5lzc4lzc4pzdIp0c4p0dIt1dYyCmI+Gd02QkJCZc0K7v3F3AAAEz0lEQVQYGQXBsesvVBkH4OfznvO9FdGfULQGEvfiLHdwb2ksWiKizbmQSIlWqSECXYOGwD9ABxGiRbpra85OQpi/c96350lBEgiBBQIqCI/zDGTKAygWglCFKCYhEHaqy+ZuVKhJoMgSCkS1NRlBALYTpTgPQwDAZOjex3LNPgAGXaMZ0AanqzG62jQ9ddDcOgO2PxIK6ULYpGcLCGQKKAQhYgKlEEEQqYKiuhIgSiDwMFgANaoAEJIJMhGTESYAACaTgaGrMUBXMxqYJp5gYDSD4YKG8+vN25X76BIiS02ipkRm35XAIniGsuuWEirWbCmZLNnHgxDPRhEqgZ0qljJ7u+vWIhbMJlJj3YViYyaFIiZMAAAwMtBM9cTZR4MzGHq4kzE6vhKnrtbdY+hMZ9ocRtH3pAF7yWCmQLpikAYFOEuJQs0eRNLY+xyEjha1YsZ+hG4u+xyhwGWtDfSwqLI3TQrVzAQBADAAoKbj9AFaJSZul8sY075i2tW4IYzJtAG9Qfk+AAAAAADGk8s3+Y8IRBVBEYJMdihst9hdoQQKu6umgGCNqZgAvPMRvf0jdMF5ADBxK542x+62nN99xN8BAAAAADyfx9Mr+GHzk8/e5t3XP1CbfXd9763nAAAAAAAAr977lnyv+tnZd6uQNdlnJ4RdY1FBqFqqi1XLdm0irK7ZQlTLorpspBvV7stgBACACYOu1pHJ3956DgAAAAB49d6L8+rlT/GL18znL9+tfvkpU1x4kSRJkiRJkiRJkiRJkiRJkiRJkhdq0c6+uyqoCbuN2LumjAKYtC6AszQyMJsZdGWhy8YdhbKYmUkAAIwAqqnUDC+SJEmSJEmSJEmSJEmSJEleqHkJXhq//NfL77z89DdmNg/hfQAAAAAAeAI0alvpmtQILjGh0xUT8OzrDawy2FedB+E+u5CYNQuFY5MLKIIJAEAwoMFM8T4AAAAAnoDDz/8H0K+ev/rcyGbS5XUAAAAAAAD+OYGzb6qXroAN9GwhE8FDUegC63qA5S4yTGYBXbau2QOmY0QmAMCEEUN1d9UpvA4AAAAA4J/VfIMPaP77xqs3v5SxK27xxZsAAAAAAAAfC9j3MQoZ2dbZgiw1MWHi6x2KR5uNG72E1TVdJIOzu/DsbGbsUAAIEwAEGaOVKpZuX7wJAAAAAPjY8cnP4ZPXyl9+8OnnX77x+8+O3aP4/MMPAQAAAADwJfh2rz9g6ZQIBNm9oLrILEEmSSCQEkUAFihAJDM1FJV3CAAAEzBgJpOOqh9/+CEAAAAAX4IXx/OfwWvTvvvXP/OrH322pf70W9aEnSBYIlQFIUXIA2XrVb0Uqe2ulLDE5trJVqZCahJq3ypFttk2ITJZKgihCorNJECBAAAAGOhqk16No2m9bxuMMwbTvc7+Ku1q+uwnw81MLnNM2vy7CjVwzx1IgmEMIREoFGyWSDh2iLWwj9gJZmQgGXqqCqvahiuE1foSTFVD2eimNQUJBgCAmQG0m+5znKNR8nQNxpklZmRdx/SF5gnUjOEeoyErIQhkKgioSULV2CDJPKAmMpUglBKotAqQHYrtshUhCZR9dnQVCMqIENgHG5dqSgkAMDGZU71n4i4cwBgZPRnQOl1HA9NM6zrLoY1jYMyk/w9e+WXwreroJgAAAABJRU5ErkJggg==)}\n#webamp #equalizer-window.shade.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACdlBMVEUAAAAAAAgNDRQNDhQODRQODhUPDxYPDxgQEBgRERsSERsSEhwTEx0TEx4TFB0TFB4UEx0UEx4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyMXFyQXGCQYFyUYGCUZGCYZGSgZGicaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS8eHi8eHyUfHzAfHzIfIDEfIDIgHzEgHzIgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJiwlJjsmJTsmJjsmJj0nJz4nKD0nKD4oJz0oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swL0wwMEsxMUwxMU4xMk0xMk4yMU0yMU4yMk8zM1AzNFEzNFI0M1E0M1I0NFE0NFI1NVM1NVQ1NlQ2NVU2Nhg2NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFc4OFk5OVo/QitCQTtKQT5SSj1aWmFbW2JbXGNcW2NcXGNcXWVdVztdXWddXmZeXWVeXWZeXmdeXmhgX2phYGphYWxiYm5jY29jY3BkZHFlZXJlZnRmZXRmZnNmZnVoZ3VoaHdoaHhpaXlpanlpanpqaXpqanlqanprXUFra3xrbH1sa3xsbH1sbH9tbYBtbn9ubYBuboFvb4NvcINwb4Nwb4RwcINxcIRxcYZxcodycYdycodyk5lzbFJzc4lzc4pzdIp0c4p0dIt1dYyCmI+Zc0KjlGqqurGxnVm2nF7O4s/sznr///8TArHKAAAEcUlEQVQYGd3BMc9m6xgG0HXdz/N+yEl0ujlx9AoqiehEq/MT/AoKgoK/oFRpFBqF6HQaEZXqJL7KdBIRM3vft/1+MxzORMxEZ62USxKXEJe4i7sE4XY8uMuUmyfFQhCqEMUkxCWsVJfNuVGhJnEJWUK5i3XakxHEa9sRpThuhvhXk6F7H5bT7MM/DLrGybhrg2MyGF1tmp460HTOcbf9kFBIF8ImPVvcxSVTngRBiJi4lEIEQaTKpaiuxJMocYnLNlheq1HLR0IyQSZiMsLEx00m4zJ0NcaTc52M9mSaOFzGZTSD4XTXLsd3N9+rnLcuIbLUJGpKZPa5EpdFcEPZdZYSKmq2lEy27MONEA+jCJW47FQoZWo711mLWC6zidRY50LYmEmhiAkTbxoZl2aqJ459GHfHYOjhnIzR8UKcaaO7x9CZzrQ5GEWfR9ore8lgptylKwZpd+WVYylRyOxBpBp7HwdCR4taMWPfwgxN9SGUu5O1tic9LBJ706RQzUwQHzf+VU3HMYcnrRITZ5eTMaa9YFobnCGMybRx19td+ay3N146+SR/FHGJKoIiBJmsUNjOYneFEpdgd9WUJ8EeUzHx2rd/RW+/CV0ux80/TZwVLzeH3W05vvUrfu5tfWFuLz/v8rvmG4/P+cyzn6jNPne9/+Obd/Tym5+S9zO3Y59bhVqTfeyEsGssKghVSyZUxXbaRFhds4WolkUmNtKNaueXgxFvmDDoah2Z/OzHN2/n5Te/eHw+X3rPX/zWPH7lw8dnH/ya2ZwuD97Vgwrj2OcuQU3YvSax1VRPymuTronXjn12kQlmM0LXLExsnEuhejGIN0zilWpKZuLBW3pQR7zHezGef/jB++vD52Y2N+EX3sF4pZFtpWuyRnASEzpdMXH38GJ7UmXCPtVxI5wPp0ti1iwEh01OrxTBxMcE467dzRS/8N+NJwdfO732+P4n/vZoZDPp8lXv7KcTl2OfqV7OFXfbk54tZCK4KYIud+t0c7eciwyTWZ5MbF2zx910jMjEv5kwYqjurjoKX/W2flrN4pc0z9bf9rPnGbviLP76ae/oz+Jun7dRyMi2ji3IUhMTJl7sEHabwhm9hNU1XSSDY3fhdmxm7FA+EiY+EmSMVqpYuv31097Onx3mxYMXRvnMBx8+Pvvc4xx2j+Lx+97Bn9y91+s7WDol4hJk93KpLjJLkMnFJS6JKOK15W55JZKZGorKt4k3TNyNu5lMOqq+/n3/3Z/cffHwe3e/nfbs1889f3xmS/3oB6wJO0GwRKgKQoqQjbL1ql6KZDtXSthic9rJVqZCahJqn1VClimbEJksFYRQ5RI2k3hS7uI/GZeuNunVOAyt99kG4xiD6V7HfpHWhj72S8OZmZzMYdLmD1WocTmPc1ySYBhDSMSlUC6bJRIOO8Te2IfYCWZkXJKhpyqotHI5hbBanwRT1S6x0U1ryiXBeMPMeKWd6T4Ox2FQ8vI0GMcsMSPrdJhpl+alu5oxnIfRLvG/iv8b4y5/B72CM+yl6NhDAAAAAElFTkSuQmCC)}\n#webamp #equalizer-volume.left::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}\n#webamp #equalizer-volume.left::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}\n#webamp #equalizer-volume.center::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}\n#webamp #equalizer-volume.center::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}\n#webamp #equalizer-volume.right::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}\n#webamp #equalizer-volume.right::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}\n#webamp #equalizer-balance.left::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}\n#webamp #equalizer-balance.left::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}\n#webamp #equalizer-balance.center::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}\n#webamp #equalizer-balance.center::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}\n#webamp #equalizer-balance.right::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}\n#webamp #equalizer-balance.right::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}\n#webamp #equalizer-shade.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVKQT5SSj1sXUO0kWO/uX6z+JYEAAAAM0lEQVQIHQXBwRGAIAwAsLT07Z2zsP8qbuDBAliTmDjl1m8Gob6HK5uWti27V6uxDDFxfn1PDx8P0VYSAAAAAElFTkSuQmCC)}\n#webamp #equalizer-window.shade #equalizer-shade.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVKQT5SSj20kWO/uX7CsWHebnl7AAAALUlEQVQI12NQAgIFBiUGBiYFBgVhYwMFBkVhY0Mg6QwmXVwEgeIuLgIwNWD1AJzCBeFqt4OOAAAAAElFTkSuQmCC)}\n#webamp #equalizer-window.selected #eq-buttons.clicked #equalizer-close {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEUpKUI1LxJZVjxkW0SHd0ypmGX5/v9OYEDlAAAAJ0lEQVQI12NgAANmRUFlBgamYOUgBgZGU1dDIKmSoghjQ8QhasAAAHO7BEc0qEt/AAAAAElFTkSuQmCC)}\n#webamp #equalizer-window.selected #eq-buttons.clicked #equalizer-close.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEUxMC1ZVjxkW0SHd0ypmGX5/v/v3/6CAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}\n#webamp #equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAALVBMVEUoJz4oKD8pKUAqKUEqKUIqKkMrK0Q6MSljXjtsXUORbkq0h2O0kWPCsWH///8vo79mAAAAO0lEQVQI12NIdTFWUmDIbC/vFGCI2Nl5QoAhfM6a6UCy61U7A4P7nLVAdsTJzhsMDJ5ANQwMLkaKCgwA6D4RaTQt0CAAAAAASUVORK5CYII=)}\n#webamp #equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEU6MSljXjtsXUORbkq0kWP////9IyyfAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}\n#webamp #position {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPgAAAAKCAMAAACuVWMrAAAByFBMVEUPDxgPEBkQDxgQEBkRERoREhsSERsSEhsTEx0TEx4TFB4UEx8UFB8VFSEVFSIVFiEVFiIWFSEWFiIXFyMXFyQXGCUYFyUYGCUZGSYZGSgZGicZGigaGSYaGSgaGicaGikbGyobGywbHCsbHCwcGyscGywcHCsdHSwdHS4dHi0dHi4eHS0eHS4eHi0eHi8fHzAfHzEfHzIfIDEfIDIgHzEgHzIgIDEgIDMhITQhIjUiITUiIjUiIzYjIzcjJDgkIzckIzgkJDckJTklJTolJTwlJjslJjwmJTsmJTwmJjwnJz0nJz4nKD4oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkErK0IrK0QrK0YrLEUrLEYsK0UsK0YsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swL0wwMEswMEwxMUwxMU1hYm1iYW1jY29jY3BjZHFkY3FlZHFlZXNmZXRmZnNnZnVnZ3ZoZ3VoaHVoaHdpaXhpaXppanlpanpqanlqanpra3xrbHxsbH1sbH9tbYBuboBvboFvb4NvcINwcINwcYVxcYZxcoZycYdycodzc4hzc4pzdIp0c4p0dIt1dYwExkcuAAACuklEQVQYGQXBAWEANxADMPmSFsOAjT+QNX+eFEYgZicIBCMQMBlphNGBIJgZQLjId3bmPtcHfncAkIZoAAAAAECBAuy7Hsfb2dnuwEPB7qKawjer1OYBhR0jAFMAFQIAQRJsAjSBnQUJF74aHp+DuQAgDVEAAAAA0EIVAPvgy7BSeLTgWUChFhr5QAsS/jFumXD3NrlkiGDOkNnJbGJigksiOHuIuyYmFdzxMmaH3/9+GHvAqKPTkMKgAQCbziLV77xZCiv/AZY+qB2bv/Oofmn5+1mPWnm0fPieUjVG5pZJMZJ9aqXB75nFTm3qxgAsxZ5SxrBNcN/uGQz256vdKdg5+aRBMSAAAFlorc0OCQtg11sXYnbtobUU7nJJ1FA+1D3QmNQZjHKXmptFA3+LmAzGK3D1OyAjxDo1swV0Abc95UQZY4toTBKjAAqgE1qdo5YW/HFh/OSBMuBiBLx97+GTtxrf0NVHpSbxHki4w65eI8GECWoGluBxP0gg7iQwgTdmAF9nx6iwmeecpNK0aVdQEKWKLch+MxB4zvVgAbCr3vewCp+5QKpU6FKASaQM7oWZ3y9vBPTMgtCMeyjoOzBN4fGZ3YDfmWVA7zcmpTjvWpVSVkYRQAiTgXxfp4uqrJt92KUPAJun+FJwAkpHFAsvoLuD81MLrLqSSwOHCRM2jBnhXi7iGxH3rmEGWH8H4P4NKglchgoTkwUA0M3aqJ67pgt8w9+MNcjlgcV3oaelLA/7bSgahUfBrBkMnlHoR1LMM0Ew7HQFfDcgi3pzQYB1i+HKDxbg+8yXENasqQAASbNa5c1OhjRr/d3HWNiF2tHOg1ShO6hxPCld4S8IuOPfCIjpIJiaHdMDaXL2QJAQEAYEGCKAEQRpgLGGaBoBAABomkIrWkAVbIFSNkVhU4raFMWbLYV2WcX/K67c097eK2wAAAAASUVORK5CYII=)}\n#webamp #position::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUJAgJlZXNlZnN1WyKDaTCNdTqcgkqvmGHFsn7by57u4rv06sf19fW6wGFFAAAARElEQVQI12PQnIkMAhgkXZDAUQYGSY/dcLCnFMj3PgMHp8F8YziwBvPL4aAaxPdB6N8G4p9CyJebAvmhyICBQYABBQAALnc7YhsUgeUAAAAASUVORK5CYII=)}\n#webamp #position::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUJAgJlZXNlZnN1WyKDaTCNdTqcgkqvmGHFsn7by57u4rv06sf19fW6wGFFAAAARElEQVQI12PQnIkMAhgkXZDAUQYGSY/dcLCnFMj3PgMHp8F8YziwBvPL4aAaxPdB6N8G4p9CyJebAvmhyICBQYABBQAALnc7YhsUgeUAAAAASUVORK5CYII=)}\n#webamp #position:active::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUgDABhRhBmSxNsUBdwVRt4XSGBZyqPdTmhhkuwmF6+qG/DrnXYxZOv4MtwAAAAR0lEQVQI12PwnIkMAhg8XZDAUQYGT4/dcLCnlIHB0vsMHJwG85XgQBvML4eDaiBf0wehfxuIfwohX67KwCAZigwYGAQYUAAAXWI7mESGeYIAAAAASUVORK5CYII=)}\n#webamp #position:active::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUgDABhRhBmSxNsUBdwVRt4XSGBZyqPdTmhhkuwmF6+qG/DrnXYxZOv4MtwAAAAR0lEQVQI12PwnIkMAhg8XZDAUQYGT4/dcLCnlIHB0vsMHJwG85XgQBvML4eDaiBf0wehfxuIfwohX67KwCAZigwYGAQYUAAAXWI7mESGeYIAAAAASUVORK5CYII=)}\n#webamp #shuffle {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPCAMAAABDVWaoAAAAilBMVEUQWgAqKUIqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU0xMU4yMU4yMk8zM1A0M1E0M1I0NFE0NFM1NVQ1NlQ2NVM2NlU2NlY3N1c3N1g3OFc4N1g4OFk5OVpKWmtSY3N7hJSElKWttca9ztbV3vLv///LbncEAAAAqklEQVQoz5WSsQ7CMBBD37WpGPgDpJtY+/8fAxLLfUbVM0OiNgKG4CGKL45jRbYbiSUIkBAiMZJEqI2EMjGYynVhHHoWmIfle1IEOeqeogCwAQwFq3oesIoADyfaAt4mBHivb/Av5h8nRQCslQVOHPrK/Nif/ouaSdDd+OlvXYDD2qOP1r9j98s8/p/5KlarMIoCu/SPXvmf/yb2SQJkotZD087Z2VrcBIM3KB9V4lGQbMMAAAAASUVORK5CYII=)}\n#webamp #shuffle.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPBAMAAACGpYupAAAAGFBMVEUAAAAICBAQWgBSa3Nje4R7jJyPn6itvca8iDuFAAAAY0lEQVQY02MQxA4EGHBLuIZighBDoER4ORYQCJLAoiMUIiEoKIpdQkgpNYAhIJSVNQBIARkBDEgSoRCJUAiESoilgXQwYOoAgQBsOkDiIDsCWMHCDCg6sLoKh4Q7LglD7IEIAKjwVurEkbm9AAAAAElFTkSuQmCC)}\n#webamp #shuffle.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPCAMAAABDVWaoAAAAilBMVEUA1gAqKUIqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU0xMU4yMU4yMk8zM1A0M1E0M1I0NFE0NFM1NVQ1NlQ2NVM2NlU2NlY3N1c3N1g3OFc4N1g4OFk5OVpKWmtSY3N7hJSElKWttca9ztbV3vLv//8gEwg9AAAAqklEQVQoz5WSsQ7CMBBD37WpGPgDpJtY+/8fAxLLfUbVM0OiNgKG4CGKL45jRbYbiSUIkBAiMZJEqI2EMjGYynVhHHoWmIfle1IEOeqeogCwAQwFq3oesIoADyfaAt4mBHivb/Av5h8nRQCslQVOHPrK/Nif/ouaSdDd+OlvXYDD2qOP1r9j98s8/p/5KlarMIoCu/SPXvmf/yb2SQJkotZD087Z2VrcBIM3KB9V4lGQbMMAAAAASUVORK5CYII=)}\n#webamp #shuffle.selected.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPBAMAAACGpYupAAAAGFBMVEUAAAAA1gAICBBSa3Nje4R7jJyPn6itvcZs8alFAAAAY0lEQVQY02NQwg4UGHBLuIZighAjoER4ORYQBJLAoiMUIqGkpIpdQlEwNYAhIJSVNQBIARkBDEgSoRCJUAiESqilgXQwYOoAgQBsOkDiIDsCWMHCDCg6sLoKh4Q7Lgkj7IEIAGMfXXXsp3orAAAAAElFTkSuQmCC)}\n#webamp #repeat {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPCAMAAADAkV+TAAAAeFBMVEUQWgAoKD8pKUApKkEqKUEqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU01NlQ2NVM2NVQ2NlU2NlY3N1c3N1g3OFg4N1g4OFlKWmtSY3N7hJSElKWttca9ztbV3vLv//8ki4GoAAAAgUlEQVQYGQXBMQ7CUAwFMP+SzkgoO1vvfyQOgJBYWKB52OsOQpIVSJaZTdTnCgAAIDUuAACAcwoDAAAyKfCFHQBAAQ+OyO8NGlAAkL3Bs4Fa4AAvGgAqsAfQAKAWAPQTNKACgNYAoBYBAAAozgQAAFAyAQAAWLeRNSQRmS3j3GTCH4ZgNtlEi15VAAAAAElFTkSuQmCC)}\n#webamp #repeat.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPBAMAAAAFYbKSAAAAFVBMVEUICBAQWgBSa3Nje4R7jJyPn6itvcb4vicLAAAASElEQVQI12NgwA9MXODAWYGBwS0NARyAXISsC5jLwMCCzGUUDAHpYkFwnUBSUC5raIgDA4ILkmFB5Tog9KJZhMI1Q+UqIHsAAPs1JqMDCtK2AAAAAElFTkSuQmCC)}\n#webamp #repeat.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPCAMAAADAkV+TAAAAeFBMVEUA1gAoKD8pKUApKkEqKUEqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU01NlQ2NVM2NVQ2NlU2NlY3N1c3N1g3OFg4N1g4OFlKWmtSY3N7hJSElKWttca9ztbV3vLv///lInoXAAAAgUlEQVQYGQXBMQ7CUAwFMP+SzkgoO1vvfyQOgJBYWKB52OsOQpIVSJaZTdTnCgAAIDUuAACAcwoDAAAyKfCFHQBAAQ+OyO8NGlAAkL3Bs4Fa4AAvGgAqsAfQAKAWAPQTNKACgNYAoBYBAAAozgQAAFAyAQAAWLeRNSQRmS3j3GTCH4ZgNtlEi15VAAAAAElFTkSuQmCC)}\n#webamp #repeat.selected.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPBAMAAAAFYbKSAAAAFVBMVEUA1gAICBBSa3Nje4R7jJyPn6itvcYox7XLAAAATElEQVQI12MQRAEM6FwTFzhwVmQQdEtDAEcgFyHrAuYKCoogcwUYQpwVwWIwrhNICsoVDQ1xFERwQTIiqFxHhF40i1C4ZqhcRWQvAAA51isA/VWazgAAAABJRU5ErkJggg==)}\n#webamp #equalizer-button {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMCAMAAAC+5dbKAAAAUVBMVEUQWgAqKUIqKkMrK0QrLEQsK0MsK0QsK0YsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0wwMEsxMU1KWmtSY3N7hJSElKWttca9ztbV3vLv//9O4LHRAAAAaUlEQVQYGQXBwQ2DUAwFMEODRCao2H++HnrKofBf7e0NAAD5lhcAAM+6iwUAkJVXwQ8Ho42GVeDjimmmTSM7AGYAKHCBhmmww5GEntHTAykCcIozZ6A8CQAAqawAAEDda/NgbZFErMfuD041NCuZPULmAAAAAElFTkSuQmCC)}\n#webamp #equalizer-button.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAIVBMVEUA1gArK0QvN01KWmtSY3N7hJSElKWttca9ztbV3vLv//9R/wqlAAAAT0lEQVQI12Moh4MyAYaqVTBQAuR0QEF7MIhjbNzRpNGkAeEYcHZodGg0wTlKGjCO5UyQDFQZEAD1QGTg9gA55amhUADkpBjDgQCDIAIIAAAWsDNHmvvPEQAAAABJRU5ErkJggg==)}\n#webamp #equalizer-button.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAICBAQWgBSa3Nje4R7jJyPn6itvca8iDuFAAAASElEQVQI12MQRAABBhSOgGsoFAQDOeHlUFAK4sBkQsEcQcHQANYAVghHSC2UNZQ1AM5hYIVxxNJAMlBlQADUA5ZxRzbNEOECAM5YHW8MP5O/AAAAAElFTkSuQmCC)}\n#webamp #equalizer-button.selected.winamp-button {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAA1gAICBBSa3Nje4R7jJyPn6itvcZs8alFAAAAR0lEQVQI12NQUIIDBQZUjmsoFAQDOeHlUFAK4sBkQsEcJaXQANYAVghHUSyUNZQ1AM5hYIVx1NJAMlBlQADUA5ZxRzYNyQUAEUAg+7nvOG8AAAAASUVORK5CYII=)}\n#webamp #playlist-button {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMCAMAAAC+5dbKAAAAUVBMVEUQWgAjIzgkIzckIzgkJDklJTolJjsmJTwmJjsnJz0nKD4oJz0oJz4oKD8pKUAqKUEqKUIqKkEvN01KWmtSY3N7hJSElKWttca9ztbV3vLv//+EzjHeAAAAXklEQVQYGQXBgRHCMAwEMLk4WYFj//nKAOHqR6o3AADk214AADyjGQCATKrhh+WwzwZygfve2ADUBYADwDT4gA2AhhUAxwZNACssAtqTAACgMwEAwPRRI5GpmTIhUX81UygSftVjhQAAAABJRU5ErkJggg==)}\n#webamp #playlist-button.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAIVBMVEUA1gArK0QvN01KWmtSY3N7hJSElKWttca9ztbV3vLv//9R/wqlAAAASklEQVQI12Moh4MyAYaqVTBQAuR0QEF7MIhjbNyhpKEB5RhwdmggcxAyljM7NDpgHCDQAMqBOXB7gJzy1FAoAHJSjOFAgEEQAQQAwMcyRToQk0kAAAAASUVORK5CYII=)}\n#webamp #playlist-button.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAICBAQWgBSa3Nje4R7jJyPn6itvca8iDuFAAAARElEQVQI12MQRAABBhQOo2soFDgDOeHlUFAK4sBkQsEcQcFQBlZWKEdILZQVmYOQEUsLZQ2FcYCAFSgH4rgjm2aIcAEAbLsb8tZoQy8AAAAASUVORK5CYII=)}\n#webamp #playlist-button.selected.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAA1gAICBBSa3Nje4R7jJyPn6itvcZs8alFAAAARElEQVQI12NgUoIDBQZUjmsoFDgDOeHlUFAK4sBkQsEcJaVQBlZWKEdRLJQVmYOQUUsLZQ2FcYCAFSgH4rgjm2aEcAEAZCcevKaFFFgAAAAASUVORK5CYII=)}\n#webamp #title-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACH1BMVEULFRIMDAwNDRQOFQsPDxcQEBkRERsTEh0TEx4TFB4UFBQUFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS8eHi8fHyIfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkGwkkIzckIzgkJDklJTolJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUAqKUEqKUIqKkEqKkMrK0QrLEQsIx8sK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEswMEwxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo7O1U+PlpAQF5CNhtDQ2BFQTxGQh9HR2RPTmdRPhtRUWxSSj1VVW9ZWXNaVzpbW2JdUCldXWdgYGpgYHliWkViYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBqe3trXUNra3xsbH5uboFuboZwcINwgY9xcYZzc4hzc4pzk5p0dIt1dYx4eIt6eo9+fo+AgJSBl42Gd02IiJeJlZqPj5+QkJCUlJ6VlaaZc0KdnaiggTSgoK+oqLOtrbivr7y2nFTBZ8mPAAAErElEQVQYGbXB36vfdR0H8Mfz/fl8p86Zx6Gz1YKDgaNp0vIiSLqoRLuokO66SGgJdtk/EARCXXZpEhjojVcKSoyUbroQssBdKKZWVjgkFZ24lut8P+9Xn885Z2uzHxc5H480u5rzYlssYluMFqlmtC0MdgypNESjEmIWxrTexGIgtErMGhmFWETrhkoJYldUROiDIi5UKapat6iUcwq9lU5ZlMJWbx2lt64wpQqdqa3LYnSfizUXi/MG/xIXiB2DXbFjtIhzYltzXnOB2BE7Wm92RKWEiverVMqit966bZUyKxfodnU7yq6yWFv8eOSHUkGINCFaNdH62FtiNhDsQZPWB4QWQ60kUhkEAyGG0ghDYjamhUFEjJU+EINZH2nSSusNYURVGkJUqPh3JWVWFBXrca0spkKnY6qU0rtSpjYpvfdSTK33VFdFaayndbdraEKoZtGmRCHdotlRDdHQatURSUfSO0KPLoYxqoyrUMVkVqZJs5hobbStF43EONJJQ4qqIN6vXCQ91rW2rbREb3qPiVKqKVImhSmEUqmuLPpoMfDwt0j1NKnr/E+l/P+OCjHYNURvNAyTc9aj3hK0J1xan9pbfmv2mXWttu5aj+vx0YmvPvcA9978mDYyTiOP3P/w3USkDhw75EPz6oOfJd/w+O0fefTo9b+484onvnz5ry8/+uxr7hxe/r2vOP3056721JGPM514e+SJY4dcSq8+eGue2W924pZa37XX7OuPqVOH7+Xwc9TIhEfu/wMGs4pNH55Ni9MbH/2IzY+9Xmb59Mv064d+8I/Fvo2rGDnxt9sO/8Zs0yW1if1HzZ7V1s/YUb7/g8OnNl584EtVI4PZbbd56E9sfkd40qV02sUS/rxxhEN7Xg+T2vcJ2g1nt/ZdecbZy252Zu+a6/aYYvakD+i0i1WOXrOHfxx9Y+0CW6c2TlEyMg18s+KhBz55zzHBjT5EJ1S8a+Pvw4H6Cwbv9Wux8e607/pXvHlw7zsrs2uveeuF3nCjS+tE6uAVh3j1yjdat6vz5uFTtzwlZUQfVMzuEYt3bvKhed7i9bOX/XXvgTN2nPh8c92wh4Ov8O7VJzeNvPCmsRHv3ORSel7Zv7+41oktD91t9tM7mvuufNFTh+99qRsZEXz7Z8cI3jh+3CV0xkVulVr11zbfeuvA2zVanPrdETec/lW+sG8vJ686uWnb2Jv42vHjPpgzLnJEPf3FET8vbv/lSWcvu6O6jed+wndvfqlJu+9HpMKQICQiGIOQRsgKzdDTiEbaynpMhEHErCXRVAsZKqGNU2tCBiGMRCqDBI3QYhZGKrEtFvHflFmlVHrM1orSh951FGuF6m1NVZkUfT1uKdapykSVStdfGc3ec04qFrEjZq1GizAkFiHNtoE0BA2JWVhNA03MBlKhEYu22lrF1ioWMWsEcYGQ0kipxKxiW6VSVUP1lFml7KhUl6pK2Vbp1kW3qCoKk1npqLUyq+89TvOfxAXGlsmipCaLmE3lnE4sUmVblRpoziuzErPWVlurmFaxCFqrUnbFLAkqeq9Oi0Wck0r03hKziB0pmbVU7KguK7sS2yazMqtaK7Oi9H8CJR/yJg+gKVcAAAAASUVORK5CYII=)}\n#webamp .selected #title-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACClBMVEUNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS8eHi8eHyUfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDklJTolJiwlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUAqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMEwxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo6QFU+Plo/QitDQ2BFQTxPTmdRUWxSSj1aVzpbW2JdXWdgYGpgYHliYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBrXUNra3xsbH5uboFuboZwcINxcYZzbFJzc4hzc4p0dIt1dYh1dYx4eIt6eo+Id0mIiJePj5+UlJ6VlaaZc0Kah12ckXWgoK+jlGqqurGtrbivr7yztri2nFS71tm/uX7AwcbE3+HJydDO4c7O4tHV1drj4+fsznrvvmbx8fP////AbX/CAAAEhklEQVQYGbXBz6tndR0H4Of1Oec2M7eud5ipKbHBKaJSoaZlJISrQhdCEEiQkPU/6J/gstYtgibazKJEFIpoEYm7omAsRFBRgi7OyPg1Z+R+z+fdOffHNNd+LPLO88ShuCX2xCL2xGCRakZ7wmDfkEpDNCohZmFI600sBkKrxCxkEGIRw2SslCAOREWEPijidpWiqnWLSjlU6K1MlEUprCuF0ltXmFKFTs9UFvGko+KouKX5l7hN7BsciH2DRRyKPc0tcZtmX+xLxb6mt67Rmw/qrbduUamUPZUy625TDnT7yoGymCx+PPJDqSBEmhCtmmh97C0xGwg20KT1AaFFq1EilVEwEGIojdASszEtNBExVvpADGZ9pEkrrTeEEVVpCFGh4t+VlFlRVKzHtbKYCp2OqVJK70rp6UrvvRQ91VNdFaUx9akcGJoQqlm0KVFIt2j2VUM0pMZCpHUkvSP06KINUWXcCFV0szJNmsVEa6M9vWgkxpFOGlJUBfFB5Yj0WNfantISvek9JkqppkjpClMIpVJdWfTRonHpu6R6mtTH/U+l/P++JMTgwBC90TBMDq1HvSVozzteXzhVPmP2yro2dh8z+3nnodUO57Z+rY0MfeDSM5ceJyL1iae23THXn/4y+bZfPLJ5+cHTzz1y8pffOPHi9gNXXvXN8W9/9LD3fvfVbb+6+EnWf7o68vxT247T9acv5t7B7HMv1/qxk2bf+Zla3b+12jr/EjXScekZs8Gs4ow754zFu6fv2fT5s1fLLBdfpd8z1ulWbG7fxcjLOw/e96LZGcfqDMZTI+sb2vpN+8rO1vkbp97YUTXSzB7kp1c5+33hBcepOyrh+un7+fTG1TCpzU/RLuzubm69a3fjK26eXLO9aTdmL/iQuqMqWydOcnO0ttoyW5mtbpzbWSkZ6Y3HK376e48+IbjPHfSsitfvPX1zOFt/xeD9fhbb/1hvfvbPrp07ef2E2Znp6l96w32O17Opc05xg9attljR2Tq1c2prJ2VERcXsUbF4+4I75jWLv+9uvP2Rszfs+8PX4u7xxAmn8c726oSRV18zNuLtC47Ta8qwiY9O2bUeV7ipOXf+jdXW+dUr3ciA4Hs/eYLgrcuO0zVHXJTa6G/dfc3Zd2q0uPbmeRfe+20e2vwYq7uufN2esTfx8GUf0jVHfFE9962Oy8WVB8yuVLf10o6d1ZYmnvwRqTAkCIkIxiCkETKiGXoa0UhG05AIo4hZS6KpFtIqoY1Ta0KaEEYilUGCRmgxCyOV2BOL+G/KrFIqPWZrRelD7zqKtUL1tqaqdEVfj7uKKVWZqFLp+uuj2fsOpWIR+2LWarAIQ2IR0uwZSEPQkJiFsTeamA2kQiMWGddjrMdYxGwgiNuElEZKJWYVeyqVqhqqp8wqZV+lulSvlD2VbirKoqooTGaloyZlVj/4Dc1/ErcZkm5RUpNFzKZyqBOLVNlTpRrNLWVWYpaM6zH6GItgGKqUAzFLgoreq9NiEYdSid5bYhaxLyWzIRX7qmR0ILFnMiuzqkmZFaX/E7gg7x1c8BJqAAAAAElFTkSuQmCC)}\n#webamp .llama #title-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACW1BMVEULFRIMDAwNDRQOFQsPDxcQEBkRERsTEh0TEx4TFB4UFBQUFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS0eHS8eHi8fHyIfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkGwkkIzckIzgkJDklJTclJTolJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsIx8sK0QsLEUtLD0tLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEswMEwwMUAxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2Nkk2Nk82NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OEw4OFk5OUc5OVo7O1U9P0w+PlpAQF5CNhtDQ1NDQ2BFQTxGQh9HR2RJSVlOTl9PTmdRPhtRUWxSSj1VVW9ZWXNaVzpbW2JdUCldXWdgYGpgYHliWkViYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBqe3trXUNra3xsbH5uboFuboZwcINwgY9xcYZzc31zc4hzc4pzk5p0dIt1dYh1dYx3d4F4eIt6eo9+fo+AgJSBl42EhI2Gd02IiJeJlZqPj5+QkJCUlJ6VlaaZc0KdnaiggTSgoK+lpauoqLOtrbivr7y2nFRq7ap0AAAHC0lEQVQYGQXBbayehVkA4Ou+n+ct7U7LaUGggOfs4FpwdKUZ/eDDoJjRLCtm0x9+TX9pTPxhkDDnTPzh/GGyRKPYGGPUmAwzk63JEhHIMkYmiFgOlYrYoptCoaOUMvpJ21PO+9631xUJkAAEECCAMILoNALBABiiIxGSjiAgmERWCjAQZEdAEqMgQMoydLRAAIQOIahBEwCgo+nOAh0NoFHZigKtsVpZaJWlMYtuFNNhtcFoPwAgAQABwACAAIAADAABGEEACCABSABIQACyEpAqS1IJAKCyskBlZQEdDQUABVCABmgwBV8e+ZLoQBAiBSE7hayxMgIGAlchRdaAIMPQExGychAYCMKalgRDJIyRwSCENHbUQBigRlJkG6cjghHdkUhSJZUAAChZUDQdpuNUg9VGUZh1tFaltFnOtKpqxSyroktPacl0Ni2AIQVBJ8hZhEYUSEAnQiJ7UkgZhYgqBBVKGMZQZZwE3cygzGYSzMgcgWpGIowjRSSyqEokAIACAKLCtKfATEaoVBVmtNapiDbTmAVJ6+jSoEYw8NQ+oitS9PUAAGCFHAARQAZk6EohQAaMXSGApMRYGQyCNAAMoZLEZBXAdFQZgRoBUAkAKlPJIkuWrsRk2hE96y5NlnwGAPdmtRdgz7Qnq59fnaxO/n7GLxzaz0O7HpMj42zkO1956kFCiL7h4SUAABx7dEX/ye9+4av7fvI/f2w9nvu6+M1tXHn+nx7F0cd2/5xv/etn7j36Db4494d+a+O/PfeFD/427Nj7/lcfvvR3v3b87D2vffdX1v/1/VtfvGYrqy++fvuOyeor3+/Kz85hedvcNz6655glPEH+9Nw/jq7ffexIyltunT7t40sOrt7n+FF7Np1Z9unjR29bzIuvnsH06vv8y7lY3DZOj7yxeftcvXX45j3HTu1Z3vPGQU8/vATg2KN3i+evheVdPf38Bvilr+mzOx5ixyF6ZIbvfOV/MECHLQAAsAW/s/YXP3Yrvth/9cGXZDTP/vsje77lwh/htum4+Dw6gjEP/PrOm/IQXrn/6nty/cL6swDw4vm9n3h95/TpHz2jRo/75YtP2ibA8okRMwYwlrqxxk3nBrZeAvM1z0XzSxeWF85BLlQunO/t9cyNP7Rt7oVxOjvv1KXpdIW2BYAtcO1d8KKcPgtoD/3ZjrMbX9n/QPfIAHv3evJ/2fKzgm/CBQAA0keuWrMFlaCCXbu809b9/utf71uOL9wSCI1677/u+OhrLyfeWbyVnV6+05aFjwhwzaCY7L1y8f0ENPsGuGPb00YIgDUbji9sXWZlfv7CBjbn8YXNJz88Om/Dpy6cPoPafGbT5iNh/NTK6nnunf7g3QtMTx/fflD4JlwA5Czuun4dl+86NQWAK2c3nqXFyGxgb4cn//i2Rz4ncAcAAHiJPx09lr9KBD10hD625cpfTlx59d26a93lyxt+AqB6fGLruseHGuS7i9e+tbh4FleOb0lgcXbiiIPb567a+b0kiw7em1+Lk6eMKqmEkgtO3jyfMyeXvLOBxZXLFk8u17lXtsxt2PZCcfXak2vnrj69vG1u7fbXl+/cMC6dOHHh/OnveoJyBwBequhb1i1x7OpTWQDFiR1n73xTtBE16IBHBDjzSQAAHDaZDWShEZWIH2666adewA2fuW66MFo864ZP+zYPuHioqKR+sNvb1699Jzj13MIE+I+jgxt//LXv//xYkgQO37wH3Hz+cjebrTD/I07fOL29xvnB8aWVc5j/8OaaJ+cXX3afUhbqusHCh7f999s/kz527p/v3+SG98eG6eDMJwEc1lxzXXGdWPU3vwF/8WDaP/eKN3c8dKSMjAh89vHPETh14AAuAQCsWBNUYoCsAZM3b/rEC+budWH83j/48i2HXXuPb3OP15YxzAb5xgfrD238+OnmCgCDOLm6a/fqwRGVALC05KXLWex27D2bdntmw8Fz83dvveTSynvY7Fm3L2w+6eJ4n4vLpM1vHakHN78627l7uuzSrUt19MTi0imK9MCBA7gE3N36mX0THGj2PfW2K1c92GXjoT/nt3cdSZH7f4/oYIhAECEExkAQSRBrkIaKJCSRE9MxQjIIARkxSp1BDB1JjrNMQQyCZCRExyACSZADBCMdASRIAAAABZWlowKmmpmaTEuhmWp05ZTqNtPUdFxVTKM7ZvRUR6n/G2EFQHSAAARkjyAYIkAQCQxEIpCIgGDNdCQFDEQHSYCcrE7C6iRAQhIIAAiiJdE6AjqAjo7uHrqioaMBHV2iu7KAjjJtCnQ3jRm0Qq9q6D/4GgkAAAIAxowZaNEzEDBrAEWA6Aa69UgC0NACMierkzCbBEhkdmuAgIhAh6ouMkAAiI5QlREQAhAtIiKzEtAlJgARwAwaulc1NK3+HwQZGF3RS6s/AAAAAElFTkSuQmCC)}\n#webamp .llama.selected #title-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACSVBMVEUNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS0eHS8eHi8eHyUfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDklJTolJiwlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLD0tLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMEwxMUIxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2Nk82NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo6QFU7O1U9P0w+Plo/QitAQF5DQ1NDQ2BFQTxHR2RJSVlOTl9RUWxSSj1VVW9ZWXNaVzpbW2JdXWdgYGpgYHliYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBrXUNra3xsbH5uboFuboZub3pwcINxcYZzbFJzc4hzc4p0dIt1dYh1dYx4eIt6eo9+fo9/f4eEhI2Id0mIiJePj5+UlJ6VlaaZc0Kah12ckXWdnaigoK+jlGqoqLOqurGtrbivr7yztri2nFS71tm/uX7AwcbE3+HJydDO4c7O4tHV1drj4+fsznrvvmbx8fP///8QuCFEAAAG4ElEQVQYGQXBX6zfd10H4Of1+X4POz3lrH/P2rMOGZaWdmsZnSsbatIRCDDcILuQG5ULQgzqhQazGBK4UOO8wMSLOWMEEzOiNwN2wUw7WTJnWUdTks7NgFA3LHQ9dadlbc5a253v7/P2eQIgAAQICBADSDUjEAbAkEpDNCohEMa03gQMhFYJhAxCQAwzY6UEAYiKCH1QBABUiqrWQaUAFHorMwqUwlQplN66wixV6MzaVCAeBQAEABAAGgACAAEMAAEMIAACDAAEABoggFQATW9dozcAAL311kGlUkCloANAAcwABVBgBv5q5E+lghBpQrRqovWxtwQGgnegSesDQotWo0Qqo2AgxDtKI7Q0GNNCE9GMlT4QA/SRJq0MswFhRFUaQlSoAACgpKAoKqZxUmAqdDpmlVJ615WervTeS6eneqqridKY9VkBDE0I1UCbJQrpoAGqIRpSYyHSOpLeEXp00Ybo3TgXqujQzWYamNHaCPRiIDGOdNKQoioIAIACANJjqgnoWqI3vceMUqrppHSFWWiUSnUF+ggaxz5BqqdJLQEAgBu0BkiAFkiUiIAWGKtHgEaXsbfQhGYAGKI3GsYJwDTqLUEfAFABAJUoKVJSqjfMTZVUr+qK1rXnAfDB1sv74IdTza1/AR7vPLh2lncvflMbGfrAsSeOPUBE6pavbgYAwOVHbqjH/vAvvvHrv3Zu6wJe+IZ86Tamf3/qMZz764983DP/9un7zv0dX57/ii/efPLZP7n2eBz+yOW/f+TG3/7+pfOHX//W5+cf//SuU7fuYjpx5sO/NE4/+1719pvzOL1//p/3HVqxjKdoD8x/c/TeAysnI3ffNv2LDy578e0jVk45sunK8z61curwzlw//Qb6liOeu5xD7xqnn//gtkPzdeH4/oMrFw6dPrTyrOe+uhnA5UfukT1zcMd/1vSFefiDx9TaBxbXFne/RI10HHsCBqjYBgAA2/Doht++5QD+qL527YtaihP/8Xv3fce1r+DOyp3PoRLGdvQzv/LLwymcOvLO+zO/d/48AJxa/eQ9Z94zO3bgJ/roSb9z/dv2ywiv/NeIGQNopbbWeMsq9qyDm+tmrltavnZi3ypkb2Xfybp99q93nHHX/IvvfKuvHLxwebq+TtkGwDaY3zAy/Z82vQYoZxd3X9346llVIw0e4OgqS58SvgsTAADN3E3jZvQGejh82JWy4c9XH68dF7fvCKLQf3z29qXXTwZvLu3lXid+1Y7fvUnArVu8zfiJ9bdXG6B4eIB9e75jhABsXFhZ3vMG65tdW+BgVpYPvnLj1JKFj15begO1/dK27WL82Pr6KT40rf78MuuXX7vrWfFdmABtlsX5jVwdTdYWYQ3Wru68sKZkpDceqDh61GcfEtwNAACe5MuDf2ifI6GGSvjfndOjo+nlK7OPzd24MX8/QK/xiS/N/WOraBeXNq8uLV3DdGnHCNwyu/gDx+/ZMPee443WqfDmwiZcvGjUG71ByT6Xdm4OF5ddWGDr+sxWz9fqT5fnF+56ttgyt35jfsvq9+/aMHf7qe/du3FcftfZa6sXn/EtursB8GRP3WojN9G6tUXW6CxuvLBxUcqIigp8VsDqHgAAnDH2RusopDf42cLWB49h02/sre2DO89ZeMjTfNJbL87mVOiv7vfTzXNvhktPfX4EXjo92PX+H7/8W0PXaMDxPYfA/vNXq9jrEgu7vbZ1eu9sXOIny+uXb+PmaXvdTJa2nnREKXtry2DvjTte+9HDg4PXnvn4JjuuzBVMg9U9AM4o5hawOMu66/NruKx59+5X1xZ3r/2oGxkQPPj0QwSrX4dfAADcMBd6wwCtD7Cy9f3HzN3n+vD63/jLHedsvdfT3Ov1F9B6tB9+dP6FXbv+uwDAIOenDxyajo/oDTDC8jJnWueAlUs2bXJh4cXVpQ/tWXdl/SIOOurw8sFXXJ074voJYvuFk/3h7W+t33lg+r7Zzs/UubPvW75wXqe5/+vwC+CeUv/0uY6vFacPwcvVLb50lrVFTTz6Z6TCkCAkIhiDkEbIHJqhpxGNZDQbEmEUgZaMmmohrdJo46w1IU1ojEQqgwSN0BqEkUqAgAAAACiolEoPTIquj7Ouo5gUqreJXqUr+jSu68xSlRk1qXT9f0a4ASAVEECg1QDCkICQBgykIWhIIMzNBprAQCo0AjJOY0xjQGAgCACElEZKJVABKpWqGqqnoFKASnWpXimg0s2KAlVFYQaloyYF9cffpgEAgADAkHRQUjMQmBWATkCqgCo10AAoKIFknMboY0AwDFUKIJAEFb1XpwUEQCrRe0sgAkhJkiEVQJWMAAkwg4KqSUFR+v8DYP8M63Qn0TQAAAAASUVORK5CYII=)}\n#webamp .selected #title-bar #option.clicked {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAHlBMVEUUFB8VFSAVFSIVFiEWFSAWFiEWFiI0MCyah13sznoaG8L5AAAAPElEQVQI12NgYBAUCmBgmCCoaMDAWSmoZMAwvVIwNIBhRueMjgkMAoLTKwMYGAWnz0xgEBT0DAWxXdMSACxMDDJsyBoOAAAAAElFTkSuQmCC)}\n#webamp .selected #title-bar #option:active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEUhKDU0MCyah12jlGrsznoe/O3VAAAAMklEQVQI12MwBgIDBgMHBgYDBhMRASDpKCIIJJ1UnJQcGAwEHUWAsoyOLkCSgQWIweoBtzQG0TH1VqcAAAAASUVORK5CYII=)}\n#webamp .selected #title-bar #option.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEUhKDU0MCyah12jlGrsznoe/O3VAAAAMklEQVQI12MwBgIDBgMHBgYDBhMRASDpKCIIJJ1UnJQcGAwEHUWAsoyOLkCSgQWIweoBtzQG0TH1VqcAAAAASUVORK5CYII=)}\n#webamp .selected #title-bar #minimize.clicked {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAMAAADXT/YiAAAASFBMVEUqKUIqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkcuLUhFQTxSSj1aVzpoWTVrXUNzbFKId0mckXWqurG71tm/uX7AwcbE3+HO4c5KSa+JAAAAPElEQVQIHQXBwQHAMAjEMJvQfLv/lJ0ArpK3FsLQZxogW9uqXjqlkKQphYTmcGBI4wPU6OVd4FtvYEzyA+cLGDTjuSw1AAAAAElFTkSuQmCC)}\n#webamp .selected #title-bar #minimize.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAIVBMVEVFQTxSSj1aVzpoWTVrXUNzbFKId0mRbkqckXWjlGq/uX4Hs2WWAAAAOUlEQVQI12OYCQQTGKYzMLBPYJggKCgwgWGSiYvRBIYpYWkhExhmdK3qAJKrVq0AqunoaJ/AAFYPAAQVFS+2qihdAAAAAElFTkSuQmCC)}\n#webamp .selected #title-bar #shade.clicked {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAMFBMVEUtLUgtLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMExFQTxSSj1rXUOqurHO4c6W/ePHAAAAQUlEQVQIHQE2AMn/AKqHZlVQAJnu7uUQAK7///4wAK3d3d0wAKzd3dwwAJzN3cwwAJvMzMNAAIi7u7MgAIZlVTAwDDgbUKzozR4AAAAASUVORK5CYII=)}\n#webamp .selected #title-bar #shade.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVFQTxSSj1rXUOjlGq/uX5Idn/CAAAAM0lEQVQIHQXBwRGAIAwAsLT07Z2zsP8qbuDBAliTmDjl1m8Gob6HK5uWti27V6uxDDFxfn1PDx8P0VYSAAAAAElFTkSuQmCC)}\n#webamp .selected #title-bar #close.clicked {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAALVBMVEUoJz4oKD8pKUAqKUEqKUIqKkMrK0Q0MCxoWTVrXUORbkqjlGq0h2PCsWH///9ex0i3AAAAO0lEQVQI12NIdTFWUmDIbC/vFGCIONm5Q4AhfPbq6UCy61U7A4P77LVAdsTOzhsMDJ5ANQwMLkaKCgwA5wURVkMAFf0AAAAASUVORK5CYII=)}\n#webamp .selected #title-bar #close.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEU0MCxoWTVrXUORbkqjlGr///+HjTObAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}\n#webamp #clutter-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAArBAMAAAC3GdQgAAAAElBMVEUAAAAAAAgQECEYGCkzPElgYGraVCJcAAAAVElEQVQI132NsQ2AQAwDr8gCv0FGMNLTu8gKv/8qFCAgQqI7WWebbYyBACQJEUbyRDgaTf95Va3xeGWkKUTQqPz12m9eyyYB8s7eVEUSJs8VIPe1DmVJGRTmaMgdAAAAAElFTkSuQmCC)}\n#webamp #clutter-bar.disabled {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAArBAMAAAC3GdQgAAAAD1BMVEUAAAAAAAgQECEYGClgYGoHCnLLAAAAIklEQVQI12MwFBQUZDBgAAIDIBhULAVUlgJhFlivgomLCwA8qROh1kJ8awAAAABJRU5ErkJggg==)}\n#webamp #button-o:active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAGUlEQVQI12Nw0GBwaWNwaIKRGQwODAwuLgA+SAT1jbNsAAAAAABJRU5ErkJggg==)}\n#webamp #button-0.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAGUlEQVQI12Nw0GBwaWNwaIKRGQwODAwuLgA+SAT1jbNsAAAAAABJRU5ErkJggg==)}\n#webamp #button-a:active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAGElEQVQI12Nw0GBwaWNwaGJwWQUmgWwGADIVBK9/og4OAAAAAElFTkSuQmCC)}\n#webamp #button-a.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAGElEQVQI12Nw0GBwaWNwaGJwWQUmgWwGADIVBK9/og4OAAAAAElFTkSuQmCC)}\n#webamp #button-i:active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAF0lEQVQI12NwcWFwWMHgksLgoAAjVwAALckEbUwsrjEAAAAASUVORK5CYII=)}\n#webamp #button-i.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAF0lEQVQI12NwcWFwWMHgksLgoAAjVwAALckEbUwsrjEAAAAASUVORK5CYII=)}\n#webamp #button-d:active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAADFBMVEUAAAAQECEYGClwgY/lGZUOAAAAHElEQVQI12NoYGDo6GBo+MPQcZqh4TCIdACSfwBnkgl9KMHv2wAAAABJRU5ErkJggg==)}\n#webamp #button-d.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAADFBMVEUAAAAQECEYGClwgY/lGZUOAAAAHElEQVQI12NoYGDo6GBo+MPQcZqh4TCIdACSfwBnkgl9KMHv2wAAAABJRU5ErkJggg==)}\n#webamp #button-v:active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAADFBMVEUAAAAQECEYGClwgY/lGZUOAAAAF0lEQVQI12NwYGDwOM3gcBhG/mdwsAEAPG8GMJvxEOEAAAAASUVORK5CYII=)}\n#webamp #button-v.selected {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAADFBMVEUAAAAQECEYGClwgY/lGZUOAAAAF0lEQVQI12NwYGDwOM3gcBhG/mdwsAEAPG8GMJvxEOEAAAAASUVORK5CYII=)}\n#webamp .shade #title-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACJVBMVEUAAAAA+AAKDRYKDhYLFRIMDAwNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicZGigaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS0eHS8eHi8fHyIfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkGwkkIzckIzgkJDklJTclJTolJjIlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKjUpKkEqKUEqKUIqKjoqKkEqKkMrKzwrK0QrLEQsIx8sK0QsLDssLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEswMEwwMUAxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N0Q3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo9P0xCNhtDQ1NFQTxGQh9JSVlOTl9RPhtSSj1YWGJaVzpbW2JdUCldXWdgYGpiWkViYm5kZHJmZnVoWTVpaHdqanpqe3trXUNra3xsbH5uboFub3pwcINwgY9xcYZzc31zc4hzc4pzk5p0dIt1ZDd1dYx3d4F/f4eBl42EhI2Gd02IiJeQkJCUlJ6Zc0KdnaiggTSlpau2nFTZBQIoAAAFhklEQVQYGQXBQailB3kG4Of9/v9MohPDTUZT4umU5FKjNaIEtHGCu65asgpYq4LaKhZ0YaQFaUGDLS6C1KYbEUWwi0gWBbvIpnRlETS4CFaNGMW2CZc2QydzqUkmzTn/9/k8uQAQAAIEBIgFZMoOCAtgzaQQxSQEwi7VJWAh1CRQZBUCyrJZJyMIQExE6MUQADAZZqrBZAAMusZGgzE4dDVGVxtsmUFzXA4DVo8CAAoAEAAKAAGAAAoggAUEQIACoACgAAFUF6B0taILAEBXV4OurgYmAw0ADdCAARiwgS+vfEEmCJFFiJoSy7brSmAhuAkl1QtCxTI7iepaBQshLrSFYqnAmgqLiLJOeiEW6JWSGtWFYsVMCiEmTAAAMDIwDBPH9ajBNmga22SMbm1stRndPYZj9Va9mY1RbL0NwLoIYQosx8QgDQowhSjU7BqlqpF0I2xlU5ZdmbHuwgwbtG1TYKNqBXooqqwrTQoZZoIAABgAIB3HPgKjEl26Y2OMKU3GZrCFMKZ6M6BXUHz7Q2S2KhkyXdiW6hIKoRZAAlRuAIBnAAAAAABvB54BAABgAm+H94OTc06cc+IccOI8J65n3AYvmkuucecLXdUzw1BPATM4NJ/6/vgevPc4u8PT8M6NP3z2MR6+5ztqZemFJ7717Q8TkcnX/fnf3f6Jv/ydz/zD6z/52M2Pv+O+p79ZX1l/+g1f8fLf/MUd/urPfpfjj78jbnxyDwAPAQAAAAC+CDwEAAAA8EWcff39wv76bXtnnOxxDif7Yl+uu20PrsV+f3Zt/0I1ybufGrA3cECD/Nsl+MHvz/HpB+/D396rf336MKfPMkXjiW/9DOu6MPE/u/fc7tN3PYdSD8GfrH0XXHzfG1n40TfWe2oZLldVVVVVVRUAAAAAQFVVVQEAIAGAqqrLmBm37QtU7fcnbwEAVBVB7S/RmHfX/QnNAABcunLlypUrl9Q8CB7UPvfy6R2nv3rMzErBAw94/Hku/6nw4uUHObn5BqIvnuDNrx0u7v/baxf+wKs3D7c84P91+C4AAAAAAAD4Lvg1AAAGADwJEPYFUPbe8gsAAAS1p5r3lLr/BxoZHJZNg8mVkwu8duXqkftfAzi+dMtLjKx08cGJx7/6ex/5mOCJd11+pe4+fnWhvDp3s/z2i69c/KNveu709Vdvhcv9/L9OwikAAAAAAAA4BQAAEAOAd8FTYjjbF6CdvekXAGQAjuizveZOjcvPg4xDNqoh81s37Tl73dVqLvAUG9dOX3rrVRkrJibwEQEvvHrzczfd/X+Ar322fGC95RZ34X/vuHqriZ/9UxS89FYAAAAAAADYAwAAGACwx88B5/ZMtDPn5wAYNFjosxf24AyAwe6Arrb1uPX25pJ/P3jyfnjy3sWjr/uVq6cP/6StLAg++o8fIzD/+bYbN1xdgP945h3e/PJf50sX7+TqGx9/RCGqFy7+MwAoAAAIAACPglcAAAAAPAJ/PCPOnJ+fiHPOwZxzjutcB9e2cnbt6KyxL+j/4uOgAbT54ft2+Jfhvs/Dvb15w7N/z2fv+UnJhUcfIRPWBCERwS4IKUIuoCydIorUznFNFKsIVLJY9FJk7Qq1blVCFqFYiUwWCYpQgWJlEiAgAAAABiZj0oGjZvTSrTEcDabrSM/YDH1cD4ZDpuvAbCatf1lgYDtuAyYYFkNIBAoFISLhYBfKusIolaBbNVSGnqpgqQFWISwxTWGqGsqKbloTSDAAAMwMYGzp7qPjUSNyPGoMx0XM6CNteoPmAJZpTW9GQy4QADKBAASLUSDJ7CDIVGAlSqDSKkB2oQgsEJJA2R12sS0BhcWIEMggQIaIAAATk+lMmQEGMEbG1tVgbLUtBw1MM2wwtHEwMGbSvwGhZ2YZd3bCBAAAAABJRU5ErkJggg==)}\n#webamp .shade.selected #title-bar {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACFlBMVEUAAAAA+AAKDRYNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicZGigaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS0eHS8eHi8eHyUfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDgkIzckIzgkJDklJTolJiwlJjIlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKkEqKUEqKUIqKjoqKkEqKkMrK0QrLEQsK0QsLDssLEUtLD0tLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0EvL0ovMEswL0swMEswMEwxMUIxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N0Q3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OUc5OVo9P0w/QitFQTxJSVlOTl9SSj1YWGJaVzpbW2JdXWdgYGpiYm5kZHJmZnVoWTVpaHdqanprXUNra3xsbH5uboFwcINxcYZzbFJzc4hzc4pzk5p0dIt1dYx3d4GBl42EhI2Id0mIiJeUlJ6Zc0Kah12ckXWjlGqlpauqurGztri2nFS71tm/uX7AwcbE3+HO4c7V1drj4+fsznrvvmbx8fP////Kv08RAAAFRklEQVRIx+2XTYiVVRjHf89z3jszXq4zmJozvpJhfoQp4a5NIrRwEYFIi4hUKsIW0aKdGISISZCLBDcRuFCIVm4icpXtohoilEEFwcXc8UrkoNnVYd7zPC3Oee/MnQ8cXHcY5p6P55z3Of/n638kkJvAgq70D5KkuNLorde7C3FRQFBwkbxNoBA1zYcEEFCXelEUmftOUdFwcWS+NoILgoAFvE9NwMXBXW1uVK8Apk6VuuA4EJOMY2ppQtwBg6hVkiw4QX+T5ceynFg90KUnZGm0F5+jC7ebzoPGEfCF+oFLDYapZXhqfKxPcGFnwUQSPlfA54hn0wgS0q+6IoTYME1WTTZmAFBELaQdKqgHRBCXBtKTFBpWO4Zq8iVVUARBKVws9NzPinSsZxgUCsBr70MxhR5E85uRcPD0J1RFla8XswtY7SGOGYZjYhhm5hhEcROPuIGjEC328CoyJHj6eqhEcECsz5DeCxTEg5PgNEDELF0jKhFBC8WMoiFgWT+MGPNhEVSLfD0HBVWKAgwSJA5WQ7UIkH6nNqGyqja+imCKmRBT9LhiII4loAQUHBePtbcU9VUvvgPiURVxEDcFYsjJoLZWz5WzB6s86tPpBitrO1YovgPgAACjHRil/pem6OgoU2psBGjjm5iELbdN1dyT4+hvGSHPjnNk3NkCcLPyxuxugD8MXuvehQ3NH9ACggW4ePniIRAEcfmao2dbH5wa/vjs0NGvBn8devnPb/RM0fmCMzw8eXyYY5+sg+rqJYRHx1rz73BwhZicWqH4KeDh6QMolFMbS9owWkJCZbQMUAam2FgCMCmUZXuyvK0GIq9eSYYfS95U9fKGPB8Atl/3andYP8yDPeN494Vmtzl2Czy5KBcvp4QLuNAdPtziozXTKXe8dAs4UngLoPXmaghw7dpb21RcGOFpWlh2ReYSX5YbySGysQwxzfVQ6ROMiEMos7jvDfuu4HU66WuNwQBxBq0CwzD8F87d5tjM4J27uBc5SF+BC/dh5H0EJnfugU2NO0nF1iZg8+xMa9cEs43dPB5yGB3AMIHxp8JkvD/tL1UbAPh9XkUqwxwA5SJQevUqlKAGewNh308YaUiViy+4NAdWwaNABTtn6s3dmWfudXGkSMn8kAsXfmH/ewjw/c7hx2GtnwugzFRrIYx0Z1uvTzC9fujBAMBI6++fXQS2PhUmW1foJ9tqRAzaPVAi7fmQaM8PKiC2Swy2EIHtN2uJSlJuBcTXMQiNtHMQJiBCc/DeYBPxVPEkV/39mRjcmG08CGv/zR+68KFwuBgYoAX8M9x5Docb36Wqw/3yaTBpLbvii+Taud+hBNOFiORK24ug9u2kUbtfoKgyaYnuhEFgVZRZ4vQapokENozd6TbHuhNGkWJWgHfPv5fZkk8/e4e13WyWiRsvsvnhp3KytQs6q89/lquQWoDmtyxFup7UvgRg+olyxwEOmqG06XRGUTp12FjuTcFUSrFRaU9WtI060uJ1eHsB1o7/+IYBlxyuMgmMe6R56y50mygSTpwmkbZCauaWyTQN6VFwBKQBKMHSWEEkYCqCQCNvQkWUgAUBCaYKWkRVtCbziZEJ4hJSWdeaAPb4mksf510ebKtZq4tJCiADx4IlDuJQ4YCbVmCeyYlVxSwGlbhLBW64GHZb50CMVaxzUJqq3xdSX7bWTXLVFoiERFobmSWReK9ZDl5VA/PEZbV+kBSZGgbBLZ3qmvKCUlCzO8uQqLJE9QAz6xk/iplVVInDCpJ7DlVAcMcqMNwzbWQ2we2Og1kqUiD/vwEXvQH/A3+xY8OlLccKAAAAAElFTkSuQmCC)}\n#webamp .shade.selected #title-bar #shade {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAMAAADXT/YiAAAAM1BMVEUtLUgtLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMExFQTxSSj1zk5qBl42qurHO4c7FV37rAAAAOklEQVQIHQXBwQ2EQAwEMCdEPK7/YhFiM2fXzybCxAXvN1VVbe9tpenSDDCh+GhZVmpyHDwZu2HP9QfI+BkLtDdVPQAAAABJRU5ErkJggg==)}\n#webamp .shade #title-bar #shade.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVFQTxSSj2jlGq/uX7CsWH/Y2uiAAAALUlEQVQI12NQAgIFBiUGBiYFBgVhYwMFBkVhY0Mg6QwmXVwEgeIuLgIwNWD1AJzCBeFqt4OOAAAAAElFTkSuQmCC)}\n#webamp .shade #position {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAHAgMAAACTjE7vAAAADFBMVEUAABAwMEsxMUJaa3u9OGBkAAAAIklEQVQI12NgAIIDDFqrVq06wCAaBiZDQ8PAZCiM/A8EBwAZeBBhq+F40QAAAABJRU5ErkJggg==)}\n#webamp .shade #position::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}\n#webamp .shade #position::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}\n#webamp .shade #position.left::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}\n#webamp .shade #position.left::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}\n#webamp .shade #position.right::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}\n#webamp .shade #position.right::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}\n#webamp #volume {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAAGkCAMAAAC//nO2AAAC5VBMVEUVFSEVFSIVgAoWFiMXFyQYFyUYGCUYGCYYkgsZGSgZdhAcHC0cbBQchRIeHi8fHzEfMh0fVR0omRwpKUArYyIsLEYujhYunBIvfhsvgRswSD4xMUoxMU0yMk8zM1AzM1IzNFEzNh80M1E0M1I0NFE0NFM0shU1NVQ1NlQ2NVM2NVQ2NlU3Ihw3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFk5OVo5bSw6OltAUkRCtiZHhidKSmhMlSVOeC9PpCNQT2lQUkRRmyxTO0BTU29WqypXjEFauihcmyxcwCphoCxixDFkritlvjdpdy9p2jBquCtrwCpsa4FtoCxvRB9woEtw1T5xcYlyxypz3D50xzF1TSd3iDd3oDF3tCt30zB4bi14eIx6IiN62jB7OCd7fI98e498fI59Vyp9fJB9fZJ+fpJ/f5R/1T6BxyqB4jCC3D6EtDGEwF6FnDGGYzmIoDGJQyyJYjGJrVqKxDCK4z6LfjiLjkiLmCyMpI2NmiyOWxeOjqGOmyyQxzGSRz2SVj+SkqSS4jCUyjiWlqiXXCGXaECaaSma4z6bXSGbfiebjSybw2Gb2jmdryydsJOeYhKeayafFhufKhufMzefPiGfSSGfVyGfbCefgSefkCyfmyyhok6j4Tik20Wk4jimxzGndkip40atrZKuV0auag2uwCqvlI6wYh+yERayKBayRx6ydiWynCqyriuywF+yxDG1hVK3RUy94ji/bRu/dRC/uyq/0zDB40bCcFTClFnCsV3Cv17DciPD1T7FDBLFJxLFQxvFURvFZRvFgCPFnCPFsSrFwCrF2TDGeA/G2jDIxdPI2z7JVyLJgSDJhSnJoCnJtDHJxDHJ3D7ZSh7ZWh7Zbx7ZfB/ZjifZlDfZrCfZsTfZwzDZxj7Z1DfbhC/fsSjgDhXgLBXgTB7gXB7gch7gkijgsijgyTDg2jDhHybhPCbhWC7hZy7hfC7hmTfhtjfhzD7h3D7eIOpxAAAEo0lEQVR42u3WeVRUZRjH8VuKpWZFkpjlWLN0uTMNMNOdycwpM0ZLIyjHSkoJyLBSMdvITGk1pVRMyzZTw4JSEVNLbVMgqCw1l9RcyfZ9/bv3vfd971jgP7/6o3Pe58vM4cA585z3zn3mc0brzXK5vW6Px+Pz+XRd9+sBqyArK5SZFQ6HTf4TMc2I9Wyb1tvFZrjPtIYYPsPQ9YAYw6dkhsLhbDaCT7Fqb4apuVwuNkIcxDAMvzOCTwkF2QxW5GgD7JOc2rWDdkyHZB3tUjqm8Dp1sn6lHNdunU/s7j6PD+l6cuoJeKm9LmBvltY5tcuxeF2iV7Or1E5K63Y8Xrf4w/wk3XtFT8GL31fB35MzXBddecNNN44eM3oM72b2sLpFdit7HK2KRysu4UPYHXa7vR6PwW+wnhEIOKsWCgbP5fdXLAi/w6b1+NuOWLfY5XZ5PV6PwRctQw9k+JP7aq2JvbDmES822y5bH34Sj4+tq274dT+fERTbmsU2LVtMiVhz2iyc/V+NrbzXWlfDxy7GWlf7FMGsYMi+Gv785xUc8YcZYUO87j585X3sJH75jvBB2eHM7HDyU2O2cyHiMNrpm/99GlHQHgVpPU9D65kmKEjrkY7XI2ZTEE0/Gy9dUtDvfLwEUUAUKExBtB9etK9NQbT/hXj94zYFsZxBeDkJm4K+8cvxiAKiQGkKLsaLCQrYp/hStEE5goL4kCvwhkgKEsOvRRt+2xNEAVGgLgWxwXgOBUPz8tHyhkoKRowqRhs14m5JwdgytLFEAVGgNgWXoSUpyMu/Bi0/LyEpKB6PVpykoOwetDKigChQmIKzYlfhORSMHIc3UlJQ/gheuUNB1WNoVbOJAqJAZQqux8sVFOROKH8ArXyCoOC6aVWLXsRaVDVNUDAgsfgltMVEAVFAFBAFRAFRoDgFuRPvQJuYO0BQMKcab869goLq1/GqJQUL38R77WWigChQmILJU+7HmjI5ScEreA4Fq9Zv+hhr0/pVCyUFG7d8irVlI1FAFBAFRAFRQBQQBUQBUUAUEAVEAVFAFBAFjILCF/AKBQWFK9d9iLZupaBg0s7WH9BadzoUtP6J1vouUUAUqEzBrAVosxwK6j/Aq5cU7Dj4PdrBHQ4Fh/5AO/QOUUAUEAVEAVFAFBAFRAFRQBQoT0HpzOfRZiYpeB+vfpKgYPv+w99hHd6/XVKw4MDvaAeIAqJAYQrOKaic9xzWvMrSgTYFpSta8FbMsCm4a9veb9H2blttUzBwyb7f0Pa9/SpRQBQQBUQBUUAUKE3BsOmPo00vEBQULH0Db6mgoHTDZ3gblggKZnyOt5ooIApUpmAqnqRg2NxavLm3Cwpq136EtrZWUlDZ8glaC1FAFChNwbN4yW8FzXjOt4LmPd+g7Wl2vhX8ikcUEAUqU1DyDF6JoKCk7j28uodsCu7cuvtrtN1bJQU1v+C9RRQQBSpT8DRekoImvLoHBQVNu75C29VUIyn4GY8oIApUpqDoKbwiQUHR8ka85YKCksYv8RolBfN/wqshCogClSl4Es+hYFkD3rL5NgVFDV/gNayRFPyIt4Yo+P9T8B9IsPkvQxJ1ta+jwcEAAAAASUVORK5CYII=)}\n#webamp #volume input::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}\n#webamp #volume input::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}\n#webamp #volume input:active::-webkit-slider-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}\n#webamp #volume input:active::-moz-range-thumb {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}\n#webamp .gen-window .gen-top {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUAgMAAAAFGX4uAAAACVBMVEUeHi8rK0Rra3zjkZV/AAAAG0lEQVQI12NggIJVYNDAEAoGDlSj0QGx9kABAFXxKF3wQT+3AAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-top-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAB4ElEQVRIS61Vu04DMRDc3WuQqEBIVKlAQkKioEZU1PkVpHzhXZX8RUCiTpUjojs04/XrcjyUxFF09p3t8c7OjnU2exikaiqqmt6wryY6iLCrxg5+aGp4Wh77WszjDMwFyHw+r2GwEb9jmm+GycXmEYhgFjaM8/fWRZCuXYaj8kweTbExI4gbqYpxnIFThFxj+UBlJG27DFQ4DE9anb4Y+yYJhNSoqMWD/ATSrSIxKZJtv67TdeAo5SREoqJD4Ljv1/LydCO3s7MDt87LEsg4J/3nmywWr0cDkP6U+G4l0LKnXQByeXF+YhCoC1lxmQIEdJ2iTdAlzEu/e5f7u2t5frw6GqcG8QrFA3Ww+/o4GqDOCeny5iqD7vkP9ZzrZqJOyDTs5bdipLpEZNtv9guSi8MBcuXnwvMP2SmSE4y8awwyrnzaSGmMlc2MDTLazR8gMM1sM7Rb5im4cuHCUZFuQdlQs9ftJT7SBZCOVuNUaSNmOGEjhnfsF5R5Tho1GSpjLax+TBdB2pWXTsPUmzXBYV0M6JvfN3R8CZTGdxRM6cLTIMH+UTe8nCJl1jh1iDJSmNVVglBt1X1SqCtE4rIeSdpIHaIK9FF4BmKjOAA88Nv/InHgcJXmeyJTN3X91ur6BrqJo0MRJOhhAAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-top-left-end {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAABxklEQVRIS7WVvUoDQRDHZ/r4DIEThCiCtn4UCpa+gIiF76DmCWwv+D5WYm0nCFpZCSKWKZIdmY//Zu/CxSaXQPZuM7v/md2Z3/DO6FSEhESE9COSbCSbjUdKpC9qY7Nmu7wGa5MQsVn6Djy+qWMpRHwD1+nazIXwdVGTtfkU7+EZ8dHBpVnoD5tBcglsoqNGZ2Nsi7nCGbWx/+EYIhUhPj68Et/EpVTCDIsNTVznUyJhIUouZh7H8apzcIQ4HApRHg4rHH3cwHqHwaAivr87703k/XNKj88fxJPJpDcRPZO6fiDe39vtTSTxlH5/5sTXF2e9iWgkdlx93snTyze9vn0RV5tbvUUyn81osFGVdeJalu9R7VbBKVmN2JzWSVQ1UASUoBiBJq96rxdeF7u8lt3BJXZtj06CIisA2Y6uzbQcnQs5uhYI4vFtLZmuK6CIYyi5lsFYOBGYzAxTmwKQosjpZlcAEPfWuAtEUrQL3ImJAJDGOu0bIPAShb3XLHqP09lhGmgFqdVbPDdE0LDQrAoROwLNrPZcRn5k5X+o7+4nqXGMubdEerZT2BxpR+Ip7BlRpiHaL5pQo3aK7MpNOqLKTbHIrj9doofFD8vqAQAAAABJRU5ErkJggg==)}\n#webamp .gen-window .gen-top-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABYlBMVEULFRIMDAweHS4eHi8fHyIfHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUiIyYjIjYkIzckIzgkJDklJDomJTkmJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEMsLEUsLEYtLUYuLUcuLUguLkcvJwgvLkkvL0ovMSUwL0kwL0owMEsxL0wxMC0xMEwxMU4yMU0yMU4zMk8zMlA0MlA0M1E1M1I1NFM2NFM2NVQ2Nhg3KxA3NlU3NlY4NVU4NlU4N1c5N1g5OFo6OFk6OVo7OVw7Ols7Olw8OVs8Olw8O11GQh9JRjlORDBQPx5dVztiWkVqanprXUFra3xsa3xsbH5tbX9tboBubX9vboFvb4JwTyxwb4Nxb4RxcIVxcYZycYZzcodzcoh0c4l0c4p1dIt1dIx2dY13dY6Gd02QkJCZc0LWhhB9AAABJUlEQVQYGT3BvWqUYRRG0X2++bRSGxsVhBls0oidP3W8gYCFXoW3JV6DVgmxslBbIQELJRAQA0Kc9zzbmcBkrVrZrTEaYuylEXs+EK/EEKNo4HA+SVf0n2mTMTqJcc00TTeBoGwUBZMINXPteTL2fn2E/XvHg/ktOz/fP4Ve7ZerU2Cqaw/YePdndXd1+qEWzIfsrKGbXNy+OCPN/IhrX1nI7+XFw3OqnO+z8wOa17dOz86XL79L3WHn7zMz9r59gSePP62pgxrG0bG1L23TraRWI24kRGNilv3iqJiaAgQRtEAomF+JIYRotPGIrfkki3UcncTkcqQHsjEtGEBRVeRymIBsTBYb3lCaqTqJbE0lG5WqVHrEyJX586A12omj45tj2foP9wDyBsXxPvcAAAAASUVORK5CYII=)}\n#webamp .gen-window .gen-top-right-end {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAByUlEQVRIS7VVPUsDQRCdWRvBShGszoAKYg4C1mJj8m8Cgr2/1cLfENBu5b352D1NY7GXhLvszc57MzvzRqdpU1VV8MOlolJFpeCvFuEq3uMDGyxU3Ls1mrit22MvfWDffv9e7dGccfGXg3CYd5o6KS1GrtsbPoK0zuttNXtjh3thZG0zWaYTY8z3ngGVIlosMiMS0cNGhCBprCq1ihTEWVW0mPNMlRNAKrC5SAAZoRLA/uzsRed5Vw+HDxqNunS1uqnbp1u5m05HYQhB3t5ehwHweABycX42HgTpGnkxkvX9lTw/Xg7DYXV9fX8OA+CZzA8vVbwfotYhK9Zw3iuhAtmgaEhvvGhIykqoABq6UJ74vZ422YwhAyYLTbOsgTv5iOdOz9j1qVve/a5UekwgE2ThfAnSVMCpdXLS5MlOIQWyZ2tpa/q1EMbQOAV3k5c/kaYqe/r+L5AOvtAuW4voeKY8DmhfJ5BkXzwlfOksUBR5oFhvotkLa4BYVKHGATLvcp5AdS3DHYinrZ8XrQgccDEa4MMjCQVnCZ+oaEy7fkZ0g2kBQp1HfA3E5lArDpawF0OWcIaJ4/TDzPF7tMpatNYOffX5hPUW/wFZNjaZ4b4luAAAAABJRU5ErkJggg==)}\n#webamp .gen-window .gen-top-left-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU0nT8z0BjwFhe1kd7S2ysY4eJJfLySrT3SVu5L+0tmTBhAu0tMTTQpb0lSVGutLeELnGipKxGe5/QJTPSpeyiiyWjBSQpVRAjXVIXXSyhR+oCAGL8JbEqBdscAAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-top-right-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU0nT8z0BjwFhe1kd7S2ysY4eJJfLySrT3SVu5L+0tmTBhAu0tMTTQpb0lSVGutLeELnGipKxGe5/QJTPSpeyiiyWjBSQpVRAjXVIXXSyhR+oCAGL8JbEqBdscAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-top {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUAgMAAAAFGX4uAAAACVBMVEUeHi8rK0Rra3zjkZV/AAAAG0lEQVQI12NggIJVYNDAEAoGDlSj0QGx9kABAFXxKF3wQT+3AAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-top-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABHVBMVEUdHS0dHS4dHi4eHS4eHi8eHyUfHzAfHzIfIDIgHzEgHzIhIDIhITMiITQiIjUjIjYkIzckIzgkJDckJDklJDolJiwmJTsmJTwnJj0oJj0oJz4pKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QsK0MsK0QsLEUsLEYtLUYuLUcuLUgvLkkvL0owL0owMEsxL0wxMEwyMU0yMU4zMk8zMlA0Mk80MlA0M1E0NFE1M1I1NFM2NFM2NVQ3NVY3NlY4NVU4NlU4N1c5N1g5OFk6OFlCQTtqanpra3xrbHxsa3xsbH1sbH5tbX9ubYBuboBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzbFJzcodzcoh0c4l0c4p1dIujlGrsznr///9wBmqFAAAAvklEQVQYGQXBwQlVSQBFwTq33+DWnUuj0RQmXMNwMzAKgjkI/7dVQYdtrZwyq3xFTlqqtUoP39dOa9apc9pOjXe8cRky8NDN/gcA8HDVj38DAHiYew0AwMNeD78BADy8hk8AAB4W/nwAAHh4nXz+BgDgoejjqXaqp22nHs79lZ0yM2tVgze8BHcBD68zX0yt1Jbp4XrPf6fqbJ72zz1tsN7e6N47eo07eFvBcrnQIPdyXbjyuu7DdOlnZk5Z1V/Roy8hK3ODtwAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-top-left-end {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAByUlEQVRIS7WVPU4DQQyF7Z5cgaVJpAAnIFAk50AcgB4UwQEoKNJQp6GkpKCgp6ShoUFcgCJtkBgj/7zZ2Y0WmmwiZXcnXj97xv7MB+OZCAmJCOlHJNmVbDVuKZE+qI2tmu3mO3g3CRGbpXvg+cUiXoWIO3CdLmcuhK+Lmqytp3iOyIiPj07NQn/YDJJLwIleNTu7hlusFcGojf2PwJCpCPHJ5EzciUuphBkWDk1c11MiYSFKLmYRx/ZqcAiEOAIKUd6thtj6OIHtXgY7FfHX61VvIk8vK7q+fdZjyKe03RTCW7U3Ip5NJ71l8sMr+vz4Jr6/O+9NRJOx7erzTG6W7/Tw+EY8HB32lsl6vabBoCr7xLWs3qPbrYNTsh6xNe2T6GqgCChBMwJN3vXeL7wtdnkve4Ab7NofT4MifwCynV2baTk7F/KmqBHE88uFtQqI2QVFbEPJtQzGIojAZGaY2hSAFEVON7sCgDi3xlkgk2Jc4ExMBIA01uncAIE3KOyzpp49TmeHaaAVpNZocd8QwcDCsCpEbAu0stprGflRlf+hvnuepMY25tkS5dkuYQuknYmXsFdEWYYYvyiERu8U1ZWHdGRV47aurl8JSofPjXVkWwAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-top-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABO1BMVEUeHyUfHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUjIjYkIzckIzgkJDklJDolJiwmJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEUsLEYtLUYuLUcuLUguLkcvLkkvL0owL0owMEsxMEwyMU0yMU4zMk8zMlA0MlA0M1E1M1I1NFM2NFM2NVQ2Nhg3NlU3NlY4NVU4NlU4N1c5N1g5OFo6OFk6OVo7OVw7Ols7Olw8OVs8Olw8O10/QitCQTtdVztqanprXUFra3xsa3xsbH5tbX9tboBubYBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzbFJzcodzcoh0c4l0c4p1dIt1dIx2dY13dY6Zc0KjlGqxnVm2nF7sznr///+ZhXPBAAABBUlEQVQYGQXBwYmUURBG0Vv1P90KvWtnQCcBxyBEEAMxKWMSWjQAB2V2DeKyX33Xc+reGY3RoHHeGHHWR1HVMWgUDXxbT5mK3swYkyQab3T3SyAoQFFQIhQAAPA+5iFXOPVls74AADBf30HuOn3+A6wCAGABXPucfr7WMesXAICAkry4hQzrDgAAoIru29FUuQ4AAP6BnM7P6df5LfUKAOAvj5qHXOHU32/Uh9rGnTiaMSapza77HdWEqCbm7Txetj0UIIigJRBkfRJDGKJq5EID6ynHLe4kMTpxAKEPNlBUFRiQAhZtAbgUqgqqJDV0CVCpEqHAojesn5vRyBh0/PyD5tj8B5vM5TGngJW4AAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-top-right-end {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAABzUlEQVRIS7VVu04DQQy0lx+gokuQEEjAiXwAJYSCgpIfoE1NgUTLT1KRjh4qKBbN+LF7kIZiL4nusuf1jL32WBeLVVVVwQ+XikoVlYK/WoSreI8PbLBQce/WaOK2bo+99IF9m81ztUdzxsVfDsJh3mnqpLQYuW5v+AjSOp1fV7M3drgXRtY2k2U6McZ87xlQKaLFIjMiET1sRAiSxqpSq0hBnFVFiznPVDkBpAKbiwSQESoB7M/OXnSa1vXjc0ujUZcuD0/qy+ON3F7uj8IQgmzfXocB8HgAcnx0MB4E6Rp5MZL7uwt5ejgdhsPq+vp+HwbAM5nOrqp4P0StQ1as4bxXQgWyQdGQ3njRkJSVUAE0dKE88btcrLIZQwZMFppmWQN38hHPnZ6x61O3vPtdqXSXQCbIzPkcpKmAU+vkpMmTnUIKZM/W0tb0ayaMoXEK7iYvfyJNVfb0/V8gHXymXbYW0fFMeRzQvk4gyb54SvjSWaAo8kCx3kSzF9YAsahCjQNkWuc8gepahjsQT1s/L1oROOBsNMCHRxIKzhLeU9GYdv2M6AbTDIQ6j/gaiM2hVhwsYS+GLOEME8fph5njd2eVtWitHfrq8wnrLf4D9zg6mAHJo5AAAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-top-left-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU0nT8z0BjwFhe1kd7S2ysY4eJJXLyqrT3yZtzVbS35P///7S3xMnRmvaWLJ6SRXtL6BInqmo6tPcJXTIjXcouulgyWkCSUgUx0iV10cUSeqQuABQNKbDZQyxmAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-top-right-fill {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU0nT8z0BjwFhe1kd7S2ysY4eJJXLyqrT3yZtzVbS35P///7S3xMnRmvaWLJ6SRXtL6BInqmo6tPcJXTIjXcouulgyWkCSUgUx0iV10cUSeqQuABQNKbDZQyxmAAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-bottom-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAAOCAMAAAA16ON4AAABfVBMVEUdHS0dHS4dHi4eHS4eHi8fHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUjIjYkIzckIzgkJDckJDklJDomJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEUsLEYtLUYtLUgtLkctLkguLUcuLUguLkcvLkkvL0ovMEowL0kwL0owMEsxL0wxMEwxMU4yMU0yMU4zMk8zMlA0MlA0M1E0NFE1M1I1NFM1NFQ2NFM2NFQ2NVQ3NlU3NlY4NVU4NlU4N1c5N1g5OFk5OFo6N1k6OFk6OVo7OVw7Ols7Olw8OVs8OVw8Olw8O109O149O2A9PF89PGA+O18+O2A+PF8+PGBqanpra3xsa3xsbH1sbH5tbX9ubX9ubYBuboBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzcYhzcodzcoh0c4l0c4p1dIt1dIx2dY13dY53do54dY94do94d5Ap3ahhAAACBUlEQVQYGQXBAQEYNRAEwNlLig3E4KTCcFK81AZ8bpmJn7/89vOX3z+BgBAEgQyBNARCIEHS2YEICIEAIR0BUsEF8OcvxhhwKxiXKQNxZDCBMGJ0mL3OmhpJwxHBfacmzA4u333+gAGAMQk6PqlkL7tYrnOSWca2CaCb1g5vqESDReG8+koHcOdcHwYAI6SVPWcL+RgMvmA6kEQLdOrMDHYAOHaFxxl3Hxafz6Y9ywAQEZWKTEgVwQB9igVJqkbtpkA84Jl56tjNiaM78F1mtsMAaLSrxWjKTgIB4DQs1Wg13U5p0W3nALrS7TPd/x4MYHZzggGIBmlEvUrYizwLfWvBCAVNNB3zhMYDTo5xfpzPMQ4Bxk7+/f77GEDfiYyXYh3RrO+z3xgcqmWsgkjaRuweNSbn0VIv+rmM82jB4vtxzuUCf5OKQUBgEAiSgATSIBiCwGww0hAkHRyEA0BgAFSwAsDA7iaQAECRYUYCMDvMUBJoAp51AARw4c+/AASIRgTSmEYCIkAIIQ1iEAQEIg0CqVMBBBfrn67rHZEBmWCa+913YcLhwAghaSJx1umI2RwBZ08a15c5zyGBS3NoDGtekTFMmXNm26i6TsyMOk+2BkAlgjUZTM+8tiV7FJ9rzXlPAZv0CQGAMDUNBIaOkCbSEAIiMAEERo1UCCSB67vOOwBR8T8KSRhI0bzb7AAAAABJRU5ErkJggg==)}\n#webamp .gen-window .gen-bottom-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAAOCAMAAAA16ON4AAABfVBMVEUdHS0dHS4dHi4eHS4eHi8fHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUjIjYkIzckIzgkJDklJDomJTkmJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEMsLEUsLEYtLUYuLUcuLUguLkcvLkkvL0ovMEowL0owMEsxL0wxMEwyMU0yMU4zMk8zMlA0Mk80MlA0M1E0NFE1M1I1NFM1NFQ2NFM2NFQ2NVQ3NlU3NlY4NVU4NlU4N1c5N1g5OFk5OFo6N1k6OFk6OVo7OVw7Ols7Olw8OVs8OVw8Olw8O109O149O2A9PF89PGA+O18+O2A+PF8+PGBAP1BAQFFAQFJfX3Fqanpra3xrbHxsa3xsbH1sbH5tbX9ubYBuboBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzcYhzcodzcoh0c4l0c4p1dIt1dIx2dY13dY54dY94do94d5CUuEDKAAACKUlEQVQYGQXBwZFdRRAEwKyev3ZwwQ8gFisgdMIPzFlhhLhih2THvukiM3+jqRRolgIKpUAV2KZoU6WgaQGrKQoK3VQBvvH7Nz9e39nZ7ezsPJoFrni8PvOgNNUV91y7s21xqaaqWM2dy5qVLS12Ps3q1sL7v2Awd/u6Y56XmHB7N4960mOKVDO1uSwlSgsKjNQeZuhKStg9lkwM3i8wcPblwIOGfbzdFy6bfQFbaXtqZg+ROxEqBJ0ai91AUTvjhZox3u8HMKg8l31AlrfxibfXMHPQclzJubnWbTasVChFsFPQQXTgU6GM9/vxBRikk6zxAuHOcfAElAjS7dUTkxjOGBBgl1nAYjMLbxYhftt/vlxgIIfBA8rJTXa9WstC3UwS4s6dAl2ECjS7xI6Kxk6wDcT+0q9/7gcwwNnxvEAHV9t5PkPbCeFYHfSsG6gUGEV0UGMiomkhCeLXfvzZr1+A/ExTAFw8xwVdKIU1XdhZilIKFKWxpdGdsqBA2Ub565sfgzQAwHMu0AIKTAErSAMAKNJt0AoMAHsVLeD1B1QKaNEoqIJCUWiVpkpTTaEFbKooFLUACsDrO2zhARaXDg+3zNWUS+fiZnVn6ZaiTVk2FyzZplqWO4srzTaes2NgZ7AvUNyj1kOHc0mDmTjIIo2aCTQpRrOCDSvbbcApbaapcd2s13/QFMDlOXmgNtqURq1Ys3aWRosWUAW1qaZZDQuF7qkt+Gke/wNCVMxEPwTsWgAAAABJRU5ErkJggg==)}\n#webamp .gen-window .gen-bottom {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAOAgMAAACnVF/TAAAACVBMVEUrKkM+PGB4d5A1hmUAAAAAGElEQVQI12NYBQYNDKFg4EAyjQ5wmQcFAFaEHSfLt0cNAAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-middle-left {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAdAgMAAAABTX4zAAAACVBMVEUdHS0qKUBqanoMSFahAAAAD0lEQVQI12NQ5QxhoDMGAFFyDru7vcmtAAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-middle-left-bottom {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAYAgMAAABRgO+AAAAACVBMVEUdHS0qKUBqanoMSFahAAAAD0lEQVQI12NQ5QxhoCEGAEUWDDHkAu/CAAAAAElFTkSuQmCC)}\n#webamp .gen-window .gen-middle-right {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAdAgMAAADqesUwAAAACVBMVEUdHS0qKUBqanoMSFahAAAADklEQVQI12OYOoWBBggAuDohplXr188AAAAASUVORK5CYII=)}\n#webamp .gen-window .gen-middle-right-bottom {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAYAgMAAAC6t1SDAAAACVBMVEUdHS0qKUBqanoMSFahAAAADklEQVQI12OYOoWBGggA6uEb2fBejlkAAAAASUVORK5CYII=)}\n#webamp .gen-window .gen-close.winamp-active {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEU6MSljXjtsXUORbkq0kWP////9IyyfAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}\n#webamp .character-48 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12NIYJjAsIHhApBMAAAULANhy/alSwAAAABJRU5ErkJggg==)}\n#webamp .character-49 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12NQYEhgUIBAAAbMAQE/4OmzAAAAAElFTkSuQmCC)}\n#webamp .character-50 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12N4wCAAhAkMDQwfAA78AtFOxm3MAAAAAElFTkSuQmCC)}\n#webamp .character-51 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWP4wKDAkMAgwDCBIQEAEHwCcej/ubUAAAAASUVORK5CYII=)}\n#webamp .character-52 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNQYEhgWMDwgUGBQQEADlwCUbptSVYAAAAASUVORK5CYII=)}\n#webamp .character-53 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12P4wNDA8IBBAAgfAAAWXANRkouswAAAAABJRU5ErkJggg==)}\n#webamp .character-54 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYGhgeMAwAQgTABOsA0E/JWQ/AAAAAElFTkSuQmCC)}\n#webamp .character-55 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12P4wCDAoMDgAIIADgwB4bVklkQAAAAASUVORK5CYII=)}\n#webamp .character-56 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12NIYJjAAMJAEgAQvALRax9yugAAAABJRU5ErkJggg==)}\n#webamp .character-57 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYJgAhAUMAgwJAA/sAmFIDiRPAAAAAElFTkSuQmCC)}\n#webamp .character-97 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12NIYJjA8AGIgRAAFNwDkUdAkdwAAAAASUVORK5CYII=)}\n#webamp .character-98 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12N4wDCBAYSBJAAaPARRW/xs+gAAAABJRU5ErkJggg==)}\n#webamp .character-99 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYJjA0ACEExgSABFMAuEl/r42AAAAAElFTkSuQmCC)}\n#webamp .character-100 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIUlEQVQYV2NkeMTwnwEG5CAMRrAglMPwiIEBxKaKIJpFADZCEAGAIkAWAAAAAElFTkSuQmCC)}\n#webamp .character-101 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12P4wNDA8ACIGxg+AAAZ7ARBle8LfgAAAABJRU5ErkJggg==)}\n#webamp .character-102 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12P4wNDA8ACIgRAAGXwD0QArRQgAAAAASUVORK5CYII=)}\n#webamp .character-103 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12MoYGhg2MAwAQgTABMMAyEYrKesAAAAAElFTkSuQmCC)}\n#webamp .character-104 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIklEQVQYV2NkeMTwn0GOAQIeMTCA2Iy4BaEKwRR+lcSYCQBnQhEB2omL+AAAAABJRU5ErkJggg==)}\n#webamp .character-105 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADklEQVQI12MoYFCAwgIACEwBYXIvChIAAAAASUVORK5CYII=)}\n#webamp .character-106 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12MQYADBCUCYAAAGnAGx9K9L/wAAAABJRU5ErkJggg==)}\n#webamp .character-107 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12OYwLCA4QAQLmCYAAAXTAPhR2cHZQAAAABJRU5ErkJggg==)}\n#webamp .character-108 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAGUlEQVQYV2NkeMTwn0GOAQUw0kwQ2RqgpQBKiwwB5wSvgwAAAABJRU5ErkJggg==)}\n#webamp .character-109 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIUlEQVQYV2NkeMTwn0GOAQIeMTCA2IxgQWSAXxCrdmIEAQtSEAH0ktA/AAAAAElFTkSuQmCC)}\n#webamp .character-110 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12OYwMTAcIHpARAyAAATGAMpx84ilAAAAABJRU5ErkJggg==)}\n#webamp .character-111 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADklEQVQI12NIYJgAhQkAEgwDAakOOnUAAAAASUVORK5CYII=)}\n#webamp .character-112 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12N4wDCB4QFDAwgCABlcA9Fh/HqiAAAAAElFTkSuQmCC)}\n#webamp .character-113 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12NIYJgAhBcYNjAUAAATvANxqBzBZwAAAABJRU5ErkJggg==)}\n#webamp .character-114 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12N4wKzA8IAJBD8AABkSBJqXbNZ9AAAAAElFTkSuQmCC)}\n#webamp .character-115 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12MoYGhgSGAQAMIHAA1cAlFD9hA9AAAAAElFTkSuQmCC)}\n#webamp .character-116 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQI12MoYFCAQQAH/AERspkQDgAAAABJRU5ErkJggg==)}\n#webamp .character-117 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQI12OYwACDCQAUHAMxvRgSGgAAAABJRU5ErkJggg==)}\n#webamp .character-118 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12OYwACBCQwJABOMAwEw9lTJAAAAAElFTkSuQmCC)}\n#webamp .character-119 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12OYwACCH4BwAgAXTAQhMxLiQgAAAABJRU5ErkJggg==)}\n#webamp .character-120 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12OYwDCBIQEIgTQAEgwDAb4oAK0AAAAASUVORK5CYII=)}\n#webamp .character-121 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12OYwDCBIYFBAQQBDwwB4W/sEnMAAAAASUVORK5CYII=)}\n#webamp .character-122 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWP4wCDAoMDgwNDA8AEAD3wC0QyxJxkAAAAASUVORK5CYII=)}\n#webamp .character-34 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQIHWMIYGKAAQADkABTwIHJLQAAAABJRU5ErkJggg==)}\n#webamp .character-64 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12OQYFBgiABCBQYJAAbMASFkTTvgAAAAAElFTkSuQmCC)}\n#webamp .character-32 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAE0lEQVQYV2NkYGD4z4AGGOklCAChpQYBD5K5XgAAAABJRU5ErkJggg==)}\n#webamp .character-8230 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAC0lEQVQIHWNAgBUAALQAqf6ZnokAAAAASUVORK5CYII=)}\n#webamp .character-46 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAGUlEQVQYV2NkYGD4z4AGGGki+AhqkRzCNgCztQcBQ/F5qwAAAABJRU5ErkJggg==)}\n#webamp .character-58 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAG0lEQVQYV2NkYGD4z4AGGHELPoIqlYPQFKoEABHUCAEa7xBFAAAAAElFTkSuQmCC)}\n#webamp .character-40 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NgYBBgUABCAQYGAAJMAGFQC8mLAAAAAElFTkSuQmCC)}\n#webamp .character-41 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NgYGhgcADCBgYGAAkMAYFEejkbAAAAAElFTkSuQmCC)}\n#webamp .character-45 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAG0lEQVQYV2NkYGD4z4AGGEkQfISmXY6BgXjtANzFBwGYHC/oAAAAAElFTkSuQmCC)}\n#webamp .character-39 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQIHWNQYGKAAQABgAAjjGgVVgAAAABJRU5ErkJggg==)}\n#webamp .character-33 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAH0lEQVQYV2NkYGD4z/CIgYFBjgEOGKkhiDAOzMJqJgAQawsBnvEUjAAAAABJRU5ErkJggg==)}\n#webamp .character-95 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAFklEQVQYV2NkYGD4z4AGGGki+AjTIgCyawbjsVUKxAAAAABJRU5ErkJggg==)}\n#webamp .character-43 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12NQYGJg+MEAIhkACPABPfEgkLEAAAAASUVORK5CYII=)}\n#webamp .character-92 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12NgYGhgZoBAAATIAI13IxiAAAAAAElFTkSuQmCC)}\n#webamp .character-47 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNgYOBgEGBQYHBgaAAAAqQA+cACQKYAAAAASUVORK5CYII=)}\n#webamp .character-91 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHUlEQVQYV2NkYGD4z/CIAQLkIBQjXBAqQFVBJIsAMwMMAVy4DMAAAAAASUVORK5CYII=)}\n#webamp .character-93 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIElEQVQYV2NkYGD4zwACj8AkA4McAwMjXBAmQU1BJIsACwMMAZBptUcAAAAASUVORK5CYII=)}\n#webamp .character-94 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQIHWNQYAhg6GAAAwAH9AD5R+QUOwAAAABJRU5ErkJggg==)}\n#webamp .character-38 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NQYAhgUGCIAJIaAAfsAWHaIpwJAAAAAElFTkSuQmCC)}\n#webamp .character-37 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNIYMhgEGBQYIhgkAAACgQBacCaDW0AAAAASUVORK5CYII=)}\n#webamp .character-44 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHklEQVQYV2NkYGD4z4AGGKkl+IiBgUEOYjjCTCRBAMu1CAHlOP+DAAAAAElFTkSuQmCC)}\n#webamp .character-61 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAH0lEQVQYV2NkYGD4z4AGGMGCj5BE5RgYIIIUqkTTDgA65AgBoymWoAAAAABJRU5ErkJggg==)}\n#webamp .character-36 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NQYChgSGAwAJIKAApcAbE85GZ1AAAAAElFTkSuQmCC)}\n#webamp .character-35 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12NIYPjAAMEMABUMAwFxUzDLAAAAAElFTkSuQmCC)}\n#webamp .character-197 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYJjAAMIfGCYAABIMA2Fjj6V0AAAAAElFTkSuQmCC)}\n#webamp .character-214 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12OYwJDAMAEMEwASbAMBKm1nAQAAAABJRU5ErkJggg==)}\n#webamp .character-196 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWOYwMDAkMAwgeEDwwQADwwDAcWvnbkAAAAASUVORK5CYII=)}\n#webamp .character-63 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNIYJjAIMCQwMDAkAAAC+wBwX8tiscAAAAASUVORK5CYII=)}\n#webamp .character-42 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNgYFBgeMBQwODAwAAACjwBsYRIp8kAAAAASUVORK5CYII=)}\n#webamp .character-60 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHUlEQVQYV2NkYGD4z/CIAQLkIBQjXBAqQFVBJIsAMwMMAVy4DMAAAAAASUVORK5CYII=)}\n#webamp .character-62 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIElEQVQYV2NkYGD4zwACj8AkA4McAwMjXBAmQU1BJIsACwMMAZBptUcAAAAASUVORK5CYII=)}\n#webamp .character-123 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHUlEQVQYV2NkYGD4z/CIAQLkIBQjXBAqQFVBJIsAMwMMAVy4DMAAAAAASUVORK5CYII=)}\n#webamp .character-125 {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIElEQVQYV2NkYGD4zwACj8AkA4McAwMjXBAmQU1BJIsACwMMAZBptUcAAAAASUVORK5CYII=)}\n#webamp .gen-text-a {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUA3N01bW21iYnN4eIZ/f4yNjZmUlKDQ9WnQAAAAIUlEQVQIHWMAAcZyAQamdAUGVrMABnGVQgY11yKGIIZUACkrA92ildtqAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-a {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUBGRlmNjZmbm6bGxszU1Nnx8fL///8iRh7bAAAAIUlEQVQIHWMAAcZyAQamdAUGVrMABnGVQgY11yKGIIZUACkrA92ildtqAAAAAElFTkSuQmCC)}\n#webamp .gen-text-b {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUAxMUdGRlliYnNqanpwcIB4eIZ/f4yNjZmUlKBMQpI+AAAAIUlEQVQI12NgAAHOmVOARIKlAgNnWyuQVRQuAOXOnMoAAFkvBehWf7S3AAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-b {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUA3N01iYnObm6apqbO4uL/GxszU1Nnx8fL////s2d+PAAAAIUlEQVQI12NgAAHOmVOARIKlAgNnWyuQVRQuAOXOnMoAAFkvBehWf7S3AAAAAElFTkSuQmCC)}\n#webamp .gen-text-c {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUAxMUc3N00/P1NGRllUVGZbW21qanpwcIB4eIaGhpONjZmUlKBrx3tvAAAAJUlEQVQI12NgAAHWNZMZGHQSdzAw5DgwgAgFBgabgk6gxJ7JDABjoQaLYu6ObAAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-c {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUA3N01GRllUVGZiYnN/f4yNjZmpqbO4uL/Gxszi4ubx8fL///9AK9zxAAAAJUlEQVQI12NgAAHWNZMZGHQSdzAw5DgwgAgFBgabgk6gxJ7JDABjoQaLYu6ObAAAAABJRU5ErkJggg==)}\n#webamp .gen-text-d {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUBUVGZbW214eIaNjZmUlKBPxwelAAAAG0lEQVQI12NgAALTEAUGU6ZABlOGYAgGsUMUACkqA3OelxceAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-d {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUB/f4yNjZnGxszx8fL///90u0SbAAAAG0lEQVQI12NgAALTEAUGU6ZABlOGYAgGsUMUACkqA3OelxceAAAAAElFTkSuQmCC)}\n#webamp .gen-text-e {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUA3N00/P1NGRllUVGZbW214eIZ/f4yNjZmUlKBpF6uKAAAAH0lEQVQI12NgAALOmVMZOBOAdJsDA2exABAbAcWmAQA4DwTidXJmqwAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-e {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUBGRllUVGZiYnN/f4yNjZnGxszU1Nnx8fL///+DgC81AAAAH0lEQVQI12NgAALOmVMZOBOAdJsDA2exABAbAcWmAQA4DwTidXJmqwAAAABJRU5ErkJggg==)}\n#webamp .gen-text-f {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUA3N01GRllbW21qanqUlKC2H8YaAAAAGklEQVQI12NgAALT0CAGUwUg7SwAwSC2AgMAKTIC7Ms0rr0AAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-text-f {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUBGRlliYnONjZmpqbP///9D5gpdAAAAGklEQVQI12NgAALT0CAGUwUg7SwAwSC2AgMAKTIC7Ms0rr0AAAAASUVORK5CYII=)}\n#webamp .gen-text-g {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAIVBMVEUpKUA/P1NGRllUVGZbW21wcIB4eIZ/f4yGhpONjZmUlKCnwN9hAAAAJ0lEQVQIHWMAA8aqZgYGzoQoAQYtBwYGBi2XVQoMnAVeCgyMXa0KAE4GBYcb4B3nAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-g {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAIVBMVEUpKUBUVGZiYnN/f4yNjZm4uL/GxszU1Nni4ubx8fL///+LwSrlAAAAJ0lEQVQIHWMAA8aqZgYGzoQoAQYtBwYGBi2XVQoMnAVeCgyMXa0KAE4GBYcb4B3nAAAAAElFTkSuQmCC)}\n#webamp .gen-text-h {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUBwcIBycoGCgo+hoauqqrO3t767u8O8vMPDw8nGxszKytD26YaTAAAAGElEQVQI12NgAAJphQoITl3BIO08A8YHADj6BOvV9DaxAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-h {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAFVBMVEUpKUCrq7TDw8no6Ovw8PH5+fr///9e3zXEAAAAFklEQVQI12NgAAIxgTQIDgFiozQYHwAqqAOv6ufnjgAAAABJRU5ErkJggg==)}\n#webamp .gen-text-i {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAHBAMAAADdS/HjAAAAFVBMVEUhITkkJDxra3xwcIBycoF6eoiCgo8pCsaXAAAAFUlEQVQI12MQEGQQCoQi4UQGERACABeTAqlm5PZ5AAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-i {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAHBAMAAADdS/HjAAAAFVBMVEUkJDwxMULAwMfDw8ne3uHh4eXl5ehBk9l/AAAAFUlEQVQI12NgFGBgcgCjAAZmCEoAABAKAfHk6DTHAAAAAElFTkSuQmCC)}\n#webamp .gen-text-j {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUAxMUdGRllNTWBUVGZ4eIaNjZmUlKAAywzwAAAAE0lEQVQI12NgAIFSVCwCxOrJDAAh4QLodMJ9awAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-j {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUA3N01iYnNwcIB/f4zGxszx8fL///+/0FlwAAAAE0lEQVQI12NgAIFSVCwCxOrJDAAh4QLodMJ9awAAAABJRU5ErkJggg==)}\n#webamp .gen-text-k {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUAxMUc/P1NGRllNTWBUVGZbW22GhpONjZmUlKC0yuawAAAAIklEQVQI12NgAIFM00lAIiMBSHQGAImKAiDhNhVIGLYzAABxtgda2evVPQAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-k {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUA3N01UVGZiYnNwcIB/f4yNjZni4ubx8fL////1B4EGAAAAIklEQVQI12NgAIFM00lAIiMBSHQGAImKAiDhNhVIGLYzAABxtgda2evVPQAAAABJRU5ErkJggg==)}\n#webamp .gen-text-l {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHBAMAAAAyiZrdAAAAElBMVEUpKUAxMUdGRll4eIZ/f4yUlKDDTNTnAAAAFUlEQVQI12NgAIJgNByiJMAQGqoAABtZAp1Ff+GZAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-l {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHCAYAAADAp4fuAAAAMklEQVQYV2PU1HT4z4AGGP//////+PGzDMnJJXApaghevXqLoa9vFthMEBtsJrLlIAsBN0svzTt3mzcAAAAASUVORK5CYII=)}\n#webamp .gen-text-m {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAAIVBMVEUpKUAxMUdGRllUVGZbW21iYnNwcIB4eIZ/f4yGhpOUlKBZcblpAAAAI0lEQVQI12NgAAGtJZzLGbRWaAGJrjIg4bUYSGguBBKqCcsBjp0JorkYhMsAAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-text-m {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAAIVBMVEUpKUA3N01iYnN/f4yNjZmbm6a4uL/GxszU1Nni4ub////cS6NmAAAAI0lEQVQI12NgAAGtJZzLGbRWaAGJrjIg4bUYSGguBBKqCcsBjp0JorkYhMsAAAAASUVORK5CYII=)}\n#webamp .gen-text-n {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUAxMUc3N01GRllNTWBiYnNwcIB4eIaNjZmUlKCfa5y8AAAAIElEQVQI12NgAIIK5clMjA4MTP+NgPgKAxPDeiB+wwAASdwGGeDXGZQAAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-text-n {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUA3N01GRlliYnNwcICbm6a4uL/Gxszx8fL///8Fv7lnAAAAIElEQVQI12NgAIIK5clMjA4MTP+NgPgKAxPDeiB+wwAASdwGGeDXGZQAAAAASUVORK5CYII=)}\n#webamp .gen-text-o {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUA/P1NGRllUVGZbW214eIZ/f4yGhpONjZmUlKDmamWaAAAAHElEQVQI12NgAAKx6QYMrSwTGaYwTQFjEBsoBgBK6AZDMgIWOQAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-o {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUBUVGZiYnN/f4yNjZnGxszU1Nni4ubx8fL////xzWRAAAAAHElEQVQI12NgAAKx6QYMrSwTGaYwTQFjEBsoBgBK6AZDMgIWOQAAAABJRU5ErkJggg==)}\n#webamp .gen-text-p {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJ1BMVEUpKUAxMUc/P1NGRllNTWBbW21iYnNqanpwcIB4eIZ/f4yGhpOUlKBLTaK7AAAAIElEQVQI12NgAIKYM5sYYgxPMMSEHGeIWZnIEGPAAMIAZzYHJUki1qIAAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-text-p {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJ1BMVEUpKUA3N01UVGZiYnNwcICNjZmbm6apqbO4uL/GxszU1Nni4ub////2OqNjAAAAIElEQVQI12NgAIKYM5sYYgxPMMSEHGeIWZnIEGPAAMIAZzYHJUki1qIAAAAASUVORK5CYII=)}\n#webamp .gen-text-q {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJFBMVEUpKUA3N00/P1NGRllUVGZbW214eIZ/f4yGhpONjZmSkp6UlKAHPYNOAAAAI0lEQVQI12NgAAGm6hYGBs6EaAEG6wDrAAjBmdBtAJTY1QAAWmwG3UPBF3oAAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-text-q {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUBGRllUVGZiYnN/f4yNjZm4uMDGxszU1Nni4ubx8fL7+/v////Rx7x8AAAAI0lEQVQI12NgAAGmnikMDFwFMQIMNgE2ARCCq2COAVDidAIAYQkHOMhnyMoAAAAASUVORK5CYII=)}\n#webamp .gen-text-r {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUAxMUc3N01GRllUVGZbW21qanpwcIB4eIZ/f4yGhpONjZmUlKDditvQAAAAIklEQVQI12NgAAGbM1uARMAcILHiJJBIPwQkQo4AicCTDACHOAih1LnoFgAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-r {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUA3N01GRlliYnN/f4yNjZmpqbO4uL/GxszU1Nni4ubx8fL///9vCc2uAAAAIklEQVQI12NgAAGbM1uARMAcILHiJJBIPwQkQo4AicCTDACHOAih1LnoFgAAAABJRU5ErkJggg==)}\n#webamp .gen-text-s {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUAxMUc/P1NGRllUVGZbW21qanpwcIB4eIaGhpONjZmUlKCHjnJIAAAAIklEQVQIHWMAAY1dAQzVygoM1TsDGMRmb2IIZdvE4LnLAQBTHAco/pVKOwAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-s {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUA3N01UVGZiYnN/f4yNjZmpqbO4uL/Gxszi4ubx8fL///+qJyS0AAAAIklEQVQIHWMAAY1dAQzVygoM1TsDGMRmb2IIZdvE4LnLAQBTHAco/pVKOwAAAABJRU5ErkJggg==)}\n#webamp .gen-text-t {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHCAYAAADAp4fuAAAALklEQVQYV2PU0XH+z4AGGCdMmIMpqKZq819FVZHBzc2eYfXqLQyvX71hYKSBIACnryn7i49aBgAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-t {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHAgMAAAC9yW99AAAADFBMVEUpKUBUVGZycoH///9VDRy9AAAAE0lEQVQI12NgYGD4f4BBlwEZAQAkDAKhcYNEwQAAAABJRU5ErkJggg==)}\n#webamp .gen-text-u {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAFVBMVEUpKUAxMUdGRllUVGZbW21qanqUlKDA77WeAAAAFklEQVQI12NgAAI3hRRUHJLMIJoWAAA5UATxAlDxBQAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-u {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAFVBMVEUpKUA3N01iYnN/f4yNjZmpqbP///8SF7O4AAAAFklEQVQI12NgAAI3hRRUHJLMIJoWAAA5UATxAlDxBQAAAABJRU5ErkJggg==)}\n#webamp .gen-text-v {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAKlBMVEUpKUAxMUc/P1NGRllNTWBUVGZbW21iYnNqanpwcIB4eIaGhpONjZmUlKDthvA2AAAAIklEQVQIHWMAAd8EWQaeDTEMHJeWMzDfvMTAsHcDA0NtAgBSrAdcNQnv8gAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-v {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAKlBMVEUpKUA3N01UVGZiYnNwcIB/f4yNjZmbm6apqbO4uL/Gxszi4ubx8fL///81zHafAAAAIklEQVQIHWMAAd8EWQaeDTEMHJeWMzDfvMTAsHcDA0NtAgBSrAdcNQnv8gAAAABJRU5ErkJggg==)}\n#webamp .gen-text-w {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAALVBMVEUpKUAxMUc3N00/P1NGRllNTWBUVGZbW21iYnNqanpwcIB4eIZ/f4yNjZmUlKD3PA89AAAAKUlEQVQIHWMAg3nqT/wY8rKfdzPIzXt9nIHnXd9jBo7XcRcYWJ7zLQAAwo4M1uKKXVEAAAAASUVORK5CYII=)}\n#webamp .gen-window.selected .gen-text-w {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAALVBMVEUpKUA3N01GRllUVGZiYnNwcIB/f4yNjZmbm6apqbO4uL/GxszU1Nnx8fL///+8HCoLAAAAKUlEQVQIHWMAg3nqT/wY8rKfdzPIzXt9nIHnXd9jBo7XcRcYWJ7zLQAAwo4M1uKKXVEAAAAASUVORK5CYII=)}\n#webamp .gen-text-x {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJFBMVEUpKUAxMUc3N01GRllNTWBbW21iYnNwcIB4eIaGhpONjZmUlKDqWCJLAAAAJElEQVQI12NgAAHJiVECDMzbtwCZ2Q0gYhEDA/PWHUCJhOwAAGilBx+T4WwNAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-x {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJFBMVEUpKUA3N01GRlliYnNwcICNjZmbm6a4uL/Gxszi4ubx8fL///+x/boCAAAAJElEQVQI12NgAAHJiVECDMzbtwCZ2Q0gYhEDA/PWHUCJhOwAAGilBx+T4WwNAAAAAElFTkSuQmCC)}\n#webamp .gen-text-y {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUAxMUc/P1NGRllNTWBUVGZbW21iYnN4eIaGhpONjZmUlKAsqFJVAAAAHklEQVQI12NgAIIdrJsYsrMKGDh3CTCwbGNgYIZgAE8aBbSrMTxDAAAAAElFTkSuQmCC)}\n#webamp .gen-window.selected .gen-text-y {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUA3N01UVGZiYnNwcIB/f4yNjZmbm6bGxszi4ubx8fL///+UuWJCAAAAHklEQVQI12NgAIIdrJsYsrMKGDh3CTCwbGNgYIZgAE8aBbSrMTxDAAAAAElFTkSuQmCC)}\n#webamp .gen-text-z {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAHBAMAAAAsQKpuAAAAIVBMVEUAAAApKUAxMUc/P1NGRllbW21qanp4eIZ/f4yGhpOUlKAeeVtyAAAAAXRSTlMAQObYZgAAACdJREFUCNdjEBQUYACCqlULQJRgVgCIElkBFtRcDKaiShxA1CqwEgClfwdsfnJFGQAAAABJRU5ErkJggg==)}\n#webamp .gen-window.selected .gen-text-z {background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAHBAMAAAAsQKpuAAAAIVBMVEUAAAApKUA3N01UVGZiYnONjZmpqbPGxszU1Nni4ub///8EpbEBAAAAAXRSTlMAQObYZgAAACdJREFUCNdjEBQUYACCqlULQJRgVgCIElkBFtRcDKaiShxA1CqwEgClfwdsfnJFGQAAAABJRU5ErkJggg==)}\n#webamp .gen-text-a {width: 6px;}\n#webamp .selected .gen-text-a {width: 6px;}\n#webamp .gen-text-b {width: 7px;}\n#webamp .selected .gen-text-b {width: 7px;}\n#webamp .gen-text-c {width: 7px;}\n#webamp .selected .gen-text-c {width: 7px;}\n#webamp .gen-text-d {width: 6px;}\n#webamp .selected .gen-text-d {width: 6px;}\n#webamp .gen-text-e {width: 6px;}\n#webamp .selected .gen-text-e {width: 6px;}\n#webamp .gen-text-f {width: 6px;}\n#webamp .selected .gen-text-f {width: 6px;}\n#webamp .gen-text-g {width: 7px;}\n#webamp .selected .gen-text-g {width: 7px;}\n#webamp .gen-text-h {width: 6px;}\n#webamp .selected .gen-text-h {width: 6px;}\n#webamp .gen-text-i {width: 4px;}\n#webamp .selected .gen-text-i {width: 4px;}\n#webamp .gen-text-j {width: 6px;}\n#webamp .selected .gen-text-j {width: 6px;}\n#webamp .gen-text-k {width: 7px;}\n#webamp .selected .gen-text-k {width: 7px;}\n#webamp .gen-text-l {width: 5px;}\n#webamp .selected .gen-text-l {width: 5px;}\n#webamp .gen-text-m {width: 8px;}\n#webamp .selected .gen-text-m {width: 8px;}\n#webamp .gen-text-n {width: 6px;}\n#webamp .selected .gen-text-n {width: 6px;}\n#webamp .gen-text-o {width: 6px;}\n#webamp .selected .gen-text-o {width: 6px;}\n#webamp .gen-text-p {width: 6px;}\n#webamp .selected .gen-text-p {width: 6px;}\n#webamp .gen-text-q {width: 7px;}\n#webamp .selected .gen-text-q {width: 7px;}\n#webamp .gen-text-r {width: 7px;}\n#webamp .selected .gen-text-r {width: 7px;}\n#webamp .gen-text-s {width: 6px;}\n#webamp .selected .gen-text-s {width: 6px;}\n#webamp .gen-text-t {width: 5px;}\n#webamp .selected .gen-text-t {width: 5px;}\n#webamp .gen-text-u {width: 6px;}\n#webamp .selected .gen-text-u {width: 6px;}\n#webamp .gen-text-v {width: 6px;}\n#webamp .selected .gen-text-v {width: 6px;}\n#webamp .gen-text-w {width: 8px;}\n#webamp .selected .gen-text-w {width: 8px;}\n#webamp .gen-text-x {width: 7px;}\n#webamp .selected .gen-text-x {width: 7px;}\n#webamp .gen-text-y {width: 6px;}\n#webamp .selected .gen-text-y {width: 6px;}\n#webamp .gen-text-z {width: 11px;}\n#webamp .selected .gen-text-z {width: 11px;}\n#webamp #title-bar #close {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAIgAAAAAAAAAAAAAAAf4AACAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAADwAAAAAAAAAAAAf/gAAAAA8AAAAAAAAAAAAH//iIiAAPAAAAAAAAAAAAB//4iIAADwAAAAAAAAAAAAf/iIgAAA8AAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+HP//3hz//8w8///EP///wHz//8AE///ADP//wBz//8A8///AfP//wP///8H////D////x////8/////f////w==), auto}\n#webamp #equalizer-window .band {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPcAAAAAAAAAAAAAAAAAAA/3cAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAAAAAAAAAAAAAAAAAAj3AAAA9wAAAAAAAAAAgACPcAAAAPcAAAAAAAAAAIcAj3AAAAAAAAAAAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAA/3cAAAAAAAAACP/3d3AAAA9wAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////////////////////////////////////////////////8////+H///jA///wwP//8P///+Hz//3h4f/8w+H//EPz//wH///8AED//ADA//wB4f/8A/P//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #equalizer-window .title-bar {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #equalizer-window.shade {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #equalizer-window.shade input {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp .window {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAAAAAAAAAAAAAAAAf/gAAAAAAAAAAAAAAAAAAH//iIiAAAAAAAAAAAAAAAB//4iIAAAAAAAAAAAAAAAAf/iIgAAAAAAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+H///3h///8w////EP///wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp .window input {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAAAAAAAAAAAAAAAAf/gAAAAAAAAAAAAAAAAAAH//iIiAAAAAAAAAAAAAAAB//4iIAAAAAAAAAAAAAAAAf/iIgAAAAAAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+H///3h///8w////EP///wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #main-window {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAAAAAAAAAAAAAAAAf/gAAAAAAAAAAAAAAAAAAH//iIiAAAAAAAAAAAAAAAB//4iIAAAAAAAAAAAAAAAAf/iIgAAAAAAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+H///3h///8w////EP///wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #main-window.shade #title-bar {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAAAAAAAAAAAAAAAAf/gAAAAAAAAAAAAAAAAAAH//iIiAAAAAAAAAAAAAAAB//4iIAAAAAAAAAAAAAAAAf/iIgAAAAAAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+H///3h///8w////EP///wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #playlist-window {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAAAAAAAAAAAAAAAAf/gAAAAAAAAAAAAAAAAAAH//iIiAAAAAAAAAAAAAAAB//4iIAAAAAAAAAAAAAAAAf/iIgAAAAAAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+H///3h///8w////EP///wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #playlist-window .playlist-top {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #main-window #position {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #playlist-window #playlist-resize-target {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPcAAAAAAAAAAAAAAAAAAA/3cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAcAAAAAAAAAAACPcAAAdwAHcAAAAAAAAAAAj3AAAP8AD/AAAAAAAAgACPcAAAAAAA8AAAAAAAAIcAj3AAAAAAAAAAAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////////////////////////////////////////////////////n////w////4H///iB///w/n//8OY//+HCH/3hwh/8w+Y//EP+f/wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #playlist-window .playlist-scrollbar {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPcAAAAAAAAAAAAAAAAAAA/3cAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAAAAAAAAAAAAAAAAAAj3AAAA9wAAAAAAAAAAgACPcAAAAPcAAAAAAAAAAIcAj3AAAAAAAAAAAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAA/3cAAAAAAAAACP/3d3AAAA9wAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////////////////////////////////////////////////8////+H///jA///wwP//8P///+Hz//3h4f/8w+H//EPz//wH///8AED//ADA//wB4f/8A/P//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #main-window #title-bar {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #volume {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #volume input {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp #balance {cursor: url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==), auto}\n#webamp-context-menu .context-menu {\n  left: 0px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  cursor: default;\n}\n#webamp-context-menu .context-menu.bottom {\n  top: 12px;\n}\n#webamp-context-menu .context-menu.top {\n  top: 0px;\n}\n#webamp-context-menu .context-menu,\n#webamp-context-menu .context-menu ul {\n  z-index: 50; /* Gross */\n  background-color: #ffffff;\n  position: absolute;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  border: 1px solid #a7a394;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);\n}\n#webamp-context-menu .context-menu li {\n  position: relative;\n  font-family: \"Tahoma\";\n  font-size: 11px;\n  color: black;\n  white-space: nowrap;\n  margin: 2px;\n  padding: 1px 18px 3px 18px;\n  display: block;\n}\n#webamp-context-menu .context-menu li.checked:before {\n  float: left;\n  /* TODO: Use an image */\n  content: \"\\2713\";\n  margin-left: -12px;\n}\n#webamp-context-menu .context-menu li.parent:after {\n  float: right;\n  content: \"\\25b8\";\n  margin-right: -12px;\n}\n#webamp-context-menu .context-menu li a {\n  text-decoration: none;\n  color: black;\n  cursor: default;\n}\n#webamp-context-menu .context-menu li:hover,\n#webamp-context-menu .context-menu li:hover a {\n  background-color: #224eb7;\n  color: #ffffff;\n}\n#webamp-context-menu .context-menu li.hr {\n  padding: 2px 0;\n}\n#webamp-context-menu .context-menu li.hr:hover {\n  background-color: #ffffff;\n}\n#webamp-context-menu .context-menu li.hr hr {\n  border: none;\n  height: 1px;\n  background-color: #a7a394;\n  margin: 0;\n  padding: 0;\n}\n#webamp-context-menu .context-menu ul {\n  display: none;\n  left: 100%;\n  margin-left: -3px;\n}\n#webamp-context-menu .context-menu li:hover > ul {\n  display: block;\n}\n/* Styles */\n#webamp #equalizer-window {\n  height: 116px;\n  width: 275px;\n}\n#webamp #equalizer-window.shade {\n  height: 14px;\n}\n#webamp #equalizer-volume {\n  position: absolute;\n  left: 61px;\n  top: 4px;\n  height: 6px;\n  width: 97px;\n  background-position: 0 0;\n}\n#webamp #equalizer-volume::-webkit-slider-thumb {\n  height: 7px;\n  width: 3px;\n}\n#webamp #equalizer-volume::-moz-range-thumb {\n  height: 7px;\n  width: 3px;\n}\n#webamp #equalizer-balance {\n  position: absolute;\n  left: 164px;\n  top: 4px;\n  height: 6px;\n  width: 43px;\n  background-position: 0 0;\n}\n#webamp #equalizer-balance::-webkit-slider-thumb {\n  height: 7px;\n  width: 3px;\n}\n#webamp #equalizer-balance::-moz-range-thumb {\n  height: 7px;\n  width: 3px;\n}\n#webamp .equalizer-top {\n  height: 14px;\n  width: 275px;\n  position: relative;\n}\n#webamp #equalizer-close {\n  position: absolute;\n  height: 9px;\n  width: 9px;\n  left: 264px;\n  top: 3px;\n}\n#webamp #equalizer-shade {\n  position: absolute;\n  height: 9px;\n  width: 9px;\n  left: 254px;\n  top: 3px;\n}\n#webamp #on {\n  position: absolute;\n  width: 26px;\n  height: 12px;\n  top: 18px;\n  left: 14px;\n}\n#webamp #auto {\n  position: absolute;\n  width: 32px;\n  height: 12px;\n  top: 18px;\n  left: 40px;\n}\n#webamp #presets-context {\n  position: absolute;\n  width: 44px;\n  height: 12px;\n  top: 18px;\n  left: 217px;\n}\n#webamp #presets {\n  width: 100%;\n  height: 100%;\n}\n#webamp #eqGraph {\n  position: absolute;\n  width: 113px;\n  height: 19px;\n  top: 17px;\n  left: 86px;\n}\n#webamp #preamp {\n  position: absolute;\n  left: 21px;\n  top: 38px;\n}\n#webamp #plus12db {\n  position: absolute;\n  left: 45px;\n  top: 36px;\n  width: 22px;\n  height: 8px;\n}\n#webamp #zerodb {\n  position: absolute;\n  left: 45px;\n  top: 64px;\n  width: 22px;\n  height: 8px;\n}\n#webamp #minus12db {\n  position: absolute;\n  left: 45px;\n  top: 95px;\n  width: 22px;\n  height: 8px;\n}\n#webamp #band-60 {\n  position: absolute;\n  left: 78px;\n  top: 38px;\n}\n#webamp #band-170 {\n  position: absolute;\n  left: 96px;\n  top: 38px;\n}\n#webamp #band-310 {\n  position: absolute;\n  left: 114px;\n  top: 38px;\n}\n#webamp #band-600 {\n  position: absolute;\n  left: 132px;\n  top: 38px;\n}\n#webamp #band-1000 {\n  position: absolute;\n  left: 150px;\n  top: 38px;\n}\n#webamp #band-3000 {\n  position: absolute;\n  left: 168px;\n  top: 38px;\n}\n#webamp #band-6000 {\n  position: absolute;\n  left: 186px;\n  top: 38px;\n}\n#webamp #band-12000 {\n  position: absolute;\n  left: 204px;\n  top: 38px;\n}\n#webamp #band-14000 {\n  position: absolute;\n  left: 222px;\n  top: 38px;\n}\n#webamp #band-16000 {\n  position: absolute;\n  left: 240px;\n  top: 38px;\n}\n#webamp .gen-text-space {\n  width: 5px;\n}\n#webamp .gen-text-letter {\n  height: 7px;\n  display: inline-block;\n}\n#webamp .gen-window {\n  /* Default size */\n  width: 275px;\n  height: 116px;\n  display: flex;\n  flex-direction: column;\n}\n#webamp .gen-top {\n  height: 20px;\n  display: flex;\n  flex-direction: row;\n}\n#webamp .gen-top-left {\n  width: 25px;\n  height: 20px;\n}\n#webamp .gen-top-title {\n  line-height: 7px;\n  margin-top: 2px;\n  /* TODO: This should be a conciquence of the repeating tiles, not hard coded */\n  padding: 0 3px 0 4px;\n}\n#webamp .gen-top-left-fill {\n  flex-grow: 1;\n  height: 20px;\n  background-position: left;\n}\n#webamp .gen-top-right-fill {\n  flex-grow: 1;\n  height: 20px;\n  background-position: right;\n}\n#webamp .gen-top-left-end {\n  width: 25px;\n  height: 20px;\n}\n#webamp .gen-top-right {\n  width: 25px;\n  height: 20px;\n}\n#webamp .gen-top-right-end {\n  width: 25px;\n  height: 20px;\n}\n#webamp .gen-close {\n  width: 9px;\n  height: 9px;\n  position: absolute;\n  right: 2px;\n  top: 3px;\n}\n#webamp .gen-middle {\n  flex-grow: 1;\n  display: flex;\n  flex-direction: row;\n  position: relative;\n}\n#webamp .gen-middle-left {\n  width: 11px;\n}\n#webamp .gen-middle-left-bottom {\n  width: 11px;\n  height: 24px;\n  bottom: 0;\n  position: absolute;\n}\n#webamp .gen-middle-center {\n  flex-grow: 1;\n  position: relative;\n}\n#webamp .gen-middle-right {\n  width: 8px;\n}\n#webamp .gen-middle-right-bottom {\n  width: 8px;\n  height: 24px;\n  bottom: 0;\n  position: absolute;\n}\n#webamp .gen-bottom {\n  height: 14px;\n  background-repeat: repeat-x;\n}\n#webamp .gen-bottom-left {\n  position: absolute;\n  left: 0;\n  width: 125px;\n  height: 14px;\n}\n#webamp .gen-bottom-right {\n  position: absolute;\n  right: 0;\n  width: 125px;\n  height: 14px;\n}\n#webamp .gen-bottom-right #gen-resize-target {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  height: 20px;\n  width: 20px;\n}\n/* Styles */\n#webamp #main-window {\n  position: absolute;\n  height: 116px;\n  width: 275px;\n  /* Ask the browser to scale showing large pixels if possible */\n  image-rendering: -moz-crisp-edges; /* Firefox */\n  image-rendering: -o-crisp-edges; /* Opera */\n  image-rendering: -webkit-optimize-contrast; /* Safari */\n  image-rendering: pixelated; /* Only in Chrome > 40 */\n  -ms-interpolation-mode: nearest-neighbor; /* IE (non-standard property) */\n}\n#webamp #title-bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 14px;\n  width: 275px;\n}\n#webamp #option-context,\n#webamp #minimize,\n#webamp #shade,\n#webamp #close {\n  position: absolute;\n  height: 9px;\n  width: 9px;\n  top: 3px;\n}\n#webamp #title-bar #option {\n  width: 100%;\n  height: 100%;\n}\n#webamp #title-bar #option-context {\n  left: 6px;\n}\n#webamp #title-bar #minimize {\n  left: 244px;\n}\n#webamp #title-bar #shade {\n  left: 254px;\n}\n#webamp #title-bar #close {\n  left: 264px;\n}\n#webamp #clutter-bar {\n  position: absolute;\n  top: 22px;\n  left: 10px;\n  height: 43px;\n  width: 8px;\n}\n#webamp #clutter-bar div {\n  position: absolute;\n  height: 7px;\n  width: 8px;\n  left: 0px;\n}\n#webamp #clutter-bar #button-o {\n  top: 3px;\n  height: 8px;\n}\n#webamp #clutter-bar #button-a {\n  top: 11px;\n}\n#webamp #clutter-bar #button-i {\n  top: 18px;\n}\n#webamp #clutter-bar #button-d {\n  top: 25px;\n  height: 8px;\n}\n#webamp #clutter-bar #button-v {\n  top: 33px;\n}\n#webamp #play-pause {\n  position: absolute;\n  top: 28px;\n  left: 26px;\n  height: 9px;\n  width: 9px;\n  background-repeat: no-repeat;\n}\n#webamp .play #work-indicator,\n#webamp #work-indicator.selected {\n  position: absolute;\n  top: 28px;\n  left: 24px;\n  height: 9px;\n  width: 3px;\n}\n#webamp .webamp-status #time {\n  position: absolute;\n  left: 39px;\n  top: 26px;\n  /* Just to make it clickable */\n  height: 13px;\n  width: 59px;\n}\n#webamp .stop .webamp-status #time {\n  display: none;\n}\n#webamp .pause .webamp-status #time {\n  animation: blink 2s step-start 1s infinite;\n  -webkit-animation: blink 2s step-start 1s infinite;\n}\n#webamp .webamp-status #time #minus-sign {\n  /* Note that this get's augmented by the skin CSS if NUM_EX.BMP is present */\n  position: absolute;\n  top: 6px;\n  left: -1px;\n  width: 5px;\n  height: 1px;\n}\n#webamp .webamp-status #time #minute-first-digit {\n  position: absolute;\n  pointer-events: none;\n  left: 9px;\n  height: 13px;\n  width: 9px;\n}\n#webamp .webamp-status #time #minute-second-digit {\n  position: absolute;\n  pointer-events: none;\n  left: 21px;\n  height: 13px;\n  width: 9px;\n}\n#webamp .webamp-status #time #second-first-digit {\n  position: absolute;\n  pointer-events: none;\n  left: 39px;\n  height: 13px;\n  width: 9px;\n}\n#webamp .webamp-status #time #second-second-digit {\n  position: absolute;\n  pointer-events: none;\n  left: 51px;\n  height: 13px;\n  width: 9px;\n}\n#webamp #main-window #visualizer {\n  position: absolute;\n  top: 43px;\n  left: 24px;\n}\n#webamp #main-window.shade #visualizer {\n  top: 5px;\n  left: 79px;\n}\n#webamp .text {\n  display: none;\n}\n#webamp #marquee {\n  position: absolute;\n  left: 111px;\n  top: 24px;\n  width: 154px;\n  height: 6px;\n  overflow: hidden;\n  display: block;\n  padding: 3px 0px; /* Ensure the target is correct for the cursor */\n}\n#webamp .media-info #kbps {\n  position: absolute;\n  left: 111px;\n  top: 43px;\n  width: 15px;\n  height: 6px;\n  overflow: hidden;\n}\n#webamp .stop .media-info #kbps {\n  display: none;\n}\n#webamp .media-info #khz {\n  position: absolute;\n  left: 156px;\n  top: 43px;\n  width: 10px;\n  height: 6px;\n  overflow: hidden;\n}\n#webamp .stop .media-info #khz {\n  display: none;\n}\n#webamp .media-info .mono-stereo {\n  position: absolute;\n  left: 212px;\n  top: 41px;\n  width: 57px;\n  height: 12px;\n}\n#webamp .media-info .mono-stereo div {\n  position: absolute;\n  height: 12px;\n}\n#webamp .media-info .mono-stereo #mono {\n  width: 27px;\n}\n#webamp .media-info .mono-stereo #stereo {\n  left: 27px;\n  width: 29px;\n}\n#webamp #volume {\n  position: absolute;\n  left: 107px;\n  top: 57px;\n  height: 13px;\n  width: 68px;\n  background-position: 0 0;\n}\n#webamp #volume input {\n  height: 13px;\n  /* The input itself, is actually 3px shorter than the background\n     * https://twitter.com/LuigiHann/status/959275940688867328\n     */\n  width: 65px;\n  display: block;\n}\n#webamp #volume input::-webkit-slider-thumb {\n  top: 1px;\n  height: 11px;\n  width: 14px;\n}\n#webamp #volume input::-moz-range-thumb {\n  top: 1px;\n  height: 11px;\n  width: 14px;\n}\n#webamp #balance {\n  position: absolute;\n  left: 177px;\n  top: 57px;\n  height: 13px;\n  width: 38px;\n  background-position: 0 0;\n}\n#webamp #balance::-webkit-slider-thumb {\n  top: 1px;\n  height: 11px;\n  width: 14px;\n}\n#webamp #balance::-moz-range-thumb {\n  top: 1px;\n  height: 11px;\n  width: 14px;\n}\n#webamp .windows {\n  position: absolute;\n  left: 219px;\n  top: 58px;\n  width: 46px;\n  height: 12px;\n}\n#webamp .windows div {\n  position: absolute;\n  width: 23px;\n  height: 12px;\n}\n#webamp .windows #equalizer-button {\n  left: 0;\n}\n#webamp .windows #playlist-button {\n  left: 23px;\n}\n#webamp #position {\n  position: absolute;\n  left: 16px;\n  top: 72px;\n  width: 248px;\n  height: 10px;\n}\n#webamp #position::-webkit-slider-thumb {\n  height: 10px;\n  width: 29px;\n  /*\n     * Fix the strange bug in Safair/mobile-chrome\n     * http://stackoverflow.com/questions/26727769/rendering-glitch-when-manipulating-range-input-value-via-javascript-in-webkit\n     */\n  -webkit-box-sizing: border-box;\n  position: relative;\n}\n#webamp #position::-moz-range-thumb {\n  height: 10px;\n  width: 29px;\n}\n/* For some reason, we can't use display: none here */\n#webamp .stop #position::-webkit-slider-thumb {\n  visibility: hidden;\n}\n#webamp .stop #position::-moz-range-thumb {\n  visibility: hidden;\n}\n/* For some reason this is needed for the position slider to show up now that\n * we are using React.\n */\n#webamp .play #position::-webkit-slider-thumb {\n  visibility: visible;\n}\n#webamp .actions div {\n  height: 18px;\n  width: 23px;\n  position: absolute;\n}\n#webamp .actions #previous {\n  top: 88px;\n  left: 16px;\n}\n#webamp .actions #play {\n  top: 88px;\n  left: 39px;\n}\n#webamp .actions #pause {\n  top: 88px;\n  left: 62px;\n}\n#webamp .actions #stop {\n  top: 88px;\n  left: 85px;\n}\n#webamp .actions #next {\n  top: 88px;\n  left: 108px;\n  width: 22px;\n}\n#webamp #eject {\n  position: absolute;\n  top: 89px;\n  left: 136px;\n  height: 16px;\n  width: 22px;\n}\n#webamp .shuffle-repeat {\n  position: absolute;\n  top: 89px;\n  left: 164px;\n  width: 74px;\n}\n#webamp .shuffle-repeat div {\n  position: absolute;\n  height: 15px;\n}\n#webamp .shuffle-repeat #shuffle {\n  width: 47px;\n}\n#webamp .shuffle-repeat #repeat {\n  left: 46px;\n  width: 28px;\n}\n#webamp #about {\n  position: absolute;\n  top: 91px;\n  left: 253px;\n  height: 15px;\n  width: 13px;\n}\n#webamp .digit {\n  position: absolute;\n  display: inline-block;\n  width: 9px;\n  height: 13px;\n  background-repeat: no-repeat;\n  text-indent: -9999px;\n}\n/* Shade View */\n#webamp #main-window.shade {\n  height: 14px;\n}\n#webamp .shade .media-info,\n#webamp .shade .windows,\n#webamp .shade #volume,\n#webamp .shade #balance,\n#webamp .shade .shuffle-repeat,\n#webamp .shade .webamp-status {\n  display: none;\n}\n#webamp .shade #title-bar {\n}\n#webamp .shade .actions div {\n  position: absolute;\n}\n#webamp .shade .actions #previous,\n#webamp .shade .actions #previous.winamp-active {\n  background: none;\n  height: 10px;\n  width: 7px;\n  top: 2px;\n  left: 169px;\n}\n#webamp .shade .actions #play,\n#webamp .shade .actions #play.winamp-active {\n  background: none;\n  height: 10px;\n  width: 10px;\n  top: 2px;\n  left: 176px;\n}\n#webamp .shade .actions #pause,\n#webamp .shade .actions #pause.winamp-active {\n  background: none;\n  height: 10px;\n  width: 9px;\n  top: 2px;\n  left: 186px;\n}\n#webamp .shade .actions #stop,\n#webamp .shade .actions #stop.winamp-active {\n  background: none;\n  height: 10px;\n  width: 9px;\n  top: 2px;\n  left: 195px;\n}\n#webamp .shade .actions #next,\n#webamp .shade .actions #next.winamp-active {\n  background: none;\n  height: 10px;\n  width: 10px;\n  top: 2px;\n  left: 204px;\n}\n#webamp .shade #eject,\n#webamp .shade #eject.winamp-active {\n  height: 10px;\n  width: 10px;\n  top: 2px;\n  left: 215px;\n  background: none;\n}\n#webamp .shade #position {\n  position: absolute;\n  left: 226px;\n  top: 4px;\n  width: 17px;\n  height: 7px;\n}\n#webamp .shade #position::-webkit-slider-thumb {\n  height: 7px;\n  width: 3px;\n  /* This make it appear. Not sure why */\n  background: none;\n}\n#webamp .shade #position::-moz-range-thumb {\n  height: 7px;\n  width: 3px;\n  /* This make it appear. Not sure why */\n  background: none;\n}\n#webamp #main-window .mini-time {\n  position: absolute;\n  top: 4px;\n  left: 127px;\n}\n.webamp-desktop {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: -1;\n}\n#webamp .mini-time {\n  display: block;\n  height: 6px;\n  width: 25px;\n}\n#webamp .mini-time.blinking .character:not(.background-character) {\n  animation: blink 2s step-start 1s infinite;\n  -webkit-animation: blink 2s step-start 1s infinite;\n}\n#webamp .mini-time .background-character {\n  z-index: 1;\n}\n#webamp .mini-time .character {\n  position: absolute;\n  top: 0;\n  z-index: 2;\n}\n/* Styles */\n#webamp #playlist-window {\n  display: flex;\n  flex-direction: column;\n}\n#webamp .playlist-top {\n  width: 100%;\n  min-height: 20px;\n  max-height: 20px;\n  position: relative;\n  display: flex;\n}\n#webamp .playlist-top-left {\n  width: 25px;\n}\n#webamp .playlist-top-left-spacer {\n  width: 12px;\n}\n#webamp .playlist-top-left-fill {\n  flex-grow: 1;\n  background-position: right;\n}\n#webamp .playlist-top-right-spacer {\n  /* This goes to the right of the center */\n  width: 13px;\n}\n#webamp .playlist-top-right-fill {\n  flex-grow: 1;\n  background-position: right;\n}\n#webamp .playlist-top-title {\n  width: 100px;\n}\n#webamp .playlist-top-right {\n  width: 25px;\n}\n#webamp .playlist-middle {\n  flex-grow: 1;\n  display: flex;\n  flex-direction: row;\n  overflow: hidden;\n}\n#webamp .playlist-middle-left {\n  background-repeat: repeat-y;\n  width: 12px;\n  min-width: 12px;\n}\n#webamp .playlist-middle-center {\n  flex-grow: 1;\n  padding: 3px 0;\n  min-width: 0; /* Not sure why this is needed */\n}\n#webamp .playlist-tracks {\n  display: flex;\n  flex: 1 0 auto;\n}\n#webamp .playlist-tracks .track-cell {\n  height: 13px;\n  line-height: 13px;\n  font-size: 9px;\n  letter-spacing: 0.5px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n#webamp .playlist-track-durations > div {\n  padding-right: 3px;\n  text-align: right;\n}\n#webamp .playlist-track-titles {\n  flex: 1 1 auto;\n  overflow: hidden;\n}\n#webamp .playlist-track-titles > div {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n#webamp .playlist-middle-right {\n  background-repeat: repeat-y;\n  background-position: top right;\n  width: 20px;\n  min-width: 20px;\n  position: relative;\n  padding-bottom: 18px;\n}\n#webamp .playlist-bottom {\n  width: 100%;\n  height: 38px;\n  min-height: 38px;\n  max-height: 38px;\n  position: relative;\n}\n#webamp .playlist-bottom-left {\n  width: 125px;\n  height: 100%;\n  position: absolute;\n}\n#webamp .playlist-menu li {\n  list-style: none;\n  display: none;\n  width: 22px;\n  height: 18px;\n  padding: 0;\n  margin: 0;\n}\n#webamp .playlist-menu li > div {\n  height: 100%;\n}\n#webamp .playlist-menu ul {\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  bottom: 0;\n}\n#webamp .playlist-menu.selected li {\n  display: block;\n}\n#webamp .playlist-menu .bar {\n  position: absolute;\n  bottom: 0;\n  left: -3px;\n  width: 3px;\n  height: 54px;\n}\n#webamp #playlist-add-menu {\n  position: absolute;\n  bottom: 12px;\n  left: 14px;\n  width: 22px;\n  height: 18px;\n}\n#webamp #playlist-remove-menu.playlist-menu .bar {\n  height: 72px;\n}\n#webamp #playlist-remove-menu {\n  position: absolute;\n  bottom: 12px;\n  left: 43px;\n  width: 22px;\n  height: 18px;\n}\n#webamp #playlist-selection-menu {\n  position: absolute;\n  bottom: 12px;\n  left: 72px;\n  width: 22px;\n  height: 18px;\n}\n#webamp #playlist-misc-menu {\n  position: absolute;\n  bottom: 12px;\n  left: 101px;\n  width: 22px;\n  height: 18px;\n}\n#webamp #playlist-list-menu {\n  position: absolute;\n  bottom: 12px;\n  right: 22px;\n  width: 22px;\n  height: 18px;\n}\n#webamp .playlist-bottom-right {\n  width: 150px;\n  height: 100%;\n  position: absolute;\n  right: 0;\n}\n#webamp .playlist-running-time-display {\n  position: absolute;\n  top: 10px;\n  left: 7px;\n  height: 10px;\n}\n#webamp .playlist-action-buttons {\n  position: absolute;\n  top: 22px;\n  left: 3px;\n  display: flex;\n}\n#webamp .playlist-action-buttons > div {\n  height: 10px;\n  width: 10px;\n}\n#webamp #playlist-window .playlist-visualizer {\n  width: 75px;\n  height: 100%;\n  position: absolute;\n  right: 150px;\n}\n#webamp #playlist-window .mini-time {\n  position: absolute;\n  top: 23px;\n  left: 66px;\n}\n#webamp #playlist-window #playlist-resize-target {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  height: 20px;\n  width: 20px;\n}\n#webamp #playlist-close-button {\n  position: absolute;\n  right: 2px;\n  height: 9px;\n  width: 9px;\n  top: 3px;\n}\n#webamp #playlist-shade-button {\n  position: absolute;\n  right: 12px;\n  height: 9px;\n  width: 9px;\n  top: 3px;\n}\n#webamp #playlist-window-shade {\n  height: 14px;\n}\n#webamp #playlist-window-shade .left {\n  height: 14px;\n  background-repeat: no-repeat;\n}\n#webamp #playlist-window-shade .right {\n  height: 14px;\n  background-repeat: no-repeat;\n  background-position-x: right;\n}\n#webamp #playlist-window #playlist-scroll-up-button,\n#webamp #playlist-window #playlist-scroll-down-button {\n  position: absolute;\n  width: 8px;\n  height: 5px;\n  right: 7px;\n}\n#webamp #playlist-window #playlist-scroll-up-button {\n  top: 2px;\n}\n#webamp #playlist-window #playlist-scroll-down-button {\n  top: 8px;\n}\n#webamp #playlist-window-shade #playlist-resize-target {\n  position: absolute;\n  right: 20px;\n  top: 3px;\n  height: 9px;\n  width: 9px;\n}\n#webamp #playlist-shade-track-title {\n  position: absolute;\n  top: 4px;\n  left: 5px;\n}\n#webamp #playlist-shade-time {\n  position: absolute;\n  top: 4px;\n  right: 30px;\n}\n#webamp #playlist-window .visualizer-wrapper {\n  position: absolute;\n  top: 12px;\n  left: 2px;\n  width: 72px;\n  overflow: hidden;\n}\n/* Rules used by all windows */\n#webamp {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n/* Prevent accidental highlighting */\n#webamp canvas {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n#webamp * {\n  /* Some environments globably change the box-sizing */\n  box-sizing: content-box;\n  -webkit-box-sizing: content-box;\n}\n#webamp *:focus {\n  outline: 0;\n}\n/* Range input css reset */\n#webamp input[type=\"range\"] {\n  -webkit-appearance: none;\n  margin: 0;\n  padding: 0;\n  background: none;\n  border: none;\n}\n#webamp input[type=\"range\"]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  border: none;\n  border-radius: 0;\n  background: none;\n}\n#webamp input[type=\"range\"]::-moz-range-thumb {\n  border: none;\n  border-radius: 0;\n  background: none;\n}\n#webamp input[type=\"range\"]::-moz-range-track {\n  border: none;\n  background: none;\n}\n#webamp input[type=\"range\"]:focus {\n  outline: none;\n}\n#webamp input[type=\"range\"]::-moz-focus-outer {\n  border: 0;\n}\n#webamp a:focus {\n  outline: none;\n}\n/* Animation */\n@keyframes blink {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@-webkit-keyframes blink {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n#webamp .character {\n  display: inline-block;\n  vertical-align: top;\n  width: 5px;\n  height: 6px;\n  /* background-image: TEXT.BMP via Javascript */\n  text-indent: -9999px;\n}\n#webamp .window {\n  position: absolute;\n  /* Ask the browser to scale showing large pixels if possible */\n  image-rendering: -moz-crisp-edges; /* Firefox */\n  image-rendering: -o-crisp-edges; /* Opera */\n  image-rendering: -webkit-optimize-contrast; /* Safari */\n  image-rendering: pixelated; /* Only in Chrome > 40 */\n  -ms-interpolation-mode: nearest-neighbor; /* IE (non-standard property) */\n}\n#webamp .window {\n  /* Work around rendering bug with clip-path */\n  -webkit-transform: translateZ(0);\n}\n#webamp .window.doubled {\n  -moz-transform: translateZ(0) scale(2);\n  -moz-transform-origin: top left;\n  -webkit-transform: translateZ(0) scale(2);\n  -webkit-transform-origin: top left;\n}\n";

	/**
	 * Constructs the windows to render
	 */
	function App({ media, filePickers, onMount, parentDomNode, }) {
	    const closed = useTypedSelector(getClosed);
	    const genWindowsInfo = useTypedSelector(getGenWindows);
	    const zIndex = useTypedSelector(getZIndex);
	    const browserWindowSizeChanged$1 = useActionCreator(browserWindowSizeChanged);
	    const setFocusedWindow$1 = useActionCreator(setFocusedWindow);
	    const [webampNode] = reactExports.useState(() => {
	        const node = document.createElement("div");
	        node.id = "webamp";
	        // @ts-ignore I think I'm supposed to set this with setAttribute, but I can't confirm.
	        node.role = "application";
	        return node;
	    });
	    reactExports.useLayoutEffect(() => {
	        webampNode.style.zIndex = String(zIndex);
	    }, [webampNode, zIndex]);
	    reactExports.useLayoutEffect(() => {
	        parentDomNode.appendChild(webampNode);
	        return () => {
	            parentDomNode.removeChild(webampNode);
	        };
	    }, [webampNode, parentDomNode]);
	    reactExports.useEffect(() => {
	        const handleWindowResize = () => {
	            if (webampNode == null) {
	                return;
	            }
	            // It's a bit tricky to measure the "natural" size of the browser window.
	            // Specifically we want to know how large the window would be without our
	            // own Webamp windows influencing it. To achieve this, we temporarily make
	            // our container `overflow: hidden;`. We then make our container full
	            // screen by setting the bottom/right properties to zero. This second part
	            // allows our Webamp windows to stay visible during the resize. After we
	            // measure, we set the style back so that we don't end up interfering with
	            // click events outside of our Webamp windows.
	            webampNode.style.right = "0";
	            webampNode.style.bottom = "0";
	            webampNode.style.overflow = "hidden";
	            browserWindowSizeChanged$1(getWindowSize$1());
	            webampNode.style.right = "auto";
	            webampNode.style.bottom = "auto";
	            webampNode.style.overflow = "visible";
	        };
	        handleWindowResize();
	        window.addEventListener("resize", handleWindowResize);
	        return () => {
	            window.removeEventListener("resize", handleWindowResize);
	        };
	    }, [browserWindowSizeChanged$1, webampNode]);
	    reactExports.useEffect(() => {
	        if (onMount != null) {
	            onMount();
	        }
	    }, [onMount]);
	    const renderWindows = reactExports.useCallback(() => {
	        return objectMap(genWindowsInfo, (w, id) => {
	            if (!w.open) {
	                return null;
	            }
	            switch (id) {
	                case WINDOWS.MAIN:
	                    return (jsxRuntimeExports.jsx(MainWindow, { analyser: media.getAnalyser(), filePickers: filePickers }));
	                case WINDOWS.EQUALIZER:
	                    return jsxRuntimeExports.jsx(EqualizerWindow, {});
	                case WINDOWS.PLAYLIST:
	                    return jsxRuntimeExports.jsx(PlaylistWindow, { analyser: media.getAnalyser() });
	                case WINDOWS.MILKDROP:
	                    return jsxRuntimeExports.jsx(Milkdrop, { analyser: media.getAnalyser() });
	                default:
	                    throw new Error(`Tried to render an unknown window: ${id}`);
	            }
	        });
	    }, [media, filePickers, genWindowsInfo]);
	    const handleBlur = (e) => {
	        if (!e.currentTarget.contains(e.relatedTarget)) {
	            setFocusedWindow$1(null);
	        }
	    };
	    if (closed) {
	        return null;
	    }
	    return ReactDOM$2.createPortal(jsxRuntimeExports.jsxs(reactExports.StrictMode, { children: [jsxRuntimeExports.jsx(Css, { children: css_248z }), jsxRuntimeExports.jsxs("div", { onBlur: handleBlur, children: [jsxRuntimeExports.jsx(Skin, {}), jsxRuntimeExports.jsx(ContextMenuWraper, { renderContents: () => jsxRuntimeExports.jsx(MainContextMenu, { filePickers: filePickers }), children: jsxRuntimeExports.jsx(WindowManager, { windows: renderWindows() }) })] })] }), webampNode);
	}

	const IGNORE_EVENTS_FROM_TAGS = new Set(["input", "textarea", "select"]);
	function bindHotkeys(dispatch) {
	    let currentPos = 0;
	    const trigger = [
	        78, // N
	        85, // U
	        76, // L
	        76, // L
	        83, // S
	        79, // O
	        70, // F
	        84, // T
	    ];
	    const listener = (e) => {
	        if (e.target instanceof Element &&
	            IGNORE_EVENTS_FROM_TAGS.has(e.target.tagName.toLowerCase())) {
	            return;
	        }
	        if (e.ctrlKey) {
	            switch (e.keyCode) {
	                case 68: // CTRL+D
	                    dispatch(toggleDoubleSizeMode());
	                    e.preventDefault(); // Supress the "Bookmark" action on windows.
	                    break;
	                case 76: // CTRL+L FIXME
	                    break;
	                case 82: // CTRL+R
	                    dispatch(reverseList());
	                    break;
	                case 84: // CTRL+T
	                    dispatch({ type: "TOGGLE_TIME_MODE" });
	                    break;
	            }
	        }
	        else if (e.altKey) {
	            switch (e.keyCode) {
	                case 87: // ALT+W
	                    dispatch(toggleWindow("main"));
	                    break;
	                case 69: // ALT+E
	                    dispatch(toggleWindow("playlist"));
	                    break;
	                case 71: // ALT+G
	                    dispatch(toggleWindow("equalizer"));
	                    break;
	            }
	        }
	        else {
	            switch (e.keyCode) {
	                case 37: // left arrow
	                    dispatch(seekBackward(5));
	                    break;
	                case 38: // up arrow
	                    dispatch(adjustVolume(1));
	                    break;
	                case 39: // right arrow
	                    dispatch(seekForward(5));
	                    break;
	                case 40: // down arrow
	                    dispatch(adjustVolume(-1));
	                    break;
	                case 66: // B
	                    dispatch(next());
	                    break;
	                case 67: // C
	                    dispatch(pause());
	                    break;
	                case 76: // L
	                    dispatch(openMediaFileDialog());
	                    break;
	                case 82: // R
	                    dispatch(toggleRepeat());
	                    break;
	                case 83: // S
	                    dispatch(toggleShuffle());
	                    break;
	                case 86: // V
	                    dispatch(stop());
	                    break;
	                case 88: // X
	                    dispatch(play());
	                    break;
	                case 90: // Z
	                    dispatch(previous());
	                    break;
	                case 96: // numpad 0
	                    dispatch(openMediaFileDialog());
	                    break;
	                case 97: // numpad 1
	                    dispatch(nextN(-10));
	                    break;
	                case 98: // numpad 2
	                    dispatch(adjustVolume(-1));
	                    break;
	                case 99: // numpad 3
	                    dispatch(nextN(10));
	                    break;
	                case 100: // numpad 4
	                    dispatch(previous());
	                    break;
	                case 101: // numpad 5
	                    dispatch(play());
	                    break;
	                case 102: // numpad 6
	                    dispatch(next());
	                    break;
	                case 103: // numpad 7
	                    dispatch(seekBackward(5));
	                    break;
	                case 104: // numpad 8
	                    dispatch(adjustVolume(1));
	                    break;
	                case 105: // numpad 9
	                    dispatch(seekForward(5));
	                    break;
	            }
	        }
	        // Easter Egg
	        // Ignore escape. Usually this gets swallowed by the browser, but not always.
	        if (e.keyCode !== 27) {
	            currentPos = e.keyCode === trigger[currentPos] ? currentPos + 1 : 0;
	            if (currentPos === trigger.length) {
	                dispatch({ type: "TOGGLE_LLAMA_MODE" });
	            }
	        }
	    };
	    document.addEventListener("keydown", listener);
	    return () => {
	        document.removeEventListener("keydown", listener);
	    };
	}

	class Emitter {
	    _listeners;
	    constructor() {
	        this._listeners = {};
	    }
	    on(event, callback) {
	        const eventListeners = this._listeners[event] || [];
	        eventListeners.push(callback);
	        this._listeners[event] = eventListeners;
	        const unsubscribe = () => {
	            this._listeners[event] = eventListeners.filter((cb) => cb !== callback);
	        };
	        return unsubscribe;
	    }
	    trigger(event, ...args) {
	        const callbacks = this._listeners[event];
	        if (callbacks) {
	            callbacks.forEach((cb) => cb(...args));
	        }
	    }
	    dispose() {
	        this._listeners = {};
	    }
	}

	class Disposable {
	    _teardowns = [];
	    disposed;
	    constructor() {
	        this.disposed = false;
	    }
	    add(...teardowns) {
	        if (this.disposed) {
	            throw new Error("Attempted to add a new teardown to a disposed disposable.");
	        }
	        this._teardowns.push(...teardowns);
	    }
	    dispose() {
	        if (this.disposed) {
	            throw new Error("Attempted to dispose disposable which is already disposed.");
	        }
	        this._teardowns.forEach((teardown) => {
	            if (typeof teardown === "function") {
	                teardown();
	            }
	            else if (typeof teardown.dispose === "function") {
	                teardown.dispose();
	            }
	        });
	        this._teardowns = [];
	        this.disposed = true;
	    }
	}

	// The Web Audio API does not offer an easy way to make a stereo balance
	// control. This is an attempt to fill that void, using an API similar to
	// [StereoPannerNode](https://developer.mozilla.org/en-US/docs/Web/API/StereoPannerNode)
	function StereoBalanceNode(context, options = {
	  balance: 0
	}) {
	  let balance = 0;

	  // ChannelSplitterNode cannot be told to use a `channelInterperatation` of
	  // "speakers". This means that if we get a mono file, we will end up only
	  // playing in the left speaker. So instead we use this dummy gain node to
	  // convert whatever source we get (stereo, mono, or n channels) into a stereo
	  // signal.
	  // Idea credit: https://github.com/WebAudio/web-audio-api/issues/975#issue-177242377
	  const upMixer = context.createGain();
	  upMixer.channelCount = 2;
	  upMixer.channelCountMode = "explicit";
	  upMixer.channelInterpretation = "speakers";
	  const splitter = context.createChannelSplitter(2);

	  // Create the gains for left and right
	  const leftGain = context.createGain();
	  const rightGain = context.createGain();
	  const merger = context.createChannelMerger(2);
	  upMixer.connect(splitter);
	  splitter.connect(leftGain, 0);
	  splitter.connect(rightGain, 1);
	  leftGain.connect(merger, 0, 0);
	  rightGain.connect(merger, 0, 1);

	  // -1 (left) to 1 (right)
	  function set(rawValue) {
	    const value = Number(rawValue);
	    leftGain.gain.value = value > 0 ? 1 - value : 1;
	    rightGain.gain.value = value > 0 ? 1 : 1 + value;
	    balance = value;
	  }
	  function get() {
	    return balance;
	  }

	  // Create our own version of an [AudioParam](https://developer.mozilla.org/en-US/docs/Web/API/AudioParam).
	  // We don't currently support any of the "over time" methods, but maybe some day
	  // we'll want to.
	  const audioParam = {};
	  Object.defineProperties(audioParam, {
	    value: {
	      get,
	      set,
	      enumerable: true,
	      configurable: true
	    }
	  });

	  // The way the `.connect` API works, we can't actually construct our own
	  // AudioNode. Instead we have to take an existing node and monkey patch it.
	  Object.defineProperties(upMixer, {
	    balance: {
	      value: audioParam,
	      enumerable: true,
	      writable: false,
	      configurable: true
	    },
	    connect: {
	      value: AudioNode.prototype.connect.bind(merger),
	      enumerable: false,
	      writable: false,
	      configurable: true
	    },
	    disconnect: {
	      value: AudioNode.prototype.disconnect.bind(merger),
	      enumerable: false,
	      writable: false,
	      configurable: true
	    }
	  });
	  if (balance !== options.balance) {
	    set(options.balance);
	  }
	  return upMixer;
	}

	class ElementSource {
	    _emitter;
	    _context;
	    _source;
	    _destination;
	    _audio;
	    _stalled;
	    _status;
	    _disposable;
	    on(eventType, cb) {
	        return this._emitter.on(eventType, cb);
	    }
	    constructor(context, destination) {
	        this._emitter = new Emitter();
	        this._context = context;
	        this._destination = destination;
	        this._audio = document.createElement("audio");
	        this._audio.crossOrigin = "anonymous";
	        this._stalled = false;
	        this._status = MEDIA_STATUS.STOPPED;
	        this._disposable = new Disposable();
	        // Create event handlers and register cleanup
	        const suspendHandler = () => {
	            this._setStalled(true);
	        };
	        this._audio.addEventListener("suspend", suspendHandler);
	        this._disposable.add(() => this._audio.removeEventListener("suspend", suspendHandler));
	        const durationChangeHandler = () => {
	            this._emitter.trigger("loaded");
	            this._setStalled(false);
	        };
	        this._audio.addEventListener("durationchange", durationChangeHandler);
	        this._disposable.add(() => this._audio.removeEventListener("durationchange", durationChangeHandler));
	        const endedHandler = () => {
	            this._emitter.trigger("ended");
	            this._setStatus(MEDIA_STATUS.STOPPED);
	        };
	        this._audio.addEventListener("ended", endedHandler);
	        this._disposable.add(() => this._audio.removeEventListener("ended", endedHandler));
	        const timeUpdateHandler = () => {
	            this._emitter.trigger("positionChange");
	        };
	        this._audio.addEventListener("timeupdate", timeUpdateHandler);
	        this._disposable.add(() => this._audio.removeEventListener("timeupdate", timeUpdateHandler));
	        const errorHandler = (e) => {
	            switch (this._audio.error.code) {
	                case 1:
	                    // The fetching of the associated resource was aborted by the user's request.
	                    console.error("MEDIA_ERR_ABORTED", e);
	                    break;
	                case 2:
	                    console.error("MEDIA_ERR_NETWORK", e);
	                    // Some kind of network error occurred which prevented the media from being successfully fetched, despite having previously been available.
	                    break;
	                case 3:
	                    // Despite having previously been determined to be usable, an error occurred while trying to decode the media resource, resulting in an error.
	                    // There is a bug in Chrome where improperly terminated mp3s can cuase this error.
	                    // https://bugs.chromium.org/p/chromium/issues/detail?id=794782
	                    // Related: Commit f44e826c83c74fef04c2c448af30cfb353b28312
	                    console.error("PIPELINE_ERROR_DECODE", e);
	                    break;
	                case 4:
	                    console.error("MEDIA_ERR_SRC_NOT_SUPPORTED", e);
	                    // The associated resource or media provider object (such as a MediaStream) has been found to be unsuitable.
	                    break;
	            }
	            // Rather than just geting stuck in this error state, we can just pretend this is
	            // the end of the track.
	            this._emitter.trigger("ended");
	            this._setStatus(MEDIA_STATUS.STOPPED);
	        };
	        this._audio.addEventListener("error", errorHandler);
	        this._disposable.add(() => this._audio.removeEventListener("error", errorHandler));
	        this._source = this._context.createMediaElementSource(this._audio);
	        this._source.connect(destination);
	    }
	    _setStalled(stalled) {
	        this._stalled = stalled;
	        this._emitter.trigger("stallChanged");
	    }
	    disconnect() {
	        this._source.disconnect();
	    }
	    // Async for now, for compatibility with BufferAudioSource
	    // TODO: This does not need to be async
	    async loadUrl(url) {
	        this._audio.src = url;
	    }
	    async play() {
	        if (this._status !== MEDIA_STATUS.PAUSED) {
	            this.seekToTime(0);
	        }
	        try {
	            await this._audio.play();
	            // TODO #race
	        }
	        catch (err) {
	            //
	        }
	        this._setStatus(MEDIA_STATUS.PLAYING);
	    }
	    pause() {
	        this._audio.pause();
	        this._setStatus(MEDIA_STATUS.PAUSED);
	    }
	    stop() {
	        this._audio.pause();
	        this._audio.currentTime = 0;
	        this._setStatus(MEDIA_STATUS.STOPPED);
	    }
	    seekToTime(time) {
	        /* TODO: We could check if this is actually seekable:
	        const { seekable } = this._audio;
	        for (let i = 0; i < seekable.length; i++) {
	          console.log("start", seekable.start(i), "end", seekable.end(i));
	        }
	        */
	        this._audio.currentTime = clamp(time, 0, this.getDuration());
	        this._emitter.trigger("positionChange");
	    }
	    getStalled() {
	        return this._stalled;
	    }
	    getStatus() {
	        return this._status;
	    }
	    getDuration() {
	        const { duration } = this._audio;
	        // Safari on iOS currently has a strange behavior where it reports
	        // the duration as infinity if an Accept-Ranges header is not returned.
	        // For now, 0 is better even though it's still wrong.
	        return isNaN(duration) || duration === Infinity ? 0 : duration;
	    }
	    getTimeElapsed() {
	        return this._audio.currentTime;
	    }
	    _setStatus(status) {
	        this._status = status;
	        this._emitter.trigger("statusChange");
	    }
	    dispose() {
	        // Clean up all event listeners via disposable
	        this._disposable.dispose();
	        this.stop();
	        this._emitter.dispose();
	    }
	}

	/* Emulate the native <audio> element with Web Audio API */
	// NOTE: While this is not technically a public API, https://winampify.io/ is
	// replacing this class with a custom version. Breaking changes to this API
	// surface should be communicated to Remi.
	class Media {
	    _emitter;
	    _context;
	    _balance;
	    _staticSource;
	    _preamp;
	    _analyser;
	    _gainNode;
	    _source;
	    _bands;
	    _disposable;
	    constructor() {
	        this._emitter = new Emitter();
	        this._disposable = new Disposable();
	        // @ts-ignore Typescript does not know about webkitAudioContext
	        this._context = new (window.AudioContext || window.webkitAudioContext)();
	        // Fix for iOS and Chrome (Canary) which require that the context be created
	        // or resumed by a user interaction.
	        // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes
	        // https://gist.github.com/laziel/7aefabe99ee57b16081c
	        // Via: https://stackoverflow.com/a/43395068/1263117
	        if (this._context.state === "suspended") {
	            const resumeHandler = async () => {
	                await this._context.resume();
	                if (this._context.state === "running") {
	                    document.body.removeEventListener("touchend", resumeHandler, false);
	                    document.body.removeEventListener("click", resumeHandler, false);
	                    document.body.removeEventListener("keydown", resumeHandler, false);
	                }
	            };
	            document.body.addEventListener("touchend", resumeHandler, false);
	            document.body.addEventListener("click", resumeHandler, false);
	            document.body.addEventListener("keydown", resumeHandler, false);
	            // Add cleanup for resume handlers
	            this._disposable.add(() => {
	                document.body.removeEventListener("touchend", resumeHandler, false);
	                document.body.removeEventListener("click", resumeHandler, false);
	                document.body.removeEventListener("keydown", resumeHandler, false);
	            });
	        }
	        // TODO: Maybe we can get rid of this now that we are using AudioAbstraction?
	        this._staticSource = this._context.createGain(); // Just a noop node
	        // @ts-ignore The way this class has to be monkey patched, makes it very hard to type.
	        this._balance = new StereoBalanceNode(this._context);
	        // Create the preamp node
	        this._preamp = this._context.createGain();
	        // Create the analyser node for the visualizer
	        this._analyser = this._context.createAnalyser();
	        this._analyser.fftSize = 2048;
	        // don't smooth audio analysis
	        this._analyser.smoothingTimeConstant = 0.0;
	        // Create the gain node for the volume control
	        this._gainNode = this._context.createGain();
	        // Connect all the nodes in the correct way
	        // (Note, source is created and connected later)
	        //
	        //                <source>
	        //                    |
	        //                    |_____________
	        //                    |             \
	        //                <preamp>          |
	        //                    |             | <-- Optional bypass
	        //           [...biquadFilters]     |
	        //                    |_____________/
	        //                    |
	        //              <staticSource>
	        //                    |
	        //                <balance>
	        //                    |
	        //                    |\
	        //                    | <analyser>
	        //                  <gain>
	        //                    |
	        //              <destination>
	        this._source = new ElementSource(this._context, this._staticSource);
	        this._source.on("positionChange", () => {
	            this._emitter.trigger("timeupdate");
	        });
	        this._source.on("ended", () => {
	            this._emitter.trigger("ended");
	        });
	        this._source.on("statusChange", () => {
	            switch (this._source.getStatus()) {
	                case MEDIA_STATUS.PLAYING:
	                    this._emitter.trigger("playing");
	                    break;
	            }
	            this._emitter.trigger("timeupdate");
	        });
	        this._source.on("loaded", () => {
	            this._emitter.trigger("fileLoaded");
	        });
	        this._staticSource.connect(this._preamp);
	        let output = this._preamp;
	        this._bands = {};
	        BANDS.forEach((band, i) => {
	            const filter = this._context.createBiquadFilter();
	            this._bands[band] = filter;
	            if (i === 0) {
	                // The first filter, includes all lower frequencies
	                filter.type = "lowshelf";
	            }
	            else if (i === BANDS.length - 1) {
	                // The last filter, includes all higher frequencies
	                filter.type = "highshelf";
	            }
	            else {
	                filter.type = "peaking";
	            }
	            filter.frequency.value = band;
	            filter.gain.value = 0;
	            output.connect(filter);
	            output = filter;
	        });
	        output.connect(this._balance);
	        this._balance.connect(this._gainNode);
	        this._balance.connect(this._analyser);
	        this._gainNode.connect(this._context.destination);
	    }
	    getAnalyser() {
	        return this._analyser;
	    }
	    /* Properties */
	    duration() {
	        return this._source.getDuration();
	    }
	    timeElapsed() {
	        return this._source.getTimeElapsed();
	    }
	    timeRemaining() {
	        return this.duration() - this.timeElapsed();
	    }
	    percentComplete() {
	        return (this.timeElapsed() / this.duration()) * 100;
	    }
	    /* Actions */
	    async play() {
	        await this._source.play();
	    }
	    pause() {
	        this._source.pause();
	    }
	    stop() {
	        this._source.stop();
	    }
	    /* Actions with arguments */
	    seekToPercentComplete(percent) {
	        const seekTime = this.duration() * (percent / 100);
	        this.seekToTime(seekTime);
	    }
	    // From 0-1
	    setVolume(volume) {
	        this._gainNode.gain.value = volume / 100;
	    }
	    // from 0 to 100
	    // The input value here is 0-100 which is kinda wrong, since it represents -12db to 12db.
	    // For now, 50 is 0db (no change).
	    // Equation used is: 10^((dB)/20) = x, where x (preamp.gain.value) is passed on to gainnode for boosting or attenuation.
	    setPreamp(value) {
	        const db = (value / 100) * 24 - 12;
	        this._preamp.gain.value = Math.pow(10, db / 20);
	    }
	    // From -100 to 100
	    setBalance(balance) {
	        // Yo Dawg.
	        this._balance.balance.value = balance / 100;
	    }
	    setEqBand(band, value) {
	        const db = (value / 100) * 24 - 12;
	        this._bands[band].gain.value = db;
	    }
	    disableEq() {
	        this._staticSource.disconnect();
	        this._staticSource.connect(this._balance);
	    }
	    enableEq() {
	        this._staticSource.disconnect();
	        this._staticSource.connect(this._preamp);
	    }
	    /* Listeners */
	    on(event, callback) {
	        this._emitter.on(event, callback);
	    }
	    seekToTime(time) {
	        this._source.seekToTime(time);
	    }
	    // Used only for the initial load, since it must have a CORS header
	    async loadFromUrl(url, autoPlay) {
	        this._emitter.trigger("waiting");
	        await this._source.loadUrl(url);
	        // TODO #race
	        this._emitter.trigger("stopWaiting");
	        if (autoPlay) {
	            this.play();
	        }
	    }
	    dispose() {
	        // Clean up all event listeners via disposable
	        this._disposable.dispose();
	        this._source.dispose();
	        this._emitter.dispose();
	    }
	}

	function enableMediaSession(webamp) {
	    if ("mediaSession" in navigator) {
	        /* global MediaMetadata */
	        webamp.onTrackDidChange((track) => {
	            if (track == null) {
	                return;
	            }
	            const { metaData: { title, artist, album, albumArtUrl }, } = track;
	            navigator.mediaSession.metadata = new MediaMetadata({
	                title: title ?? undefined,
	                artist: artist ?? undefined,
	                album: album ?? undefined,
	                artwork: albumArtUrl
	                    ? [
	                        {
	                            src: albumArtUrl,
	                            // We don't currently know these.
	                            // sizes: "96x96",
	                            // type: "image/png"
	                        },
	                    ]
	                    : [],
	            });
	        });
	        // @ts-ignore TypeScript does not know about the Media Session API: https://github.com/Microsoft/TypeScript/issues/19473
	        navigator.mediaSession.setActionHandler("play", () => {
	            webamp.play();
	        });
	        // @ts-ignore TypeScript does not know about the Media Session API: https://github.com/Microsoft/TypeScript/issues/19473
	        navigator.mediaSession.setActionHandler("pause", () => {
	            webamp.pause();
	        });
	        // @ts-ignore TypeScript does not know about the Media Session API: https://github.com/Microsoft/TypeScript/issues/19473
	        navigator.mediaSession.setActionHandler("seekbackward", () => {
	            webamp.seekBackward(10);
	        });
	        // @ts-ignore TypeScript does not know about the Media Session API: https://github.com/Microsoft/TypeScript/issues/19473
	        navigator.mediaSession.setActionHandler("seekforward", () => {
	            webamp.seekForward(10);
	        });
	        // @ts-ignore TypeScript does not know about the Media Session API: https://github.com/Microsoft/TypeScript/issues/19473
	        navigator.mediaSession.setActionHandler("previoustrack", () => {
	            webamp.previousTrack();
	        });
	        // @ts-ignore TypeScript does not know about the Media Session API: https://github.com/Microsoft/TypeScript/issues/19473
	        navigator.mediaSession.setActionHandler("nexttrack", () => {
	            webamp.nextTrack();
	        });
	    }
	}

	let Webamp$1 = class Webamp {
	    static VERSION = "2.2.0";
	    _actionEmitter;
	    _root;
	    _disposable;
	    options; // TODO: Make this _private
	    media; // TODO: Make this _private
	    store; // TODO: Make this _private
	    /**
	     * Returns a true if the current browser supports the features that Webamp depends upon.
	     *
	     * It is recommended to check this before you attempt to instantiate an instance of Winamp.
	     */
	    static browserIsSupported() {
	        const supportsAudioApi = !!(window.AudioContext ||
	            // @ts-ignore
	            window.webkitAudioContext);
	        const supportsCanvas = !!window.document.createElement("canvas").getContext;
	        const supportsPromises = typeof Promise !== "undefined";
	        return supportsAudioApi && supportsCanvas && supportsPromises;
	    }
	    constructor(options) {
	        this._root = null;
	        this._disposable = new Disposable();
	        this._actionEmitter = new Emitter();
	        this.options = options;
	        const { initialTracks, initialSkin, availableSkins, enableHotkeys = false, zIndex, requireJSZip, requireMusicMetadata, handleTrackDropEvent, handleAddUrlEvent, handleLoadListEvent, handleSaveListEvent, enableDoubleSizeMode, __butterchurnOptions, __customMediaClass, } = this.options;
	        // TODO: Make this much cleaner.
	        let convertPreset = null;
	        if (__butterchurnOptions != null) {
	            const { importConvertPreset, presetConverterEndpoint } = __butterchurnOptions;
	            if (importConvertPreset != null && presetConverterEndpoint != null) {
	                convertPreset = async (file) => {
	                    const { convertPreset: convert } = await importConvertPreset();
	                    return convert(await genStringFromFileReference(file), presetConverterEndpoint);
	                };
	            }
	        }
	        // TODO: Validate required options.
	        this.media = new (__customMediaClass || Media)();
	        this.store = createWebampStore(this.media, this._actionEmitter, this.options.__customMiddlewares, this.options.__initialState, {
	            requireJSZip,
	            requireMusicMetadata,
	            convertPreset,
	            // @ts-ignore Typescript is drunk.
	            handleTrackDropEvent,
	            handleAddUrlEvent,
	            handleLoadListEvent,
	            handleSaveListEvent,
	        });
	        if (options.enableMediaSession) {
	            enableMediaSession(this);
	        }
	        if (enableDoubleSizeMode) {
	            this.store.dispatch(toggleDoubleSizeMode());
	        }
	        if (navigator.onLine) {
	            this.store.dispatch({ type: "NETWORK_CONNECTED" });
	        }
	        else {
	            this.store.dispatch({ type: "NETWORK_DISCONNECTED" });
	        }
	        if (zIndex != null) {
	            this.store.dispatch({ type: "SET_Z_INDEX", zIndex });
	        }
	        if (options.__butterchurnOptions) {
	            this.store.dispatch({
	                type: "ENABLE_MILKDROP",
	                open: options.__butterchurnOptions.butterchurnOpen,
	            });
	            this.store.dispatch(initializePresets(options.__butterchurnOptions));
	        }
	        const handleOnline = () => this.store.dispatch({ type: "NETWORK_CONNECTED" });
	        const handleOffline = () => this.store.dispatch({ type: "NETWORK_DISCONNECTED" });
	        window.addEventListener("online", handleOnline);
	        window.addEventListener("offline", handleOffline);
	        this._disposable.add(() => {
	            window.removeEventListener("online", handleOnline);
	            window.removeEventListener("offline", handleOffline);
	        });
	        if (initialSkin) {
	            this.store.dispatch(setSkinFromUrl(initialSkin.url));
	        }
	        else {
	            // We are using the default skin.
	            this.store.dispatch({ type: "LOADED" });
	        }
	        if (initialTracks) {
	            this._bufferTracks(initialTracks);
	        }
	        // @ts-ignore
	        if (options.avaliableSkins != null) {
	            console.warn("The misspelled option `avaliableSkins` is deprecated. Please use `availableSkins` instead.");
	            // @ts-ignore
	            this.store.dispatch({
	                type: "SET_AVAILABLE_SKINS",
	                // @ts-ignore
	                skins: options.avaliableSkins,
	            });
	        }
	        else if (availableSkins != null) {
	            this.store.dispatch({
	                type: "SET_AVAILABLE_SKINS",
	                skins: availableSkins,
	            });
	        }
	        this.store.dispatch(setWindowLayout(options.windowLayout));
	        if (enableHotkeys) {
	            this._disposable.add(bindHotkeys(this.store.dispatch));
	        }
	    }
	    /**
	     * Play the current track.
	     */
	    play() {
	        this.store.dispatch(play());
	    }
	    /**
	     * Pause the current track.
	     */
	    pause() {
	        this.store.dispatch(pause());
	    }
	    /**
	     * Stop the currently playing audio. Equivalent to pressing the "stop" button.
	     */
	    stop() {
	        this.store.dispatch(stop());
	    }
	    /**
	     * Set volume from 0 - 100.
	     */
	    setVolume(volume) {
	        this.store.dispatch(setVolume(volume));
	    }
	    /**
	     * Seek backward n seconds in the current track.
	     */
	    seekBackward(seconds) {
	        this.store.dispatch(seekBackward(seconds));
	    }
	    /**
	     * Seek forward n seconds in the current track.
	     */
	    seekForward(seconds) {
	        this.store.dispatch(seekForward(seconds));
	    }
	    /**
	     * Seek to a given time within the current track.
	     */
	    seekToTime(seconds) {
	        this.store.dispatch(seekToTime(seconds));
	    }
	    /**
	     * Check if shuffle is enabled.
	     */
	    isShuffleEnabled() {
	        return getShuffle(this.store.getState());
	    }
	    /**
	     * Toggle shuffle mode between enabled and disabled.
	     */
	    toggleShuffle() {
	        this.store.dispatch(toggleShuffle());
	    }
	    /**
	     * Check if repeat is enabled.
	     */
	    isRepeatEnabled() {
	        return getRepeat(this.store.getState());
	    }
	    /**
	     * Toggle repeat mode between enabled and disabled.
	     */
	    toggleRepeat() {
	        this.store.dispatch(toggleRepeat());
	    }
	    /**
	     * Play the next track.
	     */
	    nextTrack() {
	        this.store.dispatch(next());
	    }
	    /**
	     * Play the previous track.
	     */
	    previousTrack() {
	        this.store.dispatch(previous());
	    }
	    /**
	     * Set the current track to a specific track in the playlist by zero-based index.
	     *
	     * Note: If Webamp is currently playing, the track will begin playing. If
	     * Webamp is not playing, the track will not start playing. You can use
	     * `webamp.pause()` before calling this method or `webamp.play()` after
	     * calling this method to control whether the track starts playing.
	     */
	    setCurrentTrack(index) {
	        this.store.dispatch(playTrack(index));
	    }
	    /**
	     * Add an array of `Track`s to the end of the playlist.
	     */
	    appendTracks(tracks) {
	        const nextIndex = getTrackCount(this.store.getState());
	        this.store.dispatch(loadMediaFiles(tracks, LOAD_STYLE.NONE, nextIndex));
	    }
	    /**
	     * Replace the playlist with an array of `Track`s and begin playing the first track.
	     */
	    setTracksToPlay(tracks) {
	        this.store.dispatch(loadMediaFiles(tracks, LOAD_STYLE.PLAY));
	    }
	    /**
	     * Get the current playlist in order.
	     */
	    getPlaylistTracks() {
	        return getPlaylistTracks(this.store.getState());
	    }
	    /**
	     * Get the current "playing" status.
	     */
	    getMediaStatus() {
	        return getMediaStatus(this.store.getState());
	    }
	    /**
	     * Get the current "playing" status of the player. Similar to
	     * `getMediaStatus()`, but can differentiate between different reasons why the
	     * player might not be playing, such as "ENDED" when the end of the playlist
	     * has been reached or "CLOSED" when the player has been closed.
	     */
	    getPlayerMediaStatus() {
	        return getPlayerMediaStatus(this.store.getState());
	    }
	    /**
	     * A callback which will be called when Webamp is _about to_ close. Returns an
	     * "unsubscribe" function. The callback will be passed a `cancel` function
	     * which you can use to conditionally prevent Webamp from being closed.
	     *
	     * @returns An "unsubscribe" function. Useful if at some point in the future you want to stop listening to these events.
	     */
	    onWillClose(cb) {
	        return this._actionEmitter.on("CLOSE_REQUESTED", (action) => {
	            cb(action.cancel);
	        });
	    }
	    /**
	     * A callback which will be called when Webamp is closed.
	     *
	     * @returns An "unsubscribe" function. Useful if at some point in the future you want to stop listening to these events.
	     */
	    onClose(cb) {
	        return this._actionEmitter.on("CLOSE_WINAMP", cb);
	    }
	    /**
	     * Equivalent to selecting "Close" from Webamp's options menu. Once closed,
	     * you can open it again with `.reopen()`.
	     */
	    close() {
	        this.store.dispatch(close());
	    }
	    /**
	     * After `.close()`ing this instance, you can reopen it by calling this method.
	     */
	    reopen() {
	        this.store.dispatch(open());
	    }
	    /**
	     * A callback which will be called when a new track starts loading.
	     *
	     * This can happen on startup when the first track starts buffering, or when a
	     * subsequent track starts playing.  The callback will be called with an
	     * object `({url: 'https://example.com/track.mp3'})` containing the URL of the
	     * track.
	     *
	     * Note: If the user drags in a track, the URL may be an ObjectURL.
	     *
	     * @returns An "unsubscribe" function. Useful if at some point in the future
	     * you want to stop listening to these events.
	     */
	    onTrackDidChange(cb) {
	        let previousTrackId = null;
	        const unsubscribe = this.store.subscribe(() => {
	            const state = this.store.getState();
	            const trackId = getCurrentlyPlayingTrackIdIfLoaded(state);
	            if (trackId === previousTrackId) {
	                return;
	            }
	            previousTrackId = trackId;
	            cb(trackId == null ? null : getCurrentTrackInfo(state));
	        });
	        // Register cleanup with disposable
	        this._disposable.add(unsubscribe);
	        return unsubscribe;
	    }
	    /**
	     * A callback which will be called when Webamp is minimized.
	     *
	     * @returns An "unsubscribe" function. Useful if at some point in the future you want to stop listening to these events.
	     */
	    onMinimize(cb) {
	        return this._actionEmitter.on("MINIMIZE_WINAMP", cb);
	    }
	    /**
	     * Set the skin to use. This can be a URL or a base64 encoded string. The skin
	     * will be loaded asynchronously.
	     *
	     * NOTE: If the URL is not on the same domain as the page, you will need to consider CORS.
	     * https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
	     */
	    setSkinFromUrl(url) {
	        this.store.dispatch(setSkinFromUrl(url));
	        // TODO: Should this return a promise?
	        // return this.skinIsLoaded(); ??
	    }
	    /**
	     * Returns a promise that resolves when the skin is done loading.
	     */
	    async skinIsLoaded() {
	        // Wait for the skin to load.
	        await this.storeHas((state) => !state.display.loading);
	        // We attempt to pre-resolve these promises before we declare the skin
	        // loaded. That's because `<EqGraph>` needs these in order to render fully.
	        // As long as these are resolved before we attempt to render, we can ensure
	        // that we will have all the data we need on first paint.
	        //
	        // Note: This won't help for non-initial skin loads.
	        await Promise.all([
	            getPreampLineImage(this.store.getState()),
	            getLineColorsImage(this.store.getState()),
	        ]);
	        return;
	    }
	    /**
	     * Webamp will wait until it has fetched the skin and fully parsed it and then render itself.
	     *
	     * Webamp is rendered into a new DOM node at the end of the <body> tag with the id `#webamp`.
	     *
	     * If a domNode is passed, Webamp will place itself in the center of that DOM node.
	     *
	     * @returns A promise is returned which will resolve after the render is complete.
	     */
	    async renderWhenReady(node) {
	        this.store.dispatch(centerWindowsInContainer(node));
	        await this.skinIsLoaded();
	        if (this._disposable.disposed) {
	            return;
	        }
	        if (this._root != null) {
	            throw new Error("Cannot render a Webamp instance twice");
	        }
	        this._root = ReactDOM.createRoot(node);
	        this._disposable.add(() => {
	            if (this._root != null) {
	                this._root.unmount();
	                this._root = null;
	            }
	        });
	        let onMount;
	        const mountPromise = new Promise((resolve) => {
	            onMount = resolve;
	        });
	        this._root.render(jsxRuntimeExports.jsx(Provider, { store: this.store, children: jsxRuntimeExports.jsx(App, { media: this.media, filePickers: this.options.filePickers || [], onMount: onMount, parentDomNode: document.body }) }));
	        await mountPromise;
	    }
	    /**
	     * **Note:** _This method is not fully functional. It is currently impossible to
	     * clean up a Winamp instance. This method makes an effort, but it still leaks
	     * the whole instance. In the future the behavior of this method will improve,
	     * so you might as well call it._
	     *
	     * When you are done with a Webamp instance, call this method and Webamp will
	     * attempt to clean itself up to avoid memory leaks.
	     */
	    dispose() {
	        this.media.dispose();
	        this._actionEmitter.dispose();
	        this._disposable.dispose();
	    }
	    __loadSerializedState(serializedState) {
	        this.store.dispatch(loadSerializedState(serializedState));
	    }
	    __getSerializedState() {
	        return getSerlializedState(this.store.getState());
	    }
	    __onStateChange(cb) {
	        const unsubscribe = this.store.subscribe(cb);
	        // Register cleanup with disposable
	        this._disposable.add(unsubscribe);
	        return unsubscribe;
	    }
	    /**
	     * Wait for the store to match a predicate condition.
	     * Returns a promise that resolves when the condition is met.
	     * If the instance is disposed, the promise will be rejected.
	     */
	    storeHas(predicate) {
	        let unsubscribed = false;
	        return new Promise((resolve, reject) => {
	            if (predicate(this.store.getState())) {
	                resolve();
	                return;
	            }
	            const unsubscribe = this.store.subscribe(() => {
	                if (predicate(this.store.getState())) {
	                    unsubscribed = true;
	                    unsubscribe();
	                    resolve();
	                }
	            });
	            // Register cleanup with disposable
	            this._disposable.add(() => {
	                if (!unsubscribed) {
	                    unsubscribe();
	                    reject(new Error("Store was disposed before condition was met."));
	                }
	            });
	        });
	    }
	    _bufferTracks(tracks) {
	        const nextIndex = getTrackCount(this.store.getState());
	        this.store.dispatch(loadMediaFiles(tracks, LOAD_STYLE.BUFFER, nextIndex));
	    }
	};
	// @ts-ignore
	window.Webamp = Webamp$1;

	// A Fork of the NPM module `setimmediate`
	// I've adapted this to only include the browser implementation and to not
	// mutate the global object and instead export the `setImmediate` function.
	let nextHandle = 1; // Spec says greater than zero
	const tasksByHandle = {};
	let currentlyRunningATask = false;
	let registerImmediate;
	function setImmediate$1(callback) {
	    // Copy function arguments
	    const args = new Array(arguments.length - 1);
	    for (let i = 0; i < args.length; i++) {
	        args[i] = arguments[i + 1];
	    }
	    // Store and register the task
	    const task = { callback: callback, args: args };
	    tasksByHandle[nextHandle] = task;
	    registerImmediate(nextHandle);
	    return nextHandle++;
	}
	function clearImmediate(handle) {
	    delete tasksByHandle[handle];
	}
	function run(task) {
	    const callback = task.callback;
	    const args = task.args;
	    switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            // eslint-disable-next-line prefer-spread
	            callback.apply(undefined, args);
	            break;
	    }
	}
	function runIfPresent(handle) {
	    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	    // So if we're currently running a task, we'll need to delay this invocation.
	    if (currentlyRunningATask) {
	        // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	        // "too much recursion" error.
	        setTimeout(runIfPresent, 0, handle);
	    }
	    else {
	        const task = tasksByHandle[handle];
	        if (task) {
	            currentlyRunningATask = true;
	            try {
	                run(task);
	            }
	            finally {
	                clearImmediate(handle);
	                currentlyRunningATask = false;
	            }
	        }
	    }
	}
	function canUsePostMessage() {
	    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	    // where `global.postMessage` means something completely different and can't be used for this purpose.
	    if (!window.importScripts) {
	        let postMessageIsAsynchronous = true;
	        const oldOnMessage = window.onmessage;
	        window.onmessage = function () {
	            postMessageIsAsynchronous = false;
	        };
	        window.postMessage("", "*");
	        window.onmessage = oldOnMessage;
	        return postMessageIsAsynchronous;
	    }
	}
	function installPostMessageImplementation() {
	    // Installs an event handler on `global` for the `message` event: see
	    // * https://developer.mozilla.org/en/DOM/window.postMessage
	    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	    const messagePrefix = `setImmediate$${Math.random()}$`;
	    window.addEventListener("message", (event) => {
	        if (event.source === window &&
	            typeof event.data === "string" &&
	            event.data.indexOf(messagePrefix) === 0) {
	            runIfPresent(+event.data.slice(messagePrefix.length));
	        }
	    }, false);
	    registerImmediate = function (handle) {
	        window.postMessage(messagePrefix + handle, "*");
	    };
	}
	function installSetTimeoutImplementation() {
	    registerImmediate = function (handle) {
	        setTimeout(runIfPresent, 0, handle);
	    };
	}
	if (canUsePostMessage()) {
	    // For non-IE10 modern browsers
	    installPostMessageImplementation();
	}
	else {
	    // For older browsers
	    installSetTimeoutImplementation();
	}

	var utils = {};

	var support = {};

	// This constructor is used to store event handlers. Instantiating this is
	// faster than explicitly calling `Object.create(null)` to get a "clean" empty
	// object (tested with v8 v4.9).
	function EventHandlers() {}
	EventHandlers.prototype = Object.create(null);

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}

	// nodejs oddity
	// require('events') === require('events').EventEmitter
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.usingDomains = false;

	EventEmitter.prototype.domain = undefined;
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	EventEmitter.init = function() {
	  this.domain = null;

	  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
	    this._events = new EventHandlers();
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || isNaN(n))
	    throw new TypeError('"n" argument must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	function $getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return $getMaxListeners(this);
	};

	// These standalone emit* functions are used to optimize calling of event
	// handlers for fast cases because emit() itself often has a variable number of
	// arguments and can be deoptimized because of that. These functions always have
	// the same number of arguments and thus do not get deoptimized, so the code
	// inside them can execute faster.
	function emitNone(handler, isFn, self) {
	  if (isFn)
	    handler.call(self);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self);
	  }
	}
	function emitOne(handler, isFn, self, arg1) {
	  if (isFn)
	    handler.call(self, arg1);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1);
	  }
	}
	function emitTwo(handler, isFn, self, arg1, arg2) {
	  if (isFn)
	    handler.call(self, arg1, arg2);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2);
	  }
	}
	function emitThree(handler, isFn, self, arg1, arg2, arg3) {
	  if (isFn)
	    handler.call(self, arg1, arg2, arg3);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2, arg3);
	  }
	}

	function emitMany(handler, isFn, self, args) {
	  if (isFn)
	    handler.apply(self, args);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].apply(self, args);
	  }
	}

	EventEmitter.prototype.emit = function emit(type) {
	  var er, handler, len, args, i, events, domain;
	  var doError = (type === 'error');

	  events = this._events;
	  if (events)
	    doError = (doError && events.error == null);
	  else if (!doError)
	    return false;

	  domain = this.domain;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    er = arguments[1];
	    if (domain) {
	      if (!er)
	        er = new Error('Uncaught, unspecified "error" event');
	      er.domainEmitter = this;
	      er.domain = domain;
	      er.domainThrown = false;
	      domain.emit('error', er);
	    } else if (er instanceof Error) {
	      throw er; // Unhandled 'error' event
	    } else {
	      // At least give some kind of context to the user
	      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	      err.context = er;
	      throw err;
	    }
	    return false;
	  }

	  handler = events[type];

	  if (!handler)
	    return false;

	  var isFn = typeof handler === 'function';
	  len = arguments.length;
	  switch (len) {
	    // fast cases
	    case 1:
	      emitNone(handler, isFn, this);
	      break;
	    case 2:
	      emitOne(handler, isFn, this, arguments[1]);
	      break;
	    case 3:
	      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
	      break;
	    case 4:
	      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
	      break;
	    // slower
	    default:
	      args = new Array(len - 1);
	      for (i = 1; i < len; i++)
	        args[i - 1] = arguments[i];
	      emitMany(handler, isFn, this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');

	  events = target._events;
	  if (!events) {
	    events = target._events = new EventHandlers();
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (!existing) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] = prepend ? [listener, existing] :
	                                          [existing, listener];
	    } else {
	      // If we've already got an array, just append.
	      if (prepend) {
	        existing.unshift(listener);
	      } else {
	        existing.push(listener);
	      }
	    }

	    // Check for listener leak
	    if (!existing.warned) {
	      m = $getMaxListeners(target);
	      if (m && m > 0 && existing.length > m) {
	        existing.warned = true;
	        var w = new Error('Possible EventEmitter memory leak detected. ' +
	                            existing.length + ' ' + type + ' listeners added. ' +
	                            'Use emitter.setMaxListeners() to increase limit');
	        w.name = 'MaxListenersExceededWarning';
	        w.emitter = target;
	        w.type = type;
	        w.count = existing.length;
	        emitWarning(w);
	      }
	    }
	  }

	  return target;
	}
	function emitWarning(e) {
	  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function _onceWrap(target, type, listener) {
	  var fired = false;
	  function g() {
	    target.removeListener(type, g);
	    if (!fired) {
	      fired = true;
	      listener.apply(target, arguments);
	    }
	  }
	  g.listener = listener;
	  return g;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');

	      events = this._events;
	      if (!events)
	        return this;

	      list = events[type];
	      if (!list)
	        return this;

	      if (list === listener || (list.listener && list.listener === listener)) {
	        if (--this._eventsCount === 0)
	          this._events = new EventHandlers();
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length; i-- > 0;) {
	          if (list[i] === listener ||
	              (list[i].listener && list[i].listener === listener)) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (list.length === 1) {
	          list[0] = undefined;
	          if (--this._eventsCount === 0) {
	            this._events = new EventHandlers();
	            return this;
	          } else {
	            delete events[type];
	          }
	        } else {
	          spliceOne(list, position);
	        }

	        if (events.removeListener)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };
	    
	// Alias for removeListener added in NodeJS 10.0
	// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
	EventEmitter.prototype.off = function(type, listener){
	    return this.removeListener(type, listener);
	};

	EventEmitter.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events;

	      events = this._events;
	      if (!events)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (!events.removeListener) {
	        if (arguments.length === 0) {
	          this._events = new EventHandlers();
	          this._eventsCount = 0;
	        } else if (events[type]) {
	          if (--this._eventsCount === 0)
	            this._events = new EventHandlers();
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        for (var i = 0, key; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = new EventHandlers();
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners) {
	        // LIFO order
	        do {
	          this.removeListener(type, listeners[listeners.length - 1]);
	        } while (listeners[0]);
	      }

	      return this;
	    };

	EventEmitter.prototype.listeners = function listeners(type) {
	  var evlistener;
	  var ret;
	  var events = this._events;

	  if (!events)
	    ret = [];
	  else {
	    evlistener = events[type];
	    if (!evlistener)
	      ret = [];
	    else if (typeof evlistener === 'function')
	      ret = [evlistener.listener || evlistener];
	    else
	      ret = unwrapListeners(evlistener);
	  }

	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$1.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount$1;
	function listenerCount$1(type) {
	  var events = this._events;

	  if (events) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
	};

	// About 1.5x faster than the two-arg version of Array#splice().
	function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
	    list[i] = list[k];
	  list.pop();
	}

	function arrayClone(arr, i) {
	  var copy = new Array(i);
	  while (i--)
	    copy[i] = arr[i];
	  return copy;
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString = {}.toString;

	var isArray$1 = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */


	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	function kMaxLength () {
	  return Buffer$1.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$1(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$1 (arg, encodingOrOffset, length) {
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
	    return new Buffer$1(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer$1.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$1._augment = function (arr) {
	  arr.__proto__ = Buffer$1.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$1.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$1.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$1.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$1.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$1.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$1.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer$1.isBuffer = isBuffer;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$1.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$1.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$1.concat = function concat (list, length) {
	  if (!isArray$1(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$1.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$1.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$1.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$1.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$1.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$1.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$1.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$1.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$1.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$1.compare(this, b) === 0
	};

	Buffer$1.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$1.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$1.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$1.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$1.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$1.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$1(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$1(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser$2 = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance$1 = global$1.performance || {};
	var performanceNow =
	  performance$1.now        ||
	  performance$1.mozNow     ||
	  performance$1.msNow      ||
	  performance$1.oNow       ||
	  performance$1.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance$1)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser$2,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var inherits;
	if (typeof Object.create === 'function'){
	  inherits = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global$1.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (browser$1$1.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (browser$1$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (browser$1$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = browser$1$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isString(arg) {
	  return typeof arg === 'string';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}

	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};

	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};

	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};

	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};

	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};

	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return Buffer$1.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = Buffer$1.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var isBufferEncoding = Buffer$1.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     };


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	function StringDecoder(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer$1(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	}

	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}

	Readable.ReadableState = ReadableState;

	var debug$n = debuglog('stream');
	inherits(Readable, EventEmitter);

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event])
	      emitter.on(event, fn);
	    else if (Array.isArray(emitter._events[event]))
	      emitter._events[event].unshift(fn);
	    else
	      emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	function listenerCount (emitter, type) {
	  return emitter.listeners(type).length;
	}
	function ReadableState(options, stream) {

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  EventEmitter.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = Buffer$1.from(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug$n('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug$n('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug$n('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug$n('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug$n('reading or ended', doRead);
	  } else if (doRead) {
	    debug$n('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug$n('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug$n('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    nextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug$n('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug$n('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false);

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug$n('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug$n('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug$n('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug$n('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug$n('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug$n('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug$n('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug$n('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug$n('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug$n('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && src.listeners('data').length) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = EventEmitter.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        nextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug$n('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug$n('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    nextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug$n('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug$n('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug$n('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug$n('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug$n('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug$n('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug$n('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer$1.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    nextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	Writable.WritableState = WritableState;
	inherits(Writable, EventEmitter);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  Object.defineProperty(this, 'buffer', {
	    get: deprecate(function () {
	      return this.getBuffer();
	    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	  });
	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	function Writable(options) {

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  EventEmitter.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  nextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    nextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer$1.from(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) nextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	        nextTick(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}

	inherits(Duplex, Readable);

	var keys = Object.keys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  nextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	inherits(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('Not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}

	inherits(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

	inherits(Stream, EventEmitter);
	Stream.Readable = Readable;
	Stream.Writable = Writable;
	Stream.Duplex = Duplex;
	Stream.Transform = Transform;
	Stream.PassThrough = PassThrough;

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;

	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EventEmitter.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EventEmitter.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};

	var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Duplex: Duplex,
		PassThrough: PassThrough,
		Readable: Readable,
		Stream: Stream,
		Transform: Transform,
		Writable: Writable,
		default: Stream
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

	var readableStreamBrowser;
	var hasRequiredReadableStreamBrowser;

	function requireReadableStreamBrowser () {
		if (hasRequiredReadableStreamBrowser) return readableStreamBrowser;
		hasRequiredReadableStreamBrowser = 1;
		/*
		 * This file is used by module bundlers (browserify/webpack/etc) when
		 * including a stream implementation. We use "readable-stream" to get a
		 * consistent behavior between nodejs versions but bundlers often have a shim
		 * for "stream". Using this shim greatly improve the compatibility and greatly
		 * reduce the final size of the bundle (only one stream implementation, not
		 * two).
		 */
		readableStreamBrowser = require$$0;
		return readableStreamBrowser;
	}

	support.base64 = true;
	support.array = true;
	support.string = true;
	support.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
	support.nodebuffer = typeof Buffer !== "undefined";
	// contains true if JSZip can read/generate Uint8Array, false otherwise.
	support.uint8array = typeof Uint8Array !== "undefined";

	if (typeof ArrayBuffer === "undefined") {
	    support.blob = false;
	}
	else {
	    var buffer = new ArrayBuffer(0);
	    try {
	        support.blob = new Blob([buffer], {
	            type: "application/zip"
	        }).size === 0;
	    }
	    catch (e) {
	        try {
	            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
	            var builder = new Builder();
	            builder.append(buffer);
	            support.blob = builder.getBlob("application/zip").size === 0;
	        }
	        catch (e) {
	            support.blob = false;
	        }
	    }
	}

	try {
	    support.nodestream = !!requireReadableStreamBrowser().Readable;
	} catch(e) {
	    support.nodestream = false;
	}

	var base64 = {};

	var hasRequiredBase64;

	function requireBase64 () {
		if (hasRequiredBase64) return base64;
		hasRequiredBase64 = 1;
		var utils = requireUtils();
		var support$1 = support;
		// private property
		var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


		// public method for encoding
		base64.encode = function(input) {
		    var output = [];
		    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		    var i = 0, len = input.length, remainingBytes = len;

		    var isArray = utils.getTypeOf(input) !== "string";
		    while (i < input.length) {
		        remainingBytes = len - i;

		        if (!isArray) {
		            chr1 = input.charCodeAt(i++);
		            chr2 = i < len ? input.charCodeAt(i++) : 0;
		            chr3 = i < len ? input.charCodeAt(i++) : 0;
		        } else {
		            chr1 = input[i++];
		            chr2 = i < len ? input[i++] : 0;
		            chr3 = i < len ? input[i++] : 0;
		        }

		        enc1 = chr1 >> 2;
		        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
		        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
		        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

		        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

		    }

		    return output.join("");
		};

		// public method for decoding
		base64.decode = function(input) {
		    var chr1, chr2, chr3;
		    var enc1, enc2, enc3, enc4;
		    var i = 0, resultIndex = 0;

		    var dataUrlPrefix = "data:";

		    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
		        // This is a common error: people give a data url
		        // (data:image/png;base64,iVBOR...) with a {base64: true} and
		        // wonders why things don't work.
		        // We can detect that the string input looks like a data url but we
		        // *can't* be sure it is one: removing everything up to the comma would
		        // be too dangerous.
		        throw new Error("Invalid base64 input, it looks like a data url.");
		    }

		    input = input.replace(/[^A-Za-z0-9+/=]/g, "");

		    var totalLength = input.length * 3 / 4;
		    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
		        totalLength--;
		    }
		    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
		        totalLength--;
		    }
		    if (totalLength % 1 !== 0) {
		        // totalLength is not an integer, the length does not match a valid
		        // base64 content. That can happen if:
		        // - the input is not a base64 content
		        // - the input is *almost* a base64 content, with a extra chars at the
		        //   beginning or at the end
		        // - the input uses a base64 variant (base64url for example)
		        throw new Error("Invalid base64 input, bad content length.");
		    }
		    var output;
		    if (support$1.uint8array) {
		        output = new Uint8Array(totalLength|0);
		    } else {
		        output = new Array(totalLength|0);
		    }

		    while (i < input.length) {

		        enc1 = _keyStr.indexOf(input.charAt(i++));
		        enc2 = _keyStr.indexOf(input.charAt(i++));
		        enc3 = _keyStr.indexOf(input.charAt(i++));
		        enc4 = _keyStr.indexOf(input.charAt(i++));

		        chr1 = (enc1 << 2) | (enc2 >> 4);
		        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
		        chr3 = ((enc3 & 3) << 6) | enc4;

		        output[resultIndex++] = chr1;

		        if (enc3 !== 64) {
		            output[resultIndex++] = chr2;
		        }
		        if (enc4 !== 64) {
		            output[resultIndex++] = chr3;
		        }

		    }

		    return output;
		};
		return base64;
	}

	var nodejsUtils = {
	    /**
	     * True if this is running in Nodejs, will be undefined in a browser.
	     * In a browser, browserify won't include this file and the whole module
	     * will be resolved an empty object.
	     */
	    isNode : typeof Buffer !== "undefined",
	    /**
	     * Create a new nodejs Buffer from an existing content.
	     * @param {Object} data the data to pass to the constructor.
	     * @param {String} encoding the encoding to use.
	     * @return {Buffer} a new Buffer.
	     */
	    newBufferFrom: function(data, encoding) {
	        if (Buffer.from && Buffer.from !== Uint8Array.from) {
	            return Buffer.from(data, encoding);
	        } else {
	            if (typeof data === "number") {
	                // Safeguard for old Node.js versions. On newer versions,
	                // Buffer.from(number) / Buffer(number, encoding) already throw.
	                throw new Error("The \"data\" argument must not be a number");
	            }
	            return new Buffer(data, encoding);
	        }
	    },
	    /**
	     * Create a new nodejs Buffer with the specified size.
	     * @param {Integer} size the size of the buffer.
	     * @return {Buffer} a new Buffer.
	     */
	    allocBuffer: function (size) {
	        if (Buffer.alloc) {
	            return Buffer.alloc(size);
	        } else {
	            var buf = new Buffer(size);
	            buf.fill(0);
	            return buf;
	        }
	    },
	    /**
	     * Find out if an object is a Buffer.
	     * @param {Object} b the object to test.
	     * @return {Boolean} true if the object is a Buffer, false otherwise.
	     */
	    isBuffer : function(b){
	        return Buffer.isBuffer(b);
	    },

	    isStream : function (obj) {
	        return obj &&
	            typeof obj.on === "function" &&
	            typeof obj.pause === "function" &&
	            typeof obj.resume === "function";
	    }
	};

	var browser$1;
	var hasRequiredBrowser$1;

	function requireBrowser$1 () {
		if (hasRequiredBrowser$1) return browser$1;
		hasRequiredBrowser$1 = 1;
		var Mutation = commonjsGlobal.MutationObserver || commonjsGlobal.WebKitMutationObserver;

		var scheduleDrain;

		{
		  if (Mutation) {
		    var called = 0;
		    var observer = new Mutation(nextTick);
		    var element = commonjsGlobal.document.createTextNode('');
		    observer.observe(element, {
		      characterData: true
		    });
		    scheduleDrain = function () {
		      element.data = (called = ++called % 2);
		    };
		  } else if (!commonjsGlobal.setImmediate && typeof commonjsGlobal.MessageChannel !== 'undefined') {
		    var channel = new commonjsGlobal.MessageChannel();
		    channel.port1.onmessage = nextTick;
		    scheduleDrain = function () {
		      channel.port2.postMessage(0);
		    };
		  } else if ('document' in commonjsGlobal && 'onreadystatechange' in commonjsGlobal.document.createElement('script')) {
		    scheduleDrain = function () {

		      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
		      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
		      var scriptEl = commonjsGlobal.document.createElement('script');
		      scriptEl.onreadystatechange = function () {
		        nextTick();

		        scriptEl.onreadystatechange = null;
		        scriptEl.parentNode.removeChild(scriptEl);
		        scriptEl = null;
		      };
		      commonjsGlobal.document.documentElement.appendChild(scriptEl);
		    };
		  } else {
		    scheduleDrain = function () {
		      setTimeout(nextTick, 0);
		    };
		  }
		}

		var draining;
		var queue = [];
		//named nextTick for less confusing stack traces
		function nextTick() {
		  draining = true;
		  var i, oldQueue;
		  var len = queue.length;
		  while (len) {
		    oldQueue = queue;
		    queue = [];
		    i = -1;
		    while (++i < len) {
		      oldQueue[i]();
		    }
		    len = queue.length;
		  }
		  draining = false;
		}

		browser$1 = immediate;
		function immediate(task) {
		  if (queue.push(task) === 1 && !draining) {
		    scheduleDrain();
		  }
		}
		return browser$1;
	}

	var browser;
	var hasRequiredBrowser;

	function requireBrowser () {
		if (hasRequiredBrowser) return browser;
		hasRequiredBrowser = 1;
		var immediate = requireBrowser$1();

		/* istanbul ignore next */
		function INTERNAL() {}

		var handlers = {};

		var REJECTED = ['REJECTED'];
		var FULFILLED = ['FULFILLED'];
		var PENDING = ['PENDING'];

		browser = Promise;

		function Promise(resolver) {
		  if (typeof resolver !== 'function') {
		    throw new TypeError('resolver must be a function');
		  }
		  this.state = PENDING;
		  this.queue = [];
		  this.outcome = void 0;
		  if (resolver !== INTERNAL) {
		    safelyResolveThenable(this, resolver);
		  }
		}

		Promise.prototype["finally"] = function (callback) {
		  if (typeof callback !== 'function') {
		    return this;
		  }
		  var p = this.constructor;
		  return this.then(resolve, reject);

		  function resolve(value) {
		    function yes () {
		      return value;
		    }
		    return p.resolve(callback()).then(yes);
		  }
		  function reject(reason) {
		    function no () {
		      throw reason;
		    }
		    return p.resolve(callback()).then(no);
		  }
		};
		Promise.prototype["catch"] = function (onRejected) {
		  return this.then(null, onRejected);
		};
		Promise.prototype.then = function (onFulfilled, onRejected) {
		  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
		    typeof onRejected !== 'function' && this.state === REJECTED) {
		    return this;
		  }
		  var promise = new this.constructor(INTERNAL);
		  if (this.state !== PENDING) {
		    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
		    unwrap(promise, resolver, this.outcome);
		  } else {
		    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
		  }

		  return promise;
		};
		function QueueItem(promise, onFulfilled, onRejected) {
		  this.promise = promise;
		  if (typeof onFulfilled === 'function') {
		    this.onFulfilled = onFulfilled;
		    this.callFulfilled = this.otherCallFulfilled;
		  }
		  if (typeof onRejected === 'function') {
		    this.onRejected = onRejected;
		    this.callRejected = this.otherCallRejected;
		  }
		}
		QueueItem.prototype.callFulfilled = function (value) {
		  handlers.resolve(this.promise, value);
		};
		QueueItem.prototype.otherCallFulfilled = function (value) {
		  unwrap(this.promise, this.onFulfilled, value);
		};
		QueueItem.prototype.callRejected = function (value) {
		  handlers.reject(this.promise, value);
		};
		QueueItem.prototype.otherCallRejected = function (value) {
		  unwrap(this.promise, this.onRejected, value);
		};

		function unwrap(promise, func, value) {
		  immediate(function () {
		    var returnValue;
		    try {
		      returnValue = func(value);
		    } catch (e) {
		      return handlers.reject(promise, e);
		    }
		    if (returnValue === promise) {
		      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
		    } else {
		      handlers.resolve(promise, returnValue);
		    }
		  });
		}

		handlers.resolve = function (self, value) {
		  var result = tryCatch(getThen, value);
		  if (result.status === 'error') {
		    return handlers.reject(self, result.value);
		  }
		  var thenable = result.value;

		  if (thenable) {
		    safelyResolveThenable(self, thenable);
		  } else {
		    self.state = FULFILLED;
		    self.outcome = value;
		    var i = -1;
		    var len = self.queue.length;
		    while (++i < len) {
		      self.queue[i].callFulfilled(value);
		    }
		  }
		  return self;
		};
		handlers.reject = function (self, error) {
		  self.state = REJECTED;
		  self.outcome = error;
		  var i = -1;
		  var len = self.queue.length;
		  while (++i < len) {
		    self.queue[i].callRejected(error);
		  }
		  return self;
		};

		function getThen(obj) {
		  // Make sure we only access the accessor once as required by the spec
		  var then = obj && obj.then;
		  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
		    return function appyThen() {
		      then.apply(obj, arguments);
		    };
		  }
		}

		function safelyResolveThenable(self, thenable) {
		  // Either fulfill, reject or reject with error
		  var called = false;
		  function onError(value) {
		    if (called) {
		      return;
		    }
		    called = true;
		    handlers.reject(self, value);
		  }

		  function onSuccess(value) {
		    if (called) {
		      return;
		    }
		    called = true;
		    handlers.resolve(self, value);
		  }

		  function tryToUnwrap() {
		    thenable(onSuccess, onError);
		  }

		  var result = tryCatch(tryToUnwrap);
		  if (result.status === 'error') {
		    onError(result.value);
		  }
		}

		function tryCatch(func, value) {
		  var out = {};
		  try {
		    out.value = func(value);
		    out.status = 'success';
		  } catch (e) {
		    out.status = 'error';
		    out.value = e;
		  }
		  return out;
		}

		Promise.resolve = resolve;
		function resolve(value) {
		  if (value instanceof this) {
		    return value;
		  }
		  return handlers.resolve(new this(INTERNAL), value);
		}

		Promise.reject = reject;
		function reject(reason) {
		  var promise = new this(INTERNAL);
		  return handlers.reject(promise, reason);
		}

		Promise.all = all;
		function all(iterable) {
		  var self = this;
		  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
		    return this.reject(new TypeError('must be an array'));
		  }

		  var len = iterable.length;
		  var called = false;
		  if (!len) {
		    return this.resolve([]);
		  }

		  var values = new Array(len);
		  var resolved = 0;
		  var i = -1;
		  var promise = new this(INTERNAL);

		  while (++i < len) {
		    allResolver(iterable[i], i);
		  }
		  return promise;
		  function allResolver(value, i) {
		    self.resolve(value).then(resolveFromAll, function (error) {
		      if (!called) {
		        called = true;
		        handlers.reject(promise, error);
		      }
		    });
		    function resolveFromAll(outValue) {
		      values[i] = outValue;
		      if (++resolved === len && !called) {
		        called = true;
		        handlers.resolve(promise, values);
		      }
		    }
		  }
		}

		Promise.race = race;
		function race(iterable) {
		  var self = this;
		  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
		    return this.reject(new TypeError('must be an array'));
		  }

		  var len = iterable.length;
		  var called = false;
		  if (!len) {
		    return this.resolve([]);
		  }

		  var i = -1;
		  var promise = new this(INTERNAL);

		  while (++i < len) {
		    resolver(iterable[i]);
		  }
		  return promise;
		  function resolver(value) {
		    self.resolve(value).then(function (response) {
		      if (!called) {
		        called = true;
		        handlers.resolve(promise, response);
		      }
		    }, function (error) {
		      if (!called) {
		        called = true;
		        handlers.reject(promise, error);
		      }
		    });
		  }
		}
		return browser;
	}

	// load the global object first:
	// - it should be better integrated in the system (unhandledRejection in node)
	// - the environment may have a custom Promise implementation (see zone.js)
	var ES6Promise = null;
	if (typeof Promise !== "undefined") {
	    ES6Promise = Promise;
	} else {
	    ES6Promise = requireBrowser();
	}

	/**
	 * Let the user use/change some implementations.
	 */
	var external = {
	    Promise: ES6Promise
	};

	var hasRequiredUtils;

	function requireUtils () {
		if (hasRequiredUtils) return utils;
		hasRequiredUtils = 1;
		(function (exports) {

			var support$1 = support;
			var base64 = requireBase64();
			var nodejsUtils$1 = nodejsUtils;
			var external$1 = external;



			/**
			 * Convert a string that pass as a "binary string": it should represent a byte
			 * array but may have > 255 char codes. Be sure to take only the first byte
			 * and returns the byte array.
			 * @param {String} str the string to transform.
			 * @return {Array|Uint8Array} the string in a binary format.
			 */
			function string2binary(str) {
			    var result = null;
			    if (support$1.uint8array) {
			        result = new Uint8Array(str.length);
			    } else {
			        result = new Array(str.length);
			    }
			    return stringToArrayLike(str, result);
			}

			/**
			 * Create a new blob with the given content and the given type.
			 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
			 * an Uint8Array because the stock browser of android 4 won't accept it (it
			 * will be silently converted to a string, "[object Uint8Array]").
			 *
			 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
			 * when a large amount of Array is used to create the Blob, the amount of
			 * memory consumed is nearly 100 times the original data amount.
			 *
			 * @param {String} type the mime type of the blob.
			 * @return {Blob} the created blob.
			 */
			exports.newBlob = function(part, type) {
			    exports.checkSupport("blob");

			    try {
			        // Blob constructor
			        return new Blob([part], {
			            type: type
			        });
			    }
			    catch (e) {

			        try {
			            // deprecated, browser only, old way
			            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
			            var builder = new Builder();
			            builder.append(part);
			            return builder.getBlob(type);
			        }
			        catch (e) {

			            // well, fuck ?!
			            throw new Error("Bug : can't construct the Blob.");
			        }
			    }


			};
			/**
			 * The identity function.
			 * @param {Object} input the input.
			 * @return {Object} the same input.
			 */
			function identity(input) {
			    return input;
			}

			/**
			 * Fill in an array with a string.
			 * @param {String} str the string to use.
			 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
			 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
			 */
			function stringToArrayLike(str, array) {
			    for (var i = 0; i < str.length; ++i) {
			        array[i] = str.charCodeAt(i) & 0xFF;
			    }
			    return array;
			}

			/**
			 * An helper for the function arrayLikeToString.
			 * This contains static information and functions that
			 * can be optimized by the browser JIT compiler.
			 */
			var arrayToStringHelper = {
			    /**
			     * Transform an array of int into a string, chunk by chunk.
			     * See the performances notes on arrayLikeToString.
			     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
			     * @param {String} type the type of the array.
			     * @param {Integer} chunk the chunk size.
			     * @return {String} the resulting string.
			     * @throws Error if the chunk is too big for the stack.
			     */
			    stringifyByChunk: function(array, type, chunk) {
			        var result = [], k = 0, len = array.length;
			        // shortcut
			        if (len <= chunk) {
			            return String.fromCharCode.apply(null, array);
			        }
			        while (k < len) {
			            if (type === "array" || type === "nodebuffer") {
			                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
			            }
			            else {
			                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
			            }
			            k += chunk;
			        }
			        return result.join("");
			    },
			    /**
			     * Call String.fromCharCode on every item in the array.
			     * This is the naive implementation, which generate A LOT of intermediate string.
			     * This should be used when everything else fail.
			     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
			     * @return {String} the result.
			     */
			    stringifyByChar: function(array){
			        var resultStr = "";
			        for(var i = 0; i < array.length; i++) {
			            resultStr += String.fromCharCode(array[i]);
			        }
			        return resultStr;
			    },
			    applyCanBeUsed : {
			        /**
			         * true if the browser accepts to use String.fromCharCode on Uint8Array
			         */
			        uint8array : (function () {
			            try {
			                return support$1.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
			            } catch (e) {
			                return false;
			            }
			        })(),
			        /**
			         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
			         */
			        nodebuffer : (function () {
			            try {
			                return support$1.nodebuffer && String.fromCharCode.apply(null, nodejsUtils$1.allocBuffer(1)).length === 1;
			            } catch (e) {
			                return false;
			            }
			        })()
			    }
			};

			/**
			 * Transform an array-like object to a string.
			 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
			 * @return {String} the result.
			 */
			function arrayLikeToString(array) {
			    // Performances notes :
			    // --------------------
			    // String.fromCharCode.apply(null, array) is the fastest, see
			    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
			    // but the stack is limited (and we can get huge arrays !).
			    //
			    // result += String.fromCharCode(array[i]); generate too many strings !
			    //
			    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
			    // TODO : we now have workers that split the work. Do we still need that ?
			    var chunk = 65536,
			        type = exports.getTypeOf(array),
			        canUseApply = true;
			    if (type === "uint8array") {
			        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
			    } else if (type === "nodebuffer") {
			        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
			    }

			    if (canUseApply) {
			        while (chunk > 1) {
			            try {
			                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
			            } catch (e) {
			                chunk = Math.floor(chunk / 2);
			            }
			        }
			    }

			    // no apply or chunk error : slow and painful algorithm
			    // default browser on android 4.*
			    return arrayToStringHelper.stringifyByChar(array);
			}

			exports.applyFromCharCode = arrayLikeToString;


			/**
			 * Copy the data from an array-like to an other array-like.
			 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
			 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
			 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
			 */
			function arrayLikeToArrayLike(arrayFrom, arrayTo) {
			    for (var i = 0; i < arrayFrom.length; i++) {
			        arrayTo[i] = arrayFrom[i];
			    }
			    return arrayTo;
			}

			// a matrix containing functions to transform everything into everything.
			var transform = {};

			// string to ?
			transform["string"] = {
			    "string": identity,
			    "array": function(input) {
			        return stringToArrayLike(input, new Array(input.length));
			    },
			    "arraybuffer": function(input) {
			        return transform["string"]["uint8array"](input).buffer;
			    },
			    "uint8array": function(input) {
			        return stringToArrayLike(input, new Uint8Array(input.length));
			    },
			    "nodebuffer": function(input) {
			        return stringToArrayLike(input, nodejsUtils$1.allocBuffer(input.length));
			    }
			};

			// array to ?
			transform["array"] = {
			    "string": arrayLikeToString,
			    "array": identity,
			    "arraybuffer": function(input) {
			        return (new Uint8Array(input)).buffer;
			    },
			    "uint8array": function(input) {
			        return new Uint8Array(input);
			    },
			    "nodebuffer": function(input) {
			        return nodejsUtils$1.newBufferFrom(input);
			    }
			};

			// arraybuffer to ?
			transform["arraybuffer"] = {
			    "string": function(input) {
			        return arrayLikeToString(new Uint8Array(input));
			    },
			    "array": function(input) {
			        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
			    },
			    "arraybuffer": identity,
			    "uint8array": function(input) {
			        return new Uint8Array(input);
			    },
			    "nodebuffer": function(input) {
			        return nodejsUtils$1.newBufferFrom(new Uint8Array(input));
			    }
			};

			// uint8array to ?
			transform["uint8array"] = {
			    "string": arrayLikeToString,
			    "array": function(input) {
			        return arrayLikeToArrayLike(input, new Array(input.length));
			    },
			    "arraybuffer": function(input) {
			        return input.buffer;
			    },
			    "uint8array": identity,
			    "nodebuffer": function(input) {
			        return nodejsUtils$1.newBufferFrom(input);
			    }
			};

			// nodebuffer to ?
			transform["nodebuffer"] = {
			    "string": arrayLikeToString,
			    "array": function(input) {
			        return arrayLikeToArrayLike(input, new Array(input.length));
			    },
			    "arraybuffer": function(input) {
			        return transform["nodebuffer"]["uint8array"](input).buffer;
			    },
			    "uint8array": function(input) {
			        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
			    },
			    "nodebuffer": identity
			};

			/**
			 * Transform an input into any type.
			 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
			 * If no output type is specified, the unmodified input will be returned.
			 * @param {String} outputType the output type.
			 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
			 * @throws {Error} an Error if the browser doesn't support the requested output type.
			 */
			exports.transformTo = function(outputType, input) {
			    if (!input) {
			        // undefined, null, etc
			        // an empty string won't harm.
			        input = "";
			    }
			    if (!outputType) {
			        return input;
			    }
			    exports.checkSupport(outputType);
			    var inputType = exports.getTypeOf(input);
			    var result = transform[inputType][outputType](input);
			    return result;
			};

			/**
			 * Resolve all relative path components, "." and "..", in a path. If these relative components
			 * traverse above the root then the resulting path will only contain the final path component.
			 *
			 * All empty components, e.g. "//", are removed.
			 * @param {string} path A path with / or \ separators
			 * @returns {string} The path with all relative path components resolved.
			 */
			exports.resolve = function(path) {
			    var parts = path.split("/");
			    var result = [];
			    for (var index = 0; index < parts.length; index++) {
			        var part = parts[index];
			        // Allow the first and last component to be empty for trailing slashes.
			        if (part === "." || (part === "" && index !== 0 && index !== parts.length - 1)) {
			            continue;
			        } else if (part === "..") {
			            result.pop();
			        } else {
			            result.push(part);
			        }
			    }
			    return result.join("/");
			};

			/**
			 * Return the type of the input.
			 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
			 * @param {Object} input the input to identify.
			 * @return {String} the (lowercase) type of the input.
			 */
			exports.getTypeOf = function(input) {
			    if (typeof input === "string") {
			        return "string";
			    }
			    if (Object.prototype.toString.call(input) === "[object Array]") {
			        return "array";
			    }
			    if (support$1.nodebuffer && nodejsUtils$1.isBuffer(input)) {
			        return "nodebuffer";
			    }
			    if (support$1.uint8array && input instanceof Uint8Array) {
			        return "uint8array";
			    }
			    if (support$1.arraybuffer && input instanceof ArrayBuffer) {
			        return "arraybuffer";
			    }
			};

			/**
			 * Throw an exception if the type is not supported.
			 * @param {String} type the type to check.
			 * @throws {Error} an Error if the browser doesn't support the requested type.
			 */
			exports.checkSupport = function(type) {
			    var supported = support$1[type.toLowerCase()];
			    if (!supported) {
			        throw new Error(type + " is not supported by this platform");
			    }
			};

			exports.MAX_VALUE_16BITS = 65535;
			exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

			/**
			 * Prettify a string read as binary.
			 * @param {string} str the string to prettify.
			 * @return {string} a pretty string.
			 */
			exports.pretty = function(str) {
			    var res = "",
			        code, i;
			    for (i = 0; i < (str || "").length; i++) {
			        code = str.charCodeAt(i);
			        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
			    }
			    return res;
			};

			/**
			 * Defer the call of a function.
			 * @param {Function} callback the function to call asynchronously.
			 * @param {Array} args the arguments to give to the callback.
			 */
			exports.delay = function(callback, args, self) {
			    setImmediate(function () {
			        callback.apply(self || null, args || []);
			    });
			};

			/**
			 * Extends a prototype with an other, without calling a constructor with
			 * side effects. Inspired by nodejs' `utils.inherits`
			 * @param {Function} ctor the constructor to augment
			 * @param {Function} superCtor the parent constructor to use
			 */
			exports.inherits = function (ctor, superCtor) {
			    var Obj = function() {};
			    Obj.prototype = superCtor.prototype;
			    ctor.prototype = new Obj();
			};

			/**
			 * Merge the objects passed as parameters into a new one.
			 * @private
			 * @param {...Object} var_args All objects to merge.
			 * @return {Object} a new object with the data of the others.
			 */
			exports.extend = function() {
			    var result = {}, i, attr;
			    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
			        for (attr in arguments[i]) {
			            if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
			                result[attr] = arguments[i][attr];
			            }
			        }
			    }
			    return result;
			};

			/**
			 * Transform arbitrary content into a Promise.
			 * @param {String} name a name for the content being processed.
			 * @param {Object} inputData the content to process.
			 * @param {Boolean} isBinary true if the content is not an unicode string
			 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
			 * @param {Boolean} isBase64 true if the string content is encoded with base64.
			 * @return {Promise} a promise in a format usable by JSZip.
			 */
			exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

			    // if inputData is already a promise, this flatten it.
			    var promise = external$1.Promise.resolve(inputData).then(function(data) {


			        var isBlob = support$1.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);

			        if (isBlob && typeof FileReader !== "undefined") {
			            return new external$1.Promise(function (resolve, reject) {
			                var reader = new FileReader();

			                reader.onload = function(e) {
			                    resolve(e.target.result);
			                };
			                reader.onerror = function(e) {
			                    reject(e.target.error);
			                };
			                reader.readAsArrayBuffer(data);
			            });
			        } else {
			            return data;
			        }
			    });

			    return promise.then(function(data) {
			        var dataType = exports.getTypeOf(data);

			        if (!dataType) {
			            return external$1.Promise.reject(
			                new Error("Can't read the data of '" + name + "'. Is it " +
			                          "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
			            );
			        }
			        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
			        if (dataType === "arraybuffer") {
			            data = exports.transformTo("uint8array", data);
			        } else if (dataType === "string") {
			            if (isBase64) {
			                data = base64.decode(data);
			            }
			            else if (isBinary) {
			                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
			                if (isOptimizedBinaryString !== true) {
			                    // this is a string, not in a base64 format.
			                    // Be sure that this is a correct "binary string"
			                    data = string2binary(data);
			                }
			            }
			        }
			        return data;
			    });
			}; 
		} (utils));
		return utils;
	}

	var utilsExports = requireUtils();
	var Utils = /*@__PURE__*/getDefaultExportFromCjs(utilsExports);

	// @ts-ignore
	Utils.delay = function (callback, args, self) {
	    setImmediate$1(() => {
	        callback.apply(self || null, args || []);
	    });
	};
	class Webamp extends Webamp$1 {
	    constructor(options) {
	        super({
	            ...options,
	            requireJSZip: async () => JSZip,
	            requireMusicMetadata: async () => {
	                // @ts-ignore
	                return musicMetadata;
	            },
	        });
	    }
	}
	// Bit of a hack here. This overwrites the value set in WebampLazy.ts
	// @ts-ignore
	window.Webamp = Webamp;

	const debug$m = initDebug('music-metadata:id3v2:frame-parser');
	const defaultEnc = 'latin1'; // latin1 == iso-8859-1;
	function parseGenre(origVal) {
	    // match everything inside parentheses
	    const genres = [];
	    let code;
	    let word = '';
	    for (const c of origVal) {
	        if (typeof code === 'string') {
	            if (c === '(' && code === '') {
	                word += '(';
	                code = undefined;
	            }
	            else if (c === ')') {
	                if (word !== '') {
	                    genres.push(word);
	                    word = '';
	                }
	                const genre = parseGenreCode(code);
	                if (genre) {
	                    genres.push(genre);
	                }
	                code = undefined;
	            }
	            else
	                code += c;
	        }
	        else if (c === '(') {
	            code = '';
	        }
	        else {
	            word += c;
	        }
	    }
	    if (word) {
	        if (genres.length === 0 && word.match(/^\d*$/)) {
	            word = parseGenreCode(word);
	        }
	        if (word) {
	            genres.push(word);
	        }
	    }
	    return genres;
	}
	function parseGenreCode(code) {
	    if (code === 'RX')
	        return 'Remix';
	    if (code === 'CR')
	        return 'Cover';
	    if (code.match(/^\d*$/)) {
	        return Genres[Number.parseInt(code)];
	    }
	}
	class FrameParser {
	    /**
	     * Create id3v2 frame parser
	     * @param major - Major version, e.g. (4) for  id3v2.4
	     * @param warningCollector - Used to collect decode issue
	     */
	    constructor(major, warningCollector) {
	        this.major = major;
	        this.warningCollector = warningCollector;
	    }
	    readData(uint8Array, type, includeCovers) {
	        if (uint8Array.length === 0) {
	            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
	            return;
	        }
	        const { encoding, bom } = TextEncodingToken.get(uint8Array, 0);
	        const length = uint8Array.length;
	        let offset = 0;
	        let output = []; // ToDo
	        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
	        let fzero;
	        debug$m(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);
	        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {
	            case 'T*': // 4.2.1. Text information frames - details
	            case 'GRP1': // iTunes-specific ID3v2 grouping field
	            case 'IPLS': // v2.3: Involved people list
	            case 'MVIN':
	            case 'MVNM':
	            case 'PCS':
	            case 'PCST': {
	                let text;
	                try {
	                    text = decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, '');
	                }
	                catch (error) {
	                    if (error instanceof Error) {
	                        this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
	                        break;
	                    }
	                    throw error;
	                }
	                switch (type) {
	                    case 'TMCL': // Musician credits list
	                    case 'TIPL': // Involved people list
	                    case 'IPLS': // Involved people list
	                        output = FrameParser.functionList(this.splitValue(type, text));
	                        break;
	                    case 'TRK':
	                    case 'TRCK':
	                    case 'TPOS':
	                        output = text;
	                        break;
	                    case 'TCOM':
	                    case 'TEXT':
	                    case 'TOLY':
	                    case 'TOPE':
	                    case 'TPE1':
	                    case 'TSRC':
	                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
	                        output = this.splitValue(type, text);
	                        break;
	                    case 'TCO':
	                    case 'TCON':
	                        output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);
	                        break;
	                    case 'PCS':
	                    case 'PCST':
	                        // TODO: Why `default` not results `1` but `''`?
	                        output = this.major >= 4 ? this.splitValue(type, text) : [text];
	                        output = (Array.isArray(output) && output[0] === '') ? 1 : 0;
	                        break;
	                    default:
	                        output = this.major >= 4 ? this.splitValue(type, text) : [text];
	                }
	                break;
	            }
	            case 'TXXX': {
	                const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
	                const textTag = {
	                    description: idAndData.id,
	                    text: this.splitValue(type, decodeString(idAndData.data, encoding).replace(/\x00+$/, ''))
	                };
	                output = textTag;
	                break;
	            }
	            case 'PIC':
	            case 'APIC':
	                if (includeCovers) {
	                    const pic = {};
	                    offset += 1;
	                    switch (this.major) {
	                        case 2:
	                            pic.format = decodeString(uint8Array.slice(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;
	                            offset += 3;
	                            break;
	                        case 3:
	                        case 4:
	                            fzero = findZero(uint8Array, offset, length, defaultEnc);
	                            pic.format = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
	                            offset = fzero + 1;
	                            break;
	                        default:
	                            throw makeUnexpectedMajorVersionError$1(this.major);
	                    }
	                    pic.format = FrameParser.fixPictureMimeType(pic.format);
	                    pic.type = AttachedPictureType[uint8Array[offset]];
	                    offset += 1;
	                    fzero = findZero(uint8Array, offset, length, encoding);
	                    pic.description = decodeString(uint8Array.slice(offset, fzero), encoding);
	                    offset = fzero + nullTerminatorLength;
	                    pic.data = uint8Array.slice(offset, length);
	                    output = pic;
	                }
	                break;
	            case 'CNT':
	            case 'PCNT':
	                output = UINT32_BE.get(uint8Array, 0);
	                break;
	            case 'SYLT': {
	                const syltHeader = SyncTextHeader.get(uint8Array, 0);
	                offset += SyncTextHeader.len;
	                const result = {
	                    descriptor: '',
	                    language: syltHeader.language,
	                    contentType: syltHeader.contentType,
	                    timeStampFormat: syltHeader.timeStampFormat,
	                    syncText: []
	                };
	                let readSyllables = false;
	                while (offset < length) {
	                    const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);
	                    offset += nullStr.len;
	                    if (readSyllables) {
	                        const timestamp = UINT32_BE.get(uint8Array, offset);
	                        offset += UINT32_BE.len;
	                        result.syncText.push({
	                            text: nullStr.text,
	                            timestamp
	                        });
	                    }
	                    else {
	                        result.descriptor = nullStr.text;
	                        readSyllables = true;
	                    }
	                }
	                output = result;
	                break;
	            }
	            case 'ULT':
	            case 'USLT':
	            case 'COM':
	            case 'COMM': {
	                const textHeader = TextHeader.get(uint8Array, offset);
	                offset += TextHeader.len;
	                const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
	                offset += descriptorStr.len;
	                const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
	                const comment = {
	                    language: textHeader.language,
	                    descriptor: descriptorStr.text,
	                    text: textStr.text
	                };
	                output = comment;
	                break;
	            }
	            case 'UFID': {
	                const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
	                output = { owner_identifier: ufid.id, identifier: ufid.data };
	                break;
	            }
	            case 'PRIV': { // private frame
	                const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
	                output = { owner_identifier: priv.id, data: priv.data };
	                break;
	            }
	            case 'POPM': { // Popularimeter
	                fzero = findZero(uint8Array, offset, length, defaultEnc);
	                const email = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
	                offset = fzero + 1;
	                const dataLen = length - offset;
	                output = {
	                    email,
	                    rating: UINT8.get(uint8Array, offset),
	                    counter: dataLen >= 5 ? UINT32_BE.get(uint8Array, offset + 1) : undefined
	                };
	                break;
	            }
	            case 'GEOB': { // General encapsulated object
	                fzero = findZero(uint8Array, offset + 1, length, encoding);
	                const mimeType = decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
	                offset = fzero + 1;
	                fzero = findZero(uint8Array, offset, length, encoding);
	                const filename = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
	                offset = fzero + 1;
	                fzero = findZero(uint8Array, offset, length, encoding);
	                const description = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
	                offset = fzero + 1;
	                const geob = {
	                    type: mimeType,
	                    filename,
	                    description,
	                    data: uint8Array.slice(offset, length)
	                };
	                output = geob;
	                break;
	            }
	            // W-Frames:
	            case 'WCOM':
	            case 'WCOP':
	            case 'WOAF':
	            case 'WOAR':
	            case 'WOAS':
	            case 'WORS':
	            case 'WPAY':
	            case 'WPUB':
	                // Decode URL
	                fzero = findZero(uint8Array, offset + 1, length, encoding);
	                output = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
	                break;
	            case 'WXXX': {
	                // Decode URL
	                fzero = findZero(uint8Array, offset + 1, length, encoding);
	                const description = decodeString(uint8Array.slice(offset + 1, fzero), encoding);
	                offset = fzero + (encoding === 'utf-16le' ? 2 : 1);
	                output = { description, url: decodeString(uint8Array.slice(offset, length), defaultEnc) };
	                break;
	            }
	            case 'WFD':
	            case 'WFED':
	                output = decodeString(uint8Array.slice(offset + 1, findZero(uint8Array, offset + 1, length, encoding)), encoding);
	                break;
	            case 'MCDI': {
	                // Music CD identifier
	                output = uint8Array.slice(0, length);
	                break;
	            }
	            default:
	                debug$m(`Warning: unsupported id3v2-tag-type: ${type}`);
	                break;
	        }
	        return output;
	    }
	    static readNullTerminatedString(uint8Array, encoding) {
	        let offset = encoding.bom ? 2 : 0;
	        const zeroIndex = findZero(uint8Array, offset, uint8Array.length, encoding.encoding);
	        const txt = uint8Array.slice(offset, zeroIndex);
	        if (encoding.encoding === 'utf-16le') {
	            offset = zeroIndex + 2;
	        }
	        else {
	            offset = zeroIndex + 1;
	        }
	        return {
	            text: decodeString(txt, encoding.encoding),
	            len: offset
	        };
	    }
	    static fixPictureMimeType(pictureType) {
	        pictureType = pictureType.toLocaleLowerCase();
	        switch (pictureType) {
	            case 'jpg':
	                return 'image/jpeg';
	            case 'png':
	                return 'image/png';
	        }
	        return pictureType;
	    }
	    /**
	     * Converts TMCL (Musician credits list) or TIPL (Involved people list)
	     * @param entries
	     */
	    static functionList(entries) {
	        const res = {};
	        for (let i = 0; i + 1 < entries.length; i += 2) {
	            const names = entries[i + 1].split(',');
	            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;
	        }
	        return res;
	    }
	    /**
	     * id3v2.4 defines that multiple T* values are separated by 0x00
	     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
	     * @param tag - Tag name
	     * @param text - Concatenated tag value
	     * @returns Split tag value
	     */
	    splitValue(tag, text) {
	        let values;
	        if (this.major < 4) {
	            values = text.split(/\x00/g);
	            if (values.length > 1) {
	                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);
	            }
	            else {
	                values = text.split(/\//g);
	            }
	        }
	        else {
	            values = text.split(/\x00/g);
	        }
	        return FrameParser.trimArray(values);
	    }
	    static trimArray(values) {
	        return values.map(value => value.replace(/\x00+$/, '').trim());
	    }
	    static readIdentifierAndData(uint8Array, offset, length, encoding) {
	        const fzero = findZero(uint8Array, offset, length, encoding);
	        const id = decodeString(uint8Array.slice(offset, fzero), encoding);
	        offset = fzero + FrameParser.getNullTerminatorLength(encoding);
	        return { id, data: uint8Array.slice(offset, length) };
	    }
	    static getNullTerminatorLength(enc) {
	        return enc === 'utf-16le' ? 2 : 1;
	    }
	}
	class Id3v2ContentError extends makeUnexpectedFileContentError('id3v2') {
	}
	function makeUnexpectedMajorVersionError$1(majorVer) {
	    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
	}

	const asciiDecoder = new TextDecoder('ascii');
	class ID3v2Parser {
	    constructor() {
	        this.tokenizer = undefined;
	        this.id3Header = undefined;
	        this.metadata = undefined;
	        this.headerType = undefined;
	        this.options = undefined;
	    }
	    static removeUnsyncBytes(buffer) {
	        let readI = 0;
	        let writeI = 0;
	        while (readI < buffer.length - 1) {
	            if (readI !== writeI) {
	                buffer[writeI] = buffer[readI];
	            }
	            readI += (buffer[readI] === 0xFF && buffer[readI + 1] === 0) ? 2 : 1;
	            writeI++;
	        }
	        if (readI < buffer.length) {
	            buffer[writeI++] = buffer[readI];
	        }
	        return buffer.slice(0, writeI);
	    }
	    static getFrameHeaderLength(majorVer) {
	        switch (majorVer) {
	            case 2:
	                return 6;
	            case 3:
	            case 4:
	                return 10;
	            default:
	                throw makeUnexpectedMajorVersionError(majorVer);
	        }
	    }
	    static readFrameFlags(b) {
	        return {
	            status: {
	                tag_alter_preservation: getBit(b, 0, 6),
	                file_alter_preservation: getBit(b, 0, 5),
	                read_only: getBit(b, 0, 4)
	            },
	            format: {
	                grouping_identity: getBit(b, 1, 7),
	                compression: getBit(b, 1, 3),
	                encryption: getBit(b, 1, 2),
	                unsynchronisation: getBit(b, 1, 1),
	                data_length_indicator: getBit(b, 1, 0)
	            }
	        };
	    }
	    static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
	        const frameParser = new FrameParser(majorVer, warningCollector);
	        switch (majorVer) {
	            case 2:
	                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
	            case 3:
	            case 4:
	                if (frameHeader.flags?.format.unsynchronisation) {
	                    uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);
	                }
	                if (frameHeader.flags?.format.data_length_indicator) {
	                    uint8Array = uint8Array.slice(4, uint8Array.length);
	                }
	                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
	            default:
	                throw makeUnexpectedMajorVersionError(majorVer);
	        }
	    }
	    /**
	     * Create a combined tag key, of tag & description
	     * @param tag e.g.: COM
	     * @param description e.g. iTunPGAP
	     * @returns string e.g. COM:iTunPGAP
	     */
	    static makeDescriptionTagName(tag, description) {
	        return tag + (description ? `:${description}` : '');
	    }
	    async parse(metadata, tokenizer, options) {
	        this.tokenizer = tokenizer;
	        this.metadata = metadata;
	        this.options = options;
	        const id3Header = await this.tokenizer.readToken(ID3v2Header);
	        if (id3Header.fileIdentifier !== 'ID3') {
	            throw new Id3v2ContentError('expected ID3-header file-identifier \'ID3\' was not found');
	        }
	        this.id3Header = id3Header;
	        this.headerType = (`ID3v2.${id3Header.version.major}`);
	        return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
	    }
	    async parseExtendedHeader() {
	        const extendedHeader = await this.tokenizer.readToken(ExtendedHeader);
	        const dataRemaining = extendedHeader.size - ExtendedHeader.len;
	        return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
	    }
	    async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
	        await this.tokenizer.ignore(dataRemaining);
	        return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
	    }
	    async parseId3Data(dataLen) {
	        const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
	        for (const tag of this.parseMetadata(uint8Array)) {
	            switch (tag.id) {
	                case 'TXXX':
	                    if (tag.value) {
	                        await this.handleTag(tag, tag.value.text, () => tag.value.description);
	                    }
	                    break;
	                default:
	                    await (Array.isArray(tag.value) ? Promise.all(tag.value.map(value => this.addTag(tag.id, value))) : this.addTag(tag.id, tag.value));
	            }
	        }
	    }
	    async handleTag(tag, values, descriptor, resolveValue = value => value) {
	        await Promise.all(values.map(value => this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, descriptor(value)), resolveValue(value))));
	    }
	    async addTag(id, value) {
	        await this.metadata.addTag(this.headerType, id, value);
	    }
	    parseMetadata(data) {
	        let offset = 0;
	        const tags = [];
	        while (true) {
	            if (offset === data.length)
	                break;
	            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
	            if (offset + frameHeaderLength > data.length) {
	                this.metadata.addWarning('Illegal ID3v2 tag length');
	                break;
	            }
	            const frameHeaderBytes = data.slice(offset, offset + frameHeaderLength);
	            offset += frameHeaderLength;
	            const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
	            const frameDataBytes = data.slice(offset, offset + frameHeader.length);
	            offset += frameHeader.length;
	            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
	            if (values) {
	                tags.push({ id: frameHeader.id, value: values });
	            }
	        }
	        return tags;
	    }
	    readFrameHeader(uint8Array, majorVer) {
	        let header;
	        switch (majorVer) {
	            case 2:
	                header = {
	                    id: asciiDecoder.decode(uint8Array.slice(0, 3)),
	                    length: UINT24_BE.get(uint8Array, 3)
	                };
	                if (!header.id.match(/[A-Z0-9]{3}/g)) {
	                    this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
	                }
	                break;
	            case 3:
	            case 4:
	                header = {
	                    id: asciiDecoder.decode(uint8Array.slice(0, 4)),
	                    length: (majorVer === 4 ? UINT32SYNCSAFE : UINT32_BE).get(uint8Array, 4),
	                    flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
	                };
	                if (!header.id.match(/[A-Z0-9]{4}/g)) {
	                    this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
	                }
	                break;
	            default:
	                throw makeUnexpectedMajorVersionError(majorVer);
	        }
	        return header;
	    }
	}
	function makeUnexpectedMajorVersionError(majorVer) {
	    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
	}

	const debug$l = initDebug('music-metadata:parser:ID3');
	/**
	 * Abstract parser which tries take ID3v2 and ID3v1 headers.
	 */
	class AbstractID3Parser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.id3parser = new ID3v2Parser();
	    }
	    static async startsWithID3v2Header(tokenizer) {
	        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';
	    }
	    async parse() {
	        try {
	            await this.parseID3v2();
	        }
	        catch (err) {
	            if (err instanceof EndOfStreamError) {
	                debug$l("End-of-stream");
	            }
	            else {
	                throw err;
	            }
	        }
	    }
	    finalize() {
	        return;
	    }
	    async parseID3v2() {
	        await this.tryReadId3v2Headers();
	        debug$l('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);
	        await this.postId3v2Parse();
	        if (this.options.skipPostHeaders && this.metadata.hasAny()) {
	            this.finalize();
	        }
	        else {
	            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);
	            await id3v1parser.parse();
	            this.finalize();
	        }
	    }
	    async tryReadId3v2Headers() {
	        const id3Header = await this.tokenizer.peekToken(ID3v2Header);
	        if (id3Header.fileIdentifier === 'ID3') {
	            debug$l('Found ID3v2 header, pos=%s', this.tokenizer.position);
	            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
	            return this.tryReadId3v2Headers();
	        }
	    }
	}

	/**
	 * Replay Gain Data Format
	 *
	 * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format
	 */
	const ReplayGain = {
	    len: 2,
	    get: (buf, off) => {
	        const gain_type = getBitAllignedNumber$1(buf, off, 0, 3);
	        const sign = getBitAllignedNumber$1(buf, off, 6, 1);
	        const gain_adj = getBitAllignedNumber$1(buf, off, 7, 9) / 10.0;
	        if (gain_type > 0) {
	            return {
	                type: getBitAllignedNumber$1(buf, off, 0, 3),
	                origin: getBitAllignedNumber$1(buf, off, 3, 3),
	                adjustment: (sign ? -gain_adj : gain_adj)
	            };
	        }
	        return undefined;
	    }
	};

	/**
	 * Extended Lame Header
	 */
	/**
	 * Info Tag
	 * @link http://gabriel.mp3-tech.org/mp3infotag.html
	 * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112
	 */
	const ExtendedLameHeader = {
	    len: 27,
	    get: (buf, off) => {
	        const track_peak = UINT32_BE.get(buf, off + 2);
	        return {
	            revision: getBitAllignedNumber$1(buf, off, 0, 4),
	            vbr_method: getBitAllignedNumber$1(buf, off, 4, 4),
	            lowpass_filter: 100 * UINT8.get(buf, off + 1),
	            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,
	            track_gain: ReplayGain.get(buf, 6),
	            album_gain: ReplayGain.get(buf, 8),
	            music_length: UINT32_BE.get(buf, off + 20),
	            music_crc: UINT8.get(buf, off + 24),
	            header_crc: UINT16_BE.get(buf, off + 24)
	        };
	    }
	};

	/**
	 * Info Tag: Xing, LAME
	 */
	const InfoTagHeaderTag = new StringType(4, 'ascii');
	/**
	 * LAME TAG value
	 * Did not find any official documentation for this
	 * Value e.g.: "3.98.4"
	 */
	const LameEncoderVersion = new StringType(6, 'ascii');
	/**
	 * Info Tag
	 * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
	 */
	const XingHeaderFlags = {
	    len: 4,
	    get: (buf, off) => {
	        return {
	            frames: isBitSet$2(buf, off, 31),
	            bytes: isBitSet$2(buf, off, 30),
	            toc: isBitSet$2(buf, off, 29),
	            vbrScale: isBitSet$2(buf, off, 28)
	        };
	    }
	};
	// /**
	//  * XING Header Tag
	//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
	//  */
	async function readXingHeader(tokenizer) {
	    const flags = await tokenizer.readToken(XingHeaderFlags);
	    const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };
	    if (flags.frames) {
	        xingInfoTag.numFrames = await tokenizer.readToken(UINT32_BE);
	    }
	    if (flags.bytes) {
	        xingInfoTag.streamSize = await tokenizer.readToken(UINT32_BE);
	    }
	    if (flags.toc) {
	        xingInfoTag.toc = new Uint8Array(100);
	        await tokenizer.readBuffer(xingInfoTag.toc);
	    }
	    if (flags.vbrScale) {
	        xingInfoTag.vbrScale = await tokenizer.readToken(UINT32_BE);
	    }
	    const lameTag = await tokenizer.peekToken(new StringType(4, 'ascii'));
	    if (lameTag === 'LAME') {
	        await tokenizer.ignore(4);
	        xingInfoTag.lame = {
	            version: await tokenizer.readToken(new StringType(5, 'ascii'))
	        };
	        const match = xingInfoTag.lame.version.match(/\d+.\d+/g);
	        if (match !== null) {
	            const majorMinorVersion = match[0]; // e.g. 3.97
	            const version = majorMinorVersion.split('.').map(n => Number.parseInt(n, 10));
	            if (version[0] >= 3 && version[1] >= 90) {
	                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);
	            }
	        }
	    }
	    return xingInfoTag;
	}

	const debug$k = initDebug('music-metadata:parser:mpeg');
	class MpegContentError extends makeUnexpectedFileContentError('MPEG') {
	}
	/**
	 * Cache buffer size used for searching synchronization preabmle
	 */
	const maxPeekLen = 1024;
	/**
	 * MPEG-4 Audio definitions
	 * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio
	 */
	const MPEG4 = {
	    /**
	     * Audio Object Types
	     */
	    AudioObjectTypes: [
	        'AAC Main',
	        'AAC LC', // Low Complexity
	        'AAC SSR', // Scalable Sample Rate
	        'AAC LTP' // Long Term Prediction
	    ],
	    /**
	     * Sampling Frequencies
	     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
	     */
	    SamplingFrequencies: [
	        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1
	    ]
	    /**
	     * Channel Configurations
	     */
	};
	const MPEG4_ChannelConfigurations = [
	    undefined,
	    ['front-center'],
	    ['front-left', 'front-right'],
	    ['front-center', 'front-left', 'front-right'],
	    ['front-center', 'front-left', 'front-right', 'back-center'],
	    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],
	    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],
	    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']
	];
	/**
	 * MPEG Audio Layer I/II/III frame header
	 * Ref: https://www.mp3-tech.org/programmer/frame_header.html
	 * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
	 * Ref: https://wiki.multimedia.cx/index.php/ADTS
	 */
	class MpegFrameHeader {
	    constructor(buf, off) {
	        // E(15,12): Bitrate index
	        this.bitrateIndex = null;
	        // F(11,10): Sampling rate frequency index
	        this.sampRateFreqIndex = null;
	        // G(9): Padding bit
	        this.padding = null;
	        // H(8): Private bit
	        this.privateBit = null;
	        // I(7,6): Channel Mode
	        this.channelModeIndex = null;
	        // J(5,4): Mode extension (Only used in Joint stereo)
	        this.modeExtension = null;
	        // L(2): Original
	        this.isOriginalMedia = null;
	        this.version = null;
	        this.bitrate = null;
	        this.samplingRate = null;
	        this.frameLength = 0;
	        // B(20,19): MPEG Audio versionIndex ID
	        this.versionIndex = getBitAllignedNumber$1(buf, off + 1, 3, 2);
	        // C(18,17): Layer description
	        this.layer = MpegFrameHeader.LayerDescription[getBitAllignedNumber$1(buf, off + 1, 5, 2)];
	        if (this.versionIndex > 1 && this.layer === 0) {
	            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)
	        }
	        else {
	            this.parseMpegHeader(buf, off); // Conventional MPEG header
	        }
	        // D(16): Protection bit (if true 16-bit CRC follows header)
	        this.isProtectedByCRC = !isBitSet$2(buf, off + 1, 7);
	    }
	    calcDuration(numFrames) {
	        return this.samplingRate == null ? null : (numFrames * this.calcSamplesPerFrame() / this.samplingRate);
	    }
	    calcSamplesPerFrame() {
	        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
	    }
	    calculateSideInfoLength() {
	        if (this.layer !== 3)
	            return 2;
	        if (this.channelModeIndex === 3) {
	            // mono
	            if (this.version === 1) {
	                return 17;
	            }
	            if (this.version === 2 || this.version === 2.5) {
	                return 9;
	            }
	        }
	        else {
	            if (this.version === 1) {
	                return 32;
	            }
	            if (this.version === 2 || this.version === 2.5) {
	                return 17;
	            }
	        }
	        return null;
	    }
	    calcSlotSize() {
	        return [null, 4, 1, 1][this.layer];
	    }
	    parseMpegHeader(buf, off) {
	        this.container = 'MPEG';
	        // E(15,12): Bitrate index
	        this.bitrateIndex = getBitAllignedNumber$1(buf, off + 2, 0, 4);
	        // F(11,10): Sampling rate frequency index
	        this.sampRateFreqIndex = getBitAllignedNumber$1(buf, off + 2, 4, 2);
	        // G(9): Padding bit
	        this.padding = isBitSet$2(buf, off + 2, 6);
	        // H(8): Private bit
	        this.privateBit = isBitSet$2(buf, off + 2, 7);
	        // I(7,6): Channel Mode
	        this.channelModeIndex = getBitAllignedNumber$1(buf, off + 3, 0, 2);
	        // J(5,4): Mode extension (Only used in Joint stereo)
	        this.modeExtension = getBitAllignedNumber$1(buf, off + 3, 2, 2);
	        // K(3): Copyright
	        this.isCopyrighted = isBitSet$2(buf, off + 3, 4);
	        // L(2): Original
	        this.isOriginalMedia = isBitSet$2(buf, off + 3, 5);
	        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.
	        this.emphasis = getBitAllignedNumber$1(buf, off + 3, 7, 2);
	        this.version = MpegFrameHeader.VersionID[this.versionIndex];
	        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
	        this.codec = `MPEG ${this.version} Layer ${this.layer}`;
	        // Calculate bitrate
	        const bitrateInKbps = this.calcBitrate();
	        if (!bitrateInKbps) {
	            throw new MpegContentError('Cannot determine bit-rate');
	        }
	        this.bitrate = bitrateInKbps * 1000;
	        // Calculate sampling rate
	        this.samplingRate = this.calcSamplingRate();
	        if (this.samplingRate == null) {
	            throw new MpegContentError('Cannot determine sampling-rate');
	        }
	    }
	    parseAdtsHeader(buf, off) {
	        debug$k("layer=0 => ADTS");
	        this.version = this.versionIndex === 2 ? 4 : 2;
	        this.container = `ADTS/MPEG-${this.version}`;
	        const profileIndex = getBitAllignedNumber$1(buf, off + 2, 0, 2);
	        this.codec = 'AAC';
	        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
	        debug$k(`MPEG-4 audio-codec=${this.codec}`);
	        const samplingFrequencyIndex = getBitAllignedNumber$1(buf, off + 2, 2, 4);
	        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
	        debug$k(`sampling-rate=${this.samplingRate}`);
	        const channelIndex = getBitAllignedNumber$1(buf, off + 2, 7, 3);
	        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
	        debug$k(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);
	        this.frameLength = getBitAllignedNumber$1(buf, off + 3, 6, 2) << 11;
	    }
	    calcBitrate() {
	        if (this.bitrateIndex === 0x00 || // free
	            this.bitrateIndex === 0x0F) { // reserved
	            return null;
	        }
	        if (this.version && this.bitrateIndex) {
	            const codecIndex = 10 * Math.floor(this.version) + this.layer;
	            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
	        }
	        return null;
	    }
	    calcSamplingRate() {
	        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null)
	            return null; // 'reserved'
	        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
	    }
	}
	MpegFrameHeader.SyncByte1 = 0xFF;
	MpegFrameHeader.SyncByte2 = 0xE0;
	MpegFrameHeader.VersionID = [2.5, null, 2, 1];
	MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
	MpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];
	MpegFrameHeader.bitrate_index = {
	    1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
	    2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
	    3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
	    4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
	    5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
	    6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
	    7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
	    8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
	    9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
	    10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
	    11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
	    12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
	    13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
	    14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
	};
	MpegFrameHeader.sampling_rate_freq_index = {
	    1: { 0: 44100, 1: 48000, 2: 32000 },
	    2: { 0: 22050, 1: 24000, 2: 16000 },
	    2.5: { 0: 11025, 1: 12000, 2: 8000 }
	};
	MpegFrameHeader.samplesInFrameTable = [
	    /* Layer   I    II   III */
	    [0, 384, 1152, 1152], // MPEG-1
	    [0, 384, 1152, 576] // MPEG-2(.5
	];
	/**
	 * MPEG Audio Layer I/II/III
	 */
	const FrameHeader = {
	    len: 4,
	    get: (buf, off) => {
	        return new MpegFrameHeader(buf, off);
	    }
	};
	function getVbrCodecProfile(vbrScale) {
	    return `V${Math.floor((100 - vbrScale) / 10)}`;
	}
	class MpegParser extends AbstractID3Parser {
	    constructor() {
	        super(...arguments);
	        this.frameCount = 0;
	        this.syncFrameCount = -1;
	        this.countSkipFrameData = 0;
	        this.totalDataLength = 0;
	        this.bitrates = [];
	        this.offset = 0;
	        this.frame_size = 0;
	        this.crc = null;
	        this.calculateEofDuration = false;
	        this.samplesPerFrame = null;
	        this.buf_frame_header = new Uint8Array(4);
	        /**
	         * Number of bytes already parsed since beginning of stream / file
	         */
	        this.mpegOffset = null;
	        this.syncPeek = {
	            buf: new Uint8Array(maxPeekLen),
	            len: 0
	        };
	    }
	    /**
	     * Called after ID3 headers have been parsed
	     */
	    async postId3v2Parse() {
	        this.metadata.setFormat('lossless', false);
	        this.metadata.setAudioOnly();
	        try {
	            let quit = false;
	            while (!quit) {
	                await this.sync();
	                quit = await this.parseCommonMpegHeader();
	            }
	        }
	        catch (err) {
	            if (err instanceof EndOfStreamError) {
	                debug$k("End-of-stream");
	                if (this.calculateEofDuration) {
	                    if (this.samplesPerFrame !== null) {
	                        const numberOfSamples = this.frameCount * this.samplesPerFrame;
	                        this.metadata.setFormat('numberOfSamples', numberOfSamples);
	                        if (this.metadata.format.sampleRate) {
	                            const duration = numberOfSamples / this.metadata.format.sampleRate;
	                            debug$k(`Calculate duration at EOF: ${duration} sec.`, duration);
	                            this.metadata.setFormat('duration', duration);
	                        }
	                    }
	                }
	            }
	            else {
	                throw err;
	            }
	        }
	    }
	    /**
	     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
	     */
	    finalize() {
	        const format = this.metadata.format;
	        const hasID3v1 = !!this.metadata.native.ID3v1;
	        if (this.mpegOffset !== null) {
	            if (format.duration && this.tokenizer.fileInfo.size) {
	                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
	                if (format.codecProfile && format.codecProfile[0] === 'V') {
	                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);
	                }
	            }
	            if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {
	                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
	                if (this.frame_size !== null && this.samplesPerFrame !== null) {
	                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
	                    this.metadata.setFormat('numberOfSamples', numberOfSamples);
	                    if (format.sampleRate && !format.duration) {
	                        const duration = numberOfSamples / format.sampleRate;
	                        debug$k("Calculate CBR duration based on file size: %s", duration);
	                        this.metadata.setFormat('duration', duration);
	                    }
	                }
	            }
	        }
	    }
	    async sync() {
	        let gotFirstSync = false;
	        while (true) {
	            let bo = 0;
	            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });
	            if (this.syncPeek.len <= 163) {
	                throw new EndOfStreamError();
	            }
	            while (true) {
	                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {
	                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
	                    this.buf_frame_header[1] = this.syncPeek.buf[bo];
	                    await this.tokenizer.ignore(bo);
	                    debug$k(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
	                    if (this.syncFrameCount === this.frameCount) {
	                        debug$k(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
	                        this.frameCount = 0;
	                        this.frame_size = 0;
	                    }
	                    this.syncFrameCount = this.frameCount;
	                    return; // sync
	                }
	                gotFirstSync = false;
	                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
	                if (bo === -1) {
	                    if (this.syncPeek.len < this.syncPeek.buf.length) {
	                        throw new EndOfStreamError();
	                    }
	                    await this.tokenizer.ignore(this.syncPeek.len);
	                    break; // continue with next buffer
	                }
	                ++bo;
	                gotFirstSync = true;
	            }
	        }
	    }
	    /**
	     * Combined ADTS & MPEG (MP2 & MP3) header handling
	     * @return {Promise<boolean>} true if parser should quit
	     */
	    async parseCommonMpegHeader() {
	        if (this.frameCount === 0) {
	            this.mpegOffset = this.tokenizer.position - 1;
	        }
	        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });
	        let header;
	        try {
	            header = FrameHeader.get(this.buf_frame_header, 0);
	        }
	        catch (err) {
	            await this.tokenizer.ignore(1);
	            if (err instanceof Error) {
	                this.metadata.addWarning(`Parse error: ${err.message}`);
	                return false; // sync
	            }
	            throw err;
	        }
	        await this.tokenizer.ignore(3);
	        this.metadata.setFormat('container', header.container);
	        this.metadata.setFormat('codec', header.codec);
	        this.metadata.setFormat('lossless', false);
	        this.metadata.setFormat('sampleRate', header.samplingRate);
	        this.frameCount++;
	        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
	    }
	    /**
	     * @return {Promise<boolean>} true if parser should quit
	     */
	    async parseAudioFrameHeader(header) {
	        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);
	        this.metadata.setFormat('bitrate', header.bitrate);
	        if (this.frameCount < 20 * 10000) {
	            debug$k('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
	        }
	        const slot_size = header.calcSlotSize();
	        if (slot_size === null) {
	            throw new MpegContentError('invalid slot_size');
	        }
	        const samples_per_frame = header.calcSamplesPerFrame();
	        debug$k(`samples_per_frame=${samples_per_frame}`);
	        const bps = samples_per_frame / 8.0;
	        if (header.bitrate !== null && header.samplingRate != null) {
	            const fsize = (bps * header.bitrate / header.samplingRate) + ((header.padding) ? slot_size : 0);
	            this.frame_size = Math.floor(fsize);
	        }
	        this.audioFrameHeader = header;
	        if (header.bitrate !== null) {
	            this.bitrates.push(header.bitrate);
	        }
	        // xtra header only exists in first frame
	        if (this.frameCount === 1) {
	            this.offset = FrameHeader.len;
	            await this.skipSideInformation();
	            return false;
	        }
	        if (this.frameCount === 3) {
	            // the stream is CBR if the first 3 frame bitrates are the same
	            if (this.areAllSame(this.bitrates)) {
	                // Actual calculation will be done in finalize
	                this.samplesPerFrame = samples_per_frame;
	                this.metadata.setFormat('codecProfile', 'CBR');
	                if (this.tokenizer.fileInfo.size)
	                    return true; // Will calculate duration based on the file size
	            }
	            else if (this.metadata.format.duration) {
	                return true; // We already got the duration, stop processing MPEG stream any further
	            }
	            if (!this.options.duration) {
	                return true; // Enforce duration not enabled, stop processing entire stream
	            }
	        }
	        // once we know the file is VBR attach listener to end of
	        // stream so we can do the duration calculation when we
	        // have counted all the frames
	        if (this.options.duration && this.frameCount === 4) {
	            this.samplesPerFrame = samples_per_frame;
	            this.calculateEofDuration = true;
	        }
	        this.offset = 4;
	        if (header.isProtectedByCRC) {
	            await this.parseCrc();
	            return false;
	        }
	        await this.skipSideInformation();
	        return false;
	    }
	    async parseAdts(header) {
	        const buf = new Uint8Array(3);
	        await this.tokenizer.readBuffer(buf);
	        header.frameLength += getBitAllignedNumber$1(buf, 0, 0, 11);
	        this.totalDataLength += header.frameLength;
	        this.samplesPerFrame = 1024;
	        if (header.samplingRate !== null) {
	            const framesPerSec = header.samplingRate / this.samplesPerFrame;
	            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
	            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
	            this.metadata.setFormat('bitrate', bitrate);
	            debug$k(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);
	        }
	        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
	        // Consume remaining header and frame data
	        if (this.frameCount === 3) {
	            this.metadata.setFormat('codecProfile', header.codecProfile);
	            if (header.mp4ChannelConfig) {
	                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);
	            }
	            if (this.options.duration) {
	                this.calculateEofDuration = true;
	            }
	            else {
	                return true; // Stop parsing after the third frame
	            }
	        }
	        return false;
	    }
	    async parseCrc() {
	        this.crc = await this.tokenizer.readNumber(INT16_BE);
	        this.offset += 2;
	        return this.skipSideInformation();
	    }
	    async skipSideInformation() {
	        if (this.audioFrameHeader) {
	            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
	            if (sideinfo_length !== null) {
	                await this.tokenizer.readToken(new Uint8ArrayType(sideinfo_length));
	                // side information
	                this.offset += sideinfo_length;
	                await this.readXtraInfoHeader();
	                return;
	            }
	        }
	    }
	    async readXtraInfoHeader() {
	        const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);
	        this.offset += InfoTagHeaderTag.len; // 12
	        switch (headerTag) {
	            case 'Info':
	                this.metadata.setFormat('codecProfile', 'CBR');
	                return this.readXingInfoHeader();
	            case 'Xing': {
	                const infoTag = await this.readXingInfoHeader();
	                if (infoTag.vbrScale !== null) {
	                    const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
	                    this.metadata.setFormat('codecProfile', codecProfile);
	                }
	                return null;
	            }
	            case 'Xtra':
	                // ToDo: ???
	                break;
	            case 'LAME': {
	                const version = await this.tokenizer.readToken(LameEncoderVersion);
	                if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {
	                    this.offset += LameEncoderVersion.len;
	                    this.metadata.setFormat('tool', `LAME ${version}`);
	                    await this.skipFrameData(this.frame_size - this.offset);
	                    return null;
	                }
	                this.metadata.addWarning('Corrupt LAME header');
	                break;
	            }
	            // ToDo: ???
	        }
	        // ToDo: promise duration???
	        const frameDataLeft = this.frame_size - this.offset;
	        if (frameDataLeft < 0) {
	            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);
	        }
	        else {
	            await this.skipFrameData(frameDataLeft);
	        }
	        return null;
	    }
	    /**
	     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
	     * @returns {Promise<string>}
	     */
	    async readXingInfoHeader() {
	        const offset = this.tokenizer.position;
	        const infoTag = await readXingHeader(this.tokenizer);
	        this.offset += this.tokenizer.position - offset;
	        if (infoTag.lame) {
	            this.metadata.setFormat('tool', `LAME ${stripNulls(infoTag.lame.version)}`);
	            if (infoTag.lame.extended) {
	                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);
	                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);
	                if (infoTag.lame.extended.track_gain) {
	                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);
	                }
	                if (infoTag.lame.extended.album_gain) {
	                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);
	                }
	                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);
	            }
	        }
	        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {
	            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
	            this.metadata.setFormat('duration', duration);
	            debug$k('Get duration from Xing header: %s', this.metadata.format.duration);
	            return infoTag;
	        }
	        // frames field is not present
	        const frameDataLeft = this.frame_size - this.offset;
	        await this.skipFrameData(frameDataLeft);
	        return infoTag;
	    }
	    async skipFrameData(frameDataLeft) {
	        if (frameDataLeft < 0)
	            throw new MpegContentError('frame-data-left cannot be negative');
	        await this.tokenizer.ignore(frameDataLeft);
	        this.countSkipFrameData += frameDataLeft;
	    }
	    areAllSame(array) {
	        const first = array[0];
	        return array.every(element => {
	            return element === first;
	        });
	    }
	}

	var MpegParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MpegContentError: MpegContentError,
		MpegParser: MpegParser
	});

	/**
	 * Ref:
	 * - https://tools.ietf.org/html/draft-fleischman-asf-01, Appendix A: ASF GUIDs
	 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html
	 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html
	 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html
	 *
	 * ASF File Structure:
	 * - https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx
	 *
	 * ASF GUIDs:
	 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html
	 * - https://github.com/dji-sdk/FFmpeg/blob/master/libavformat/asf.c
	 */
	class GUID {
	    static fromBin(bin, offset = 0) {
	        return new GUID(GUID.decode(bin, offset));
	    }
	    /**
	     * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
	     * @param objectId Binary GUID
	     * @param offset Read offset in bytes, default 0
	     * @returns GUID as dashed hexadecimal representation
	     */
	    static decode(objectId, offset = 0) {
	        const view = new DataView(objectId.buffer, offset);
	        const guid = `${view.getUint32(0, true).toString(16)}-${view.getUint16(4, true).toString(16)}-${view.getUint16(6, true).toString(16)}-${view.getUint16(8).toString(16)}-${uint8ArrayToHex(objectId.slice(offset + 10, offset + 16))}`;
	        return guid.toUpperCase();
	    }
	    /**
	     * Decode stream type
	     * @param mediaType Media type GUID
	     * @returns Media type
	     */
	    static decodeMediaType(mediaType) {
	        switch (mediaType.str) {
	            case GUID.AudioMedia.str: return 'audio';
	            case GUID.VideoMedia.str: return 'video';
	            case GUID.CommandMedia.str: return 'command';
	            case GUID.Degradable_JPEG_Media.str: return 'degradable-jpeg';
	            case GUID.FileTransferMedia.str: return 'file-transfer';
	            case GUID.BinaryMedia.str: return 'binary';
	        }
	    }
	    /**
	     * Encode GUID
	     * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
	     * @returns Encoded Binary GUID
	     */
	    static encode(str) {
	        const bin = new Uint8Array(16);
	        const view = new DataView(bin.buffer);
	        view.setUint32(0, Number.parseInt(str.slice(0, 8), 16), true);
	        view.setUint16(4, Number.parseInt(str.slice(9, 13), 16), true);
	        view.setUint16(6, Number.parseInt(str.slice(14, 18), 16), true);
	        bin.set(hexToUint8Array(str.slice(19, 23)), 8);
	        bin.set(hexToUint8Array(str.slice(24)), 10);
	        return bin;
	    }
	    constructor(str) {
	        this.str = str;
	    }
	    equals(guid) {
	        return this.str === guid.str;
	    }
	    toBin() {
	        return GUID.encode(this.str);
	    }
	}
	// 10.1 Top-level ASF object GUIDs
	GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
	GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
	GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
	GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
	GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
	GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
	// 10.2 Header Object GUIDs
	GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
	GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
	GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
	GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
	GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
	GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
	GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
	GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
	GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
	GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
	GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
	GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
	GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
	GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
	GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
	GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
	// 10.3 Header Extension Object GUIDs
	GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
	GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
	GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
	GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
	GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
	GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
	GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
	GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
	GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
	GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
	GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
	GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
	GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
	// 10.4 Stream Properties Object Stream Type GUIDs
	GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
	GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
	GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
	GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
	GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
	GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
	GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
	GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");

	function getParserForAttr(i) {
	    return attributeParsers[i];
	}
	function parseUnicodeAttr(uint8Array) {
	    return stripNulls(decodeString(uint8Array, 'utf-16le'));
	}
	const attributeParsers = [
	    parseUnicodeAttr,
	    parseByteArrayAttr,
	    parseBoolAttr,
	    parseDWordAttr,
	    parseQWordAttr,
	    parseWordAttr,
	    parseByteArrayAttr
	];
	function parseByteArrayAttr(buf) {
	    return new Uint8Array(buf);
	}
	function parseBoolAttr(buf, offset = 0) {
	    return parseWordAttr(buf, offset) === 1;
	}
	function parseDWordAttr(buf, offset = 0) {
	    return UINT32_LE.get(buf, offset);
	}
	function parseQWordAttr(buf, offset = 0) {
	    return UINT64_LE.get(buf, offset);
	}
	function parseWordAttr(buf, offset = 0) {
	    return UINT16_LE.get(buf, offset);
	}

	// ASF Objects
	class AsfContentParseError extends makeUnexpectedFileContentError('ASF') {
	}
	/**
	 * Token for: 3. ASF top-level Header Object
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3
	 */
	const TopLevelHeaderObjectToken = {
	    len: 30,
	    get: (buf, off) => {
	        return {
	            objectId: GUID.fromBin(buf, off),
	            objectSize: Number(UINT64_LE.get(buf, off + 16)),
	            numberOfHeaderObjects: UINT32_LE.get(buf, off + 24)
	            // Reserved: 2 bytes
	        };
	    }
	};
	/**
	 * Token for: 3.1 Header Object (mandatory, one only)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_1
	 */
	const HeaderObjectToken = {
	    len: 24,
	    get: (buf, off) => {
	        return {
	            objectId: GUID.fromBin(buf, off),
	            objectSize: Number(UINT64_LE.get(buf, off + 16))
	        };
	    }
	};
	class State {
	    constructor(header) {
	        this.len = Number(header.objectSize) - HeaderObjectToken.len;
	    }
	    postProcessTag(tags, name, valueType, data) {
	        if (name === 'WM/Picture') {
	            tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
	        }
	        else {
	            const parseAttr = getParserForAttr(valueType);
	            if (!parseAttr) {
	                throw new AsfContentParseError(`unexpected value headerType: ${valueType}`);
	            }
	            tags.push({ id: name, value: parseAttr(data) });
	        }
	    }
	}
	// ToDo: use ignore type
	class IgnoreObjectState extends State {
	    get(_buf, _off) {
	        return null;
	    }
	}
	/**
	 * Token for: 3.2: File Properties Object (mandatory, one only)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_2
	 */
	class FilePropertiesObject extends State {
	    get(buf, off) {
	        return {
	            fileId: GUID.fromBin(buf, off),
	            fileSize: UINT64_LE.get(buf, off + 16),
	            creationDate: UINT64_LE.get(buf, off + 24),
	            dataPacketsCount: UINT64_LE.get(buf, off + 32),
	            playDuration: UINT64_LE.get(buf, off + 40),
	            sendDuration: UINT64_LE.get(buf, off + 48),
	            preroll: UINT64_LE.get(buf, off + 56),
	            flags: {
	                broadcast: getBit(buf, off + 64, 24),
	                seekable: getBit(buf, off + 64, 25)
	            },
	            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
	            minimumDataPacketSize: UINT32_LE.get(buf, off + 68),
	            maximumDataPacketSize: UINT32_LE.get(buf, off + 72),
	            maximumBitrate: UINT32_LE.get(buf, off + 76)
	        };
	    }
	}
	FilePropertiesObject.guid = GUID.FilePropertiesObject;
	/**
	 * Token for: 3.3 Stream Properties Object (mandatory, one per stream)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_3
	 */
	class StreamPropertiesObject extends State {
	    get(buf, off) {
	        return {
	            streamType: GUID.decodeMediaType(GUID.fromBin(buf, off)),
	            errorCorrectionType: GUID.fromBin(buf, off + 8)
	            // ToDo
	        };
	    }
	}
	StreamPropertiesObject.guid = GUID.StreamPropertiesObject;
	/**
	 * 3.4: Header Extension Object (mandatory, one only)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_4
	 */
	class HeaderExtensionObject {
	    constructor() {
	        this.len = 22;
	    }
	    get(buf, off) {
	        const view = new DataView(buf.buffer, off);
	        return {
	            reserved1: GUID.fromBin(buf, off),
	            reserved2: view.getUint16(16, true),
	            extensionDataSize: view.getUint16(18, true)
	        };
	    }
	}
	HeaderExtensionObject.guid = GUID.HeaderExtensionObject;
	/**
	 * 3.5: The Codec List Object provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5
	 */
	const CodecListObjectHeader = {
	    len: 20,
	    get: (buf, off) => {
	        const view = new DataView(buf.buffer, off);
	        return {
	            entryCount: view.getUint16(16, true)
	        };
	    }
	};
	async function readString(tokenizer) {
	    const length = await tokenizer.readNumber(UINT16_LE);
	    return (await tokenizer.readToken(new StringType(length * 2, 'utf-16le'))).replace('\0', '');
	}
	/**
	 * 3.5: Read the Codec-List-Object, which provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5
	 */
	async function readCodecEntries(tokenizer) {
	    const codecHeader = await tokenizer.readToken(CodecListObjectHeader);
	    const entries = [];
	    for (let i = 0; i < codecHeader.entryCount; ++i) {
	        entries.push(await readCodecEntry(tokenizer));
	    }
	    return entries;
	}
	async function readInformation(tokenizer) {
	    const length = await tokenizer.readNumber(UINT16_LE);
	    const buf = new Uint8Array(length);
	    await tokenizer.readBuffer(buf);
	    return buf;
	}
	/**
	 * Read Codec-Entries
	 * @param tokenizer
	 */
	async function readCodecEntry(tokenizer) {
	    const type = await tokenizer.readNumber(UINT16_LE);
	    return {
	        type: {
	            videoCodec: (type & 0x0001) === 0x0001,
	            audioCodec: (type & 0x0002) === 0x0002
	        },
	        codecName: await readString(tokenizer),
	        description: await readString(tokenizer),
	        information: await readInformation(tokenizer)
	    };
	}
	/**
	 * 3.10 Content Description Object (optional, one only)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_10
	 */
	class ContentDescriptionObjectState extends State {
	    get(buf, off) {
	        const tags = [];
	        const view = new DataView(buf.buffer, off);
	        let pos = 10;
	        for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {
	            const length = view.getUint16(i * 2, true);
	            if (length > 0) {
	                const tagName = ContentDescriptionObjectState.contentDescTags[i];
	                const end = pos + length;
	                tags.push({ id: tagName, value: parseUnicodeAttr(buf.slice(off + pos, off + end)) });
	                pos = end;
	            }
	        }
	        return tags;
	    }
	}
	ContentDescriptionObjectState.guid = GUID.ContentDescriptionObject;
	ContentDescriptionObjectState.contentDescTags = ['Title', 'Author', 'Copyright', 'Description', 'Rating'];
	/**
	 * 3.11 Extended Content Description Object (optional, one only)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_11
	 */
	class ExtendedContentDescriptionObjectState extends State {
	    get(buf, off) {
	        const tags = [];
	        const view = new DataView(buf.buffer, off);
	        const attrCount = view.getUint16(0, true);
	        let pos = 2;
	        for (let i = 0; i < attrCount; i += 1) {
	            const nameLen = view.getUint16(pos, true);
	            pos += 2;
	            const name = parseUnicodeAttr(buf.slice(off + pos, off + pos + nameLen));
	            pos += nameLen;
	            const valueType = view.getUint16(pos, true);
	            pos += 2;
	            const valueLen = view.getUint16(pos, true);
	            pos += 2;
	            const value = buf.slice(off + pos, off + pos + valueLen);
	            pos += valueLen;
	            this.postProcessTag(tags, name, valueType, value);
	        }
	        return tags;
	    }
	}
	ExtendedContentDescriptionObjectState.guid = GUID.ExtendedContentDescriptionObject;
	/**
	 * 4.1 Extended Stream Properties Object (optional, 1 per media stream)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_1
	 */
	class ExtendedStreamPropertiesObjectState extends State {
	    get(buf, off) {
	        const view = new DataView(buf.buffer, off);
	        return {
	            startTime: UINT64_LE.get(buf, off),
	            endTime: UINT64_LE.get(buf, off + 8),
	            dataBitrate: view.getInt32(12, true),
	            bufferSize: view.getInt32(16, true),
	            initialBufferFullness: view.getInt32(20, true),
	            alternateDataBitrate: view.getInt32(24, true),
	            alternateBufferSize: view.getInt32(28, true),
	            alternateInitialBufferFullness: view.getInt32(32, true),
	            maximumObjectSize: view.getInt32(36, true),
	            flags: {
	                reliableFlag: getBit(buf, off + 40, 0),
	                seekableFlag: getBit(buf, off + 40, 1),
	                resendLiveCleanpointsFlag: getBit(buf, off + 40, 2)
	            },
	            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
	            streamNumber: view.getInt16(42, true),
	            streamLanguageId: view.getInt16(44, true),
	            averageTimePerFrame: view.getInt32(52, true),
	            streamNameCount: view.getInt32(54, true),
	            payloadExtensionSystems: view.getInt32(56, true),
	            streamNames: [], // ToDo
	            streamPropertiesObject: null
	        };
	    }
	}
	ExtendedStreamPropertiesObjectState.guid = GUID.ExtendedStreamPropertiesObject;
	/**
	 * 4.7  Metadata Object (optional, 0 or 1)
	 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_7
	 */
	class MetadataObjectState extends State {
	    get(uint8Array, off) {
	        const tags = [];
	        const view = new DataView(uint8Array.buffer, off);
	        const descriptionRecordsCount = view.getUint16(0, true);
	        let pos = 2;
	        for (let i = 0; i < descriptionRecordsCount; i += 1) {
	            pos += 4;
	            const nameLen = view.getUint16(pos, true);
	            pos += 2;
	            const dataType = view.getUint16(pos, true);
	            pos += 2;
	            const dataLen = view.getUint32(pos, true);
	            pos += 4;
	            const name = parseUnicodeAttr(uint8Array.slice(off + pos, off + pos + nameLen));
	            pos += nameLen;
	            const data = uint8Array.slice(off + pos, off + pos + dataLen);
	            pos += dataLen;
	            this.postProcessTag(tags, name, dataType, data);
	        }
	        return tags;
	    }
	}
	MetadataObjectState.guid = GUID.MetadataObject;
	// 4.8	Metadata Library Object (optional, 0 or 1)
	class MetadataLibraryObjectState extends MetadataObjectState {
	}
	MetadataLibraryObjectState.guid = GUID.MetadataLibraryObject;
	/**
	 * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd757977(v=vs.85).aspx
	 */
	class WmPictureToken {
	    static fromBuffer(buffer) {
	        const pic = new WmPictureToken(buffer.length);
	        return pic.get(buffer, 0);
	    }
	    constructor(len) {
	        this.len = len;
	    }
	    get(buffer, offset) {
	        const view = new DataView(buffer.buffer, offset);
	        const typeId = view.getUint8(0);
	        const size = view.getInt32(1, true);
	        let index = 5;
	        while (view.getUint16(index) !== 0) {
	            index += 2;
	        }
	        const format = new StringType(index - 5, 'utf-16le').get(buffer, 5);
	        while (view.getUint16(index) !== 0) {
	            index += 2;
	        }
	        const description = new StringType(index - 5, 'utf-16le').get(buffer, 5);
	        return {
	            type: AttachedPictureType[typeId],
	            format,
	            description,
	            size,
	            data: buffer.slice(index + 4)
	        };
	    }
	}

	const debug$j = initDebug('music-metadata:parser:ASF');
	const headerType = 'asf';
	/**
	 * Windows Media Metadata Usage Guidelines
	 * - Ref: https://msdn.microsoft.com/en-us/library/ms867702.aspx
	 *
	 * Ref:
	 * - https://tools.ietf.org/html/draft-fleischman-asf-01
	 * - https://hwiegman.home.xs4all.nl/fileformats/asf/ASF_Specification.pdf
	 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html
	 * - https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx
	 */
	class AsfParser extends BasicParser {
	    async parse() {
	        const header = await this.tokenizer.readToken(TopLevelHeaderObjectToken);
	        if (!header.objectId.equals(GUID.HeaderObject)) {
	            throw new AsfContentParseError(`expected asf header; but was not found; got: ${header.objectId.str}`);
	        }
	        try {
	            await this.parseObjectHeader(header.numberOfHeaderObjects);
	        }
	        catch (err) {
	            debug$j('Error while parsing ASF: %s', err);
	        }
	    }
	    async parseObjectHeader(numberOfObjectHeaders) {
	        let tags;
	        do {
	            // Parse common header of the ASF Object (3.1)
	            const header = await this.tokenizer.readToken(HeaderObjectToken);
	            // Parse data part of the ASF Object
	            debug$j('header GUID=%s', header.objectId.str);
	            switch (header.objectId.str) {
	                case FilePropertiesObject.guid.str: { // 3.2
	                    const fpo = await this.tokenizer.readToken(new FilePropertiesObject(header));
	                    this.metadata.setFormat('duration', Number(fpo.playDuration / BigInt(1000)) / 10000 - Number(fpo.preroll) / 1000);
	                    this.metadata.setFormat('bitrate', fpo.maximumBitrate);
	                    break;
	                }
	                case StreamPropertiesObject.guid.str: { // 3.3
	                    const spo = await this.tokenizer.readToken(new StreamPropertiesObject(header));
	                    this.metadata.setFormat('container', `ASF/${spo.streamType}`);
	                    break;
	                }
	                case HeaderExtensionObject.guid.str: { // 3.4
	                    const extHeader = await this.tokenizer.readToken(new HeaderExtensionObject());
	                    await this.parseExtensionObject(extHeader.extensionDataSize);
	                    break;
	                }
	                case ContentDescriptionObjectState.guid.str: // 3.10
	                    tags = await this.tokenizer.readToken(new ContentDescriptionObjectState(header));
	                    await this.addTags(tags);
	                    break;
	                case ExtendedContentDescriptionObjectState.guid.str: // 3.11
	                    tags = await this.tokenizer.readToken(new ExtendedContentDescriptionObjectState(header));
	                    await this.addTags(tags);
	                    break;
	                case GUID.CodecListObject.str: {
	                    const codecs = await readCodecEntries(this.tokenizer);
	                    codecs.forEach(codec => {
	                        this.metadata.addStreamInfo({
	                            type: codec.type.videoCodec ? TrackType.video : TrackType.audio,
	                            codecName: codec.codecName
	                        });
	                    });
	                    const audioCodecs = codecs.filter(codec => codec.type.audioCodec).map(codec => codec.codecName).join('/');
	                    this.metadata.setFormat('codec', audioCodecs);
	                    break;
	                }
	                case GUID.StreamBitratePropertiesObject.str:
	                    // ToDo?
	                    await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
	                    break;
	                case GUID.PaddingObject.str:
	                    // ToDo: register bytes pad
	                    debug$j('Padding: %s bytes', header.objectSize - HeaderObjectToken.len);
	                    await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
	                    break;
	                default:
	                    this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
	                    debug$j('Ignore ASF-Object-GUID: %s', header.objectId.str);
	                    await this.tokenizer.readToken(new IgnoreObjectState(header));
	            }
	        } while (--numberOfObjectHeaders);
	        // done
	    }
	    async addTags(tags) {
	        await Promise.all(tags.map(({ id, value }) => this.metadata.addTag(headerType, id, value)));
	    }
	    async parseExtensionObject(extensionSize) {
	        do {
	            // Parse common header of the ASF Object (3.1)
	            const header = await this.tokenizer.readToken(HeaderObjectToken);
	            const remaining = header.objectSize - HeaderObjectToken.len;
	            // Parse data part of the ASF Object
	            switch (header.objectId.str) {
	                case ExtendedStreamPropertiesObjectState.guid.str: // 4.1
	                    // ToDo: extended stream header properties are ignored
	                    await this.tokenizer.readToken(new ExtendedStreamPropertiesObjectState(header));
	                    break;
	                case MetadataObjectState.guid.str: { // 4.7
	                    const moTags = await this.tokenizer.readToken(new MetadataObjectState(header));
	                    await this.addTags(moTags);
	                    break;
	                }
	                case MetadataLibraryObjectState.guid.str: { // 4.8
	                    const mlTags = await this.tokenizer.readToken(new MetadataLibraryObjectState(header));
	                    await this.addTags(mlTags);
	                    break;
	                }
	                case GUID.PaddingObject.str:
	                    // ToDo: register bytes pad
	                    await this.tokenizer.ignore(remaining);
	                    break;
	                case GUID.CompatibilityObject.str:
	                    await this.tokenizer.ignore(remaining);
	                    break;
	                case GUID.ASF_Index_Placeholder_Object.str:
	                    await this.tokenizer.ignore(remaining);
	                    break;
	                default:
	                    this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
	                    // console.log("Ignore ASF-Object-GUID: %s", header.objectId.str);
	                    await this.tokenizer.readToken(new IgnoreObjectState(header));
	                    break;
	            }
	            extensionSize -= header.objectSize;
	        } while (extensionSize > 0);
	    }
	}

	var AsfParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		AsfParser: AsfParser
	});

	/**
	 * DSDIFF chunk header
	 * The data-size encoding is deviating from EA-IFF 85
	 * Ref: http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf
	 */
	const ChunkHeader64 = {
	    len: 12,
	    get: (buf, off) => {
	        return {
	            // Group-ID
	            chunkID: FourCcToken.get(buf, off),
	            // Size
	            chunkSize: INT64_BE.get(buf, off + 4)
	        };
	    }
	};

	const debug$i = initDebug('music-metadata:parser:aiff');
	class DsdiffContentParseError extends makeUnexpectedFileContentError('DSDIFF') {
	}
	/**
	 * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)
	 *
	 * Ref:
	 * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf
	 */
	class DsdiffParser extends BasicParser {
	    async parse() {
	        const header = await this.tokenizer.readToken(ChunkHeader64);
	        if (header.chunkID !== 'FRM8')
	            throw new DsdiffContentParseError('Unexpected chunk-ID');
	        this.metadata.setAudioOnly();
	        const type = (await this.tokenizer.readToken(FourCcToken)).trim();
	        switch (type) {
	            case 'DSD':
	                this.metadata.setFormat('container', `DSDIFF/${type}`);
	                this.metadata.setFormat('lossless', true);
	                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));
	            default:
	                throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);
	        }
	    }
	    async readFmt8Chunks(remainingSize) {
	        while (remainingSize >= ChunkHeader64.len) {
	            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);
	            //  If the data is an odd number of bytes in length, a pad byte must be added at the end
	            debug$i(`Chunk id=${chunkHeader.chunkID}`);
	            await this.readData(chunkHeader);
	            remainingSize -= (BigInt(ChunkHeader64.len) + chunkHeader.chunkSize);
	        }
	    }
	    async readData(header) {
	        debug$i(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
	        const p0 = this.tokenizer.position;
	        switch (header.chunkID.trim()) {
	            case 'FVER': { // 3.1 FORMAT VERSION CHUNK
	                const version = await this.tokenizer.readToken(UINT32_LE);
	                debug$i(`DSDIFF version=${version}`);
	                break;
	            }
	            case 'PROP': { // 3.2 PROPERTY CHUNK
	                const propType = await this.tokenizer.readToken(FourCcToken);
	                if (propType !== 'SND ')
	                    throw new DsdiffContentParseError('Unexpected PROP-chunk ID');
	                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));
	                break;
	            }
	            case 'ID3': { // Unofficial ID3 tag support
	                const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(Number(header.chunkSize)));
	                const rst = fromBuffer(id3_data);
	                await new ID3v2Parser().parse(this.metadata, rst, this.options);
	                break;
	            }
	            case 'DSD':
	                if (this.metadata.format.numberOfChannels) {
	                    this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));
	                }
	                if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {
	                    this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
	                }
	                break;
	            default:
	                debug$i(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
	                break;
	        }
	        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
	        if (remaining > 0) {
	            debug$i(`After Parsing chunk, remaining ${remaining} bytes`);
	            await this.tokenizer.ignore(Number(remaining));
	        }
	    }
	    async handleSoundPropertyChunks(remainingSize) {
	        debug$i(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
	        while (remainingSize > 0) {
	            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);
	            debug$i(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
	            const p0 = this.tokenizer.position;
	            switch (sndPropHeader.chunkID.trim()) {
	                case 'FS': { // 3.2.1 Sample Rate Chunk
	                    const sampleRate = await this.tokenizer.readToken(UINT32_BE);
	                    this.metadata.setFormat('sampleRate', sampleRate);
	                    break;
	                }
	                case 'CHNL': { // 3.2.2 Channels Chunk
	                    const numChannels = await this.tokenizer.readToken(UINT16_BE);
	                    this.metadata.setFormat('numberOfChannels', numChannels);
	                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(UINT16_BE.len));
	                    break;
	                }
	                case 'CMPR': { // 3.2.3 Compression Type Chunk
	                    const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();
	                    const count = await this.tokenizer.readToken(UINT8);
	                    const compressionName = await this.tokenizer.readToken(new StringType(count, 'ascii'));
	                    if (compressionIdCode === 'DSD') {
	                        this.metadata.setFormat('lossless', true);
	                        this.metadata.setFormat('bitsPerSample', 1);
	                    }
	                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);
	                    break;
	                }
	                case 'ABSS': { // 3.2.4 Absolute Start Time Chunk
	                    const hours = await this.tokenizer.readToken(UINT16_BE);
	                    const minutes = await this.tokenizer.readToken(UINT8);
	                    const seconds = await this.tokenizer.readToken(UINT8);
	                    const samples = await this.tokenizer.readToken(UINT32_BE);
	                    debug$i(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
	                    break;
	                }
	                case 'LSCO': { // 3.2.5 Loudspeaker Configuration Chunk
	                    const lsConfig = await this.tokenizer.readToken(UINT16_BE);
	                    debug$i(`LSCO lsConfig=${lsConfig}`);
	                    break;
	                }
	                default:
	                    debug$i(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
	                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
	            }
	            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
	            if (remaining > 0) {
	                debug$i(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);
	                await this.tokenizer.ignore(Number(remaining));
	            }
	            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;
	            debug$i(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
	        }
	        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
	            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
	            this.metadata.setFormat('bitrate', bitrate);
	        }
	    }
	    async handleChannelChunks(remainingSize) {
	        debug$i(`Parsing channel-chunks, remainingSize=${remainingSize}`);
	        const channels = [];
	        while (remainingSize >= FourCcToken.len) {
	            const channelId = await this.tokenizer.readToken(FourCcToken);
	            debug$i(`Channel[ID=${channelId}]`);
	            channels.push(channelId);
	            remainingSize -= BigInt(FourCcToken.len);
	        }
	        debug$i(`Channels: ${channels.join(', ')}`);
	        return channels;
	    }
	}

	var DsdiffParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DsdiffContentParseError: DsdiffContentParseError,
		DsdiffParser: DsdiffParser
	});

	const compressionTypes = {
	    NONE: 'not compressed	PCM	Apple Computer',
	    sowt: 'PCM (byte swapped)',
	    fl32: '32-bit floating point IEEE 32-bit float',
	    fl64: '64-bit floating point IEEE 64-bit float	Apple Computer',
	    alaw: 'ALaw 2:1	8-bit ITU-T G.711 A-law',
	    ulaw: 'µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer',
	    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',
	    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',
	    FL32: 'Float 32	IEEE 32-bit float '
	};
	class AiffContentError extends makeUnexpectedFileContentError('AIFF') {
	}
	class Common {
	    constructor(header, isAifc) {
	        this.isAifc = isAifc;
	        const minimumChunkSize = isAifc ? 22 : 18;
	        if (header.chunkSize < minimumChunkSize)
	            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
	        this.len = header.chunkSize;
	    }
	    get(buf, off) {
	        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value
	        const shift = UINT16_BE.get(buf, off + 8) - 16398;
	        const baseSampleRate = UINT16_BE.get(buf, off + 8 + 2);
	        const res = {
	            numChannels: UINT16_BE.get(buf, off),
	            numSampleFrames: UINT32_BE.get(buf, off + 2),
	            sampleSize: UINT16_BE.get(buf, off + 6),
	            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
	        };
	        if (this.isAifc) {
	            res.compressionType = FourCcToken.get(buf, off + 18);
	            if (this.len > 22) {
	                const strLen = UINT8.get(buf, off + 22);
	                if (strLen > 0) {
	                    const padding = (strLen + 1) % 2;
	                    if (23 + strLen + padding === this.len) {
	                        res.compressionName = new StringType(strLen, 'latin1').get(buf, off + 23);
	                    }
	                    else {
	                        throw new AiffContentError('Illegal pstring length');
	                    }
	                }
	                else {
	                    res.compressionName = undefined;
	                }
	            }
	        }
	        else {
	            res.compressionName = 'PCM';
	        }
	        return res;
	    }
	}

	/**
	 * Common AIFF chunk header
	 */
	const Header$4 = {
	    len: 8,
	    get: (buf, off) => {
	        return {
	            // Chunk type ID
	            chunkID: FourCcToken.get(buf, off),
	            // Chunk size
	            chunkSize: Number(BigInt(UINT32_BE.get(buf, off + 4)))
	        };
	    }
	};

	const debug$h = initDebug('music-metadata:parser:aiff');
	/**
	 * AIFF - Audio Interchange File Format
	 *
	 * Ref:
	 * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html
	 * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf
	 */
	class AIFFParser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.isCompressed = null;
	    }
	    async parse() {
	        const header = await this.tokenizer.readToken(Header$4);
	        if (header.chunkID !== 'FORM')
	            throw new AiffContentError('Invalid Chunk-ID, expected \'FORM\''); // Not AIFF format
	        const type = await this.tokenizer.readToken(FourCcToken);
	        switch (type) {
	            case 'AIFF':
	                this.metadata.setFormat('container', type);
	                this.isCompressed = false;
	                break;
	            case 'AIFC':
	                this.metadata.setFormat('container', 'AIFF-C');
	                this.isCompressed = true;
	                break;
	            default:
	                throw new AiffContentError(`Unsupported AIFF type: ${type}`);
	        }
	        this.metadata.setFormat('lossless', !this.isCompressed);
	        this.metadata.setAudioOnly();
	        try {
	            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= Header$4.len) {
	                debug$h(`Reading AIFF chunk at offset=${this.tokenizer.position}`);
	                const chunkHeader = await this.tokenizer.readToken(Header$4);
	                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
	                const bytesRead = await this.readData(chunkHeader);
	                await this.tokenizer.ignore(nextChunk - bytesRead);
	            }
	        }
	        catch (err) {
	            if (err instanceof EndOfStreamError) {
	                debug$h("End-of-stream");
	            }
	            else {
	                throw err;
	            }
	        }
	    }
	    async readData(header) {
	        switch (header.chunkID) {
	            case 'COMM': { // The Common Chunk
	                if (this.isCompressed === null) {
	                    throw new AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');
	                }
	                const common = await this.tokenizer.readToken(new Common(header, this.isCompressed));
	                this.metadata.setFormat('bitsPerSample', common.sampleSize);
	                this.metadata.setFormat('sampleRate', common.sampleRate);
	                this.metadata.setFormat('numberOfChannels', common.numChannels);
	                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);
	                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);
	                if (common.compressionName || common.compressionType) {
	                    this.metadata.setFormat('codec', common.compressionName ?? compressionTypes[common.compressionType]);
	                }
	                return header.chunkSize;
	            }
	            case 'ID3 ': { // ID3-meta-data
	                const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
	                const rst = fromBuffer(id3_data);
	                await new ID3v2Parser().parse(this.metadata, rst, this.options);
	                return header.chunkSize;
	            }
	            case 'SSND': // Sound Data Chunk
	                if (this.metadata.format.duration) {
	                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);
	                }
	                return 0;
	            case 'NAME': // Sample name chunk
	            case 'AUTH': // Author chunk
	            case '(c) ': // Copyright chunk
	            case 'ANNO': // Annotation chunk
	                return this.readTextChunk(header);
	            default:
	                debug$h(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);
	                return 0;
	        }
	    }
	    async readTextChunk(header) {
	        const value = await this.tokenizer.readToken(new StringType(header.chunkSize, 'ascii'));
	        const values = value.split('\0').map(v => v.trim()).filter(v => v?.length);
	        await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));
	        return header.chunkSize;
	    }
	}

	var AiffParser = /*#__PURE__*/Object.freeze({
		__proto__: null,
		AIFFParser: AIFFParser
	});

	/**
	 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
	 */
	const ChunkHeader = {
	    len: 12,
	    get: (buf, off) => {
	        return { id: FourCcToken.get(buf, off), size: UINT64_LE.get(buf, off + 4) };
	    }
	};
	/**
	 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
	 */
	const DsdChunk = {
	    len: 16,
	    get: (buf, off) => {
	        return {
	            fileSize: INT64_LE.get(buf, off),
	            metadataPointer: INT64_LE.get(buf, off + 8)
	        };
	    }
	};
	/**
	 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
	 */
	const FormatChunk = {
	    len: 40,
	    get: (buf, off) => {
	        return {
	            formatVersion: INT32_LE.get(buf, off),
	            formatID: INT32_LE.get(buf, off + 4),
	            channelType: INT32_LE.get(buf, off + 8),
	            channelNum: INT32_LE.get(buf, off + 12),
	            samplingFrequency: INT32_LE.get(buf, off + 16),
	            bitsPerSample: INT32_LE.get(buf, off + 20),
	            sampleCount: INT64_LE.get(buf, off + 24),
	            blockSizePerChannel: INT32_LE.get(buf, off + 32)
	        };
	    }
	};

	const debug$g = initDebug('music-metadata:parser:DSF');
	class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {
	}
	/**
	 * DSF (dsd stream file) File Parser
	 * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf
	 */
	class DsfParser extends AbstractID3Parser {
	    async postId3v2Parse() {
	        const p0 = this.tokenizer.position; // mark start position, normally 0
	        const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
	        if (chunkHeader.id !== 'DSD ')
	            throw new DsdContentParseError('Invalid chunk signature');
	        this.metadata.setFormat('container', 'DSF');
	        this.metadata.setFormat('lossless', true);
	        this.metadata.setAudioOnly();
	        const dsdChunk = await this.tokenizer.readToken(DsdChunk);
	        if (dsdChunk.metadataPointer === BigInt(0)) {
	            debug$g("No ID3v2 tag present");
	        }
	        else {
	            debug$g(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
	            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
	            // Jump to ID3 header
	            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
	            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
	        }
	    }
	    async parseChunks(bytesRemaining) {
	        while (bytesRemaining >= ChunkHeader.len) {
	            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
	            debug$g(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
	            switch (chunkHeader.id) {
	                case 'fmt ': {
	                    const formatChunk = await this.tokenizer.readToken(FormatChunk);
	                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);
	                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);
	                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);
	                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);
	                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
	                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
	                    this.metadata.setFormat('bitrate', bitrate);
	                    return; // We got what we want, stop further processing of chunks
	                }
	                default:
	                    this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);
	                    break;
	            }
	            bytesRemaining -= chunkHeader.size;
	        }
	    }
	}

	var DsfParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DsdContentParseError: DsdContentParseError,
		DsfParser: DsfParser
	});

	/**
	 * Parse the METADATA_BLOCK_PICTURE
	 * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE
	 * Ref: https://xiph.org/flac/format.html#metadata_block_picture
	 * // ToDo: move to ID3 / APIC?
	 */
	class VorbisPictureToken {
	    static fromBase64(base64str) {
	        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));
	    }
	    static fromBuffer(buffer) {
	        const pic = new VorbisPictureToken(buffer.length);
	        return pic.get(buffer, 0);
	    }
	    constructor(len) {
	        this.len = len;
	    }
	    get(buffer, offset) {
	        const type = AttachedPictureType[UINT32_BE.get(buffer, offset)];
	        offset += 4;
	        const mimeLen = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const format = new StringType(mimeLen, 'utf-8').get(buffer, offset);
	        offset += mimeLen;
	        const descLen = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const description = new StringType(descLen, 'utf-8').get(buffer, offset);
	        offset += descLen;
	        const width = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const height = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const colour_depth = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const indexed_color = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const picDataLen = UINT32_BE.get(buffer, offset);
	        offset += 4;
	        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));
	        return {
	            type,
	            format,
	            description,
	            width,
	            height,
	            colour_depth,
	            indexed_color,
	            data
	        };
	    }
	}
	/**
	 * Comment header decoder
	 * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1
	 */
	const CommonHeader = {
	    len: 7,
	    get: (buf, off) => {
	        return {
	            packetType: UINT8.get(buf, off),
	            vorbis: new StringType(6, 'ascii').get(buf, off + 1)
	        };
	    }
	};
	/**
	 * Identification header decoder
	 * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2
	 */
	const IdentificationHeader$1 = {
	    len: 23,
	    get: (uint8Array, off) => {
	        return {
	            version: UINT32_LE.get(uint8Array, off + 0),
	            channelMode: UINT8.get(uint8Array, off + 4),
	            sampleRate: UINT32_LE.get(uint8Array, off + 5),
	            bitrateMax: UINT32_LE.get(uint8Array, off + 9),
	            bitrateNominal: UINT32_LE.get(uint8Array, off + 13),
	            bitrateMin: UINT32_LE.get(uint8Array, off + 17)
	        };
	    }
	};

	class VorbisDecoder {
	    constructor(data, offset) {
	        this.data = data;
	        this.offset = offset;
	    }
	    readInt32() {
	        const value = UINT32_LE.get(this.data, this.offset);
	        this.offset += 4;
	        return value;
	    }
	    readStringUtf8() {
	        const len = this.readInt32();
	        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));
	        this.offset += len;
	        return value;
	    }
	    parseUserComment() {
	        const offset0 = this.offset;
	        const v = this.readStringUtf8();
	        const idx = v.indexOf('=');
	        return {
	            key: v.slice(0, idx).toUpperCase(),
	            value: v.slice(idx + 1),
	            len: this.offset - offset0
	        };
	    }
	}

	const debug$f = initDebug('music-metadata:parser:ogg:vorbis1');
	class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {
	}
	/**
	 * Vorbis 1 Parser.
	 * Used by OggStream
	 */
	class VorbisStream {
	    constructor(metadata, options) {
	        this.pageSegments = [];
	        this.metadata = metadata;
	        this.options = options;
	    }
	    /**
	     * Vorbis 1 parser
	     * @param header Ogg Page Header
	     * @param pageData Page data
	     */
	    async parsePage(header, pageData) {
	        this.lastPageHeader = header;
	        if (header.headerType.firstPage) {
	            this.parseFirstPage(header, pageData);
	        }
	        else {
	            if (header.headerType.continued) {
	                if (this.pageSegments.length === 0) {
	                    throw new VorbisContentError('Cannot continue on previous page');
	                }
	                this.pageSegments.push(pageData);
	            }
	            if (header.headerType.lastPage || !header.headerType.continued) {
	                // Flush page segments
	                if (this.pageSegments.length > 0) {
	                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);
	                    await this.parseFullPage(fullPage);
	                }
	                // Reset page segments
	                this.pageSegments = header.headerType.lastPage ? [] : [pageData];
	            }
	        }
	    }
	    static mergeUint8Arrays(arrays) {
	        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);
	        const merged = new Uint8Array(totalSize);
	        arrays.forEach((array, i, _arrays) => {
	            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);
	            merged.set(array, offset);
	        });
	        return merged;
	    }
	    async flush() {
	        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));
	    }
	    async parseUserComment(pageData, offset) {
	        const decoder = new VorbisDecoder(pageData, offset);
	        const tag = decoder.parseUserComment();
	        await this.addTag(tag.key, tag.value);
	        return tag.len;
	    }
	    async addTag(id, value) {
	        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {
	            if (this.options.skipCovers) {
	                debug$f("Ignore picture");
	                return;
	            }
	            value = VorbisPictureToken.fromBase64(value);
	            debug$f(`Push picture: id=${id}, format=${value.format}`);
	        }
	        else {
	            debug$f(`Push tag: id=${id}, value=${value}`);
	        }
	        await this.metadata.addTag('vorbis', id, value);
	    }
	    calculateDuration() {
	        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {
	            // Calculate duration
	            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);
	            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);
	        }
	    }
	    /**
	     * Parse first Ogg/Vorbis page
	     * @param header
	     * @param pageData
	     */
	    parseFirstPage(_header, pageData) {
	        this.metadata.setFormat('codec', 'Vorbis I');
	        this.metadata.setFormat('hasAudio', true);
	        debug$f('Parse first page');
	        // Parse  Vorbis common header
	        const commonHeader = CommonHeader.get(pageData, 0);
	        if (commonHeader.vorbis !== 'vorbis')
	            throw new VorbisContentError('Metadata does not look like Vorbis');
	        if (commonHeader.packetType === 1) {
	            const idHeader = IdentificationHeader$1.get(pageData, CommonHeader.len);
	            this.metadata.setFormat('sampleRate', idHeader.sampleRate);
	            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);
	            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);
	            debug$f('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
	        }
	        else
	            throw new VorbisContentError('First Ogg page should be type 1: the identification header');
	    }
	    async parseFullPage(pageData) {
	        // New page
	        const commonHeader = CommonHeader.get(pageData, 0);
	        debug$f('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);
	        switch (commonHeader.packetType) {
	            case 3: //  type 3: comment header
	                return this.parseUserCommentList(pageData, CommonHeader.len);
	        }
	    }
	    /**
	     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
	     */
	    async parseUserCommentList(pageData, offset) {
	        const strLen = UINT32_LE.get(pageData, offset);
	        offset += 4;
	        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);
	        offset += strLen;
	        let userCommentListLength = UINT32_LE.get(pageData, offset);
	        offset += 4;
	        while (userCommentListLength-- > 0) {
	            offset += (await this.parseUserComment(pageData, offset));
	        }
	    }
	}

	const debug$e = initDebug('music-metadata:parser:FLAC');
	class FlacContentError extends makeUnexpectedFileContentError('FLAC') {
	}
	/**
	 * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:
	 * ref: https://xiph.org/flac/format.html#metadata_block
	 */
	const BlockType = {
	    STREAMINFO: 0, // STREAMINFO
	    PADDING: 1, // PADDING
	    APPLICATION: 2, // APPLICATION
	    SEEKTABLE: 3, // SEEKTABLE
	    VORBIS_COMMENT: 4, // VORBIS_COMMENT
	    CUESHEET: 5, // CUESHEET
	    PICTURE: 6 // PICTURE
	};
	class FlacParser extends AbstractID3Parser {
	    constructor() {
	        super(...arguments);
	        this.vorbisParser = new VorbisStream(this.metadata, this.options);
	        this.padding = 0;
	    }
	    async postId3v2Parse() {
	        const fourCC = await this.tokenizer.readToken(FourCcToken);
	        if (fourCC.toString() !== 'fLaC') {
	            throw new FlacContentError('Invalid FLAC preamble');
	        }
	        this.metadata.setAudioOnly();
	        let blockHeader;
	        do {
	            // Read block header
	            blockHeader = await this.tokenizer.readToken(BlockHeader);
	            // Parse block data
	            await this.parseDataBlock(blockHeader);
	        } while (!blockHeader.lastBlock);
	        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
	            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
	            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);
	        }
	    }
	    async parseDataBlock(blockHeader) {
	        debug$e(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
	        switch (blockHeader.type) {
	            case BlockType.STREAMINFO:
	                return this.parseBlockStreamInfo(blockHeader.length);
	            case BlockType.PADDING:
	                this.padding += blockHeader.length;
	                break;
	            case BlockType.APPLICATION:
	                break;
	            case BlockType.SEEKTABLE:
	                break;
	            case BlockType.VORBIS_COMMENT:
	                return this.parseComment(blockHeader.length);
	            case BlockType.CUESHEET:
	                break;
	            case BlockType.PICTURE:
	                await this.parsePicture(blockHeader.length);
	                return;
	            default:
	                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);
	        }
	        // Ignore data block
	        return this.tokenizer.ignore(blockHeader.length).then();
	    }
	    /**
	     * Parse STREAMINFO
	     */
	    async parseBlockStreamInfo(dataLen) {
	        if (dataLen !== BlockStreamInfo.len)
	            throw new FlacContentError('Unexpected block-stream-info length');
	        const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);
	        this.metadata.setFormat('container', 'FLAC');
	        this.metadata.setFormat('codec', 'FLAC');
	        this.metadata.setFormat('lossless', true);
	        this.metadata.setFormat('numberOfChannels', streamInfo.channels);
	        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);
	        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);
	        if (streamInfo.totalSamples > 0) {
	            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);
	        }
	    }
	    /**
	     * Parse VORBIS_COMMENT
	     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
	     */
	    async parseComment(dataLen) {
	        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
	        const decoder = new VorbisDecoder(data, 0);
	        decoder.readStringUtf8(); // vendor (skip)
	        const commentListLength = decoder.readInt32();
	        const tags = new Array(commentListLength);
	        for (let i = 0; i < commentListLength; i++) {
	            tags[i] = decoder.parseUserComment();
	        }
	        await Promise.all(tags.map(tag => this.vorbisParser.addTag(tag.key, tag.value)));
	    }
	    async parsePicture(dataLen) {
	        if (this.options.skipCovers) {
	            return this.tokenizer.ignore(dataLen);
	        }
	        const picture = await this.tokenizer.readToken(new VorbisPictureToken(dataLen));
	        this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);
	    }
	}
	const BlockHeader = {
	    len: 4,
	    get: (buf, off) => {
	        return {
	            lastBlock: getBit(buf, off, 7),
	            type: getBitAllignedNumber$1(buf, off, 1, 7),
	            length: UINT24_BE.get(buf, off + 1)
	        };
	    }
	};
	/**
	 * METADATA_BLOCK_DATA
	 * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo
	 */
	const BlockStreamInfo = {
	    len: 34,
	    get: (buf, off) => {
	        return {
	            // The minimum block size (in samples) used in the stream.
	            minimumBlockSize: UINT16_BE.get(buf, off),
	            // The maximum block size (in samples) used in the stream.
	            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
	            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,
	            // The minimum frame size (in bytes) used in the stream.
	            // May be 0 to imply the value is not known.
	            minimumFrameSize: UINT24_BE.get(buf, off + 4),
	            // The maximum frame size (in bytes) used in the stream.
	            // May be 0 to imply the value is not known.
	            maximumFrameSize: UINT24_BE.get(buf, off + 7),
	            // Sample rate in Hz. Though 20 bits are available,
	            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
	            // Also, a value of 0 is invalid.
	            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,
	            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
	            // (number of channels)-1. FLAC supports from 1 to 8 channels
	            channels: getBitAllignedNumber$1(buf, off + 12, 4, 3) + 1,
	            // bits per sample)-1.
	            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
	            bitsPerSample: getBitAllignedNumber$1(buf, off + 12, 7, 5) + 1,
	            // Total samples in stream.
	            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
	            // A value of zero here means the number of total samples is unknown.
	            totalSamples: getBitAllignedNumber$1(buf, off + 13, 4, 36),
	            // the MD5 hash of the file (see notes for usage... it's a littly tricky)
	            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)
	        };
	    }
	};

	var FlacParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		FlacParser: FlacParser
	});

	const DataType = {
	    string: 0,
	    uint: 1,
	    uid: 2,
	    bool: 3,
	    binary: 4,
	    float: 5,
	};

	/**
	 * Elements of document type description
	 * Derived from https://github.com/tungol/EBML/blob/master/doctypes/matroska.dtd
	 * Extended with:
	 * - https://www.matroska.org/technical/specs/index.html
	 */
	const matroskaDtd = {
	    name: 'dtd',
	    container: {
	        0x1a45dfa3: {
	            name: 'ebml',
	            container: {
	                0x4286: { name: 'ebmlVersion', value: DataType.uint }, // 5.1.1
	                0x42f7: { name: 'ebmlReadVersion', value: DataType.uint }, // 5.1.2
	                0x42f2: { name: 'ebmlMaxIDWidth', value: DataType.uint }, // 5.1.3
	                0x42f3: { name: 'ebmlMaxSizeWidth', value: DataType.uint }, // 5.1.4
	                0x4282: { name: 'docType', value: DataType.string }, // 5.1.5
	                0x4287: { name: 'docTypeVersion', value: DataType.uint }, // 5.1.6
	                0x4285: { name: 'docTypeReadVersion', value: DataType.uint } // 5.1.7
	            }
	        },
	        // Matroska segments
	        0x18538067: {
	            name: 'segment',
	            container: {
	                // Meta Seek Information (also known as MetaSeek)
	                0x114d9b74: {
	                    name: 'seekHead',
	                    container: {
	                        0x4dbb: {
	                            name: 'seek',
	                            multiple: true,
	                            container: {
	                                0x53ab: { name: 'id', value: DataType.binary },
	                                0x53ac: { name: 'position', value: DataType.uint }
	                            }
	                        }
	                    }
	                },
	                // Segment Information
	                0x1549a966: {
	                    name: 'info',
	                    container: {
	                        0x73a4: { name: 'uid', value: DataType.uid },
	                        0x7384: { name: 'filename', value: DataType.string },
	                        0x3cb923: { name: 'prevUID', value: DataType.uid },
	                        0x3c83ab: { name: 'prevFilename', value: DataType.string },
	                        0x3eb923: { name: 'nextUID', value: DataType.uid },
	                        0x3e83bb: { name: 'nextFilename', value: DataType.string },
	                        0x2ad7b1: { name: 'timecodeScale', value: DataType.uint },
	                        0x4489: { name: 'duration', value: DataType.float },
	                        0x4461: { name: 'dateUTC', value: DataType.uint },
	                        0x7ba9: { name: 'title', value: DataType.string },
	                        0x4d80: { name: 'muxingApp', value: DataType.string },
	                        0x5741: { name: 'writingApp', value: DataType.string }
	                    }
	                },
	                // Cluster
	                0x1f43b675: {
	                    name: 'cluster',
	                    multiple: true,
	                    container: {
	                        0xe7: { name: 'timecode', value: DataType.uid },
	                        0x58d7: { name: 'silentTracks ', multiple: true },
	                        0xa7: { name: 'position', value: DataType.uid },
	                        0xab: { name: 'prevSize', value: DataType.uid },
	                        0xa0: { name: 'blockGroup' },
	                        0xa3: { name: 'simpleBlock' }
	                    }
	                },
	                // Track
	                0x1654ae6b: {
	                    name: 'tracks',
	                    container: {
	                        0xae: {
	                            name: 'entries',
	                            multiple: true,
	                            container: {
	                                0xd7: { name: 'trackNumber', value: DataType.uint },
	                                0x73c5: { name: 'uid', value: DataType.uid },
	                                0x83: { name: 'trackType', value: DataType.uint },
	                                0xb9: { name: 'flagEnabled', value: DataType.bool },
	                                0x88: { name: 'flagDefault', value: DataType.bool },
	                                0x55aa: { name: 'flagForced', value: DataType.bool }, // extended
	                                0x9c: { name: 'flagLacing', value: DataType.bool },
	                                0x6de7: { name: 'minCache', value: DataType.uint },
	                                0x6de8: { name: 'maxCache', value: DataType.uint },
	                                0x23e383: { name: 'defaultDuration', value: DataType.uint },
	                                0x23314f: { name: 'timecodeScale', value: DataType.float },
	                                0x536e: { name: 'name', value: DataType.string },
	                                0x22b59c: { name: 'language', value: DataType.string },
	                                0x86: { name: 'codecID', value: DataType.string },
	                                0x63a2: { name: 'codecPrivate', value: DataType.binary },
	                                0x258688: { name: 'codecName', value: DataType.string },
	                                0x3a9697: { name: 'codecSettings', value: DataType.string },
	                                0x3b4040: { name: 'codecInfoUrl', value: DataType.string },
	                                0x26b240: { name: 'codecDownloadUrl', value: DataType.string },
	                                0xaa: { name: 'codecDecodeAll', value: DataType.bool },
	                                0x6fab: { name: 'trackOverlay', value: DataType.uint },
	                                // Video
	                                0xe0: {
	                                    name: 'video',
	                                    container: {
	                                        0x9a: { name: 'flagInterlaced', value: DataType.bool },
	                                        0x53b8: { name: 'stereoMode', value: DataType.uint },
	                                        0xb0: { name: 'pixelWidth', value: DataType.uint },
	                                        0xba: { name: 'pixelHeight', value: DataType.uint },
	                                        0x54b0: { name: 'displayWidth', value: DataType.uint },
	                                        0x54ba: { name: 'displayHeight', value: DataType.uint },
	                                        0x54b3: { name: 'aspectRatioType', value: DataType.uint },
	                                        0x2eb524: { name: 'colourSpace', value: DataType.uint },
	                                        0x2fb523: { name: 'gammaValue', value: DataType.float }
	                                    }
	                                },
	                                // Audio
	                                0xe1: {
	                                    name: 'audio',
	                                    container: {
	                                        0xb5: { name: 'samplingFrequency', value: DataType.float },
	                                        0x78b5: { name: 'outputSamplingFrequency', value: DataType.float },
	                                        0x9f: { name: 'channels', value: DataType.uint }, // https://www.matroska.org/technical/specs/index.html
	                                        0x94: { name: 'channels', value: DataType.uint },
	                                        0x7d7b: { name: 'channelPositions', value: DataType.binary },
	                                        0x6264: { name: 'bitDepth', value: DataType.uint }
	                                    }
	                                },
	                                // Content Encoding
	                                0x6d80: {
	                                    name: 'contentEncodings',
	                                    container: {
	                                        0x6240: {
	                                            name: 'contentEncoding',
	                                            container: {
	                                                0x5031: { name: 'order', value: DataType.uint },
	                                                0x5032: { name: 'scope', value: DataType.bool },
	                                                0x5033: { name: 'type', value: DataType.uint },
	                                                0x5034: {
	                                                    name: 'contentEncoding',
	                                                    container: {
	                                                        0x4254: { name: 'contentCompAlgo', value: DataType.uint },
	                                                        0x4255: { name: 'contentCompSettings', value: DataType.binary }
	                                                    }
	                                                },
	                                                0x5035: {
	                                                    name: 'contentEncoding',
	                                                    container: {
	                                                        0x47e1: { name: 'contentEncAlgo', value: DataType.uint },
	                                                        0x47e2: { name: 'contentEncKeyID', value: DataType.binary },
	                                                        0x47e3: { name: 'contentSignature ', value: DataType.binary },
	                                                        0x47e4: { name: 'ContentSigKeyID  ', value: DataType.binary },
	                                                        0x47e5: { name: 'contentSigAlgo ', value: DataType.uint },
	                                                        0x47e6: { name: 'contentSigHashAlgo ', value: DataType.uint }
	                                                    }
	                                                },
	                                                0x6264: { name: 'bitDepth', value: DataType.uint }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                },
	                // Cueing Data
	                0x1c53bb6b: {
	                    name: 'cues',
	                    container: {
	                        0xbb: {
	                            name: 'cuePoint',
	                            container: {
	                                0xb3: { name: 'cueTime', value: DataType.uid },
	                                0xb7: {
	                                    name: 'positions',
	                                    container: {
	                                        0xf7: { name: 'track', value: DataType.uint },
	                                        0xf1: { name: 'clusterPosition', value: DataType.uint },
	                                        0x5378: { name: 'blockNumber', value: DataType.uint },
	                                        0xea: { name: 'codecState', value: DataType.uint },
	                                        0xdb: {
	                                            name: 'reference', container: {
	                                                0x96: { name: 'time', value: DataType.uint },
	                                                0x97: { name: 'cluster', value: DataType.uint },
	                                                0x535f: { name: 'number', value: DataType.uint },
	                                                0xeb: { name: 'codecState', value: DataType.uint }
	                                            }
	                                        },
	                                        0xf0: { name: 'relativePosition', value: DataType.uint } // extended
	                                    }
	                                }
	                            }
	                        }
	                    }
	                },
	                // Attachment
	                0x1941a469: {
	                    name: 'attachments',
	                    container: {
	                        0x61a7: {
	                            name: 'attachedFiles',
	                            multiple: true,
	                            container: {
	                                0x467e: { name: 'description', value: DataType.string },
	                                0x466e: { name: 'name', value: DataType.string },
	                                0x4660: { name: 'mimeType', value: DataType.string },
	                                0x465c: { name: 'data', value: DataType.binary },
	                                0x46ae: { name: 'uid', value: DataType.uid }
	                            }
	                        }
	                    }
	                },
	                // Chapters
	                0x1043a770: {
	                    name: 'chapters',
	                    container: {
	                        0x45b9: {
	                            name: 'editionEntry',
	                            container: {
	                                0xb6: {
	                                    name: 'chapterAtom',
	                                    container: {
	                                        0x73c4: { name: 'uid', value: DataType.uid },
	                                        0x91: { name: 'timeStart', value: DataType.uint },
	                                        0x92: { name: 'timeEnd', value: DataType.uid },
	                                        0x98: { name: 'hidden', value: DataType.bool },
	                                        0x4598: { name: 'enabled', value: DataType.uid },
	                                        0x8f: {
	                                            name: 'track', container: {
	                                                0x89: { name: 'trackNumber', value: DataType.uid },
	                                                0x80: {
	                                                    name: 'display', container: {
	                                                        0x85: { name: 'string', value: DataType.string },
	                                                        0x437c: { name: 'language ', value: DataType.string },
	                                                        0x437e: { name: 'country ', value: DataType.string }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                },
	                // Tagging
	                0x1254c367: {
	                    name: 'tags',
	                    container: {
	                        0x7373: {
	                            name: 'tag',
	                            multiple: true,
	                            container: {
	                                0x63c0: {
	                                    name: 'target',
	                                    container: {
	                                        0x63c5: { name: 'tagTrackUID', value: DataType.uid },
	                                        0x63c4: { name: 'tagChapterUID', value: DataType.uint },
	                                        0x63c6: { name: 'tagAttachmentUID', value: DataType.uid },
	                                        0x63ca: { name: 'targetType', value: DataType.string }, // extended
	                                        0x68ca: { name: 'targetTypeValue', value: DataType.uint }, // extended
	                                        0x63c9: { name: 'tagEditionUID', value: DataType.uid } // extended
	                                    }
	                                },
	                                0x67c8: {
	                                    name: 'simpleTags',
	                                    multiple: true,
	                                    container: {
	                                        0x45a3: { name: 'name', value: DataType.string },
	                                        0x4487: { name: 'string', value: DataType.string },
	                                        0x4485: { name: 'binary', value: DataType.binary },
	                                        0x447a: { name: 'language', value: DataType.string }, // extended
	                                        0x447b: { name: 'languageIETF', value: DataType.string }, // extended
	                                        0x4484: { name: 'default', value: DataType.bool } // extended
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	};

	const debug$d = initDebug('music-metadata:parser:ebml');
	class EbmlContentError extends makeUnexpectedFileContentError('EBML') {
	}
	const ParseAction = {
	    ReadNext: 0, // Continue reading the next elements
	    IgnoreElement: 2, // Ignore (do not read) this element
	    SkipSiblings: 3, // Skip all remaining elements at the same level
	    TerminateParsing: 4, // Terminate the parsing process
	    SkipElement: 5 // Consider the element has read, assume position is at the next element
	};
	/**
	 * Extensible Binary Meta Language (EBML) iterator
	 * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language
	 * http://matroska.sourceforge.net/technical/specs/rfc/index.html
	 *
	 * WEBM VP8 AUDIO FILE
	 */
	class EbmlIterator {
	    /**
	     * @param {ITokenizer} tokenizer Input
	     * @param tokenizer
	     */
	    constructor(tokenizer) {
	        this.padding = 0;
	        this.parserMap = new Map();
	        this.ebmlMaxIDLength = 4;
	        this.ebmlMaxSizeLength = 8;
	        this.tokenizer = tokenizer;
	        this.parserMap.set(DataType.uint, e => this.readUint(e));
	        this.parserMap.set(DataType.string, e => this.readString(e));
	        this.parserMap.set(DataType.binary, e => this.readBuffer(e));
	        this.parserMap.set(DataType.uid, async (e) => this.readBuffer(e));
	        this.parserMap.set(DataType.bool, e => this.readFlag(e));
	        this.parserMap.set(DataType.float, e => this.readFloat(e));
	    }
	    async iterate(dtdElement, posDone, listener) {
	        return this.parseContainer(linkParents(dtdElement), posDone, listener);
	    }
	    async parseContainer(dtdElement, posDone, listener) {
	        const tree = {};
	        while (this.tokenizer.position < posDone) {
	            let element;
	            const elementPosition = this.tokenizer.position;
	            try {
	                element = await this.readElement();
	            }
	            catch (error) {
	                if (error instanceof EndOfStreamError) {
	                    break;
	                }
	                throw error;
	            }
	            const child = dtdElement.container[element.id];
	            if (child) {
	                const action = listener.startNext(child);
	                switch (action) {
	                    case ParseAction.ReadNext:
	                        {
	                            debug$d(`Read element: name=${getElementPath(child)}{id=0x${element.id.toString(16)}, container=${!!child.container}} at position=${elementPosition}`);
	                            if (child.container) {
	                                const res = await this.parseContainer(child, element.len >= 0 ? this.tokenizer.position + element.len : -1, listener);
	                                if (child.multiple) {
	                                    if (!tree[child.name]) {
	                                        tree[child.name] = [];
	                                    }
	                                    tree[child.name].push(res);
	                                }
	                                else {
	                                    tree[child.name] = res;
	                                }
	                                await listener.elementValue(child, res, elementPosition);
	                            }
	                            else {
	                                const parser = this.parserMap.get(child.value);
	                                if (typeof parser === 'function') {
	                                    const value = await parser(element);
	                                    tree[child.name] = value;
	                                    await listener.elementValue(child, value, elementPosition);
	                                }
	                            }
	                        }
	                        break;
	                    case ParseAction.SkipElement:
	                        debug$d(`Go to next element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
	                        break;
	                    case ParseAction.IgnoreElement:
	                        debug$d(`Ignore element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
	                        await this.tokenizer.ignore(element.len);
	                        break;
	                    case ParseAction.SkipSiblings:
	                        debug$d(`Ignore remaining container, at: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
	                        await this.tokenizer.ignore(posDone - this.tokenizer.position);
	                        break;
	                    case ParseAction.TerminateParsing:
	                        debug$d(`Terminate parsing at element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
	                        return tree;
	                }
	            }
	            else {
	                switch (element.id) {
	                    case 0xec: // void
	                        this.padding += element.len;
	                        await this.tokenizer.ignore(element.len);
	                        break;
	                    default:
	                        debug$d(`parseEbml: parent=${getElementPath(dtdElement)}, unknown child: id=${element.id.toString(16)} at position=${elementPosition}`);
	                        this.padding += element.len;
	                        await this.tokenizer.ignore(element.len);
	                }
	            }
	        }
	        return tree;
	    }
	    async readVintData(maxLength) {
	        const msb = await this.tokenizer.peekNumber(UINT8);
	        let mask = 0x80;
	        let oc = 1;
	        // Calculate VINT_WIDTH
	        while ((msb & mask) === 0) {
	            if (oc > maxLength) {
	                throw new EbmlContentError('VINT value exceeding maximum size');
	            }
	            ++oc;
	            mask >>= 1;
	        }
	        const id = new Uint8Array(oc);
	        await this.tokenizer.readBuffer(id);
	        return id;
	    }
	    async readElement() {
	        const id = await this.readVintData(this.ebmlMaxIDLength);
	        const lenField = await this.readVintData(this.ebmlMaxSizeLength);
	        lenField[0] ^= 0x80 >> (lenField.length - 1);
	        return {
	            id: readUIntBE(id, id.length),
	            len: readUIntBE(lenField, lenField.length)
	        };
	    }
	    async readFloat(e) {
	        switch (e.len) {
	            case 0:
	                return 0.0;
	            case 4:
	                return this.tokenizer.readNumber(Float32_BE);
	            case 8:
	                return this.tokenizer.readNumber(Float64_BE);
	            case 10:
	                return this.tokenizer.readNumber(Float64_BE);
	            default:
	                throw new EbmlContentError(`Invalid IEEE-754 float length: ${e.len}`);
	        }
	    }
	    async readFlag(e) {
	        return (await this.readUint(e)) === 1;
	    }
	    async readUint(e) {
	        const buf = await this.readBuffer(e);
	        return readUIntBE(buf, e.len);
	    }
	    async readString(e) {
	        const rawString = await this.tokenizer.readToken(new StringType(e.len, 'utf-8'));
	        return rawString.replace(/\x00.*$/g, '');
	    }
	    async readBuffer(e) {
	        const buf = new Uint8Array(e.len);
	        await this.tokenizer.readBuffer(buf);
	        return buf;
	    }
	}
	function readUIntBE(buf, len) {
	    return Number(readUIntBeAsBigInt(buf, len));
	}
	/**
	 * Reeds an unsigned integer from a big endian buffer of length `len`
	 * @param buf Buffer to decode from
	 * @param len Number of bytes
	 * @private
	 */
	function readUIntBeAsBigInt(buf, len) {
	    const normalizedNumber = new Uint8Array(8);
	    const cleanNumber = buf.subarray(0, len);
	    try {
	        normalizedNumber.set(cleanNumber, 8 - len);
	        return UINT64_BE.get(normalizedNumber, 0);
	    }
	    catch (_error) {
	        return BigInt(-1);
	    }
	}
	function linkParents(element) {
	    if (element.container) {
	        Object.keys(element.container)
	            .map(id => {
	            const child = element.container[id];
	            child.id = Number.parseInt(id);
	            return child;
	        }).forEach(child => {
	            child.parent = element;
	            linkParents(child);
	        });
	    }
	    return element;
	}
	function getElementPath(element) {
	    let path = '';
	    if (element.parent && element.parent.name !== 'dtd') {
	        path += `${getElementPath(element.parent)}/`;
	    }
	    return path + element.name;
	}

	const debug$c = initDebug('music-metadata:parser:matroska');
	/**
	 * Extensible Binary Meta Language (EBML) parser
	 * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language
	 * http://matroska.sourceforge.net/technical/specs/rfc/index.html
	 *
	 * WEBM VP8 AUDIO FILE
	 */
	class MatroskaParser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.seekHeadOffset = 0;
	        /**
	         * Use index to skip multiple segment/cluster elements at once.
	         * Significant performance impact
	         */
	        this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? false;
	    }
	    async parse() {
	        const containerSize = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER;
	        const matroskaIterator = new EbmlIterator(this.tokenizer);
	        debug$c('Initializing DTD end MatroskaIterator');
	        await matroskaIterator.iterate(matroskaDtd, containerSize, {
	            startNext: (element) => {
	                switch (element.id) {
	                    // case 0x1f43b675: // cluster
	                    case 0x1c53bb6b: // Cueing Data
	                        debug$c(`Skip element: name=${element.name}, id=0x${element.id.toString(16)}`);
	                        return ParseAction.IgnoreElement;
	                    case 0x1f43b675: // cluster
	                        if (this.flagUseIndexToSkipClusters && this.seekHead) {
	                            const index = this.seekHead.seek.find(index => index.position + this.seekHeadOffset > this.tokenizer.position);
	                            if (index) {
	                                // Go to next index position
	                                const ignoreSize = index.position + this.seekHeadOffset - this.tokenizer.position;
	                                debug$c(`Use index to go to next position, ignoring ${ignoreSize} bytes`);
	                                this.tokenizer.ignore(ignoreSize);
	                                return ParseAction.SkipElement;
	                            }
	                        }
	                        return ParseAction.IgnoreElement;
	                    default:
	                        return ParseAction.ReadNext;
	                }
	            },
	            elementValue: async (element, value, offset) => {
	                debug$c(`Received: name=${element.name}, value=${value}`);
	                switch (element.id) {
	                    case 0x4282: // docType
	                        this.metadata.setFormat('container', `EBML/${value}`);
	                        break;
	                    case 0x114d9b74:
	                        this.seekHead = value;
	                        this.seekHeadOffset = offset;
	                        break;
	                    case 0x1549a966:
	                        { // Info (Segment Information)
	                            const info = value;
	                            const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;
	                            if (typeof info.duration === 'number') {
	                                const duration = info.duration * timecodeScale / 1000000000;
	                                await this.addTag('segment:title', info.title);
	                                this.metadata.setFormat('duration', Number(duration));
	                            }
	                        }
	                        break;
	                    case 0x1654ae6b:
	                        { // tracks
	                            const audioTracks = value;
	                            if (audioTracks?.entries) {
	                                audioTracks.entries.forEach(entry => {
	                                    const stream = {
	                                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),
	                                        codecSettings: entry.codecSettings,
	                                        flagDefault: entry.flagDefault,
	                                        flagLacing: entry.flagLacing,
	                                        flagEnabled: entry.flagEnabled,
	                                        language: entry.language,
	                                        name: entry.name,
	                                        type: entry.trackType,
	                                        audio: entry.audio,
	                                        video: entry.video
	                                    };
	                                    this.metadata.addStreamInfo(stream);
	                                });
	                                const audioTrack = audioTracks.entries
	                                    .filter(entry => entry.trackType === TrackType.audio)
	                                    .reduce((acc, cur) => {
	                                    if (!acc)
	                                        return cur;
	                                    if (cur.flagDefault && !acc.flagDefault)
	                                        return cur;
	                                    if (cur.trackNumber < acc.trackNumber)
	                                        return cur;
	                                    return acc;
	                                }, null);
	                                if (audioTrack) {
	                                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));
	                                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);
	                                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);
	                                }
	                            }
	                        }
	                        break;
	                    case 0x1254c367:
	                        { // tags
	                            const tags = value;
	                            await Promise.all(tags.tag.map(async (tag) => {
	                                const target = tag.target;
	                                const targetType = target?.targetTypeValue ? TargetType[target.targetTypeValue] : (target?.targetType ? target.targetType : 'track');
	                                await Promise.all(tag.simpleTags.map(async (simpleTag) => {
	                                    const value = simpleTag.string ? simpleTag.string : simpleTag.binary;
	                                    await this.addTag(`${targetType}:${simpleTag.name}`, value);
	                                }));
	                            }));
	                        }
	                        break;
	                    case 0x1941a469:
	                        { // attachments
	                            const attachments = value;
	                            await Promise.all(attachments.attachedFiles
	                                .filter(file => file.mimeType.startsWith('image/'))
	                                .map(file => this.addTag('picture', {
	                                data: file.data,
	                                format: file.mimeType,
	                                description: file.description,
	                                name: file.name
	                            })));
	                        }
	                        break;
	                }
	            }
	        });
	    }
	    async addTag(tagId, value) {
	        await this.metadata.addTag('matroska', tagId, value);
	    }
	}

	var MatroskaParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MatroskaParser: MatroskaParser
	});

	const debug$b = initDebug('music-metadata:parser:MP4:atom');
	class Mp4ContentError extends makeUnexpectedFileContentError('MP4') {
	}
	const Header$3 = {
	    len: 8,
	    get: (buf, off) => {
	        const length = UINT32_BE.get(buf, off);
	        if (length < 0)
	            throw new Mp4ContentError('Invalid atom header length');
	        return {
	            length: BigInt(length),
	            name: new StringType(4, 'latin1').get(buf, off + 4)
	        };
	    },
	    put: (buf, off, hdr) => {
	        UINT32_BE.put(buf, off, Number(hdr.length));
	        return FourCcToken.put(buf, off + 4, hdr.name);
	    }
	};
	/**
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190
	 */
	const ExtendedSize = UINT64_BE;
	const ftyp = {
	    len: 4,
	    get: (buf, off) => {
	        return {
	            type: new StringType(4, 'ascii').get(buf, off)
	        };
	    }
	};
	/**
	 * Base class for 'fixed' length atoms.
	 * In some cases these atoms are longer then the sum of the described fields.
	 * Issue: https://github.com/Borewit/music-metadata/issues/120
	 */
	class FixedLengthAtom {
	    /**
	     *
	     * @param {number} len Length as specified in the size field
	     * @param {number} expLen Total length of sum of specified fields in the standard
	     * @param atomId Atom ID
	     */
	    constructor(len, expLen, atomId) {
	        if (len < expLen) {
	            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
	        }
	        if (len > expLen) {
	            debug$b(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
	        }
	        this.len = len;
	    }
	}
	/**
	 * Timestamp stored in seconds since Mac Epoch (1 January 1904)
	 */
	const SecondsSinceMacEpoch = {
	    len: 4,
	    get: (buf, off) => {
	        const secondsSinceUnixEpoch = UINT32_BE.get(buf, off) - 2082844800;
	        return new Date(secondsSinceUnixEpoch * 1000);
	    }
	};
	/**
	 * Token: Media Header Atom
	 * Ref:
	 * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34
	 * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd
	 */
	class MdhdAtom extends FixedLengthAtom {
	    constructor(len) {
	        super(len, 24, 'mdhd');
	    }
	    get(buf, off) {
	        return {
	            version: UINT8.get(buf, off + 0),
	            flags: UINT24_BE.get(buf, off + 1),
	            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
	            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
	            timeScale: UINT32_BE.get(buf, off + 12),
	            duration: UINT32_BE.get(buf, off + 16),
	            language: UINT16_BE.get(buf, off + 20),
	            quality: UINT16_BE.get(buf, off + 22)
	        };
	    }
	}
	/**
	 * Token: Movie Header Atom
	 */
	class MvhdAtom extends FixedLengthAtom {
	    constructor(len) {
	        super(len, 100, 'mvhd');
	    }
	    get(buf, off) {
	        return {
	            version: UINT8.get(buf, off),
	            flags: UINT24_BE.get(buf, off + 1),
	            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
	            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
	            timeScale: UINT32_BE.get(buf, off + 12),
	            duration: UINT32_BE.get(buf, off + 16),
	            preferredRate: UINT32_BE.get(buf, off + 20),
	            preferredVolume: UINT16_BE.get(buf, off + 24),
	            // ignore reserver: 10 bytes
	            // ignore matrix structure: 36 bytes
	            previewTime: UINT32_BE.get(buf, off + 72),
	            previewDuration: UINT32_BE.get(buf, off + 76),
	            posterTime: UINT32_BE.get(buf, off + 80),
	            selectionTime: UINT32_BE.get(buf, off + 84),
	            selectionDuration: UINT32_BE.get(buf, off + 88),
	            currentTime: UINT32_BE.get(buf, off + 92),
	            nextTrackID: UINT32_BE.get(buf, off + 96)
	        };
	    }
	}
	/**
	 * Data Atom Structure
	 */
	class DataAtom {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        return {
	            type: {
	                set: UINT8.get(buf, off + 0),
	                type: UINT24_BE.get(buf, off + 1)
	            },
	            locale: UINT24_BE.get(buf, off + 4),
	            value: new Uint8ArrayType(this.len - 8).get(buf, off + 8)
	        };
	    }
	}
	/**
	 * Data Atom Structure
	 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31
	 */
	class NameAtom {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        return {
	            version: UINT8.get(buf, off),
	            flags: UINT24_BE.get(buf, off + 1),
	            name: new StringType(this.len - 4, 'utf-8').get(buf, off + 4)
	        };
	    }
	}
	/**
	 * Track Header Atoms structure (`tkhd`)
	 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550
	 */
	class TrackHeaderAtom {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        return {
	            version: UINT8.get(buf, off),
	            flags: UINT24_BE.get(buf, off + 1),
	            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
	            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
	            trackId: UINT32_BE.get(buf, off + 12),
	            // reserved 4 bytes
	            duration: UINT32_BE.get(buf, off + 20),
	            layer: UINT16_BE.get(buf, off + 24),
	            alternateGroup: UINT16_BE.get(buf, off + 26),
	            volume: UINT16_BE.get(buf, off + 28) // ToDo: fixed point
	            // ToDo: add remaining fields
	        };
	    }
	}
	/**
	 * Atom: Sample Description Atom ('stsd')
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
	 */
	const stsdHeader = {
	    len: 8,
	    get: (buf, off) => {
	        return {
	            version: UINT8.get(buf, off),
	            flags: UINT24_BE.get(buf, off + 1),
	            numberOfEntries: UINT32_BE.get(buf, off + 4)
	        };
	    }
	};
	/**
	 * Atom: Sample Description Atom ('stsd')
	 * Ref: https://developer.apple.com/documentation/quicktime-file-format/sample_description_atom
	 */
	class SampleDescriptionTable {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const descrLen = this.len - 12;
	        return {
	            dataFormat: FourCcToken.get(buf, off),
	            dataReferenceIndex: UINT16_BE.get(buf, off + 10),
	            description: descrLen > 0 ? new Uint8ArrayType(descrLen).get(buf, off + 12) : undefined
	        };
	    }
	}
	/**
	 * Atom: Sample-description Atom ('stsd')
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
	 */
	class StsdAtom {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const header = stsdHeader.get(buf, off);
	        off += stsdHeader.len;
	        const table = [];
	        for (let n = 0; n < header.numberOfEntries; ++n) {
	            const size = UINT32_BE.get(buf, off); // Sample description size
	            off += UINT32_BE.len;
	            table.push(new SampleDescriptionTable(size - UINT32_BE.len).get(buf, off));
	            off += size;
	        }
	        return {
	            header,
	            table
	        };
	    }
	}
	/**
	 * Common Sound Sample Description (version & revision)
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317
	 */
	const SoundSampleDescriptionVersion = {
	    len: 8,
	    get(buf, off) {
	        return {
	            version: INT16_BE.get(buf, off),
	            revision: INT16_BE.get(buf, off + 2),
	            vendor: INT32_BE.get(buf, off + 4)
	        };
	    }
	};
	/**
	 * Sound Sample Description (Version 0)
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736
	 */
	const SoundSampleDescriptionV0 = {
	    len: 12,
	    get(buf, off) {
	        return {
	            numAudioChannels: INT16_BE.get(buf, off + 0),
	            sampleSize: INT16_BE.get(buf, off + 2),
	            compressionId: INT16_BE.get(buf, off + 4),
	            packetSize: INT16_BE.get(buf, off + 6),
	            sampleRate: UINT16_BE.get(buf, off + 8) + UINT16_BE.get(buf, off + 10) / 10000
	        };
	    }
	};
	class SimpleTableAtom {
	    constructor(len, token) {
	        this.len = len;
	        this.token = token;
	    }
	    get(buf, off) {
	        const nrOfEntries = INT32_BE.get(buf, off + 4);
	        return {
	            version: INT8.get(buf, off + 0),
	            flags: INT24_BE.get(buf, off + 1),
	            numberOfEntries: nrOfEntries,
	            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
	        };
	    }
	}
	const TimeToSampleToken = {
	    len: 8,
	    get(buf, off) {
	        return {
	            count: INT32_BE.get(buf, off + 0),
	            duration: INT32_BE.get(buf, off + 4)
	        };
	    }
	};
	/**
	 * Time-to-sample('stts') atom.
	 * Store duration information for a media’s samples.
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696
	 */
	class SttsAtom extends SimpleTableAtom {
	    constructor(len) {
	        super(len, TimeToSampleToken);
	    }
	}
	const SampleToChunkToken = {
	    len: 12,
	    get(buf, off) {
	        return {
	            firstChunk: INT32_BE.get(buf, off),
	            samplesPerChunk: INT32_BE.get(buf, off + 4),
	            sampleDescriptionId: INT32_BE.get(buf, off + 8)
	        };
	    }
	};
	/**
	 * Sample-to-Chunk ('stsc') atom interface
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706
	 */
	class StscAtom extends SimpleTableAtom {
	    constructor(len) {
	        super(len, SampleToChunkToken);
	    }
	}
	/**
	 * Sample-size ('stsz') atom
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710
	 */
	class StszAtom {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const nrOfEntries = INT32_BE.get(buf, off + 8);
	        return {
	            version: INT8.get(buf, off),
	            flags: INT24_BE.get(buf, off + 1),
	            sampleSize: INT32_BE.get(buf, off + 4),
	            numberOfEntries: nrOfEntries,
	            entries: readTokenTable(buf, INT32_BE, off + 12, this.len - 12, nrOfEntries)
	        };
	    }
	}
	/**
	 * Chunk offset atom, 'stco'
	 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715
	 */
	class StcoAtom extends SimpleTableAtom {
	    constructor(len) {
	        super(len, INT32_BE);
	        this.len = len;
	    }
	}
	/**
	 * Token used to decode text-track from 'mdat' atom (raw data stream)
	 */
	class ChapterText {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const titleLen = INT16_BE.get(buf, off + 0);
	        const str = new StringType(titleLen, 'utf-8');
	        return str.get(buf, off + 2);
	    }
	}
	function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
	    debug$b(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);
	    if (remainingLen === 0)
	        return [];
	    if (remainingLen !== numberOfEntries * token.len)
	        throw new Mp4ContentError('mismatch number-of-entries with remaining atom-length');
	    const entries = [];
	    // parse offset-table
	    for (let n = 0; n < numberOfEntries; ++n) {
	        entries.push(token.get(buf, off));
	        off += token.len;
	    }
	    return entries;
	}
	/**
	 * Sample-size ('tfhd') TrackFragmentHeaderBox
	 */
	class TrackFragmentHeaderBox {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const flagOffset = off + 1;
	        const header = {
	            version: INT8.get(buf, off),
	            flags: {
	                baseDataOffsetPresent: getBit(buf, flagOffset + 2, 0),
	                sampleDescriptionIndexPresent: getBit(buf, flagOffset + 2, 1),
	                defaultSampleDurationPresent: getBit(buf, flagOffset + 2, 3),
	                defaultSampleSizePresent: getBit(buf, flagOffset + 2, 4),
	                defaultSampleFlagsPresent: getBit(buf, flagOffset + 2, 5),
	                defaultDurationIsEmpty: getBit(buf, flagOffset, 0),
	                defaultBaseIsMoof: getBit(buf, flagOffset, 1)
	            },
	            trackId: UINT32_BE.get(buf, 4)
	        };
	        let dynOffset = 8;
	        if (header.flags.baseDataOffsetPresent) {
	            header.baseDataOffset = UINT64_BE.get(buf, dynOffset);
	            dynOffset += 8;
	        }
	        if (header.flags.sampleDescriptionIndexPresent) {
	            header.sampleDescriptionIndex = UINT32_BE.get(buf, dynOffset);
	            dynOffset += 4;
	        }
	        if (header.flags.defaultSampleDurationPresent) {
	            header.defaultSampleDuration = UINT32_BE.get(buf, dynOffset);
	            dynOffset += 4;
	        }
	        if (header.flags.defaultSampleSizePresent) {
	            header.defaultSampleSize = UINT32_BE.get(buf, dynOffset);
	            dynOffset += 4;
	        }
	        if (header.flags.defaultSampleFlagsPresent) {
	            header.defaultSampleFlags = UINT32_BE.get(buf, dynOffset);
	        }
	        return header;
	    }
	}
	/**
	 * Sample-size ('trun') TrackRunBox
	 */
	class TrackRunBox {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const flagOffset = off + 1;
	        const trun = {
	            version: INT8.get(buf, off),
	            flags: {
	                dataOffsetPresent: getBit(buf, flagOffset + 2, 0),
	                firstSampleFlagsPresent: getBit(buf, flagOffset + 2, 2),
	                sampleDurationPresent: getBit(buf, flagOffset + 1, 0),
	                sampleSizePresent: getBit(buf, flagOffset + 1, 1),
	                sampleFlagsPresent: getBit(buf, flagOffset + 1, 2),
	                sampleCompositionTimeOffsetsPresent: getBit(buf, flagOffset + 1, 3)
	            },
	            sampleCount: UINT32_BE.get(buf, off + 4),
	            samples: []
	        };
	        let dynOffset = off + 8;
	        if (trun.flags.dataOffsetPresent) {
	            trun.dataOffset = UINT32_BE.get(buf, dynOffset);
	            dynOffset += 4;
	        }
	        if (trun.flags.firstSampleFlagsPresent) {
	            trun.firstSampleFlags = UINT32_BE.get(buf, dynOffset);
	            dynOffset += 4;
	        }
	        for (let n = 0; n < trun.sampleCount; ++n) {
	            if (dynOffset >= this.len) {
	                debug$b("TrackRunBox size mismatch");
	                break;
	            }
	            const sample = {};
	            if (trun.flags.sampleDurationPresent) {
	                sample.sampleDuration = UINT32_BE.get(buf, dynOffset);
	                dynOffset += 4;
	            }
	            if (trun.flags.sampleSizePresent) {
	                sample.sampleSize = UINT32_BE.get(buf, dynOffset);
	                dynOffset += 4;
	            }
	            if (trun.flags.sampleFlagsPresent) {
	                sample.sampleFlags = UINT32_BE.get(buf, dynOffset);
	                dynOffset += 4;
	            }
	            if (trun.flags.sampleCompositionTimeOffsetsPresent) {
	                sample.sampleCompositionTimeOffset = UINT32_BE.get(buf, dynOffset);
	                dynOffset += 4;
	            }
	            trun.samples.push(sample);
	        }
	        return trun;
	    }
	}
	/**
	 * HandlerBox (`hdlr`)
	 */
	class HandlerBox {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        const charTypeToken = new StringType(4, 'utf-8');
	        return {
	            version: INT8.get(buf, off),
	            flags: UINT24_BE.get(buf, off + 1),
	            componentType: charTypeToken.get(buf, off + 4),
	            handlerType: charTypeToken.get(buf, off + 8),
	            componentName: new StringType(this.len - 28, 'utf-8').get(buf, off + 28),
	        };
	    }
	}
	/**
	 * Chapter Track Reference Box (`chap`)
	 */
	class ChapterTrackReferenceBox {
	    constructor(len) {
	        this.len = len;
	    }
	    get(buf, off) {
	        let dynOffset = 0;
	        const trackIds = [];
	        while (dynOffset < this.len) {
	            trackIds.push(UINT32_BE.get(buf, off + dynOffset));
	            dynOffset += 4;
	        }
	        return trackIds;
	    }
	}

	const debug$a = initDebug('music-metadata:parser:MP4:Atom');
	class Atom {
	    static async readAtom(tokenizer, dataHandler, parent, remaining) {
	        // Parse atom header
	        const offset = tokenizer.position;
	        debug$a(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')
	        const header = await tokenizer.readToken(Header$3);
	        const extended = header.length === 1n;
	        if (extended) {
	            header.length = await tokenizer.readToken(ExtendedSize);
	        }
	        const atomBean = new Atom(header, extended, parent);
	        const payloadLength = atomBean.getPayloadLength(remaining);
	        debug$a(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')
	        await atomBean.readData(tokenizer, dataHandler, payloadLength);
	        return atomBean;
	    }
	    constructor(header, extended, parent) {
	        this.header = header;
	        this.extended = extended;
	        this.parent = parent;
	        this.children = [];
	        this.atomPath = (this.parent ? `${this.parent.atomPath}.` : '') + this.header.name;
	    }
	    getHeaderLength() {
	        return this.extended ? 16 : 8;
	    }
	    getPayloadLength(remaining) {
	        return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();
	    }
	    async readAtoms(tokenizer, dataHandler, size) {
	        while (size > 0) {
	            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);
	            this.children.push(atomBean);
	            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);
	        }
	    }
	    async readData(tokenizer, dataHandler, remaining) {
	        switch (this.header.name) {
	            // "Container" atoms, contains nested atoms
	            case 'moov': // The Movie Atom: contains other atoms
	            case 'udta': // User defined atom
	            case 'mdia': // Media atom
	            case 'minf': // Media Information Atom
	            case 'stbl': // The Sample Table Atom
	            case '<id>':
	            case 'ilst':
	            case 'tref':
	            case 'moof':
	                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
	            case 'meta': { // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
	                // meta has 4 bytes of padding, ignore
	                const peekHeader = await tokenizer.peekToken(Header$3);
	                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;
	                await tokenizer.ignore(paddingLength);
	                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
	            }
	            default:
	                return dataHandler(this, remaining);
	        }
	    }
	}

	const debug$9 = initDebug('music-metadata:parser:MP4');
	const tagFormat = 'iTunes';
	const encoderDict = {
	    raw: {
	        lossy: false,
	        format: 'raw'
	    },
	    MAC3: {
	        lossy: true,
	        format: 'MACE 3:1'
	    },
	    MAC6: {
	        lossy: true,
	        format: 'MACE 6:1'
	    },
	    ima4: {
	        lossy: true,
	        format: 'IMA 4:1'
	    },
	    ulaw: {
	        lossy: true,
	        format: 'uLaw 2:1'
	    },
	    alaw: {
	        lossy: true,
	        format: 'uLaw 2:1'
	    },
	    Qclp: {
	        lossy: true,
	        format: 'QUALCOMM PureVoice'
	    },
	    '.mp3': {
	        lossy: true,
	        format: 'MPEG-1 layer 3'
	    },
	    alac: {
	        lossy: false,
	        format: 'ALAC'
	    },
	    'ac-3': {
	        lossy: true,
	        format: 'AC-3'
	    },
	    mp4a: {
	        lossy: true,
	        format: 'MPEG-4/AAC'
	    },
	    mp4s: {
	        lossy: true,
	        format: 'MP4S'
	    },
	    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
	    c608: {
	        lossy: true,
	        format: 'CEA-608'
	    },
	    c708: {
	        lossy: true,
	        format: 'CEA-708'
	    }
	};
	function distinct(value, index, self) {
	    return self.indexOf(value) === index;
	}
	/*
	 * Parser for the MP4 (MPEG-4 Part 14) container format
	 * Standard: ISO/IEC 14496-14
	 * supporting:
	 * - QuickTime container
	 * - MP4 File Format
	 * - 3GPP file format
	 * - 3GPP2 file format
	 *
	 * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.
	 * Support for Apple iTunes tags as found in a M4A/M4V files.
	 * Ref:
	 *   https://en.wikipedia.org/wiki/ISO_base_media_file_format
	 *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html
	 *   http://atomicparsley.sourceforge.net/mpeg-4files.html
	 *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata
	 *   https://wiki.multimedia.cx/index.php/QuickTime_container
	 */
	class MP4Parser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.tracks = new Map();
	        this.hasVideoTrack = false;
	        this.hasAudioTrack = true;
	        this.atomParsers = {
	            /**
	             * Parse movie header (mvhd) atom
	             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
	             */
	            mvhd: async (len) => {
	                const mvhd = await this.tokenizer.readToken(new MvhdAtom(len));
	                this.metadata.setFormat('creationTime', mvhd.creationTime);
	                this.metadata.setFormat('modificationTime', mvhd.modificationTime);
	            },
	            chap: async (len) => {
	                const td = this.getTrackDescription();
	                const trackIds = [];
	                while (len >= UINT32_BE.len) {
	                    trackIds.push(await this.tokenizer.readNumber(UINT32_BE));
	                    len -= UINT32_BE.len;
	                }
	                td.chapterList = trackIds;
	            },
	            /**
	             * Parse mdat atom.
	             * Will scan for chapters
	             */
	            mdat: async (len) => {
	                this.audioLengthInBytes = len;
	                this.calculateBitRate();
	                if (this.options.includeChapters) {
	                    const trackWithChapters = [...this.tracks.values()].filter(track => track.chapterList);
	                    if (trackWithChapters.length === 1) {
	                        const chapterTrackIds = trackWithChapters[0].chapterList;
	                        const chapterTracks = [...this.tracks.values()].filter(track => chapterTrackIds.indexOf(track.header.trackId) !== -1);
	                        if (chapterTracks.length === 1) {
	                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
	                        }
	                    }
	                }
	                await this.tokenizer.ignore(len);
	            },
	            ftyp: async (len) => {
	                const types = [];
	                while (len > 0) {
	                    const ftype = await this.tokenizer.readToken(ftyp);
	                    len -= ftyp.len;
	                    const value = ftype.type.replace(/\W/g, '');
	                    if (value.length > 0) {
	                        types.push(value); // unshift for backward compatibility
	                    }
	                }
	                debug$9(`ftyp: ${types.join('/')}`);
	                const x = types.filter(distinct).join('/');
	                this.metadata.setFormat('container', x);
	            },
	            /**
	             * Parse sample description atom
	             */
	            stsd: async (len) => {
	                const stsd = await this.tokenizer.readToken(new StsdAtom(len));
	                const trackDescription = this.getTrackDescription();
	                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));
	            },
	            /**
	             * Parse sample-sizes atom ('stsz')
	             */
	            stsz: async (len) => {
	                const stsz = await this.tokenizer.readToken(new StszAtom(len));
	                const td = this.getTrackDescription();
	                td.sampleSize = stsz.sampleSize;
	                td.sampleSizeTable = stsz.entries;
	            },
	            date: async (len) => {
	                const date = await this.tokenizer.readToken(new StringType(len, 'utf-8'));
	                await this.addTag('date', date);
	            }
	        };
	    }
	    static read_BE_Integer(array, signed) {
	        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');
	        const token = Token[integerType];
	        if (!token) {
	            throw new Mp4ContentError(`Token for integer type not found: "${integerType}"`);
	        }
	        return Number(token.get(array, 0));
	    }
	    async parse() {
	        this.hasVideoTrack = false;
	        this.hasAudioTrack = true;
	        this.tracks.clear();
	        let remainingFileSize = this.tokenizer.fileInfo.size || 0;
	        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {
	            try {
	                const token = await this.tokenizer.peekToken(Header$3);
	                if (token.name === '\0\0\0\0') {
	                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
	                    debug$9(errMsg);
	                    this.addWarning(errMsg);
	                    break;
	                }
	            }
	            catch (error) {
	                if (error instanceof Error) {
	                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
	                    debug$9(errMsg);
	                    this.addWarning(errMsg);
	                }
	                else
	                    throw error;
	                break;
	            }
	            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
	            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
	        }
	        // Post process metadata
	        const formatList = [];
	        this.tracks.forEach(track => {
	            const trackFormats = [];
	            track.soundSampleDescription.forEach(ssd => {
	                const streamInfo = {};
	                const encoderInfo = encoderDict[ssd.dataFormat];
	                if (encoderInfo) {
	                    trackFormats.push(encoderInfo.format);
	                    streamInfo.codecName = encoderInfo.format;
	                }
	                else {
	                    streamInfo.codecName = `<${ssd.dataFormat}>`;
	                }
	                if (ssd.description) {
	                    const { description } = ssd;
	                    if (description.sampleRate > 0) {
	                        streamInfo.type = TrackType.audio;
	                        streamInfo.audio = {
	                            samplingFrequency: description.sampleRate,
	                            bitDepth: description.sampleSize,
	                            channels: description.numAudioChannels
	                        };
	                    }
	                }
	                this.metadata.addStreamInfo(streamInfo);
	            });
	            if (trackFormats.length >= 1) {
	                formatList.push(trackFormats.join('/'));
	            }
	        });
	        if (formatList.length > 0) {
	            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));
	        }
	        const audioTracks = [...this.tracks.values()].filter(track => {
	            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
	        });
	        if (audioTracks.length >= 1) {
	            const audioTrack = audioTracks[0];
	            if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {
	                if (audioTrack.media.header.duration > 0) {
	                    debug$9('Using duration defined on audio track');
	                    const duration = audioTrack.media.header.duration / audioTrack.media.header.timeScale; // calculate duration in seconds
	                    this.metadata.setFormat('duration', duration);
	                }
	                else if (audioTrack.fragments.length > 0) {
	                    debug$9('Calculate duration defined in track fragments');
	                    let totalTimeUnits = 0;
	                    for (const fragment of audioTrack.fragments) {
	                        const defaultDuration = fragment.header.defaultSampleDuration;
	                        for (const sample of fragment.trackRun.samples) {
	                            const dur = sample.sampleDuration ?? defaultDuration;
	                            if (dur == null) {
	                                throw new Error("Missing sampleDuration and no default_sample_duration in tfhd");
	                            }
	                            totalTimeUnits += dur;
	                        }
	                    }
	                    this.metadata.setFormat('duration', totalTimeUnits / audioTrack.media.header.timeScale);
	                }
	            }
	            const ssd = audioTrack.soundSampleDescription[0];
	            if (ssd.description && audioTrack.media.header) {
	                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);
	                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);
	                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);
	                if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {
	                    const totalSampleSize = audioTrack.timeToSampleTable
	                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)
	                        .reduce((total, sampleSize) => total + sampleSize);
	                    const duration = totalSampleSize / ssd.description.sampleRate;
	                    this.metadata.setFormat('duration', duration);
	                }
	            }
	            const encoderInfo = encoderDict[ssd.dataFormat];
	            if (encoderInfo) {
	                this.metadata.setFormat('lossless', !encoderInfo.lossy);
	            }
	            this.calculateBitRate();
	        }
	        this.metadata.setFormat('hasAudio', this.hasAudioTrack);
	        this.metadata.setFormat('hasVideo', this.hasVideoTrack);
	    }
	    async handleAtom(atom, remaining) {
	        if (atom.parent) {
	            switch (atom.parent.header.name) {
	                case 'ilst':
	                case '<id>':
	                    return this.parseMetadataItemData(atom);
	                case 'moov':
	                    switch (atom.header.name) {
	                        case 'trak':
	                            return this.parseTrackBox(atom);
	                    }
	                    break;
	                case 'moof':
	                    switch (atom.header.name) {
	                        case 'traf':
	                            return this.parseTrackFragmentBox(atom);
	                    }
	            }
	        }
	        // const payloadLength = atom.getPayloadLength(remaining);
	        if (this.atomParsers[atom.header.name]) {
	            return this.atomParsers[atom.header.name](remaining);
	        }
	        debug$9(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);
	        await this.tokenizer.ignore(remaining);
	    }
	    getTrackDescription() {
	        // ToDo: pick the right track, not the last track!!!!
	        const tracks = [...this.tracks.values()];
	        return tracks[tracks.length - 1];
	    }
	    calculateBitRate() {
	        if (this.audioLengthInBytes && this.metadata.format.duration) {
	            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);
	        }
	    }
	    async addTag(id, value) {
	        await this.metadata.addTag(tagFormat, id, value);
	    }
	    addWarning(message) {
	        debug$9(`Warning: ${message}`);
	        this.metadata.addWarning(message);
	    }
	    /**
	     * Parse data of Meta-item-list-atom (item of 'ilst' atom)
	     * @param metaAtom
	     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
	     */
	    parseMetadataItemData(metaAtom) {
	        let tagKey = metaAtom.header.name;
	        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
	            const payLoadLength = child.getPayloadLength(remaining);
	            switch (child.header.name) {
	                case 'data': // value atom
	                    return this.parseValueAtom(tagKey, child);
	                case 'name': // name atom (optional)
	                case 'mean':
	                case 'rate': {
	                    const name = await this.tokenizer.readToken(new NameAtom(payLoadLength));
	                    tagKey += `:${name.name}`;
	                    break;
	                }
	                default: {
	                    const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(payLoadLength));
	                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${uint8ArrayToString(uint8Array, 'ascii')}`);
	                }
	            }
	        }, metaAtom.getPayloadLength(0));
	    }
	    async parseValueAtom(tagKey, metaAtom) {
	        const dataAtom = await this.tokenizer.readToken(new DataAtom(Number(metaAtom.header.length) - Header$3.len));
	        if (dataAtom.type.set !== 0) {
	            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);
	        }
	        // Use well-known-type table
	        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35
	        switch (dataAtom.type.type) {
	            case 0: // reserved: Reserved for use where no type needs to be indicated
	                switch (tagKey) {
	                    case 'trkn':
	                    case 'disk': {
	                        const num = UINT8.get(dataAtom.value, 3);
	                        const of = UINT8.get(dataAtom.value, 5);
	                        // console.log("  %s[data] = %s/%s", tagKey, num, of);
	                        await this.addTag(tagKey, `${num}/${of}`);
	                        break;
	                    }
	                    case 'gnre': {
	                        const genreInt = UINT8.get(dataAtom.value, 1);
	                        const genreStr = Genres[genreInt - 1];
	                        // console.log("  %s[data] = %s", tagKey, genreStr);
	                        await this.addTag(tagKey, genreStr);
	                        break;
	                    }
	                    case 'rate': {
	                        const rate = new TextDecoder('ascii').decode(dataAtom.value);
	                        await this.addTag(tagKey, rate);
	                        break;
	                    }
	                    default:
	                        debug$9(`unknown proprietary value type for: ${metaAtom.atomPath}`);
	                }
	                break;
	            case 1: // UTF-8: Without any count or NULL terminator
	            case 18: // Unknown: Found in m4b in combination with a '©gen' tag
	                await this.addTag(tagKey, new TextDecoder('utf-8').decode(dataAtom.value));
	                break;
	            case 13: // JPEG
	                if (this.options.skipCovers)
	                    break;
	                await this.addTag(tagKey, {
	                    format: 'image/jpeg',
	                    data: Uint8Array.from(dataAtom.value)
	                });
	                break;
	            case 14: // PNG
	                if (this.options.skipCovers)
	                    break;
	                await this.addTag(tagKey, {
	                    format: 'image/png',
	                    data: Uint8Array.from(dataAtom.value)
	                });
	                break;
	            case 21: // BE Signed Integer
	                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));
	                break;
	            case 22: // BE Unsigned Integer
	                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));
	                break;
	            case 65: // An 8-bit signed integer
	                await this.addTag(tagKey, UINT8.get(dataAtom.value, 0));
	                break;
	            case 66: // A big-endian 16-bit signed integer
	                await this.addTag(tagKey, UINT16_BE.get(dataAtom.value, 0));
	                break;
	            case 67: // A big-endian 32-bit signed integer
	                await this.addTag(tagKey, UINT32_BE.get(dataAtom.value, 0));
	                break;
	            default:
	                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
	        }
	    }
	    async parseTrackBox(trakBox) {
	        // @ts-ignore
	        const track = {
	            media: {},
	            fragments: []
	        };
	        await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {
	            const payLoadLength = child.getPayloadLength(remaining);
	            switch (child.header.name) {
	                case 'chap': {
	                    const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));
	                    track.chapterList = chap;
	                    break;
	                }
	                case 'tkhd': // TrackHeaderBox
	                    track.header = await this.tokenizer.readToken(new TrackHeaderAtom(payLoadLength));
	                    break;
	                case 'hdlr': // TrackHeaderBox
	                    track.handler = await this.tokenizer.readToken(new HandlerBox(payLoadLength));
	                    switch (track.handler.handlerType) {
	                        case 'audi':
	                            debug$9('Contains audio track');
	                            this.hasAudioTrack = true;
	                            break;
	                        case 'vide':
	                            debug$9('Contains video track');
	                            this.hasVideoTrack = true;
	                            break;
	                    }
	                    break;
	                case 'mdhd': { // Parse media header (mdhd) box
	                    const mdhd_data = await this.tokenizer.readToken(new MdhdAtom(payLoadLength));
	                    track.media.header = mdhd_data;
	                    break;
	                }
	                case 'stco': {
	                    const stco = await this.tokenizer.readToken(new StcoAtom(payLoadLength));
	                    track.chunkOffsetTable = stco.entries; // remember chunk offsets
	                    break;
	                }
	                case 'stsc': { // sample-to-Chunk box
	                    const stsc = await this.tokenizer.readToken(new StscAtom(payLoadLength));
	                    track.sampleToChunkTable = stsc.entries;
	                    break;
	                }
	                case 'stsd': { // sample description box
	                    const stsd = await this.tokenizer.readToken(new StsdAtom(payLoadLength));
	                    track.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));
	                    break;
	                }
	                case 'stts': { // time-to-sample table
	                    const stts = await this.tokenizer.readToken(new SttsAtom(payLoadLength));
	                    track.timeToSampleTable = stts.entries;
	                    break;
	                }
	                case 'stsz': {
	                    const stsz = await this.tokenizer.readToken(new StszAtom(payLoadLength));
	                    track.sampleSize = stsz.sampleSize;
	                    track.sampleSizeTable = stsz.entries;
	                    break;
	                }
	                case 'dinf':
	                case 'vmhd':
	                case 'smhd':
	                    debug$9(`Ignoring: ${child.header.name}`);
	                    await this.tokenizer.ignore(payLoadLength);
	                    break;
	                default: {
	                    debug$9(`Unexpected track box: ${child.header.name}`);
	                    await this.tokenizer.ignore(payLoadLength);
	                }
	            }
	        }, trakBox.getPayloadLength(0));
	        // Register track
	        this.tracks.set(track.header.trackId, track);
	    }
	    parseTrackFragmentBox(trafBox) {
	        let tfhd;
	        return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {
	            const payLoadLength = child.getPayloadLength(remaining);
	            switch (child.header.name) {
	                case 'tfhd': { // TrackFragmentHeaderBox
	                    const fragmentHeaderBox = new TrackFragmentHeaderBox(child.getPayloadLength(remaining));
	                    tfhd = await this.tokenizer.readToken(fragmentHeaderBox);
	                    break;
	                }
	                case 'tfdt': // TrackFragmentBaseMediaDecodeTimeBo
	                    await this.tokenizer.ignore(payLoadLength);
	                    break;
	                case 'trun': { // TrackRunBox
	                    const trackRunBox = new TrackRunBox(payLoadLength);
	                    const trun = await this.tokenizer.readToken(trackRunBox);
	                    if (tfhd) {
	                        const track = this.tracks.get(tfhd.trackId);
	                        track?.fragments.push({ header: tfhd, trackRun: trun });
	                    }
	                    break;
	                }
	                default: {
	                    debug$9(`Unexpected box: ${child.header.name}`);
	                    await this.tokenizer.ignore(payLoadLength);
	                }
	            }
	        }, trafBox.getPayloadLength(0));
	    }
	    /**
	     * @param sampleDescription
	     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
	     */
	    parseSoundSampleDescription(sampleDescription) {
	        const ssd = {
	            dataFormat: sampleDescription.dataFormat,
	            dataReferenceIndex: sampleDescription.dataReferenceIndex
	        };
	        let offset = 0;
	        if (sampleDescription.description) {
	            const version = SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
	            offset += SoundSampleDescriptionVersion.len;
	            if (version.version === 0 || version.version === 1) {
	                // Sound Sample Description (Version 0)
	                ssd.description = SoundSampleDescriptionV0.get(sampleDescription.description, offset);
	            }
	            else {
	                debug$9(`Warning: sound-sample-description ${version} not implemented`);
	            }
	        }
	        return ssd;
	    }
	    async parseChapterTrack(chapterTrack, track, len) {
	        if (!chapterTrack.sampleSize) {
	            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
	                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');
	        }
	        const chapters = [];
	        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
	            const start = chapterTrack.timeToSampleTable
	                .slice(0, i)
	                .reduce((acc, cur) => acc + cur.duration, 0);
	            const chunkOffset = chapterTrack.chunkOffsetTable[i];
	            const nextChunkLen = chunkOffset - this.tokenizer.position;
	            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
	            len -= nextChunkLen + sampleSize;
	            if (len < 0)
	                throw new Mp4ContentError('Chapter chunk exceeding token length');
	            await this.tokenizer.ignore(nextChunkLen);
	            const title = await this.tokenizer.readToken(new ChapterText(sampleSize));
	            debug$9(`Chapter ${i + 1}: ${title}`);
	            const chapter = {
	                title,
	                timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,
	                start,
	                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
	            };
	            debug$9(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`); // ToDo, use media duration if required!!!
	            chapters.push(chapter);
	        }
	        this.metadata.setFormat('chapters', chapters);
	        await this.tokenizer.ignore(len);
	    }
	    findSampleOffset(track, chapterOffset) {
	        let chunkIndex = 0;
	        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
	            ++chunkIndex;
	        }
	        return this.getChunkDuration(chunkIndex + 1, track);
	    }
	    getChunkDuration(chunkId, track) {
	        let ttsi = 0;
	        let ttsc = track.timeToSampleTable[ttsi].count;
	        let ttsd = track.timeToSampleTable[ttsi].duration;
	        let curChunkId = 1;
	        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
	        let totalDuration = 0;
	        while (curChunkId < chunkId) {
	            const nrOfSamples = Math.min(ttsc, samplesPerChunk);
	            totalDuration += nrOfSamples * ttsd;
	            ttsc -= nrOfSamples;
	            samplesPerChunk -= nrOfSamples;
	            if (samplesPerChunk === 0) {
	                ++curChunkId;
	                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
	            }
	            else {
	                ++ttsi;
	                ttsc = track.timeToSampleTable[ttsi].count;
	                ttsd = track.timeToSampleTable[ttsi].duration;
	            }
	        }
	        return totalDuration;
	    }
	    getSamplesPerChunk(chunkId, stcTable) {
	        for (let i = 0; i < stcTable.length - 1; ++i) {
	            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
	                return stcTable[i].samplesPerChunk;
	            }
	        }
	        return stcTable[stcTable.length - 1].samplesPerChunk;
	    }
	}

	var MP4Parser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MP4Parser: MP4Parser
	});

	const debug$8 = initDebug('music-metadata:parser:musepack:sv8');
	const PacketKey = new StringType(2, 'latin1');
	/**
	 * Stream Header Packet part 1
	 * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket
	 */
	const SH_part1 = {
	    len: 5,
	    get: (buf, off) => {
	        return {
	            crc: UINT32_LE.get(buf, off),
	            streamVersion: UINT8.get(buf, off + 4)
	        };
	    }
	};
	/**
	 * Stream Header Packet part 3
	 * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket
	 */
	const SH_part3 = {
	    len: 2,
	    get: (buf, off) => {
	        return {
	            sampleFrequency: [44100, 48000, 37800, 32000][getBitAllignedNumber$1(buf, off, 0, 3)],
	            maxUsedBands: getBitAllignedNumber$1(buf, off, 3, 5),
	            channelCount: getBitAllignedNumber$1(buf, off + 1, 0, 4) + 1,
	            msUsed: isBitSet$2(buf, off + 1, 4),
	            audioBlockFrames: getBitAllignedNumber$1(buf, off + 1, 5, 3)
	        };
	    }
	};
	class StreamReader {
	    get tokenizer() {
	        return this._tokenizer;
	    }
	    set tokenizer(value) {
	        this._tokenizer = value;
	    }
	    constructor(_tokenizer) {
	        this._tokenizer = _tokenizer;
	    }
	    async readPacketHeader() {
	        const key = await this.tokenizer.readToken(PacketKey);
	        const size = await this.readVariableSizeField();
	        return {
	            key,
	            payloadLength: size.value - 2 - size.len
	        };
	    }
	    async readStreamHeader(size) {
	        const streamHeader = {};
	        debug$8(`Reading SH at offset=${this.tokenizer.position}`);
	        const part1 = await this.tokenizer.readToken(SH_part1);
	        size -= SH_part1.len;
	        Object.assign(streamHeader, part1);
	        debug$8(`SH.streamVersion = ${part1.streamVersion}`);
	        const sampleCount = await this.readVariableSizeField();
	        size -= sampleCount.len;
	        streamHeader.sampleCount = sampleCount.value;
	        const bs = await this.readVariableSizeField();
	        size -= bs.len;
	        streamHeader.beginningOfSilence = bs.value;
	        const part3 = await this.tokenizer.readToken(SH_part3);
	        size -= SH_part3.len;
	        Object.assign(streamHeader, part3);
	        // assert.equal(size, 0);
	        await this.tokenizer.ignore(size);
	        return streamHeader;
	    }
	    async readVariableSizeField(len = 1, hb = 0) {
	        let n = await this.tokenizer.readNumber(UINT8);
	        if ((n & 0x80) === 0) {
	            return { len, value: hb + n };
	        }
	        n &= 0x7F;
	        n += hb;
	        return this.readVariableSizeField(len + 1, n << 7);
	    }
	}

	class MusepackContentError extends makeUnexpectedFileContentError('Musepack') {
	}

	const debug$7 = initDebug('music-metadata:parser:musepack');
	class MpcSv8Parser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.audioLength = 0;
	    }
	    async parse() {
	        const signature = await this.tokenizer.readToken(FourCcToken);
	        if (signature !== 'MPCK')
	            throw new MusepackContentError('Invalid Magic number');
	        this.metadata.setFormat('container', 'Musepack, SV8');
	        return this.parsePacket();
	    }
	    async parsePacket() {
	        const sv8reader = new StreamReader(this.tokenizer);
	        do {
	            const header = await sv8reader.readPacketHeader();
	            debug$7(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);
	            switch (header.key) {
	                case 'SH': { // Stream Header
	                    const sh = await sv8reader.readStreamHeader(header.payloadLength);
	                    this.metadata.setFormat('numberOfSamples', sh.sampleCount);
	                    this.metadata.setFormat('sampleRate', sh.sampleFrequency);
	                    this.metadata.setFormat('duration', sh.sampleCount / sh.sampleFrequency);
	                    this.metadata.setFormat('numberOfChannels', sh.channelCount);
	                    break;
	                }
	                case 'AP': // Audio Packet
	                    this.audioLength += header.payloadLength;
	                    await this.tokenizer.ignore(header.payloadLength);
	                    break;
	                case 'RG': // Replaygain
	                case 'EI': // Encoder Info
	                case 'SO': // Seek Table Offset
	                case 'ST': // Seek Table
	                case 'CT': // Chapter-Tag
	                    await this.tokenizer.ignore(header.payloadLength);
	                    break;
	                case 'SE': // Stream End
	                    if (this.metadata.format.duration) {
	                        this.metadata.setFormat('bitrate', this.audioLength * 8 / this.metadata.format.duration);
	                    }
	                    return tryParseApeHeader(this.metadata, this.tokenizer, this.options);
	                default:
	                    throw new MusepackContentError(`Unexpected header: ${header.key}`);
	            }
	            // biome-ignore lint/correctness/noConstantCondition: break is handled in the switch statement
	        } while (true);
	    }
	}

	class BitReader {
	    constructor(tokenizer) {
	        this.pos = 0;
	        this.dword = null;
	        this.tokenizer = tokenizer;
	    }
	    /**
	     *
	     * @param bits 1..30 bits
	     */
	    async read(bits) {
	        while (this.dword === null) {
	            this.dword = await this.tokenizer.readToken(UINT32_LE);
	        }
	        let out = this.dword;
	        this.pos += bits;
	        if (this.pos < 32) {
	            out >>>= (32 - this.pos);
	            return out & ((1 << bits) - 1);
	        }
	        this.pos -= 32;
	        if (this.pos === 0) {
	            this.dword = null;
	            return out & ((1 << bits) - 1);
	        }
	        this.dword = await this.tokenizer.readToken(UINT32_LE);
	        if (this.pos) {
	            out <<= this.pos;
	            out |= this.dword >>> (32 - this.pos);
	        }
	        return out & ((1 << bits) - 1);
	    }
	    async ignore(bits) {
	        if (this.pos > 0) {
	            const remaining = 32 - this.pos;
	            this.dword = null;
	            bits -= remaining;
	            this.pos = 0;
	        }
	        const remainder = bits % 32;
	        const numOfWords = (bits - remainder) / 32;
	        await this.tokenizer.ignore(numOfWords * 4);
	        return this.read(remainder);
	    }
	}

	/**
	 * BASIC STRUCTURE
	 */
	const Header$2 = {
	    len: 6 * 4,
	    get: (buf, off) => {
	        const header = {
	            // word 0
	            signature: new TextDecoder('latin1').decode(buf.subarray(off, off + 3)),
	            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
	            streamMinorVersion: getBitAllignedNumber$1(buf, off + 3, 0, 4),
	            streamMajorVersion: getBitAllignedNumber$1(buf, off + 3, 4, 4),
	            // word 1
	            frameCount: UINT32_LE.get(buf, off + 4),
	            // word 2
	            maxLevel: UINT16_LE.get(buf, off + 8),
	            sampleFrequency: [44100, 48000, 37800, 32000][getBitAllignedNumber$1(buf, off + 10, 0, 2)],
	            link: getBitAllignedNumber$1(buf, off + 10, 2, 2),
	            profile: getBitAllignedNumber$1(buf, off + 10, 4, 4),
	            maxBand: getBitAllignedNumber$1(buf, off + 11, 0, 6),
	            intensityStereo: isBitSet$2(buf, off + 11, 6),
	            midSideStereo: isBitSet$2(buf, off + 11, 7),
	            // word 3
	            titlePeak: UINT16_LE.get(buf, off + 12),
	            titleGain: UINT16_LE.get(buf, off + 14),
	            // word 4
	            albumPeak: UINT16_LE.get(buf, off + 16),
	            albumGain: UINT16_LE.get(buf, off + 18),
	            // word
	            lastFrameLength: (UINT32_LE.get(buf, off + 20) >>> 20) & 0x7FF,
	            trueGapless: isBitSet$2(buf, off + 23, 0)
	        };
	        header.lastFrameLength = header.trueGapless ? (UINT32_LE.get(buf, 20) >>> 20) & 0x7FF : 0;
	        return header;
	    }
	};

	const debug$6 = initDebug('music-metadata:parser:musepack');
	class MpcSv7Parser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.bitreader = null;
	        this.audioLength = 0;
	        this.duration = null;
	    }
	    async parse() {
	        const header = await this.tokenizer.readToken(Header$2);
	        if (header.signature !== 'MP+')
	            throw new MusepackContentError('Unexpected magic number');
	        debug$6(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);
	        this.metadata.setFormat('container', 'Musepack, SV7');
	        this.metadata.setFormat('sampleRate', header.sampleFrequency);
	        const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
	        this.metadata.setFormat('numberOfSamples', numberOfSamples);
	        this.duration = numberOfSamples / header.sampleFrequency;
	        this.metadata.setFormat('duration', this.duration);
	        this.bitreader = new BitReader(this.tokenizer);
	        this.metadata.setFormat('numberOfChannels', header.midSideStereo || header.intensityStereo ? 2 : 1);
	        const version = await this.bitreader.read(8);
	        this.metadata.setFormat('codec', (version / 100).toFixed(2));
	        await this.skipAudioData(header.frameCount);
	        debug$6(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);
	        return tryParseApeHeader(this.metadata, this.tokenizer, this.options);
	    }
	    async skipAudioData(frameCount) {
	        while (frameCount-- > 0) {
	            const frameLength = await this.bitreader.read(20);
	            this.audioLength += 20 + frameLength;
	            await this.bitreader.ignore(frameLength);
	        }
	        // last frame
	        const lastFrameLength = await this.bitreader.read(11);
	        this.audioLength += lastFrameLength;
	        if (this.duration !== null) {
	            this.metadata.setFormat('bitrate', this.audioLength / this.duration);
	        }
	    }
	}

	const debug$5 = initDebug('music-metadata:parser:musepack');
	class MusepackParser extends AbstractID3Parser {
	    async postId3v2Parse() {
	        const signature = await this.tokenizer.peekToken(new StringType(3, 'latin1'));
	        let mpcParser;
	        switch (signature) {
	            case 'MP+': {
	                debug$5('Stream-version 7');
	                mpcParser = new MpcSv7Parser(this.metadata, this.tokenizer, this.options);
	                break;
	            }
	            case 'MPC': {
	                debug$5('Stream-version 8');
	                mpcParser = new MpcSv8Parser(this.metadata, this.tokenizer, this.options);
	                break;
	            }
	            default: {
	                throw new MusepackContentError('Invalid signature prefix');
	            }
	        }
	        this.metadata.setAudioOnly();
	        return mpcParser.parse();
	    }
	}

	var MusepackParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MusepackParser: MusepackParser
	});

	class OpusContentError extends makeUnexpectedFileContentError('Opus') {
	}
	/**
	 * Opus ID Header parser
	 * Ref: https://wiki.xiph.org/OggOpus#ID_Header
	 */
	class IdHeader {
	    constructor(len) {
	        if (len < 19) {
	            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');
	        }
	        this.len = len;
	    }
	    get(buf, off) {
	        return {
	            magicSignature: new StringType(8, 'ascii').get(buf, off + 0),
	            version: UINT8.get(buf, off + 8),
	            channelCount: UINT8.get(buf, off + 9),
	            preSkip: UINT16_LE.get(buf, off + 10),
	            inputSampleRate: UINT32_LE.get(buf, off + 12),
	            outputGain: UINT16_LE.get(buf, off + 16),
	            channelMapping: UINT8.get(buf, off + 18)
	        };
	    }
	}

	/**
	 * Opus parser
	 * Internet Engineering Task Force (IETF) - RFC 6716
	 * Used by OggStream
	 */
	class OpusStream extends VorbisStream {
	    constructor(metadata, options, tokenizer) {
	        super(metadata, options);
	        this.idHeader = null;
	        this.lastPos = -1;
	        this.tokenizer = tokenizer;
	    }
	    /**
	     * Parse first Opus Ogg page
	     * @param {IPageHeader} header
	     * @param {Uint8Array} pageData
	     */
	    parseFirstPage(_header, pageData) {
	        this.metadata.setFormat('codec', 'Opus');
	        // Parse Opus ID Header
	        this.idHeader = new IdHeader(pageData.length).get(pageData, 0);
	        if (this.idHeader.magicSignature !== "OpusHead")
	            throw new OpusContentError("Illegal ogg/Opus magic-signature");
	        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);
	        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);
	        this.metadata.setAudioOnly();
	    }
	    async parseFullPage(pageData) {
	        const magicSignature = new StringType(8, 'ascii').get(pageData, 0);
	        switch (magicSignature) {
	            case 'OpusTags':
	                await this.parseUserCommentList(pageData, 8);
	                this.lastPos = this.tokenizer.position - pageData.length;
	                break;
	        }
	    }
	    calculateDuration() {
	        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {
	            // Calculate duration
	            const pos_48bit = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;
	            this.metadata.setFormat('numberOfSamples', pos_48bit);
	            this.metadata.setFormat('duration', pos_48bit / 48000);
	            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
	                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;
	                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);
	            }
	        }
	    }
	}

	/**
	 * Speex Header Packet
	 * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000
	 */
	const Header$1 = {
	    len: 80,
	    get: (buf, off) => {
	        return {
	            speex: new StringType(8, 'ascii').get(buf, off + 0),
	            version: trimRightNull(new StringType(20, 'ascii').get(buf, off + 8)),
	            version_id: INT32_LE.get(buf, off + 28),
	            header_size: INT32_LE.get(buf, off + 32),
	            rate: INT32_LE.get(buf, off + 36),
	            mode: INT32_LE.get(buf, off + 40),
	            mode_bitstream_version: INT32_LE.get(buf, off + 44),
	            nb_channels: INT32_LE.get(buf, off + 48),
	            bitrate: INT32_LE.get(buf, off + 52),
	            frame_size: INT32_LE.get(buf, off + 56),
	            vbr: INT32_LE.get(buf, off + 60),
	            frames_per_packet: INT32_LE.get(buf, off + 64),
	            extra_headers: INT32_LE.get(buf, off + 68),
	            reserved1: INT32_LE.get(buf, off + 72),
	            reserved2: INT32_LE.get(buf, off + 76)
	        };
	    }
	};

	const debug$4 = initDebug('music-metadata:parser:ogg:speex');
	/**
	 * Speex, RFC 5574
	 * Ref:
	 * - https://www.speex.org/docs/manual/speex-manual/
	 * - https://tools.ietf.org/html/rfc5574
	 */
	class SpeexStream extends VorbisStream {
	    constructor(metadata, options, tokenizer) {
	        super(metadata, options);
	        this.tokenizer = tokenizer;
	    }
	    /**
	     * Parse first Speex Ogg page
	     * @param {IPageHeader} header
	     * @param {Uint8Array} pageData
	     */
	    parseFirstPage(_header, pageData) {
	        debug$4('First Ogg/Speex page');
	        const speexHeader = Header$1.get(pageData, 0);
	        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);
	        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);
	        this.metadata.setFormat('sampleRate', speexHeader.rate);
	        if (speexHeader.bitrate !== -1) {
	            this.metadata.setFormat('bitrate', speexHeader.bitrate);
	        }
	        this.metadata.setAudioOnly();
	    }
	}

	/**
	 * 6.2 Identification Header
	 * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode
	 */
	const IdentificationHeader = {
	    len: 42,
	    get: (buf, off) => {
	        return {
	            id: new StringType(7, 'ascii').get(buf, off),
	            vmaj: UINT8.get(buf, off + 7),
	            vmin: UINT8.get(buf, off + 8),
	            vrev: UINT8.get(buf, off + 9),
	            vmbw: UINT16_BE.get(buf, off + 10),
	            vmbh: UINT16_BE.get(buf, off + 17),
	            nombr: UINT24_BE.get(buf, off + 37),
	            nqual: UINT8.get(buf, off + 40)
	        };
	    }
	};

	const debug$3 = initDebug('music-metadata:parser:ogg:theora');
	/**
	 * Ref:
	 * - https://theora.org/doc/Theora.pdf
	 */
	class TheoraStream {
	    constructor(metadata, _options, tokenizer) {
	        this.metadata = metadata;
	        this.tokenizer = tokenizer;
	    }
	    /**
	     * Vorbis 1 parser
	     * @param header Ogg Page Header
	     * @param pageData Page data
	     */
	    async parsePage(header, pageData) {
	        if (header.headerType.firstPage) {
	            await this.parseFirstPage(header, pageData);
	        }
	    }
	    calculateDuration() {
	        debug$3('duration calculation not implemented');
	    }
	    /**
	     * Parse first Theora Ogg page. the initial identification header packet
	     */
	    async parseFirstPage(_header, pageData) {
	        debug$3('First Ogg/Theora page');
	        this.metadata.setFormat('codec', 'Theora');
	        const idHeader = IdentificationHeader.get(pageData, 0);
	        this.metadata.setFormat('bitrate', idHeader.nombr);
	        this.metadata.setFormat('hasVideo', true);
	    }
	    flush() {
	        return Promise.resolve();
	    }
	}

	const PageHeader = {
	    len: 27,
	    get: (buf, off) => {
	        return {
	            capturePattern: new StringType(4, 'latin1').get(buf, off),
	            version: UINT8.get(buf, off + 4),
	            headerType: {
	                continued: getBit(buf, off + 5, 0),
	                firstPage: getBit(buf, off + 5, 1),
	                lastPage: getBit(buf, off + 5, 2)
	            },
	            // packet_flag: Token.UINT8.get(buf, off + 5),
	            absoluteGranulePosition: Number(UINT64_LE.get(buf, off + 6)),
	            streamSerialNumber: UINT32_LE.get(buf, off + 14),
	            pageSequenceNo: UINT32_LE.get(buf, off + 18),
	            pageChecksum: UINT32_LE.get(buf, off + 22),
	            page_segments: UINT8.get(buf, off + 26)
	        };
	    }
	};
	class SegmentTable {
	    static sum(buf, off, len) {
	        const dv = new DataView(buf.buffer, 0);
	        let s = 0;
	        for (let i = off; i < off + len; ++i) {
	            s += dv.getUint8(i);
	        }
	        return s;
	    }
	    constructor(header) {
	        this.len = header.page_segments;
	    }
	    get(buf, off) {
	        return {
	            totalPageSize: SegmentTable.sum(buf, off, this.len)
	        };
	    }
	}

	class OggContentError extends makeUnexpectedFileContentError('Ogg') {
	}
	const debug$2 = initDebug('music-metadata:parser:ogg');
	class OggStream {
	    constructor(metadata, streamSerial, options) {
	        this.pageNumber = 0;
	        this.closed = false;
	        this.metadata = metadata;
	        this.streamSerial = streamSerial;
	        this.options = options;
	    }
	    async parsePage(tokenizer, header) {
	        this.pageNumber = header.pageSequenceNo;
	        debug$2('serial=%s page#=%s, Ogg.id=%s', header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);
	        const segmentTable = await tokenizer.readToken(new SegmentTable(header));
	        debug$2('totalPageSize=%s', segmentTable.totalPageSize);
	        const pageData = await tokenizer.readToken(new Uint8ArrayType(segmentTable.totalPageSize));
	        debug$2('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
	        if (header.headerType.firstPage) {
	            const idData = pageData.slice(0, 7); // Copy this portion
	            switch (idData[0]) {
	                case 0x01:
	                case 0x80:
	                    idData[0] = 0x5F; // underscore
	                    break;
	            }
	            const id = new TextDecoder('latin1').decode(idData);
	            switch (id) {
	                case '_vorbis': // Ogg/Vorbis
	                    debug$2(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);
	                    this.pageConsumer = new VorbisStream(this.metadata, this.options);
	                    break;
	                case 'OpusHea': // Ogg/Opus
	                    debug$2('Set page consumer to Ogg/Opus');
	                    this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);
	                    break;
	                case 'Speex  ': // Ogg/Speex
	                    debug$2('Set page consumer to Ogg/Speex');
	                    this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);
	                    break;
	                case 'fishead':
	                case '_theora': // Ogg/Theora
	                    debug$2('Set page consumer to Ogg/Theora');
	                    this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);
	                    break;
	                default:
	                    throw new OggContentError(`Ogg codec not recognized (id=${id})`);
	            }
	        }
	        if (header.headerType.lastPage) {
	            this.closed = true;
	        }
	        if (this.pageConsumer) {
	            await this.pageConsumer.parsePage(header, pageData);
	        }
	        else
	            throw new Error('pageConsumer should be initialized');
	    }
	}
	/**
	 * Parser for Ogg logical bitstream framing
	 */
	class OggParser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.streams = new Map();
	    }
	    /**
	     * Parse page
	     * @returns {Promise<void>}
	     */
	    async parse() {
	        this.streams = new Map();
	        debug$2('pos=%s, parsePage()', this.tokenizer.position);
	        let header;
	        try {
	            do {
	                header = await this.tokenizer.readToken(PageHeader);
	                if (header.capturePattern !== 'OggS')
	                    throw new OggContentError('Invalid Ogg capture pattern');
	                this.metadata.setFormat('container', 'Ogg');
	                let stream = this.streams.get(header.streamSerialNumber);
	                if (!stream) {
	                    stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);
	                    this.streams.set(header.streamSerialNumber, stream);
	                }
	                await stream.parsePage(this.tokenizer, header);
	            } while (![...this.streams.values()].every(item => item.closed));
	        }
	        catch (err) {
	            if (err instanceof EndOfStreamError) {
	                debug$2("Reached end-of-stream");
	            }
	            else if (err instanceof OggContentError) {
	                this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);
	            }
	            else
	                throw err;
	        }
	        for (const stream of this.streams.values()) {
	            if (!stream.closed) {
	                this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);
	                await stream.pageConsumer?.flush();
	            }
	            stream.pageConsumer?.calculateDuration();
	        }
	    }
	}

	var OggParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		OggContentError: OggContentError,
		OggParser: OggParser
	});

	const SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100,
	    48000, 64000, 88200, 96000, 192000, -1];
	/**
	 * WavPack Block Header
	 *
	 * 32-byte little-endian header at the front of every WavPack block
	 *
	 * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 "Block Header")
	 */
	const BlockHeaderToken = {
	    len: 32,
	    get: (buf, off) => {
	        const flags = UINT32_LE.get(buf, off + 24);
	        const res = {
	            // should equal 'wvpk'
	            BlockID: FourCcToken.get(buf, off),
	            //  0x402 to 0x410 are valid for decode
	            blockSize: UINT32_LE.get(buf, off + 4),
	            //  0x402 (1026) to 0x410 are valid for decode
	            version: UINT16_LE.get(buf, off + 8),
	            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
	            totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */ UINT32_LE.get(buf, off + 12),
	            // 40-bit block_index
	            blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */ UINT32_LE.get(buf, off + 16),
	            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
	            blockSamples: UINT32_LE.get(buf, off + 20),
	            // various flags for id and decoding
	            flags: {
	                bitsPerSample: (1 + getBitAllignedNumber(flags, 0, 2)) * 8,
	                isMono: isBitSet(flags, 2),
	                isHybrid: isBitSet(flags, 3),
	                isJointStereo: isBitSet(flags, 4),
	                crossChannel: isBitSet(flags, 5),
	                hybridNoiseShaping: isBitSet(flags, 6),
	                floatingPoint: isBitSet(flags, 7),
	                samplingRate: SampleRates[getBitAllignedNumber(flags, 23, 4)],
	                isDSD: isBitSet(flags, 31)
	            },
	            // crc for actual decoded data
	            crc: new Uint8ArrayType(4).get(buf, off + 28)
	        };
	        if (res.flags.isDSD) {
	            res.totalSamples *= 8;
	        }
	        return res;
	    }
	};
	/**
	 * 3.0 Metadata Sub-Blocks
	 * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 "Metadata Sub-Block")
	 */
	const MetadataIdToken = {
	    len: 1,
	    get: (buf, off) => {
	        return {
	            functionId: getBitAllignedNumber(buf[off], 0, 6), // functionId overlaps with isOptional flag
	            isOptional: isBitSet(buf[off], 5),
	            isOddSize: isBitSet(buf[off], 6),
	            largeBlock: isBitSet(buf[off], 7)
	        };
	    }
	};
	function isBitSet(flags, bitOffset) {
	    return getBitAllignedNumber(flags, bitOffset, 1) === 1;
	}
	function getBitAllignedNumber(flags, bitOffset, len) {
	    return (flags >>> bitOffset) & (0xffffffff >>> (32 - len));
	}

	const debug$1 = initDebug('music-metadata:parser:WavPack');
	class WavPackContentError extends makeUnexpectedFileContentError('WavPack') {
	}
	/**
	 * WavPack Parser
	 */
	class WavPackParser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.audioDataSize = 0;
	    }
	    async parse() {
	        this.metadata.setAudioOnly();
	        this.audioDataSize = 0;
	        // First parse all WavPack blocks
	        await this.parseWavPackBlocks();
	        // try to parse APEv2 header
	        return tryParseApeHeader(this.metadata, this.tokenizer, this.options);
	    }
	    async parseWavPackBlocks() {
	        do {
	            const blockId = await this.tokenizer.peekToken(FourCcToken);
	            if (blockId !== 'wvpk')
	                break;
	            const header = await this.tokenizer.readToken(BlockHeaderToken);
	            if (header.BlockID !== 'wvpk')
	                throw new WavPackContentError('Invalid WavPack Block-ID');
	            debug$1(`WavPack header blockIndex=${header.blockIndex}, len=${BlockHeaderToken.len}`);
	            if (header.blockIndex === 0 && !this.metadata.format.container) {
	                this.metadata.setFormat('container', 'WavPack');
	                this.metadata.setFormat('lossless', !header.flags.isHybrid);
	                // tagTypes: this.type,
	                this.metadata.setFormat('bitsPerSample', header.flags.bitsPerSample);
	                if (!header.flags.isDSD) {
	                    // In case isDSD, these values will ne set in ID_DSD_BLOCK
	                    this.metadata.setFormat('sampleRate', header.flags.samplingRate);
	                    this.metadata.setFormat('duration', header.totalSamples / header.flags.samplingRate);
	                }
	                this.metadata.setFormat('numberOfChannels', header.flags.isMono ? 1 : 2);
	                this.metadata.setFormat('numberOfSamples', header.totalSamples);
	                this.metadata.setFormat('codec', header.flags.isDSD ? 'DSD' : 'PCM');
	            }
	            const ignoreBytes = header.blockSize - (BlockHeaderToken.len - 8);
	            await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));
	            if (header.blockSamples > 0) {
	                this.audioDataSize += header.blockSize; // Count audio data for bit-rate calculation
	            }
	        } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= BlockHeaderToken.len);
	        if (this.metadata.format.duration) {
	            this.metadata.setFormat('bitrate', this.audioDataSize * 8 / this.metadata.format.duration);
	        }
	    }
	    /**
	     * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
	     * @param header Header
	     * @param remainingLength Remaining length
	     */
	    async parseMetadataSubBlock(header, remainingLength) {
	        let remaining = remainingLength;
	        while (remaining > MetadataIdToken.len) {
	            const id = await this.tokenizer.readToken(MetadataIdToken);
	            const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? UINT24_LE : UINT8);
	            const data = new Uint8Array(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
	            await this.tokenizer.readBuffer(data);
	            debug$1(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);
	            switch (id.functionId) {
	                case 0x0: // ID_DUMMY: could be used to pad WavPack blocks
	                    break;
	                case 0xe: { // ID_DSD_BLOCK
	                    debug$1('ID_DSD_BLOCK');
	                    // https://github.com/dbry/WavPack/issues/71#issuecomment-483094813
	                    const mp = 1 << UINT8.get(data, 0);
	                    const samplingRate = header.flags.samplingRate * mp * 8; // ToDo: second factor should be read from DSD-metadata block https://github.com/dbry/WavPack/issues/71#issuecomment-483094813
	                    if (!header.flags.isDSD)
	                        throw new WavPackContentError('Only expect DSD block if DSD-flag is set');
	                    this.metadata.setFormat('sampleRate', samplingRate);
	                    this.metadata.setFormat('duration', header.totalSamples / samplingRate);
	                    break;
	                }
	                case 0x24: // ID_ALT_TRAILER: maybe used to embed original ID3 tag header
	                    debug$1('ID_ALT_TRAILER: trailer for non-wav files');
	                    break;
	                case 0x26: // ID_MD5_CHECKSUM
	                    this.metadata.setFormat('audioMD5', data);
	                    break;
	                case 0x2f: // ID_BLOCK_CHECKSUM
	                    debug$1(`ID_BLOCK_CHECKSUM: checksum=${uint8ArrayToHex(data)}`);
	                    break;
	                default:
	                    debug$1(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
	                    break;
	            }
	            remaining -= MetadataIdToken.len + (id.largeBlock ? UINT24_LE.len : UINT8.len) + dataSizeInWords * 2;
	            debug$1(`remainingLength=${remaining}`);
	            if (id.isOddSize)
	                this.tokenizer.ignore(1);
	        }
	        if (remaining !== 0)
	            throw new WavPackContentError('metadata-sub-block should fit it remaining length');
	    }
	}

	var WavPackParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		WavPackContentError: WavPackContentError,
		WavPackParser: WavPackParser
	});

	/**
	 * Common RIFF chunk header
	 */
	const Header = {
	    len: 8,
	    get: (buf, off) => {
	        return {
	            // Group-ID
	            chunkID: new StringType(4, 'latin1').get(buf, off),
	            // Size
	            chunkSize: UINT32_LE.get(buf, off + 4)
	        };
	    }
	};
	/**
	 * Token to parse RIFF-INFO tag value
	 */
	class ListInfoTagValue {
	    constructor(tagHeader) {
	        this.tagHeader = tagHeader;
	        this.len = tagHeader.chunkSize;
	        this.len += this.len & 1; // if it is an odd length, round up to even
	    }
	    get(buf, off) {
	        return new StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);
	    }
	}

	class WaveContentError extends makeUnexpectedFileContentError('Wave') {
	}
	/**
	 * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx
	 */
	const WaveFormat = {
	    PCM: 0x0001,
	    // MPEG-4 and AAC Audio Types
	    ADPCM: 0x0002,
	    IEEE_FLOAT: 0x0003,
	    MPEG_ADTS_AAC: 0x1600,
	    MPEG_LOAS: 0x1602,
	    RAW_AAC1: 0x00FF,
	    // Dolby Audio Types
	    DOLBY_AC3_SPDIF: 0x0092,
	    DVM: 0x2000,
	    RAW_SPORT: 0x0240,
	    ESST_AC3: 0x0241,
	    DRM: 0x0009,
	    DTS2: 0x2001,
	    MPEG: 0x0050
	};
	const WaveFormatNameMap = {
	    [WaveFormat.PCM]: 'PCM',
	    [WaveFormat.ADPCM]: 'ADPCM',
	    [WaveFormat.IEEE_FLOAT]: 'IEEE_FLOAT',
	    [WaveFormat.MPEG_ADTS_AAC]: 'MPEG_ADTS_AAC',
	    [WaveFormat.MPEG_LOAS]: 'MPEG_LOAS',
	    [WaveFormat.RAW_AAC1]: 'RAW_AAC1',
	    [WaveFormat.DOLBY_AC3_SPDIF]: 'DOLBY_AC3_SPDIF',
	    [WaveFormat.DVM]: 'DVM',
	    [WaveFormat.RAW_SPORT]: 'RAW_SPORT',
	    [WaveFormat.ESST_AC3]: 'ESST_AC3',
	    [WaveFormat.DRM]: 'DRM',
	    [WaveFormat.DTS2]: 'DTS2',
	    [WaveFormat.MPEG]: 'MPEG'
	};
	/**
	 * format chunk; chunk-id is "fmt "
	 * http://soundfile.sapp.org/doc/WaveFormat/
	 */
	class Format {
	    constructor(header) {
	        if (header.chunkSize < 16)
	            throw new WaveContentError('Invalid chunk size');
	        this.len = header.chunkSize;
	    }
	    get(buf, off) {
	        return {
	            wFormatTag: UINT16_LE.get(buf, off),
	            nChannels: UINT16_LE.get(buf, off + 2),
	            nSamplesPerSec: UINT32_LE.get(buf, off + 4),
	            nAvgBytesPerSec: UINT32_LE.get(buf, off + 8),
	            nBlockAlign: UINT16_LE.get(buf, off + 12),
	            wBitsPerSample: UINT16_LE.get(buf, off + 14)
	        };
	    }
	}
	/**
	 * Fact chunk; chunk-id is "fact"
	 * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html
	 * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file
	 */
	class FactChunk {
	    constructor(header) {
	        if (header.chunkSize < 4) {
	            throw new WaveContentError('Invalid fact chunk size.');
	        }
	        this.len = header.chunkSize;
	    }
	    get(buf, off) {
	        return {
	            dwSampleLength: UINT32_LE.get(buf, off)
	        };
	    }
	}

	/**
	 * Broadcast Audio Extension Chunk
	 * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf
	 */
	const BroadcastAudioExtensionChunk = {
	    len: 420,
	    get: (uint8array, off) => {
	        return {
	            description: stripNulls(new StringType(256, 'ascii').get(uint8array, off)).trim(),
	            originator: stripNulls(new StringType(32, 'ascii').get(uint8array, off + 256)).trim(),
	            originatorReference: stripNulls(new StringType(32, 'ascii').get(uint8array, off + 288)).trim(),
	            originationDate: stripNulls(new StringType(10, 'ascii').get(uint8array, off + 320)).trim(),
	            originationTime: stripNulls(new StringType(8, 'ascii').get(uint8array, off + 330)).trim(),
	            timeReferenceLow: UINT32_LE.get(uint8array, off + 338),
	            timeReferenceHigh: UINT32_LE.get(uint8array, off + 342),
	            version: UINT16_LE.get(uint8array, off + 346),
	            umid: new Uint8ArrayType(64).get(uint8array, off + 348),
	            loudnessValue: UINT16_LE.get(uint8array, off + 412),
	            maxTruePeakLevel: UINT16_LE.get(uint8array, off + 414),
	            maxMomentaryLoudness: UINT16_LE.get(uint8array, off + 416),
	            maxShortTermLoudness: UINT16_LE.get(uint8array, off + 418)
	        };
	    }
	};

	const debug = initDebug('music-metadata:parser:RIFF');
	/**
	 * Resource Interchange File Format (RIFF) Parser
	 *
	 * WAVE PCM soundfile format
	 *
	 * Ref:
	 * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html
	 * - http://soundfile.sapp.org/doc/WaveFormat
	 *
	 * ToDo: Split WAVE part from RIFF parser
	 */
	class WaveParser extends BasicParser {
	    constructor() {
	        super(...arguments);
	        this.blockAlign = 0;
	    }
	    async parse() {
	        const riffHeader = await this.tokenizer.readToken(Header);
	        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
	        if (riffHeader.chunkID !== 'RIFF')
	            return; // Not RIFF format
	        this.metadata.setAudioOnly();
	        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {
	            if (!(err instanceof EndOfStreamError)) {
	                throw err;
	            }
	        });
	    }
	    async parseRiffChunk(chunkSize) {
	        const type = await this.tokenizer.readToken(FourCcToken);
	        this.metadata.setFormat('container', type);
	        switch (type) {
	            case 'WAVE':
	                return this.readWaveChunk(chunkSize - FourCcToken.len);
	            default:
	                throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);
	        }
	    }
	    async readWaveChunk(remaining) {
	        while (remaining >= Header.len) {
	            const header = await this.tokenizer.readToken(Header);
	            remaining -= Header.len + header.chunkSize;
	            if (header.chunkSize > remaining) {
	                this.metadata.addWarning('Data chunk size exceeds file size');
	            }
	            this.header = header;
	            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
	            switch (header.chunkID) {
	                case 'LIST':
	                    await this.parseListTag(header);
	                    break;
	                case 'fact': // extended Format chunk,
	                    this.metadata.setFormat('lossless', false);
	                    this.fact = await this.tokenizer.readToken(new FactChunk(header));
	                    break;
	                case 'fmt ': { // The Util Chunk, non-PCM Formats
	                    const fmt = await this.tokenizer.readToken(new Format(header));
	                    let subFormat = WaveFormatNameMap[fmt.wFormatTag];
	                    if (!subFormat) {
	                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);
	                        subFormat = `non-PCM (${fmt.wFormatTag})`;
	                    }
	                    this.metadata.setFormat('codec', subFormat);
	                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);
	                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);
	                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);
	                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
	                    this.blockAlign = fmt.nBlockAlign;
	                    break;
	                }
	                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data
	                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data
	                    const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
	                    const rst = fromBuffer(id3_data);
	                    await new ID3v2Parser().parse(this.metadata, rst, this.options);
	                    break;
	                }
	                case 'data': { // PCM-data
	                    if (this.metadata.format.lossless !== false) {
	                        this.metadata.setFormat('lossless', true);
	                    }
	                    let chunkSize = header.chunkSize;
	                    if (this.tokenizer.fileInfo.size) {
	                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
	                        if (calcRemaining < chunkSize) {
	                            this.metadata.addWarning('data chunk length exceeding file length');
	                            chunkSize = calcRemaining;
	                        }
	                    }
	                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);
	                    if (numberOfSamples) {
	                        this.metadata.setFormat('numberOfSamples', numberOfSamples);
	                        if (this.metadata.format.sampleRate) {
	                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);
	                        }
	                    }
	                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps
	                        this.metadata.setFormat('bitrate', 352000);
	                    }
	                    else if (this.metadata.format.sampleRate) {
	                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);
	                    }
	                    await this.tokenizer.ignore(header.chunkSize);
	                    break;
	                }
	                case 'bext': { // Broadcast Audio Extension chunk	https://tech.ebu.ch/docs/tech/tech3285.pdf
	                    const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);
	                    Object.keys(bext).forEach(key => {
	                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);
	                    });
	                    const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;
	                    await this.tokenizer.ignore(bextRemaining);
	                    break;
	                }
	                case '\x00\x00\x00\x00': // padding ??
	                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
	                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
	                    await this.tokenizer.ignore(header.chunkSize);
	                    break;
	                default:
	                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
	                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
	                    await this.tokenizer.ignore(header.chunkSize);
	            }
	            if (this.header.chunkSize % 2 === 1) {
	                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF
	                await this.tokenizer.ignore(1);
	            }
	        }
	    }
	    async parseListTag(listHeader) {
	        const listType = await this.tokenizer.readToken(new StringType(4, 'latin1'));
	        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);
	        switch (listType) {
	            case 'INFO':
	                return this.parseRiffInfoTags(listHeader.chunkSize - 4);
	            default:
	                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);
	                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);
	                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();
	        }
	    }
	    async parseRiffInfoTags(chunkSize) {
	        while (chunkSize >= 8) {
	            const header = await this.tokenizer.readToken(Header);
	            const valueToken = new ListInfoTagValue(header);
	            const value = await this.tokenizer.readToken(valueToken);
	            this.addTag(header.chunkID, stripNulls(value));
	            chunkSize -= (8 + valueToken.len);
	        }
	        if (chunkSize !== 0) {
	            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);
	        }
	    }
	    addTag(id, value) {
	        this.metadata.addTag('exif', id, value);
	    }
	}

	var WaveParser$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		WaveParser: WaveParser
	});

	return Webamp;

}));
//# sourceMappingURL=webamp.bundle.js.map
